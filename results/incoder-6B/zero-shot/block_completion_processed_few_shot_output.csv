eval_prompt,ground_truth,model_output
"import sys
import collections
import math
import bisect
import heapq
#import itertools
#import functools
input = sys.stdin.readline
 
M = 10 ** 9 + 7
power = [1] * (2 * 10 ** 5)
for i in range(1, 2 * 10 ** 5):
    power[i] = power[i-1] * 2 % M
 
n = int(input())
arr = list(map(int, input().split()))
arr.sort()
ans = 0
if n > 64:
    arr = arr[:64]
    def fn(ls):
        q = []
        for i in range(8):
            for j in range(i + 1, 64):
                curr = ls[i] + ls[j]
                if len(q) == 64:
                    if curr >= -q[0]:
                        break
                    else:
                        {{completion}}
                else:
                    heapq.heappush(q, -curr)
        return sorted([-i for i in q])
    for i in range(n - 64):
        x = arr[0]
        arr = [num - x for num in arr]
        ans = (ans + x * power[n - 1 - i]) % M
        arr = fn(arr)

def fx(ls):
    m = len(ls)
    q = []
    for i in range(math.isqrt(m)):
        for j in range(i + 1, m):
            curr = ls[i] + ls[j]
            if len(q) == m - 1:
                if curr >= -q[0]:
                    break
                else:
                    heapq.heappushpop(q, -curr)
            else:
                heapq.heappush(q, -curr)
    return sorted([-i for i in q])
n = len(arr)
for i in range(n - 1):
    x = arr[0]
    arr = [num - x for num in arr]
    ans = (ans + x * power[n - 1 - i]) % M
    arr = fx(arr)
ans += arr[0]
print(ans % M)","heapq.heappushpop(q, -curr)","heapq.heappushpop(q, -curr)"
"import heapq
def f(L):
    n=len(L)
    ma=[]
    for i in range(n):
        for j in range(i+1,n):
            if len(ma)==n-1 and L[i]+L[j]>=(-1)*ma[0]:
                break
            elif len(ma)==n-1 and L[i]+L[j]<(-1)*ma[0]:
                {{completion}}
            else:
                heapq.heappush(ma,(-1)*(L[i]+L[j]))
    return sorted([(-1)*j for j in ma])
def g(L):
    n=len(L)
    ma=[]
    for i in range(n):
        for j in range(i+1,n):
            if len(ma)==n and L[i]+L[j]>=(-1)*ma[0]:
                break
            elif len(ma)==n and L[i]+L[j]<(-1)*ma[0]:
                heapq.heappop(ma)
                heapq.heappush(ma,(-1)*(L[i]+L[j]))
            else:
                heapq.heappush(ma,(-1)*(L[i]+L[j]))
    return sorted([(-1)*j for j in ma])
n=int(input())
L=list(map(int,input().split()))
ans=sorted(L)[:64]
ans1=0
K=64
if n>K:
    for i in range(n-K):
        sub=ans[0]
        for j in range(64):
            ans[j]-=sub
        ans1+=sub*(2**(n-1-i))
        ans=g(ans)
for gg in range(min(n,K)-1):
    sub=ans[0]
    for j in range(min(n,K)-gg):
        ans[j]-=sub
    ans1+=sub*(2**(min(n,K)-1-gg))
    ans=f(ans)
print((ans[0]+ans1)%1000000007)
","heapq.heappop(ma)
                heapq.heappush(ma,(-1)*(L[i]+L[j]))","heapq.heappop(ma)
                heapq.heappush(ma,(-1)*(L[i]+L[j]))"
"import sys
import collections
import math
import bisect
import heapq
#import itertools
#import functools
input = sys.stdin.readline
 
M = 10 ** 9 + 7
power = [1] * (2 * 10 ** 5)
for i in range(1, 2 * 10 ** 5):
    power[i] = power[i-1] * 2 % M
 
n = int(input())
arr = list(map(int, input().split()))
arr.sort()
ans = 0
if n > 64:
    arr = arr[:64]
    def fn(ls):
        q = []
        for i in range(8):
            for j in range(i + 1, 64):
                curr = ls[i] + ls[j]
                if len(q) == 64:
                    if curr >= -q[0]:
                        break
                    else:
                        {{completion}}
                else:
                    heapq.heappush(q, -curr)
        return sorted([-i for i in q])
    for i in range(n - 64):
        x = arr[0]
        arr = [num - x for num in arr]
        ans = (ans + x * power[n - 1 - i]) % M
        arr = fn(arr)

def fx(ls):
    m = len(ls)
    q = []
    for i in range(math.isqrt(m)):
        for j in range(i + 1, m):
            curr = ls[i] + ls[j]
            if len(q) == m - 1:
                if curr >= -q[0]:
                    break
                else:
                    heapq.heappushpop(q, -curr)
            else:
                heapq.heappush(q, -curr)
    return sorted([-i for i in q])
n = len(arr)
for i in range(n - 1):
    x = arr[0]
    arr = [num - x for num in arr]
    ans = (ans + x * power[n - 1 - i]) % M
    arr = fx(arr)
ans += arr[0]
print(ans % M)","heapq.heappushpop(q, -curr)","heapq.heappushpop(q, -curr)"
"def f(total,r,k):
    ans = ((pow(k-1,n,m)-(-1)**n)*pow(k,-1,m))%m
    if (r*n-total)%k == 0:
        ans += (-1)**n
    return ans
n,k,m = map(int,input().split())
ans = 0
if k % 2 == 1:
    for i in range(k):
        ans += pow(k,n-1,m)-f(2*i,i,k)
    print(ans%m)
else:
    for i in range(k//2):
        {{completion}}
    print(ans%m)","ans += pow(k,n-1,m)-f(2*i,i,k//2)*pow(2,n-1,m)","ans += pow(k,n-1,m)-f(2*i,i,k)"
"import math
def pow(n, m, p):
    if m==0:
        return 1
    else:
        if m%2==0:
            return (pow(n, m//2, p)**2)%p
        else:
            {{completion}}
n, k, p =map(int, input().split())
if k%2==1:
    print((pow(k, n, p) - pow(k-1, n, p)+(-1)**((n+1)%2)*(math.gcd(n-2, k)-1))%p)
else:
    print((pow(2, p-2, p)*(pow(k, n, p) - pow(k-2, n, p)) + (-1)**((n+1)%2)*(math.gcd(n-2, k//2)-1)*pow(2, n-1, p))%p)","return (n*pow(n, m//2, p)**2)%p","ans=1
            while m%2!=0:
                ans=(ans*n)%m
                m=m//2
            return ans
n, k, p =map(int, input().split())
if k%2==1:
    print((pow(k, n, p) - pow(k-1, n, p)+(-1)**((n+1)%2)*(math.gcd(n-2, k)-1))%p)
else:
    print((pow(2, p-2, p)*(pow(k, n, p) - pow(k-2, n, p)) + (-1)**((n+1)%2)*(math.gcd(n-2, k//2)-1)*pow(2, n-1, p))%p)
    
</cell>
<"
"def calculate_lucky_tickets(n, k, m):
    def f(total, r, k):
        ans = ((pow(k - 1, n, m) - (-1) ** n) * pow(k, -1, m)) % m
        if (r * n - total) % k == 0:
            ans += (-1) ** n
        return ans

    ans = 0

    if k % 2 == 1:
        for i in range(k):
            ans += pow(k, n - 1, m) - f(2 * i, i, k)
    else:
        for i in range(k // 2):
            {{completion}}

    return ans % m


n, k, m = map(int, input().split())
result = calculate_lucky_tickets(n, k, m)
print(result)
","ans += pow(k, n - 1, m) - f(2 * i, i, k // 2) * pow(2, n - 1, m)","ans += f(i, i, k)
            ans += f(i, i, k)"
"import math
n,k,m = map(int,input().split())
ans = 0
if k % 2 == 1:
    print((pow(k,n,m)-pow(k-1,n,m)+(-1)**n*(1-math.gcd(n-2,k)))%m)
else:
    {{completion}}","print((pow(k//2,n,m)-pow(k//2-1,n,m)+(-1)**n*(1-math.gcd(n-2,k//2)))*pow(2,n-1,m)%m)","ans = pow(k,n,m)-pow(k-1,n,m)+(-1)**n*(1-math.gcd(n-2,k))
    print(ans % m)
<|/ file source=github ext=.py |>"
"n, k, m = input().split()
n = int(n)
k = int(k)
m = int(m)

if k % 2 == 1:
    ans = (pow(k, n, m) + pow(-1, n, m) - pow(k - 1, n, m)) % m
    for t in range(k):
        if n * t % k == 2 * t % k:
            ans += pow(-1, n - 1, m)
    ans = (ans % m + m) % m
    print(ans)
else:
    ans = ((pow(k, n, m) + pow(-2, n, m) - pow(k - 2, n, m)) * pow(2, m - 2, m)) % m
    for t in range(k // 2):
        if n * t % k == 2 * t % k or (n * t + k // 2) % k == 2 * t % k:
            {{completion}}
    ans = (ans % m + m) % m
    print(ans)","ans += pow(-1, n - 1, m) * pow(2, n - 1, m)
            ans %= m","ans += pow(-1, n - 1, m)
    ans = (ans % m + m) % m
    print(ans)

if k % 3 == 1:
    ans = (pow(k, n, m) + pow(-2, n, m) - pow(k - 2, n, m)) % m
    for t in range(k):
        if n * t % k == 2 * t % k or n * t + k % 3 == 2 * t % k:
            ans += pow(-1, n - 1, m)
    ans = (ans % m + m) % m
    print(ans)
else:
    ans = ((pow(k, n, m) + pow(-3, n, m) - pow(k - 3, n, m)) * pow(3, "
"from math import gcd
n,k,m=map(int,input().split())
if k&1:
    print((pow(k,n,m)-pow(k-1,n,m)-(-1)**n*(gcd(n-2,k)-1))%m)
else:
    {{completion}}","print((pow(k,n,m)*pow(2,-1,m)-pow(2,n-1,m)*(pow(k//2-1,n,m)+(-1)**n*(gcd(n-2,k//2)-1)))%m)","s=0
    for i in range(n):
        s+=int(input())
    print(s%m)
<|/ file source=github filename=lucky_ticket.py "
"import sys;Z=sys.stdin.readline;Y=lambda:map(int,Z().split());X=range
z=lambda v,k:v+max(v-k,0)
def F(n,k,a,b):
 if 1 not in b:return F(n,k<<1,[i<<1 for i in a],[1]*n)
 if b[-1]!=1:i=b.index(1)+1;A=F(n,k,a[i:]+a[:i],b[i:]+b[:i]);return A[-i:]+A[:-i]
 N=n+1;f=[0]*N;g=[0]*N;s=v=0;p=n-1;d=[0]*n;A=[0]*n
 for i in X(n):
  if b[i]==1:s+=z(v+a[i-1],k);v=0;p=i
  else:{{completion}}
 for i in X(n-2,-2,-1):
  if b[i]==1:d[i]=z(v+a[i],k);v=0
  else:g[i]=g[i+1]+(a[i]<<1);v+=a[i]
 for i in X(n):
  if b[i]==1:A[i]=s
  else:A[i]=s-d[d[i]]+z(f[i+1],k)+g[i]
 return A
for _ in X(*Y()):print(*F(*Y(),[*Y()],[*Y()]))",f[i+1]=f[i]+a[i-1];v+=a[i-1];d[i]=p,"g[i]=g[i+1]+(a[i-1]<<1);v+=a[i-1]
 for i in X(n-2,-2,-1):
  if b[i]==1:d[i]=z(v+a[i],k);v=0
  else:g[i]=g[i+1]+(a[i]<<1);v+=a[i]
 for i in X(n):
  if b[i]==1:A[i]=s
  else:A[i]=s-d[d[i]]+z(f[i+1],k)+g[i]
 return A
for _ in X(*Y()):print(*F(*Y(),[*Y()],[*Y()]))
'''
<|/ a dscore=0 |>"
"import sys
from itertools import chain
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n, k = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    P = [0] * (n + 1)
    for i, a in enumerate(A):
        P[i + 1] = a + P[i]
    
    C = [i for i, b in enumerate(B) if b == 1]
    m = len(C)

    if m == 0:
        res = [2 * P[-1]] * n
        return "" "".join(map(str, res))
    
    cost = 0
    deposit = 0
    l = m - 1
    r = 0
    prv = [-1] * n
    nxt = [-1] * n

    for i in chain(range(C[0], n), range(C[0])):
        if B[i] == 1:
            need = k - deposit
            cost += need
            prv[i] = C[l]
            r = (r + 1) % m
            nxt[i] = C[r]
            l = (l + 1) % m
            
        else:
            {{completion}}
        
        deposit += need - A[i]
    
    cost -= deposit

    res = [0] * n
    for i, b in enumerate(B):
        if b == 1:
            res[i] = cost
            continue
        
        ans = cost

        if prv[i] < nxt[i]:
            need = P[nxt[i]] - P[prv[i]]
        else:
            need = P[-1] - P[prv[i]] + P[nxt[i]]
        
        ans -= need + max(0, need - k)

        if prv[i] < i:
            need = P[i] - P[prv[i]]
        else:
            need = P[-1] - P[prv[i]] + P[i]

        ans += need + max(0, need - k)

        if nxt[i] > i:
            need = P[nxt[i]] - P[i]
        else:
            need = P[-1] - P[i] + P[nxt[i]]
        
        ans += 2 * need
        res[i] = ans

    return "" "".join(map(str, res))

out = []
for _ in range(int(input())):
    out.append(solve())

print(""\n"".join(map(str, out)))","need = max(A[i] - deposit, 0)
            cost += 2 * need
            prv[i] = C[l]
            nxt[i] = C[r]","need = P[C[l]] - P[C[r]] + P[C[i]]
            cost += need
            prv[i] = C[l]
            nxt[i] = C[r]
            l = (l + 1) % m
            r = (r + 1) % m"
"#your code goes here
import sys;Z=sys.stdin.readline;Y=lambda:map(int,Z().split())
def f(v,k):return v if v<=k else v+v-k                                 #input
def solve(n,k,a,b):
 if 1 not in b:return solve(n,k<<1,[i<<1 for i in a],[1]*n)
 if b[-1]!=1:
  i=b.index(1)+1
  A=solve(n,k,a[i:]+a[:i],b[i:]+b[:i])
  return A[-i:]+A[:-i]
 f1=[0];f2=[0];s=v=0;p=n-1;d=[0]*n
 for i in range(n):
  if b[i]==1:f1.append(0);s+=f(v+a[i-1],k);v=0;p=i                  #if
  else:{{completion}}
 for i in range(n-2,-2,-1):
  if b[i]==1:f2.append(0);d[i]=f(v+a[i],k);v=0
  else:f2.append(f2[-1]+(a[i]<<1));v+=a[i]
 f1=f1[1:];f2=f2[-2::-1];A=[]
 for i in range(n):
  if b[i]==1:A.append(s)
  else:A.append(s-d[d[i]]+f(f1[i],k)+f2[i])
 return A
for _ in range(*Y()):n,k=Y();a=[*Y()];b=[*Y()];print(*solve(n,k,a,b))                    #return",f1.append(f1[-1]+a[i-1]);v+=a[i-1];d[i]=p,"f1.append(f1[-1]+(a[i-1]<<1));v+=a[i-1];p=i
 f1=f1[1:];f2=f2[-2::-1];A=[]
 for i in range(n):
  if b[i]==1:A.append(s)
  else:A.append(s-d[d[i]]+f(f1[i],k)+f2[i])
 return A
for _ in range(*Y()):n,k=Y();a=[*Y()];b=[*Y()];print(*solve(n,k,a,b))                    #return
'''
<|/ a tags=python,dynamic-programming,algorithm |>
<| a dscore=0 |>
<code>
import sys;Z=sys.stdin.read"
"import sys
input = lambda: sys.stdin.readline().rstrip()

n, a, b = map(int, input().split())
V = list(map(int, input().split()))

res = [[0] * (b + 1) for _ in range(a + 1)]

for m in range(a + b + 1):
    lb = max(0, m - b)
    ub = min(a, m)
    ylo = xlo = lb
    yhi = xhi = ub

    for v in V:
        ylo -= v
        yhi -= v

        if ylo >= ub:
            ylo = xlo = yhi = xhi = ub
            continue

        if yhi <= lb:
            ylo = xlo = yhi = xhi = lb
            continue

        if ylo < lb:
            xlo += lb - ylo
            ylo = lb
            yhi = ylo + xhi - xlo
        
        if yhi > ub:
            xhi -= yhi - ub
            yhi = ub
            ylo = yhi - xhi + xlo
    
    for c in range(lb, ub + 1):
        if c <= xlo:
            res[c][m - c] = ylo
        elif c >= xhi:
            {{completion}}
        else:
            res[c][m - c] = ylo + c - xlo

out = ["" "".join(map(str, row)) for row in res]
print(""\n"".join(out))",res[c][m - c] = yhi,res[c][m - c] = yhi
"import sys

def solve(A, B, tot, ops):
    if tot <= B:
        L = 0
    else:
        L = tot - B
    
    if tot >= A:
        R = A
    else:
        R = tot
    n = R - L + 1
    l, r = L, R
    lc = rc = 1

    for o in ops:
        if o > 0:
            # A -> B
            if o >= r - L:
                l = r = L
                lc = rc = n
            elif o <= l - L:
                l -= o
                r -= o
            else:
                lc += o - l + L
                l = L
                r -= o
        else:
            # A <- B
            o = -o
            if o >= R - l:
                l = r = R
                lc = rc = n
            elif o <= R - r:
                {{completion}}
            else:
                rc += o - R + r
                l += o
                r = R
        #print(o, tot, ""(%d[%d], %d[%d])"" % (l, lc, r, rc))
    if l == r:
        return L, R, [l] * n
    return L, R, [l] * lc + list(range(l + 1, r)) + [r] * rc


n, A, B = list(map(int, sys.stdin.readline().split()))
raw_ops = list(map(int, sys.stdin.readline().split()))
ops = []
for i in raw_ops:
    if i == 0: 
        continue
    if not ops:
        ops.append(i)
        continue
    if ops[-1] * i > 0:
        ops[-1] += i
    else:
        ops.append(i)

ret = [[0] * (B + 1) for _ in range(A + 1)]

for tot in range(A + B + 1):
    L, R, rest = solve(A, B, tot, ops)
    #print((A, B), tot, (L, R), rest)
    assert(R-L + 1 == len(rest))
    for l in range(L, R + 1):
        assert(0<= l <= A)
        assert(0<= tot - l <= B)
        assert(0 <= l - L < len(rest))
        ret[l][tot - l] = rest[l - L]

for i in ret:
    print(' '.join(map(str, i)))
","l += o
                r += o","l -= o
                r -= o"
"import sys
import io
import os

MOD = 998244353  # 1000000007   INV2 = (MOD + 1) >> 1 # pow(2, MOD - 2, MOD)
inf = 1 << 60


def solve():
    N, X, Y = read_int_tuple()
    A = [0] + read_int_list()
    
    dp = [[inf] * (N + 1) for _ in range(N + 1)]
    fp = [[inf] * (N + 1) for _ in range(N + 1)]
    gp = [[inf] * (N + 1) for _ in range(N + 1)]
    
    for i in range(1, N + 1):
        dp[i][i] = X
        fp[i][i], gp[i][i] = Y, Y * 2
        gp[i][i - 1] = 0
    
    for ln in range(2, N + 1):
        for l in range(1, N - ln + 2):
            r = l + ln - 1
            dp[l][r] = min(dp[l][k] + dp[k + 1][r] for k in range(l, r))
            
            if A[l] == A[r]:
                fp[l][r] = min(fp[l][r], fp[l][r - 1] + Y)
                gp[l][r] = min(gp[l][r], gp[l][r - 1] + Y * 2)
            
            for k in range(l, r):
                fp[l][r] = min(fp[l][r], fp[l][k] + dp[k + 1][r])
                gp[l][r] = min(gp[l][r], gp[l][k] + dp[k + 1][r])
            
            if A[l] == A[r]:
                last = r
                while l <= last and A[l] == A[last]:
                    {{completion}}

    print(dp[1][N])


def main():
    # region local test
    # if 'AW' in os.environ.get('COMPUTERNAME', ''):
    #     test_no = 1
    #     f = open(os.path.dirname(__file__) + f'\\in{test_no}.txt', 'r')

    #     global input
    #     input = lambda: f.readline().rstrip(""\r\n"")
    # endregion

    T = 1
    for t in range(T):
        solve()
        # print('YES' if solve() else 'NO')
        # print('Yes' if solve() else 'No')


# region IO
BUFSIZE = 8192


class FastIO(io.IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = io.BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(io.IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip('\r\n')


def read_int_list():
    return list(map(int, input().split()))


def read_ints_minus_one():
    return [int(x) - 1 for x in input().split()]


def read_int_tuple():
    return map(int, input().split())

def read_encode_str(d=97):  # 'a': 97; 'A': 65
    return [ord(x) - d for x in input()]

def read_graph(n: int, m: int, d=1):
    g = [[] for _ in range(n)]
    for _ in range(m):
        u, v = map(int, input().split())
        g[u - d].append(v - d)
        g[v - d].append(u - d)
    return g

def read_grid(m: int):
    return [input() for _ in range(m)]

def read_int():
    return int(input())


read_str = input

# endregion

if __name__ == ""__main__"":
    main()","last -= 1
                    dp[l][r] = min(dp[l][r], gp[l][last] + X, fp[l][r] + X)","l += 1
                    last -= 1
                
                last = r
                while r <= last and A[r] == A[last]:
                    r += 1
                    last -= 1
                
                fp[l][r] = min(fp[l][r], fp[l][last] + Y)
                gp[l][r] = min(gp[l][r], gp[l][last] + Y * 2)
            
    for l in range(1, N + 1):
        dp[l][N] = min(dp[l][N], dp[N][N])
        fp[l][N] = min(fp[l][N], fp[N][N])
        gp[l]["
"enum = enumerate

test = int ( input ( ) )

for testtest in range ( test ) :

    n , k  = map ( int , input ( ) . split ( ) )
    
    F = list ( map ( int , input ( ) . split ( ) ) )
    
    D = list ( map ( int , input ( ) . split ( ) ) )
    
    V = [ F[i]*D[i] for i in range ( n ) ]
    
    V.sort()
        
    S = set()
    
    for f in F : 
        if f > k : 
            S.add(f)
    
    
    def check ( a , b ) :
        
        if b - a > k : return 0
        
        st = max ( b - k , 1 )
        en = a + k
        
        A = [ 0 for i in range ( en - st + 1 + 1 ) ]
        
        for s in S :
            
            v = ((st+s-1)//s)*s
            
            while v <= en :
                A[v-st] += 1
                v += s
                
        cur = 0
        
        for i in range ( st , st + k + 1 ) : cur += A[i-st]
        
        for i in range ( st , a + 1 ) :
        
            if cur == len(S) : return 1
            
            
            cur -= A[i-st]
            cur += A[i-st+k+1]
            
            
        return 0
        
        
        
    ans = 0
    
    a = 0
    b = 0
    
    while a < n and b < n :
        if check(V[a],V[b]) :
            ans = max ( ans , b - a + 1 )
            b += 1
        else :
            a += 1
            if a > b : {{completion}}
    
    print(n-ans)
            
            
            
    
    
    ",b = a,"break
            
            
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import sys
input = sys.stdin.readline

def solve():
    n, k = map(int, input().split())
    F = list(map(int, input().split()))
    D = list(map(int, input().split()))
    P = [f * d for f, d in zip(F, D)]
    
    ans = 0
    for p in P:
        L = max(0, p - k)
        R = p + k
        
        fixed = [0] * (k + 2)
        present = [0] * (k + 2)

        for f, d in zip(F, D):

            if L <= f * d <= p:
                fixed[0] += 1
                fixed[f * d + k - p + 1] -= 1
            
            elif p < f * d <= R:
                {{completion}}

            if f <= k + 1:
                present[0] += 1
                continue
            
            di = p // f

            if di > 0 and L <= f * di:
                present[0] += 1
                present[f * di + k - p + 1] -= 1
              
            if f * (di + 1) <= R:
                present[f * (di + 1) - p] += 1
        
        if present[0] == n:
            ans = max(ans, fixed[0])

        for j in range(1, k + 1):
            fixed[j] += fixed[j - 1]
            present[j] += present[j - 1]
            
            if present[j] == n:
                ans = max(ans, fixed[j])

    return n - ans  
        
T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))",fixed[f * d - p] += 1,"fixed[f * (d + 1)] += 1
            
            if f <= k + 1:
                present[0] += 1
                continue
            
            di = p // f

            if di > 0 and L <= f * di:
                present[0] += 1
                present[f * di + k - p + 1] -= 1
              
            if f * (di + 1) <= R:
                present[f * (di + 1) - p] += 1
        
        if present[0] == n:
            ans = max(ans, fixed[0])

        for j in range(1, k + 1):
            fixed[j] += fixed[j - 1]
            present[j] += present[j - 1]
            
            if present[j] == n:
"
"import sys

input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    f = list(map(int, input().split()))
    d = list(map(int, input().split()))
    p = [f[i] * d[i] for i in range(n)]
    p.sort()
    s = set()
    for fi in f:
        if fi > k:
            s.add(fi)

    def check(a, b):
        if b - a > k:
            return 0
        st = max(b - k, 1)
        en = a + k
        x = [0 for _ in range(en - st + 1 + 1)]
        for si in s:
            v = ((st + si - 1) // si) * si
            while v <= en:
                x[v - st] += 1
                v += si
        c = 0
        for i in range(st, st + k + 1):
            c += x[i - st]
        for i in range(st, a + 1):
            if c == len(s):
                return 1
            c -= x[i - st]
            c += x[i - st + k + 1]
        return 0

    result = 0
    a = 0
    b = 0
    while a < n and b < n:
        if check(p[a], p[b]):
            result = max(result, b - a + 1)
            b += 1
        else:
            a += 1
            if a > b:
                {{completion}}
    print(n - result)
",b = a,"a -= 1
                b += 1
    print(result)"
"import sys
input = sys.stdin.readline
class MinSegmentTree:
	""""""A data structure that can answer point update & range minimum queries.""""""

	def __init__(self, len_: int):
		self.len = len_
		self.tree = [0] * (2 * len_)

	def set(self, ind: int, val: int) -> None:
		""""""Sets the value at ind to val.""""""
		ind += self.len
		self.tree[ind] = val

		while ind > 1:
			self.tree[ind // 2] = min(self.tree[ind], self.tree[ind ^ 1])
			ind //= 2

	def range_min(self, start: int, end: int) -> int:
		"""""":return the minimum element of all elements in [start, end)""""""
		start += self.len
		end += self.len
		min_ = float(""inf"")
		while start < end:
			if start % 2 == 1:
				min_ = min(min_, self.tree[start])
				start += 1
			if end % 2 == 1:
				end -= 1
				min_ = min(min_, self.tree[end])

			start //= 2
			end //= 2
		return min_




for _ in range(int(input())):
    n,m = map(int,input().split())
    s = input()
    d1 = []
    d2 = []
    for i in range(n-1):
        d1.append((ord(s[i+1])-ord(s[i]))%26)
    for i in range(n-2):
        d2.append((ord(s[i+2])-ord(s[i]))%26)
    s1 = MinSegmentTree(n-1)
    s2 = MinSegmentTree(n-2)
    for i in range(n-1):
        s1.set(i,d1[i])
    for i in range(n-2):
        s2.set(i,d2[i])
    for i in range(m):
        s = list(map(int,input().split()))
        if s[0] == 1:
            l = s[1]-1
            r = s[2]
            x = s[3]
            if l != 0:
                d1[l-1] += x
                d1[l-1] %= 26
                s1.set(l-1,d1[l-1])
            if r != n:
                d1[r-1] -= x
                d1[r-1] %= 26
                s1.set(r-1,d1[r-1])
            for j in [l-1,l-2]:
                if n-3 >= j >= 0:
                    {{completion}}
            for j in [r-1,r-2]:
                if n-3 >= j >= 0:
                    d2[j] -= x
                    d2[j] %= 26
                    s2.set(j,d2[j])
        else:
            if s1.range_min(s[1]-1,s[2]-1) == 0 or s2.range_min(s[1]-1,s[2]-2) == 0:
                print('NO')
            else:
                print('YES')","d2[j] += x
                    d2[j] %= 26
                    s2.set(j,d2[j])","d1[j] += x
                    d1[j] %= 26
                    s2.set(j,d1[j])
        else:
            if s1.range_min(s[1]-1,s[2]-1) == 0 or s2.range_min(s[1]-1,s[2]-2) == 0:
                print('NO')
            else:
                print('YES')
        if s[0] == 2:
            l = s[1]-1
            r = s[2]
            x = s[3]
            if l != 0:
                d2[l-1] += x
                d2[l-1] %= 26
                s2.set(l-1,d2[l-1])
            if r != n:
                d2[r-1] -= x
                d2[r-1] %= 26
                s2.set(r-1,d2[r-1])"
"import collections
import math
import sys
import heapq

input = sys.stdin.readline


def inp():
    return (int(input()))
def inlt():
    return (list(map(int, input().split())))
def insr():
    s = input()
    return (list(s[:len(s) - 1]))
def invr():
    return (map(int, input().split()))

def lowbit(x):
    return x & -x

def update(index, d, tree):
    while index < len(tree):
        tree[index] += d
        index += lowbit(index)

def getsum(index, tree):
    res = 0
    while index > 0:
        res += tree[index]
        index -= lowbit(index)
    return res

def getsum_range(left, right, tree):
    res = 0 if left > right else getsum(right, tree) - getsum(left - 1, tree)
    return res


def solution():
    n, m = inlt()
    s = insr()
    s = [0] + [ord(i) - 97 for i in s]
    # x is the diff between s[i] and s[i+1]
    x = [-1] * (n + 1)
    for i in range(1, n):
        x[i] = (s[i + 1] - s[i]) % 26
    # y is the diff between s[i] and s[i+2]
    y = [-1] * (n + 1)
    for i in range(1, n - 1):
        y[i] = (s[i + 2] - s[i]) % 26
    # Fenwick tree of x and y, build the fenwick tree
    tree1 = [0] * (n + 5)
    tree2 = [0] * (n + 5)
    for i in range(1, n):
        if not x[i]:
            tree1[i] = 1
        if not y[i]:
            tree2[i] = 1
    for i in range(1, n + 5):
        j = i + lowbit(i)
        if j < n + 5:
            tree1[j] += tree1[i]
            tree2[j] += tree2[i]
    for _ in range(m):
        t = inlt()
        l, r = t[1], t[2]
        if t[0] == 1:
            u = t[3] % 26
            if not u:
                continue
            for i in [l-1, r]:
                d = u if i < l else -u
                if not 1 <= i < n:
                    {{completion}}
                if not x[i]:
                    update(i, -1, tree1)
                x[i] = (x[i] + d) % 26
                if not x[i]:
                    update(i, 1, tree1)
            z = [l - 2, l - 1, r - 1, r] if l != r else [l-2, r]
            for i in z:
                d = u if i < l else -u
                if not 1 <= i < n-1:
                    continue
                if not y[i]:
                    update(i, -1, tree2)
                y[i] = (y[i] + d) % 26
                if not y[i]:
                    update(i, 1, tree2)
        else:
            c = getsum_range(l, r - 1, tree1) + getsum_range(l, r - 2, tree2)
            ans = ""YES"" if not c else ""NO""
            print(ans)


if __name__ == '__main__':
    t = inp()
    for i in range(t):
        solution()
",continue,"d = -u
                if not x[i]:
                    update(i, -1, tree1)
                x[i] = (x[i] + d) % 26
                if not x[i]:
                    update(i, 1, tree1)
            z = [l - 2, l - 1, r - 1, r] if l != r else [l-2, r]
            for i in z:
                d = u if i < l else -u
                if not 1 <= i < n-1:
                    continue
                if not y[i]:
                    update(i, -1, tree2)
                y[i] = (y[i] + d) % 26
                if not y[i]:
                    update(i, 1, tree2)
        elif t[0] == 2:
            u = t[3] % 26
            if not u:
                continue
            for i in [l-1, "
"import sys
ipt = sys.stdin.readline

def iin():
    return int(ipt())
def lmin():
    return list(map(int,ipt().split()))

class Bit:
    '''
    0-indexed
    '''
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)
  
    def sum(self, i):
        '''
        iまでの和を求める
        '''
        i+=1
        s = 0
        while i > 0:
            s += self.tree[i]
            #s %= MOD
            i -= i & -i
        return s
  
    def add(self, i, x):
        '''
        iにxを追加する
        '''
        i+=1
        while i <= self.size:
            self.tree[i] += x
            #self.tree[i] %= MOD
            i += i & -i
    
    def get(self,i):
        """"""
        iの値を得る
        """"""
        return self.sum(i)-self.sum(i-1)

MOD = 26

for _ in range(iin()):
    N,Q = lmin()
    B = [0]*N
    S = ipt()[:-1]
    for i in range(1,N):
        B[i] = (ord(S[i])-ord(S[i-1]))%MOD
    
    
    
    bit2 = Bit(N)
    bit3 = Bit(N)
    for i in range(1,N):
        bit2.add(i,(B[i])%MOD == 0)
    for i in range(1,N-1):
        bit3.add(i,(B[i+1]+B[i])%MOD == 0)
    
    query = [lmin() for _ in range(Q)]
    for q in query:
        #print(B)
        if q[0] == 1:
            l,r,x = q[1:]
            if l != 1:
                B[l-1] = (B[l-1]+x)%MOD
                bit2.add(l-1,-bit2.get(l-1)+ (B[l-1]%MOD == 0))
                #print(bit2.get(l-1))
                if l-2 > 0:
                    {{completion}}
                if l != N:
                    #print(-bit3.get(l-1),(B[l]+B[l-1])%MOD)
                    bit3.add(l-1,-bit3.get(l-1) + ((B[l]+B[l-1])%MOD == 0))
                    #print(bit3.get(l-1))
            if r != N:
                B[r] = (B[r]-x)%MOD
                bit2.add(r,-bit2.get(r)+ (B[r]%MOD == 0))
                #print(bit2.get(r))
                if r != 1:
                    bit3.add(r-1,-bit3.get(r-1)+ ((B[r]+B[r-1])%MOD == 0))
                if r < N-1:
                    bit3.add(r,-bit3.get(r)+ ((B[r+1]+B[r])%MOD == 0))
        else:
            l,r = q[1:]
            if l == r:
                print(""YES"")
                continue

            if r-l >= 2 and bit3.sum(r-2)-bit3.sum(l-1) != 0:
                print(""NO"")
                continue

            if bit2.sum(r-1)-bit2.sum(l-1) != 0:
                print(""NO"")
                continue
            
            print(""YES"")


            
","bit3.add(l-2,-bit3.get(l-2)+ ((B[l-1]+B[l-2])%MOD == 0))","bit3.add(l-2,-bit3.get(l-2) + ((B[l-1]+B[l-2])%MOD == 0))
            if r != 1:
                B[r-1] = (B[r-1]-x)%MOD
                bit2.add(r-1,-bit2.get(r-1)+ (B[r-1]%MOD == 0))
                #print(bit2.get(r-1))
                if r-2 > 0:
                    bit3.add(r-2,-bit3.get(r-2) + ((B[r-1]+B[r-2])%MOD == 0))
        else:
            l,r = q[1:]
            if l == r:
                print(""YES"")
                continue

            if r-l >= 2 and bit"
"import sys

input = sys.stdin.readline

t = int(input())
for _ in range(t):
    m,n,k = map(int,input().split())
    grid = [list(input().strip()) for _ in range(m)]
    if m > n:
        m,n = n,m
        grid = list(zip(*grid))
    SS = [[0] * (n+1) for _ in range(m)]
    for i in range(m):
        for j in range(n):
            SS[i][j + 1] = SS[i][j] + (grid[i][j] == '#')
    ans = 0
    for i in range(m):
        for j in range(n):
            # 往上扫
            ans1 = 0
            ans2 = 0
            for l in range(min(k + 1,i + 1)):
                {{completion}}
            ans3 = 0
            ans4 = 0
            for l in range(min(k + 1,m - i)):
                left = max(0,j - k + l)
                right = min(n,j + k - l + 1)
                ans3 += SS[i + l][j + 1] - SS[i + l][left]
                ans4 += SS[i + l][right] - SS[i + l][j]
            ans = max(ans,ans1,ans2,ans3,ans4)
    print(ans)","left = max(0,j - k + l)
                right = min(n,j + k - l + 1)
                ans1 += SS[i - l][j + 1] - SS[i - l][left]
                ans2 += SS[i - l][right] - SS[i - l][j]","left = max(0,j - k + l)
                right = min(n,j + k - l + 1)
                ans1 += SS[i + l][j] - SS[i + l][left]
                ans2 += SS[i + l][right] - SS[i + l][j]
            ans = max(ans,ans1,ans2)
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            "
"# TLE solution

import sys
input = sys.stdin.readline

def solve():
    n, m, k = map(int, input().split())
    grid = [[char == ""#"" for char in input().rstrip()] for _ in range(n)]
    
    if n > m:
        grid = [list(row) for row in zip(*grid)]
        n, m = m, n

    k = min(k, m + n)
    ans = 0

    for _ in range(2):
        for _ in range(2):
            
            prv_diag = [0] * (m + k + 1)
            prv_col = [0] * (m + 1)

            for i in range(n):
                new_diag = [0] * (m + k + 1)
                new_col = [0] * (m + 1)
                dp = [0] * (m + 1)

                for j in range(m + k):
                    if j < m:
                        {{completion}}
                    if i - 1 >= 0 and j - 1 >= 0:
                        new_diag[j] += prv_diag[j - 1]
                    if i - k - 1 >= 0 and j - k - 1 >= 0:
                        new_diag[j] -= grid[i - k - 1][j - k - 1]
                
                for j in range(m - 1, -1, -1):
                    new_col[j] += grid[i][j] + prv_col[j]
                    if i - k - 1 >= 0:
                        new_col[j] -= grid[i - k - 1][j]
                    
                    dp[j] += dp[j + 1] + new_col[j] - new_diag[j + k + 1]
                    ans = max(ans, dp[j])
                
                prv_diag = new_diag
                prv_col = new_col

            grid.reverse()
        
        for row in grid:
            row.reverse()

    return ans
    

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))",new_diag[j] += grid[i][j],"dp[j] = 0
                    else:
                        dp[j] = grid[i][j]
                
                for j in range(m + 1):
                    new_diag[j] += dp[j + k + 1]"
"import sys
input = sys.stdin.readline
def inp():
    return int(input())
def inlt():
    return list(map(int, input().split()))


def rotate_right(m0):
    Y0, X0 = len(m0), len(m0[0])
    Y1, X1 = X0, Y0
    m1 = [[0] * X1 for _ in range(Y1)]
    for y0 in range(Y0):
        for x0 in range(X0):
            m1[x0][X1 - 1 - y0] = m0[y0][x0]
    return m1


for _ in range(inp()):
    Y, X, k = inlt()
    k += 1
    m = [[int(c == '#') for c in input().strip()] for _ in range(Y)]
    if Y > X:
        m = rotate_right(m)
        Y, X = len(m), len(m[0])
    # print(m)

    v = [[0] * (Y + 1) for x in range(X)]
    d = [[0] * (Y + 1) for i in range(Y + X - 1)]  # y + x

    def f():
        r = 0
        # print('start')
        for x in range(X):
            vx = v[x]
            vx[0] = 0
            for y in range(Y):
                vx[y + 1] = vx[y] + m[y][x]
        # print(v)

        for i in range(Y + X - 1):
            di = d[i]
            for y in range(Y):
                di[y] = 0
            for y in range(Y):
                x = i - y
                if 0 <= x < X:
                    {{completion}}
        # print(d)

        # 0
        for y in range(Y):
            s = 0
            for k0 in range(k, 0, -1):
                if k - k0 == X:
                    break
                vx = v[k - k0]
                s += vx[min(k0 + y, Y)] - vx[y]
            # print(y, 0, s)
            r = max(r, s)

            for x in range(1, X):
                # print(y, x)
                if y + x + k - 1 >= len(d):
                    break
                vx = v[x - 1]
                s -= vx[min(k + y, Y)] - vx[y]
                di = d[y + x + k - 1]
                s += di[min(k + y, Y)] - di[y]
                # print(y, x, s)
                r = max(r, s)
        return r

    rr = 0
    for _ in range(2):
        for _ in range(2):
            rr = max(rr, f())
            for l in m:
                l.reverse()
        m.reverse()

    print(rr)
",di[y + 1] = di[y] + m[y][x],"di[y] += m[y][x]
            d[i] = di
        # print(d)

        for y in range(Y):
            s = 0
            for k0 in range(k, 0, -1):
                if k - k0 == X:
                    break
                vx = v[k - k0]
                s += vx[min(k0 + y, Y)] - vx[y]
            r = max(r, s)

        for x in range(1, X):
            vx = v[x - 1]
            s -= vx[min(k + y, Y)] - vx[y]
            di = d[y + x + k - 1]
            s += di[min(k + y, Y)] - di[y]
            r = max(r, s)
        return r

    rr"
"import sys
# from math import *
from collections import Counter,defaultdict,deque
input=sys.stdin.readline
mod=10**9+7
def get_ints():return map(int,input().split())
def get_int():return int(input())
def get_array():return list(map(int,input().split()))
def input():return sys.stdin.readline().strip()
fact=[]
ifact=[]
def cfact(n):
    fact.append(1)
    ifact.append(1)
    for i in range(1,n+1):
        fact.append(fact[-1]*i%mod)
        ifact.append(pow(fact[-1],(mod-2),mod))

cfact(5000)

def comb(n,r):
    return fact[n]*ifact[n-r]*ifact[r]

for _ in range(int(input())):
    n,k=get_ints()
    a=get_array()
    ma=[0]*(n+1)
    dp=[0]*(n+1)
    dp[0]=1
    for i in range(n):
        e=a[i]
        cnt=0
        ma[i+1]=ma[i]
        dp[i+1]=dp[i]
        for j in range(i,-1,-1):
            if a[j]==e:
                cnt+=1
            else:
                {{completion}}
            if cnt>=2*k:
                break
            if cnt<k:
                continue
            m=ma[j]+1
            if m<ma[i+1]:
                continue
            if m>ma[i+1]:
                ma[i+1]=m
                dp[i+1]=0
            c=1
            if cnt>2:
                c=comb(cnt-2,k-2)%mod
            dp[i+1]+=(dp[j]*c%mod)
            dp[i+1]%=mod
    print(dp[n])",continue,cnt=0
"import collections
import functools
import itertools
import sys
# sys.setrecursionlimit(5500)
RD = sys.stdin.readline
INT = lambda: int(RD())
INTS = lambda: list(map(int, RD().split()))
# header
mod = 10 ** 9 + 7

_c = [[1], [1, 1]]
for k in range(5000):
    n = len(_c[-1])
    q = [1] * (n + 1)
    for i in range(1, n):
        q[i] = (_c[-1][i] + _c[-1][i-1]) % mod
    _c.append(q)

def C(n, m):
    assert(n >= 0 and 0 <= m <= n)
    return _c[n][m]

T = INT()
for _t in range(T):
    n, k = INTS()
    c = INTS()
    assert(len(c) == n)
    maxg = [0] * n
    d = collections.defaultdict(int)
    for i in range(n):
        if i > 0:
            maxg[i] = maxg[i - 1]
        d[c[i]] += 1
        if d[c[i]] >= k:
            maxg[i] += 1
            d.clear()
    # print(maxg)
    if k == 1 or maxg[-1] == 0:
        print(1)
        continue
    di = collections.defaultdict(collections.deque)
    rete = [0] * n
    rett = [0] * n
    for i in range(n):
        q = di[c[i]]
        q.append(i)
        while len(q) >= k:
            b = q[0]
            if (maxg[b - 1] if b > 0 else 0) + 1 < maxg[i]:
                q.popleft()
            else:
                break
        lq = len(q)
        # print(i, c[i], q)
        if lq >= k:
            for j in range(lq):
                if lq - j < k:
                    {{completion}}
                _a = rett[q[j] - 1] if q[j] > 0 and rett[q[j] - 1] > 0 else 1
                _b = C(lq - j - 2, k - 2)
                rete[i] = (rete[i] + _a * _b % mod) % mod
                if rete[i] == 0:
                    rete[i] = mod
        rett[i] = (rett[i-1] if i > 0 and maxg[i-1] == maxg[i] else 0) + rete[i]
        if rett[i] > 0 and rett[i] % mod == 0:
            rett[i] = mod
        else:
            rett[i] %= mod
    # print(rete)
    # print(rett)
    print(rett[-1] % mod)
        
",break,"rete[i] = (rete[i] + C(lq - j, k - 1) * C(q[j], k - 1) * C(q[j + 1], k - 1) if q[j] > 0 and q[j + 1] > 0 else 0) % mod
                else:
                    rete[i] = (rete[i] + C(lq - j, k - 1) * C(q[j], k - 1) * C(q[j + 1], k - 1) if q[j] > 0 and q[j + 1] > 0 else 0) % mod
                if rete[i] == 0:
                    rete[i] = mod
            rett[i] = (rett[i-1] if i > 0 and maxg[i-1] == maxg[i] else 0) + rete[i]
            if ret"
"def compute_g_sequence(n, memo):
    if n in memo:
        return memo[n]
    
    if n == 0:
        memo[n] = (0, 1)
        return memo[n]
    
    if n % 2 == 1:
        x, y = compute_g_sequence(n // 2, memo)
        memo[n] = (2 * x + y, y)
        return memo[n]
    
    a, b = compute_g_sequence(n // 2, memo)
    c, d = compute_g_sequence(n // 2 - 1, memo)
    memo[n] = (2 * a + 2 * c, b + d)
    return memo[n]
    
def compute_f_sequence(n, m):
    mod = 998244353
    
    if m == 1:
        result = n % mod
        if result < 0:
            {{completion}}
        return result
    
    if m >= 3:
        result = ((n + 1) // 2) * (n // 2 + 1)
        result = result % mod
        if result < 0:
            result += mod
        return result % mod
    
    result = compute_g_sequence(n, {})[0] % mod
    if result < 0:
        result += mod
    return result
    
t = int(input())

for _ in range(t):
    n, m = map(int, input().split())
    print(compute_f_sequence(n, m))
",result += mod,result += mod
"import sys
input = sys.stdin.readline
MOD = 998244353

def solve():
    n, m = map(int, input().split())
    
    if m == 1:
        return n % MOD
    
    if m > 2:
        if n % 2 == 1:
            return (n + 1) // 2 * (n + 1) // 2 % MOD
        else:
            return n // 2 * (n + 2) // 2 % MOD
    

    LOG = (n - 1).bit_length()
    dp = [[0] * 3 for _ in range(2)]
    dp[0][0] = 1
    sm = [[0] * 3 for _ in range(2)]

    for i in range(LOG + 2):
        ndp = [[0] * 3 for _ in range(2)]
        nsm = [[0] * 3 for _ in range(2)]
        for c in range(2):
            for b in range(3):
                nc = (c + b) // 2
                for nb in range(3):
                    if n >> i & 1 == (nc + nb) % 2:
                        {{completion}}
        
        dp = ndp
        sm = nsm
    
    return sm[0][0]

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","ndp[nc][nb] += dp[c][b]
                        ndp[nc][nb] %= MOD
                        nsm[nc][nb] += sm[c][b] + dp[c][b] * (nb % 2) * (1 << i)
                        nsm[nc][nb] %= MOD","ndp[c][b] += dp[c][b]
                        nsm[c][b] += sm[c][b]
        
        dp = ndp
        sm = nsm
    
    return sm[0][0]

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))
<|/ file ext=.py |>"
"dictionary2 = dict()
dictionary3 = dict()
MOD = 998244353
def solve2 (n, m) :
    if m in dictionary2 :
        return dictionary2[m]
    assert n == 2
    if m == 0 :
        return (0, 1)
    if m % 2 == 1 :
        left = solve2(n, m//2)
        dictionary2[m] = ((left[0] * 2 + left[1]) % MOD, left[1])
        return dictionary2[m]
    if m % 2 == 0 :
        left = solve2(n, m//2)
        right = solve2(n, m//2 - 1 )
        dictionary2[m] = ((left[0] * 2 + right[0] * 2) % MOD, left[1] + right[1])
        return dictionary2[m]
def solve3 (n, m) :
    if m in dictionary3 :
        return dictionary3[m]
    if m == 0 :
        return (0, 1)
    if m % 2 == 1 :
        left = solve3(n, m - 1)
        dictionary3[m] = ((left[0] + left[1]) % MOD, left[1])
        return dictionary3[m]
    left = solve3(n, m//2)
    right = solve3(n, m//2 - 1)
    dictionary3[m] = (((left[0] + right[0]) * 2) % MOD, left[1] + right[1])
    return dictionary3[m]
tc = int(input())
for t in range(tc) :
    m, n = map(int,input().split())
    n = min(n, 3)
    if n == 1 :
        print(m % MOD)
        continue
    if n == 2 :
        print(solve2(n, m)[0])
    else :
        {{completion}}
","print(solve3(n, m)[0])","ans = solve3(n, m)[0]
        print(ans % MOD)

<|/ file filename=P02_02_01.py ext=.py |>"
"import sys
import collections
import math
import bisect
#import heapq
#import itertools
import functools
input = sys.stdin.readline
 
class SegmentTree:
    
    def __init__(self, nums):
        self.l = len(nums)
        self.tree = [[0, 0, 0, 0] for _ in  range(2 * self.l)]
        for i in range(self.l):
            self.tree[self.l + i] = [nums[i], nums[i], 0, math.inf]
        for i in range(self.l - 1, 0, -1):
            self.tree[i] = self.merge(self.tree[i<<1|1], self.tree[i<<1])

    def merge(self, a, b):
        res = [0, 0, 0, 0]
        res[0] = min(a[0] + b[0], a[1] + b[2])
        res[1] = min(a[0] + b[1], a[1] + b[3])
        res[2] = min(a[2] + b[0], a[3] + b[2])
        res[3] = min(a[2] + b[1], a[3] + b[3])
        return res
    
    def update(self, i, val):
        n = self.l + i
        self.tree[n] = [val, val, 0, math.inf]
        while n > 1:
            self.tree[n>>1] = self.merge(self.tree[n | (n^1)], self.tree[n & (n^1)])
            n >>= 1
    
    def prodRange(self, i, j):
        m = self.l + i
        n = self.l + j
        resl = [0, math.inf, math.inf, 0]
        resr = [0, math.inf, math.inf, 0]
        while m <= n:
            if m & 1:
                {{completion}}
            m >>= 1
            if n & 1 == 0:
                resr = self.merge(resr, self.tree[n])
                n -= 1
            n >>= 1
        return self.merge(resr, resl)

n = int(input())
arr = list(map(int, input().split()))
q = int(input())
queries = []
for _ in range(q):
    queries.append(list(map(int, input().split())))
seg = SegmentTree(arr)
for i, v in queries:
    seg.update(i - 1, v)
    print(seg.prodRange(0, n - 2)[1] * 2)","resl = self.merge(self.tree[m], resl)
                m += 1","resl = self.merge(resl, self.tree[m])
                m += 1
            else:
                resr = self.merge(resr, self.tree[m])
                m += 1
            m >>= 1
            if n & 1 == 0:
                resr = self.merge(resr, self.tree[n])
                n -= 1
            n >>= 1
        return self.merge(resr, resl)

    def queryRange(self, i, j):
        m = self.l + i
        n = self.l + j
        resl = [0, math.inf, math.inf, 0]
        resr = [0, math.inf, math.inf, 0]
        while m <= n:
            if m & 1:
                resl = self.merge("
"class SegmentTree:
    __slots__ = [""n"", ""oper"", ""e"", ""log"", ""size"", ""data""]

    def __init__(self, n, oper, e):
        self.n = n
        self.oper = oper
        self.e = e
        self.log = (n - 1).bit_length()
        self.size = 1 << self.log
        self.data = [e() for _ in range(2 * self.size)]

    def build(self, arr):
        data, op, size, n = self.data, self.oper, self.size, self.n
        for i in range(n):
            {{completion}}
        for i in range(size - 1, 0, -1):
            ref = data[i : i + 1]
            op(ref, data[i << 1], data[i << 1 | 1])

    def set(self, p, x):
        data, log, op = self.data, self.log, self.oper
        p += self.size
        data[p] = x
        for _ in range(log):
            p >>= 1
            op([data[p]], data[p << 1], data[p << 1 | 1])

    def all_prod(self):
        return self.data[1]


import sys

inf = 1 << 60


input = lambda: sys.stdin.readline().rstrip(""\r\n"")


if __name__ == ""__main__"":
    n = int(input())
    A = list(map(int, input().split()))

    def op(rootRef, a, b):
        value = rootRef[0]
        if a == E:
            value[:] = b[:]
            return
        if b == E:
            value[:] = a[:]
            return
        value[0] = min(a[0] + b[2], a[1] + b[0], a[1] + b[2])
        value[1] = min(a[0] + b[3], a[1] + b[1], a[1] + b[3])
        value[2] = min(a[2] + b[2], a[3] + b[0], a[3] + b[2])
        value[3] = min(a[2] + b[3], a[3] + b[1], a[3] + b[3])

    E = [inf, inf, inf, inf]

    def e():
        return [inf, inf, inf, inf]

    st = SegmentTree(n - 1, op, e)
    st.build([[0, inf, inf, x] for x in A])

    for _ in range(int(input())):
        i, x = map(int, input().split())
        i -= 1

        st.set(i, [0, inf, inf, x])
        cur = st.all_prod()[-1]
        print(2 * cur)
",data[size + i] = arr[i],"op(arr[2 * i], arr[2 * i + 1], arr[2 * i + 2])
            op(arr[2 * i + 1], arr[2 * i + 2], arr[2 * i + 3])

    def query(self, p, q):
        data, op, size, log = self.data, self.oper, self.size, self.log
        p += self.size
        q = q << self.log
        data[p] = q
        for _ in range(log):
            p >>= 1
            q += data[p]
            op(data[p], data[p << 1], data[p << 1 | 1])
        return data[q]

    def all_prod(self):
        return self.data[self.size]


class SegmentTree:
    __slots__ = ["""
"from sys import stdin
input=lambda :stdin.readline()[:-1]
 
class segtree():
  def __init__(self,init,func,ide):
    self.n=len(init)
    self.func=func
    self.ide=ide
    self.size=1<<(self.n-1).bit_length()
    self.tree=[self.ide for i in range(2*self.size)]
    for i in range(self.n):
      self.tree[self.size+i]=init[i]
    for i in range(self.size-1,0,-1):
      self.tree[i]=self.func(self.tree[2*i], self.tree[2*i|1])
  
  def update(self,k,x):
    k+=self.size
    self.tree[k]=x
    k>>=1
    while k:
      self.tree[k]=self.func(self.tree[2*k],self.tree[k*2|1])
      k>>=1
  
  def get(self,i):
    return self.tree[i+self.size]
  
  def query(self,l,r):
    l+=self.size
    r+=self.size
    l_res=self.ide
    r_res=self.ide
    while l<r:
      if l&1:
        {{completion}}
      if r&1:
        r-=1
        r_res=self.func(self.tree[r],r_res)
      l>>=1
      r>>=1
    return self.func(l_res,r_res)
 
  def __iter__(self):
    for i in range(self.n):
      yield self.tree[i+self.size]
          
  def __str__(self):
    return str(list(self))
 
n=int(input())
a=list(map(int,input().split()))
 
inf=1<<50
 
def f(A,B):
  if A[0]==-1:
    return B
  if B[0]==-1:
    return A
  return (min(A[0]+B[0],A[0]+B[2],A[1]+B[0]),min(A[0]+B[1],A[0]+B[3],A[1]+B[1]),min(A[2]+B[0],A[2]+B[2],A[3]+B[0]),min(A[2]+B[1],A[2]+B[3],A[3]+B[1]))
 
seg=segtree([(a[i],inf,inf,0) for i in range(n-1)],f,(-1,-1,-1,-1))
q=int(input())
ans=[0]*q
for i in range(q):
  k,x=map(int,input().split())
  seg.update(k-1,(x,inf,inf,0))
  ans[i]=seg.tree[1][0]*2
print(*ans,sep='\n')
","l_res=self.func(l_res,self.tree[l])
        l+=1","l_res=self.func(self.tree[l],l_res)"
"def gcd(a, b):
  if a==0:
    return b
  return gcd(b%a, a)
def main():
  n = int(input())
  a = [int(i) for i in input().split()]
  ans = 0
  for k in range(1, n+1):
    if n%k==0:
      g = 0
      for i in range(n-k):
        {{completion}}
      ans += g!=1
  return ans

t = int(input())
while t:
  print(main())
  t -= 1","g = gcd(g, abs(a[i+k]-a[i]))","g = gcd(a[i], k)
      for i in range(k):
        a[i] = (a[i]/g)"
"import math
import sys


def solute():
    n = int(sys.stdin.readline())
    a_list = list(map(int, sys.stdin.readline().split()))

    i = 1
    divs = []
    while i * i <= n:
        if n % i == 0:
            divs.append(i)
            if i != n // i:
                {{completion}}
        i += 1

    divs.sort()
    succ = set()
    ans = 0
    for div in divs:
        g = 0
        did = False
        for num in succ:
            if div % num == 0:
                ans += 1
                did = True
                break
        if did:
            continue
        for i in range(n):
            g = math.gcd(g, a_list[i] - a_list[i % div])
            if g == 1:
                break
        if g != 1:
            ans += 1
            succ.add(div)

    print(ans)

t = int(sys.stdin.readline())

for _ in range(t):
    solute()",divs.append(n // i),divs.append(n // i)
"def gcd(a,b):
    if b==None:
        return a
    if b==0:
        return a
    elif a==0:
        return b
    else:
        return gcd(b,a%b)
    

for i in range(int(input())):
    n=int(input())
    l = [int(i) for i in input().split()]
    c=1
    for i in range(1,n):
        if n%i!=0:
            continue
        
        g=None
        for j in range(i):
            for k in range(j+i,n,i):
                {{completion}}
            if g==1:
                break
        else:
            c+=1
    print(c)","g=gcd(abs(l[k]-l[k-i]),g)","g=gcd(g,k%i)"
"import sys
import os

# import time
import bisect
# import functools
import math
import random
# import re
from collections import Counter, defaultdict, deque
# from copy import deepcopy
from functools import cmp_to_key, lru_cache, reduce
from heapq import heapify, heappop, heappush, heappushpop, nlargest, nsmallest
from itertools import accumulate, combinations, permutations
from operator import add, iand, ior, itemgetter, mul, xor
# from string import ascii_lowercase, ascii_uppercase
from typing import *

input = sys.stdin.readline

def I():
    return input()

def II():
    return int(input())

def MII():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

inf = float('inf')

# from types import GeneratorType

# def bootstrap(f, stack=[]):
#     def wrappedfunc(*args, **kwargs):
#         if stack:
#             return f(*args, **kwargs)
#         else:
#             to = f(*args, **kwargs)
#             while True:
#                 if type(to) is GeneratorType:
#                     stack.append(to)
#                     to = next(to)
#                 else:
#                     stack.pop()
#                     if not stack:
#                         break
#                     to = stack[-1].send(to)
#             return to
#     return wrappedfunc

# RANDOM = random.getrandbits(32)

# class Wrapper(int):
#     def __init__(self, x):
#         int.__init__(x)

#     def __hash__(self):
#         return super(Wrapper, self).__hash__() ^ RANDOM

input = sys.stdin.readline

class Factorial:
    def __init__(self, N, mod) -> None:
        N += 1
        self.mod = mod
        self.f = [1 for _ in range(N)]
        self.g = [1 for _ in range(N)]
        for i in range(1, N):
            self.f[i] = self.f[i - 1] * i % self.mod
        self.g[-1] = pow(self.f[-1], mod - 2, mod)
        for i in range(N - 2, -1, -1):
            self.g[i] = self.g[i + 1] * (i + 1) % self.mod

    def fac(self, n):
        return self.f[n]

    def fac_inv(self, n):
        return self.g[n]

    def comb(self, n, m):
        if n < m or m < 0 or n < 0: return 0
        return self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod

    def perm(self, n, m):
        if n < m or m < 0 or n < 0: return 0
        return self.f[n] * self.g[n - m] % self.mod

    def catalan(self, n):
        return (self.comb(2 * n, n) - self.comb(2 * n, n - 1)) % self.mod

    def inv(self, n):
        return self.f[n-1] * self.g[n] % self.mod

_index, _sep, buffer = 0, True, []
def read_int():
    global _index, buffer, _sep
    if _index >= len(buffer) - 1 + _sep:
        try:
            s = '' if _sep else buffer[-1]
            s += sys.stdin.readline(4096)
            _sep = s[-1].isspace()
            buffer = s.split()
        except:
            {{completion}}
        _index = 0
    _index += 1
    return int(buffer[_index - 1])

d = II()
mod = 10 ** 9 + 7
fact = Factorial(10 ** 5 * 25, mod)

x1, x2 = 0, 0
for i in range(d + 1):
    val = read_int()
    if i % 2 == 0:
        if i < d: x1 += fact.comb(d-1, i) * val
        x2 += fact.comb(d, i) * val
    else:
        if i < d: x1 -= fact.comb(d-1, i) * val
        x2 -= fact.comb(d, i) * val
    x1 %= mod
    x2 %= mod

y1 = 0
for i in range(d):
    val = read_int()
    if i < d:
        if i % 2 == 0: y1 += fact.comb(d-1, i) * val
        else: y1 -= fact.comb(d-1, i) * val

diff = (x1 - y1) % mod
print(diff * pow(x2, mod - 2, mod) % mod)


",pass,"buffer = []
            _sep = False"
"import sys
import os

# import time
import bisect
# import functools
import math
import random
# import re
from collections import Counter, defaultdict, deque
# from copy import deepcopy
from functools import cmp_to_key, lru_cache, reduce
from heapq import heapify, heappop, heappush, heappushpop, nlargest, nsmallest
from itertools import accumulate, combinations, permutations
from operator import add, iand, ior, itemgetter, mul, xor
# from string import ascii_lowercase, ascii_uppercase
from typing import *

input = sys.stdin.readline

def I():
    return input()

def II():
    return int(input())

def MII():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

inf = float('inf')

# from types import GeneratorType

# def bootstrap(f, stack=[]):
#     def wrappedfunc(*args, **kwargs):
#         if stack:
#             return f(*args, **kwargs)
#         else:
#             to = f(*args, **kwargs)
#             while True:
#                 if type(to) is GeneratorType:
#                     stack.append(to)
#                     to = next(to)
#                 else:
#                     stack.pop()
#                     if not stack:
#                         break
#                     to = stack[-1].send(to)
#             return to
#     return wrappedfunc

# RANDOM = random.getrandbits(32)

# class Wrapper(int):
#     def __init__(self, x):
#         int.__init__(x)

#     def __hash__(self):
#         return super(Wrapper, self).__hash__() ^ RANDOM

input = sys.stdin.readline

class Factorial:
    def __init__(self, N, mod) -> None:
        N += 1
        self.mod = mod
        self.f = [1 for _ in range(N)]
        self.g = [1 for _ in range(N)]
        for i in range(1, N):
            self.f[i] = self.f[i - 1] * i % self.mod
        self.g[-1] = pow(self.f[-1], mod - 2, mod)
        for i in range(N - 2, -1, -1):
            self.g[i] = self.g[i + 1] * (i + 1) % self.mod

    def fac(self, n):
        return self.f[n]

    def fac_inv(self, n):
        return self.g[n]

    def comb(self, n, m):
        if n < m or m < 0 or n < 0: return 0
        return self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod

    def perm(self, n, m):
        if n < m or m < 0 or n < 0: return 0
        return self.f[n] * self.g[n - m] % self.mod

    def catalan(self, n):
        return (self.comb(2 * n, n) - self.comb(2 * n, n - 1)) % self.mod

    def inv(self, n):
        return self.f[n-1] * self.g[n] % self.mod

_index, _sep, buffer = 1, False, ['']
def read_int():
    global _index, buffer, _sep
    if _index < len(buffer) - 1 or _sep and _index < len(buffer):
        _index += 1
        return int(buffer[_index - 1])
    else:
        try:
            s = '' if _sep else buffer[-1]
            s += sys.stdin.readline(4096)
            _sep = not s[-1].isdigit()
            buffer = s.split()
        except:
            {{completion}}
        _index = 0
    _index += 1
    return int(buffer[_index - 1])


d = II()
mod = 10 ** 9 + 7
fact = Factorial(10 ** 5 * 25, mod)

x1, x2 = 0, 0
for i in range(d + 1):
    val = read_int()
    if i % 2 == 0:
        if i < d: x1 += fact.comb(d-1, i) * val
        x2 += fact.comb(d, i) * val
    else:
        if i < d: x1 -= fact.comb(d-1, i) * val
        x2 -= fact.comb(d, i) * val
    x1 %= mod
    x2 %= mod
 
y1 = 0
for i in range(d):
    val = read_int()
    if i < d:
        if i % 2 == 0: y1 += fact.comb(d-1, i) * val
        else: y1 -= fact.comb(d-1, i) * val
 
diff = (x1 - y1) % mod
print(diff * pow(x2, mod - 2, mod) % mod)
",pass,"buffer = ['']
            _sep = False"
"for _ in range(int(input())):
    {{completion}}","a, b = map(int, input().split())
    s = int((a + b) ** 0.5)
    print(min(k - 1 + (a + k - 1) // k + (b + k - 1) // k for k in range(max(1, s - 1000), s + 1000)))","a, b = map(int, input().split())
    count = 0
    x, y = 0, 0
    while x < a and y < b:
        if x == 0 and y == 0:
            count += 1
        elif x == a:
            count += 1
            y += 1
        elif y == b:
            count += 1
            x += 1
        else:
            count += 1
            y += 1
            x += 1
    print(count)
<|/ file dstars=0 |>"
"from math import ceil, floor, sqrt

t = int(input())

for _ in range(t):
  a, b = list(map(int, input().split()))
  estM = floor(sqrt(a+b))
  mi = 1e18
  for m in range(estM-100, estM+100):
    if m <= 0: {{completion}}
    cost = m - 1 + ceil(a/m) + ceil(b/m)
    if cost < mi:
      mi = cost
  print(mi)
",continue,continue
"for x in range(int(input())):
	mm=999999999999
	a,b=map(int,input().split())
	for y in range(max(1,int((a+b)**0.5-100)),int((a+b)**0.5)+100):
		k=a//y+b//y
		if a%y:
			{{completion}}
		if b%y:
			k+=1
		mm=min(k+y-1,mm)
	print(mm)
		",k+=1,k+=1
"#import math
from sys import stdin,stdout
#from heapq import heappop,heappush
#from collections import deque
input,print = stdin.readline,stdout.write

n,k=map(int,input().split())
arr=list(map(int,input().split()))
lis=[0]*n
prev=0
count=0
for i in range(n):
    if arr[i]>prev:
        count=0
        prev=arr[i]
        continue
    else:
        count+=1
        prev=arr[i]
        if count&2:
            {{completion}}
for i in range(1,n):
    lis[i]+=lis[i-1]
for i in range(k):
    a,b=map(int,input().split())
    x=b-a+1
    if x<3:
        print(str(x)+'\n')
        continue
    x-=lis[b-1]-lis[a]
    print(str(x)+'\n')","count=1
            lis[i]=1","lis[count//2]-=1
            count-=1
        else:
            lis[count//2]+=1
            count-=1
if count&2:
    lis[count//2]-=1
    count-=1
else:
    lis[count//2]+=1
    count-=1
lis=lis[:k]"
"import sys
input = sys.stdin.readline

n, q = map(int, input().split())
A = list(map(int, input().split()))

P = [0] * (n + 2)
P[1] = 1
P[2] = 2
for i in range(2, n):
    P[i + 1] = P[i]
    if A[i] > A[i - 1] or A[i - 1] > A[i - 2]:
        P[i + 1] += 1

res = []
for _ in range(q):
    l, r = [int(x) - 1 for x in input().split()]
    ans = P[r + 1] - P[l]
    if P[l] == P[l + 1]:
        ans += 1
        if P[l + 1] == P[l + 2] and l + 1 <= r:
            {{completion}}
    elif P[l + 1] == P[l + 2] and l < r:
        ans += 1
    
    res.append(ans)

print(""\n"".join(map(str, res)))",ans += 1,ans += 1
"import io
import os
import sys

input = sys.stdin.readline

############ ---- Input Functions ---- ############


def inp():
    return int(input())


def inlt():
    return list(map(int, input().split()))


def insr():
    s = input()
    return list(s[: len(s) - 1])


def invr():
    return map(int, input().split())


if __name__ == ""__main__"":

    for _ in range(inp()):
        n, m = inlt()
        ed = {}
        s = 1
        e = 1
        sete = 0

        for __ in range(n):
            arr = inlt()
            if arr[0] == 0:
                sete = e
                e += 1
                continue
            empt = False
            if sete >= s:
                empt = True
            for i in arr[1:]:
                if i not in ed:
                    {{completion}}
                if ed[i] >= s:
                    empt = True
                    s = ed[i] + 1
                ed[i] = e
            if empt:
                e += 1
        if sete >= s:
            print(m)
            continue
        print(len([i for i in ed if ed[i] >= s]))
",ed[i] = 0,"ed[i] = e
                    e += 1"
"import sys

def solve():
    n, m = map(int, input().split())
    apples = [[] for _ in range(n)]
    for i in range(n):
        k, *a = map(int, input().split())
        for j in range(k):
            apples[i].append(a[j])

    last = {}
    def get_last(i):
        return last.get(i, -1)

    can_zero = [False] * (n + 1)
    can_zero[0] = True
    prev = [0] * (n + 1)
    oops = -1
    for i in range(n):
        if not apples[i]:
            can_zero[i + 1] = True
            last[0] = i
        else:
            nearest_pair = get_last(0)
            new_oops = oops
            for x in apples[i]:
                nearest_pair = max(nearest_pair, get_last(x))
                new_oops = max(new_oops, get_last(x))
                last[x] = i
            if nearest_pair != -1:
                nearest_zero = prev[nearest_pair]
                if oops < nearest_zero:
                    {{completion}}
            oops = new_oops
        if can_zero[i + 1]:
            prev[i + 1] = i + 1
        else:
            prev[i + 1] = prev[i]

    used = set()
    max_cnt = [0] * (n + 1)
    current_cnt = 0
    for i in reversed(range(n)):
        fail = False
        if not apples[i]:
            used.add(0)
        for x in apples[i]:
            if x in used:
                fail = True
                break
            used.add(x)
            current_cnt += 1
        if fail:
            break
        if 0 in used:
            max_cnt[i] = m
        else:
            max_cnt[i] = current_cnt

    ans = 0
    for i in range(n + 1):
        if can_zero[i]:
            ans = max(ans, max_cnt[i])
    print(ans)

input = sys.stdin.readline
t = 1
t = int(input())
for _ in range(t):
    solve()
",can_zero[i + 1] = True,"can_zero[nearest_zero] = True
                    can_zero[i] = True
                    oops = nearest_zero
                else:
                    can_zero[i] = True
                    can_zero[nearest_zero] = True
                    oops = nearest_zero
            else:
                can_zero[i] = True
                can_zero[nearest_pair] = True"
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""""""
Created on Fri Apr 21 20:49:45 2023

@author: ivanperezmejia
""""""

import sys
import math

input = sys.stdin.readline

############ ---- IInput Functions ---- ############

# for integer inputs
def inp():
    return(int(input()))


# for list inputs
def inlt():
    return(list(map(int,input().split())))


#for string inputs
def insr():
    s = input()
    return(list(s[:len(s) - 1]))


#for space separated integer variable inputs
def invr():
    return(map(int,input().split()))


if __name__ == ""__main__"":
    
    for _ in range(inp()):
        n, m = inlt()
        ed = {}
        s = 1
        e = 1
        sete = 0
 
        for _ in range(n):
            apples = inlt()
            if apples[0] == 0:
                sete = e
                e += 1
                continue
            
            empty = False
            if sete >= s:
                empty = True
            for i in apples[1:]:
                if i not in ed:
                    {{completion}}
                if ed[i] >= s:
                    empty = True
                    s = ed[i] + 1
                ed[i] = e
            if empty:
                e += 1
        
        if sete >= s:
            print(m)
            continue
        
        print(len([i for i in ed if ed[i] >= s]))
    ",ed[i] = 0,"ed[i] = e
                    e += 1
                else:"
"def II():
    return(int(input()))
def LMI():
    return(list(map(int,input().split())))
def I():
    return(input())
def MII():
    return(map(int,input().split()))
import sys
input=sys.stdin.readline
# import io,os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# from collections import Counter
# int(math.log(len(L)))
# import math
# from collections import defaultdict
mod=10**9+7
# from collections import deque
import  math



def t():
    n,k=MII()
    L=LMI()
    dp=[[0]*(n+1) for _ in range(n)]
    dp[0][1]=1
    for i in range(1,n):
        dp[i][1]=1
        for j in range(i):
            if L[j]!=L[i]:
                for s in range(1,n):
                    if s%k==0:
                        {{completion}}
            else:
                for s in range(1,n):
                    dp[i][s+1]+=dp[j][s]%mod
    ma=0
    for i in range(n):
        for j in range(1,n+1):
            if dp[i][j]!=0 and j%k==0:
                ma=max(ma,j)
    ans=0
    for i in range(n):
        ans+=dp[i][ma]%mod
        ans%=mod
    print(max(ans,1))










if __name__==""__main__"":

    for _ in range(II()):
        t()
    # t()",dp[i][s+1]+=dp[j][s]%mod,"dp[i][s+1]+=dp[j][s]%mod
    dp[n][n+1]=1
    for i in range(n-1,-1,-1):
        for j in range(i+1,n):
            if L[j]!=L[i]:
                for s in range(1,n):
                    if s%k==0:
                        dp[i][s+1]+=dp[j][s]%mod
    for i in range(n-1,-1,-1):
        for j in range(i+1,n):
            if L[j]!=L[i]:
                for s in range(1,n):
                    if s%k==0:
                        dp[i][s+1]+=dp[j][s]%mod
    for i in range(n-1,-1,-1):
        for j in range(i+1,n):
            if L[j]!=L[i]:
                for s in range(1,"
"from sys import stdin
input=lambda :stdin.readline()[:-1]
t=int(input())
for u in range(0,t):
    n,k=map(int,input().split())
    c=list(map(int,input().split()))
    data1=[-1]*n
    data2=[]
    for i in range(0,n):
        j=i
        p=0
        while True:
            if c[j]==c[i]:
                p+=1
            if p==k:
                data1[i]=j
                break
            j+=1
            if j>=n:
                break
    for i in range(0,n):
        if data1[i]>=0:
            data2.append([i,data1[i]])
    data2.sort(key=lambda x:x[1])
    out=0
    r=-1
    for w in data2:
        if w[0]>r:
            out+=1
            r=w[1]
    m=out*k
    if out==0:
        print(1)
        continue
    if k==1:
        print(1)
        continue
    d1=[1]*n
    d2=[-1]*n
    for i in range(2,m+1):
        sum_=[0]*(n+1)
        sum1=0
        for j in range(0,n-1):
            sum1+=d1[j]
            sum1%=1000000007
            sum_[c[j]]+=d1[j]
            sum_[c[j]]%=1000000007
            if i%k==1:
                d2[j+1]=sum1
            else:
                {{completion}}
        d2[0]=0
        d1=list(map(int,d2))
        d2=[-1]*n
    print(sum(d1)%1000000007)",d2[j+1]=sum_[c[j+1]],"d2[j+1]=sum1-sum_[c[j]]
        for j in range(0,n-1):
            d1[j]=sum_[c[j]]
        d1[0]=0
        d1=list(map(int,d1))
        d1=[-1]*n
    for i in range(0,n-1):
        d2[i]=sum1-sum_[c[i]]"
"import sys

# sys.setrecursionlimit(300005)
int1 = lambda x: int(x)-1
pDB = lambda *x: print(*x, end=""\n"", file=sys.stderr)
p2D = lambda x: print(*x, sep=""\n"", end=""\n\n"", file=sys.stderr)
def II(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def SI(): return sys.stdin.readline().rstrip()
# dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
# dij = [(0, 1), (-1, 0), (0, -1), (1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
inf = (1 << 63)-1
# inf = 4294967295
md = 10**9+7
# md = 998244353

def solve():
    n,k=LI()
    aa=LI()

    if k==1:
        print(1)
        return

    dp=[[0]*(n+1) for _ in range(n+1)]
    dp[0][0]=1
    for i,a in enumerate(aa,1):
        for c in range(1,i+1):
            v=0
            for j in range(i):
                if j==0 or c%k==1 or aa[j-1]==a:
                    {{completion}}
            dp[i][c]=v

    # p2D(dp)
    for c in range(n//k*k,-1,-k):
        ans=0
        for i in range(n+1):
            ans+=dp[i][c]
            ans%=md
        if ans:
            print(ans)
            return
    print(1)

    # ***************************************

testnumber = II()
# testnumber = 1
for testcase in range(testnumber):
    solve()
    # print(""YES"" if solve() else ""NO"")
    # print(""Yes"" if solve() else ""No"")
","v+=dp[j][c-1]
                    v%=md","v+=dp[j][c]
            v+=dp[i][c]
            dp[i][c]=v

    for c in range(n//k*k,-1,-k):
        ans=0
        for i in range(n+1):
            ans+=dp[i][c]
            ans%=md
        if ans:
            print(ans)
            return
    print(1)

def solve():
    n,k=LI()
    aa=LI()

    if k==1:
        print(1)
        return

    dp=[[0]*(n+1) for _ in range(n+1)]
    dp[0][0]=1
    for i,a in enumerate(aa,1):
        for c in range(1,i+1):
            v"
"M=998244353
F=[1]
I=[1]
for i in range(1,300001):{{completion}}
n,m,k=map(int,input().split())
n-=m*(k+1)
print(sum((-1)**i*pow(2,m-i,M)*F[m]*I[i]*I[m-i]*F[n+m-k*i]*I[m]*I[n-k*i]for i in range(m+1)if n>=k*i)%M)
","F.append((F[-1]*i)%M);I.append(pow(F[-1],-1,M))","
    F.append(F[-1]*i)
    I.append(I[-1]*i)
F.append(1)
I.append(1)
for i in range(1,n+1):
    F.append(F[-1]*i)
    I.append(I[-1]*i)
for i in range(1,m+1):
    F.append(F[-1]*i)
    I.append(I[-1]*i)
for i in range(1,k+1):
    F.append(F[-1]*i)
    I.append(I[-1]*i)
for i in range(1,n+1):
    F.append(F[-1]*i)
    I.append(I[-1]*i)
for i in range(1,m+1):
    F.append(F[-1]*i)
    I.append(I[-1]*i)
for i in range(1,k+1):"
"MOD, N = 998244353, int(3e5) + 5

fct, invfct, p2 = [N * [1] for _ in range(3)]

for i in range(1, N):
    {{completion}}

invfct[-1] = pow(fct[-1], MOD - 2, MOD)

for i in range(N - 2, 0, -1):
    invfct[i] = invfct[i + 1] * (i + 1) % MOD


def nCr(n, r):
    return fct[n] * invfct[n - r] % MOD * invfct[r] % MOD


n, m, k = map(int, input().split())

i, ans = 2 * [0]

while i <= m and n - k * (i + m) >= m:
    cur = 1 if i % 2 == 0 else MOD - 1

    cur = cur * nCr(n - k * (i + m), m) % MOD * nCr(m, i) % MOD * p2[m - i] % MOD

    ans = (ans + cur) % MOD

    i += 1

print(ans)","fct[i] = fct[i - 1] * i % MOD

    p2[i] = p2[i - 1] * 2 % MOD","mod = i % MOD
    fct[i] = (mod + MOD * pow(2, i, MOD)) % MOD
    invfct[i] = (mod + MOD * pow(2, N - i, MOD)) % MOD

for i in range(1, N):
    p2[i] = (mod + MOD * pow(2, i, MOD)) % MOD

MOD = MOD * 2

fct[-1] = pow(fct[-1], MOD - 2, MOD)"
"from math import comb

mod=998244353
nm=10**6
fact=[1]*(nm+1)
for i in range(2,nm+1):
    fact[i]=fact[i-1]*i % mod
 
inv=[1]*(nm+1)
inv[nm]=pow(fact[nm],mod-2,mod)
for i in range(nm-1,0,-1):
    inv[i]=inv[i+1]*(i+1) %mod
 
def comb(n, m):
    return fact[n]*inv[m] % mod*inv[n-m] % mod if 0 <= m <= n else 0
 
n, m, k = map(int, input().split())
if n<(m*(k+1)):
    print(0)
else:
    sn,ans=1,0
    for i in range(m+1):
        a=m-i
        c=n-a*(k+1)-i*(2*k+1)
        if c>=0:
            {{completion}}
        sn=-sn
    print(ans)
","ans+=sn*comb(a+i+c, a)*comb(i+c, i)*pow(2, a, mod)
            ans%=mod","ans=ans+comb(c,i)
        if a>=0:
            ans=ans+comb(a,i)"
"import sys
from collections import defaultdict
input = sys.stdin.readline 

for _ in range(int(input())):
    n = int(input()) 
    a = [] 
    for i in range(n):
        a.append(list(map(int, input().split()))) 
    mx = max(i for i, _ in a) 
    my = max(i for _, i in a) 
    s = sum(i * j for i, j in a) 
    
    ans = set()
    
    def possible(x, y):
        f = defaultdict(set) 
        g = defaultdict(set) 
        
        for i, (u, v) in enumerate(a):
            f[u].add(i) 
            g[v].add(i) 
        
        for i in range(n):
            if(x in f and len(f[x]) > 0):
                p = f[x].pop() 
                y -= a[p][1] 
                g[a[p][1]].remove(p) 
            elif(y in g and len(g[y]) > 0):
                {{completion}} 
            else:
                return False 
        return True 
    
    if(s % mx == 0 and possible(mx, s // mx)):
        ans.add((mx, s // mx))
             
             
    if(s % my == 0 and possible(s // my, my)):
        ans.add((s // my, my)) 
    
    print(len(ans)) 
    for i, j in ans:
        print(i, j)
    ","p = g[y].pop() 
                x -= a[p][0] 
                f[a[p][0]].remove(p)","p = g[y].pop() 
                x -= a[p][0] 
                f[a[p][0]].remove(p) 
            elif(y == 0):
                return True 
            elif(y == 1):
                return False 
            elif(y == 2):
                return True 
            elif(y == 3):
                return False 
            elif(y == 4):
                return True 
            elif(y == 5):
                return False 
            elif(y == 6):
                return True 
            elif(y == 7):
                return False 
            elif(y == 8):
                return True 
            elif(y == 9):
                return False 
            elif(y == 10):
                return True 
            elif(y == 11):
                return False 
            elif(y == 12"
"# https://codeforces.com/contest/1820

import sys
from collections import defaultdict
from typing import DefaultDict, List

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n = int(input())
    r = [tuple(map(int, input().split())) for _ in range(n)]

    area = 0
    dh: DefaultDict[int, List[int]] = defaultdict(list)
    dw: DefaultDict[int, List[int]] = defaultdict(list)
    for i, (h, w) in enumerate(r):
        area += h * w
        dh[h] += [i]
        dw[w] += [i]
    h_max = max(dh.keys())
    w_max = max(dw.keys())

    ans = set()

    for vertical_cut in [True, False]:

        used = [False] * n
        area_current = area

        if vertical_cut:
            if area % h_max != 0:
                continue
            h_current = h_max
            w_current = area_current // h_current
        else:
            if area % w_max != 0:
                continue
            w_current = w_max
            h_current = area_current // w_current

        candidate = (h_current, w_current)
        cut_possible = False
        while True:
            if vertical_cut:
                w_tmp = 0
                for i in dh[h_current]:
                    if not used[i]:
                        used[i] = True
                        w_tmp += r[i][1]
                if w_tmp == 0:
                    break
                else:
                    w_current -= w_tmp
                    area_current -= h_current * w_tmp
                    if area_current == 0:
                        cut_possible = True
                        break
            else:
                h_tmp = 0
                for i in dw[w_current]:
                    if not used[i]:
                        used[i] = True
                        h_tmp += r[i][0]
                if h_tmp == 0:
                    break
                else:
                    h_current -= h_tmp
                    area_current -= h_tmp * w_current
                    if area_current == 0:
                        {{completion}}
            vertical_cut = not vertical_cut

        if cut_possible:
            ans |= {candidate}

    print(len(ans))
    for shape in ans:
        print(*shape)


for _ in range(int(input())):
    solve_case()
","cut_possible = True
                        break","cut_possible = True
                        break

            candidate = (h_current, w_current)
            if candidate in ans:
                break"
"import sys
from collections import defaultdict, deque
from math import inf
MOD = 10**9 + 7

stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

t = int(input())

# at most two possible configurations
# either the largest h was an original height, of the largest w was the original width

def solve():
    n = ni()
    area = 0
    max_h = 0
    max_w = 0
    AB = []
    H = defaultdict(list)
    HH = defaultdict(list)
    W = defaultdict(list)
    WW = defaultdict(list)
    for i in range(n):
        a,b = na()
        max_h = max(max_h, a)
        max_w = max(max_w, b)
        area += a*b
        H[a].append(i)
        HH[a].append(i)
        W[b].append(i)
        WW[b].append(i)
        AB.append((a,b))

    ans = set()

    def dfs(sh,sw,H,W):
        q = [(sh,sw)]
        seen = [False]*n
        used = 0
        while q:
            assert len(q) == 1
            h,w = q.pop()
            # print(h,w,H,W)
            if h < 0 or w < 0: {{completion}}
            if (h == 0 or w == 0) and used == n:
                ans.add((sh,sw))
                break
            used += 1
            while H[h] and seen[H[h][-1]]:
                H[h].pop()
            if H[h]:
                i = H[h].pop()
                seen[i] = True
                a,b = AB[i]
                q.append((h,w-b))
                continue

            while W[w] and seen[W[w][-1]]:
                W[w].pop()
            if W[w]:
                i = W[w].pop()
                seen[i] = True
                a,b = AB[i]
                q.append((h-a,w))

    if area % max_h == 0:
        w = area//max_h
        dfs(max_h,w,H,W)
    if area % max_w == 0:
        h = area//max_w
        dfs(h,max_w,HH,WW)

    print(len(ans))
    for a,b in ans:
        print(a,b)




for _ in range(t):
    solve()
",break,continue
"import sys
input=sys.stdin.buffer.readline
def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input()
def rm():
    return map(int,input().split())

def main():
    s1=rs();a1=[c for c in s1]
    s2=rs();a2=[c for c in s2]
    a=[a1,a2]
    n=len(s1)
    dif=0
    for i in range(n):
        if a1[i]!=a2[i]:dif+=1
    t,q=rm()
    blk=[-1]*q
    for i in range(q):
        if i-t>=0 and blk[i-t]!=-1:
            if a1[blk[i-t]]!=a2[blk[i-t]]: dif+=1
        qry=rl()
        if len(qry)==1: 
            print('YES' if dif==0 else 'NO')
        elif len(qry)==2:
            blk[i]=qry[1]-1
            if a1[blk[i]]!=a2[blk[i]]:{{completion}}
        else:
            st1,loc1,st2,loc2=qry[1:]
            loc1-=1;loc2-=1;st1-=1;st2-=1
            dif-=(int(a[0][loc1]!=a[1][loc1])+int(a[0][loc2]!=a[1][loc2]))
            a[st1][loc1],a[st2][loc2]=a[st2][loc2],a[st1][loc1]
            dif+=(int(a[0][loc1]!=a[1][loc1])+int(a[0][loc2]!=a[1][loc2]))

t=ri()
for i in range(t):
    main()",dif-=1,"dif+=1
            print('YES' if dif==0 else 'NO')
        elif len(qry)==3:
            blk[i]=qry[1]-1
            blk[i+1]=qry[2]-1
            if a1[blk[i]]!=a2[blk[i]] or a1[blk[i+1]]!=a2[blk[i+1]]:dif+=1
            print('YES' if dif==0 else 'NO')
        elif len(qry)==4:
            blk[i]=qry[1]-1
            blk[i+1]=qry[2]-1
            blk[i+2]=qry[3]-1
            if a1[blk[i]]!=a2[blk[i]] or a1[blk[i+1]]!=a"
"import sys
from array import array
from bisect import *

input = lambda: sys.stdin.buffer.readline().decode().rstrip()
inp = lambda dtype: [dtype(x) for x in input().split()]
debug = lambda *x: print(*x, file=sys.stderr)
sum_n = lambda n: (n * (n + 1)) // 2
get_bit = lambda x, i: (x >> i) & 1
ceil_ = lambda a, b: a // b if (a >= 0) ^ (b > 0) else (abs(a) + abs(b) - 1) // abs(b)
Mint, Mlong, out = 2 ** 30 - 1, 2 ** 62 - 1, []

for _ in range(1, int(input()) + 1):
    s = [array('u', input()) for _ in range(2)]
    t, q = inp(int)
    n, tot_diff = len(s[0]), 0
    adj = [array('i') for _ in range(q)]

    for i in range(n):
        if s[0][i] != s[1][i]:
            tot_diff += 1

    for i in range(q):
        qur = inp(int)
        while adj[i]:
            ix = adj[i].pop()
            tot_diff += s[0][ix] != s[1][ix]

        if qur[0] == 3:
            out.append(['no', 'yes'][tot_diff == 0])

        elif qur[0] == 1:
            if i + t < q:
                adj[i + t].append(qur[1] - 1)
            if s[0][qur[1] - 1] != s[1][qur[1] - 1]:
                tot_diff -= 1
        else:
            for j in range(5): qur[j] -= 1
            poss = {qur[2], qur[4]}

            for ix in poss:
                if s[0][ix] != s[1][ix]:
                    {{completion}}

            s[qur[1]][qur[2]], s[qur[3]][qur[4]] = s[qur[3]][qur[4]], s[qur[1]][qur[2]]

            for ix in poss:
                if s[0][ix] != s[1][ix]:
                    tot_diff += 1
print('\n'.join(map(str, out)))
",tot_diff -= 1,"tot_diff += 1
            poss = {qur[1], qur[3]}"
"import sys
from collections import deque

input = lambda: sys.stdin.readline().rstrip()


def solution(s, t, m, q):
    n = len(s[0])
    res, Q, cnt = [], deque(), 0
    cnt = sum(s[0][i] != s[1][i] for i in range(n))

    for i in range(m):
        while Q and Q[0][0] == i:
            tm, x = Q.popleft()
            if s[0][x] != s[1][x]:
                cnt += 1

        if q[i][0] == 0:
            idx = q[i][1]
            if s[0][idx] != s[1][idx]:
                cnt -= 1
            Q.append((i + t, idx))

        elif q[i][0] == 1:
            a, b, c, d = q[i][1:]
            if s[0][b] != s[1][b]: cnt -= 1
            if s[0][d] != s[1][d]: cnt -= 1
            s[a][b], s[c][d] = s[c][d], s[a][b]
            if s[0][b] != s[1][b]: cnt += 1
            if s[0][d] != s[1][d]: cnt += 1

        else:
            if cnt:
                res.append(""NO"")
            else:
                {{completion}}

    return ""\n"".join(res)


for _ in range(int(input())):
    s = []
    for i in range(2):
        s.append([i for i in input()])
    t, m = [int(i) for i in input().split()]
    q = []
    for i in range(m):
        q.append([int(i) - 1 for i in input().split()])
    print(solution(s, t, m, q))
","res.append(""YES"")","res.append(""YES"")"
"import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    k = int(input())
    s = input().strip()
    n = len(s)
    stack = []
    costs = []
    for i in range(n):
        if s[i] == '(':
            stack.append(i)
        else:
            {{completion}}
    print(sum(sorted(costs)[:max(0,len(costs)-k)]))
",costs.append((i - stack.pop()) // 2),"costs.append(stack.pop())
    costs.append(n)"
"import sys
from collections import defaultdict, deque, Counter
t = int(sys.stdin.readline().strip())
for _ in range(t) : 
    k = int(sys.stdin.readline().strip())
    node = sys.stdin.readline().strip()
    n = len(node)
    open = []
    length = []
    answer, now = 0, 0
    for i in range(n) : 
        if node[i] == '(' : 
            open.append(i)
        else : 
            {{completion}}
    node = node + '.'
    for i in range(n-1, -1, -1) : 
        if node[i] == '(' : 
            now -= 1
        else : 
            answer += now
            now += 1
    length.sort(reverse = 1)
    print(answer - sum(length[:min(k, n)]))",length.append((i - open.pop() - 1) // 2),"length.append(now)
            now += 1
    length.sort(reverse = 1)
    open.reverse()
    open = deque(open)
    open.append(n)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open)
    open = deque(open"
"import sys
ipt = sys.stdin.readline

def iin():
    return int(ipt())

def lmin():
    return list(map(int,ipt().split()))

MOD = 998244353

from heapq import heappop,heappush

for _ in range(iin()):
    
    K = iin()
    S = ipt()[:-1]
    N = len(S)
    cnt = [0,0,0,0,0,0,0,0]
    st = []
    ans = 0
    for i,s in enumerate(S):
        if s == ""("":
            ans += len(st)
            st.append(i)
        else:
            {{completion}}
            
    cnt.sort()
    if K:
        ans -= sum(cnt[-K:])
    print(ans)


    ",cnt.append((i-st.pop())//2),"st.pop()
            cnt[st[-1]] += 1
            st.append(i)"
"import sys

input = sys.stdin.buffer.readline

infinity = 10 ** 10

for _ in range(int(input())) :
    n, k = map(int, input().split())
    l = [int(x) for x in input().split()]
    r = [int(x) for x in input().split()]

    answer = infinity
    oneCounter = 0
    prefix = 0
    for i in range(n) :
        d = r[i] - l[i] + 1

        if prefix + d >= k :
            counter = min(oneCounter, prefix + d - k)
            if prefix - counter > k :
                {{completion}}
            x = l[i] + k - (prefix - counter) - 1
            answer = min(answer, x + 2 * (i + 1 - counter))

        prefix += d
        oneCounter += (d == 1)

    print(answer if answer != infinity else -1)
",break,"counter = k - prefix
            answer = min(answer, counter)
        else :"
"import sys
input = sys.stdin.buffer.readline
def read_line():
    return list(map(int, input().split()))
 
def solve():
    n, m = read_line()
    l = read_line()
    r = read_line()
    one_cnt = 0
    sum = 0

    res = 2 ** 60
    for i in range(n):

        
        if sum + r[i] - l[i] + 1 < m:
            {{completion}}
        x = m - sum + l[i] - 1
        one = min(one_cnt, r[i] - x)
        res = min(res, x + one + (i + 1 - one) * 2)
        sum += r[i] - l[i] + 1
        one_cnt += l[i] == r[i]

    if res == (2 ** 60): 
        res = -1
    print(res)
    
 
T = int(input())
for _ in range(T):
    solve()","sum += r[i] - l[i] + 1
            one_cnt += l[i] == r[i]
            continue","one_cnt += 1
            sum = 0
            continue
        "
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')

t = int(input())
ans = []
for s in range(t):
    n, k = map(int, input().split())
    L = list(map(int, input().split()))
    R = list(map(int, input().split()))
    locsum = 0
    i = -1
    ones = 0
    res = 0
    while i < n-1 and locsum < k:
        i += 1
        if R[i] == L[i]:
            ones += 1
        x = min(k - locsum, R[i] - L[i] + 1)
        locsum += x
        res = L[i] - 1 + x
    
    if locsum < k:
        ans.append(-1)
    else:
        steps = res + 2*(i+1)
        locsteps = steps
        j = 0
        while j < ones:
            if res == R[-1]:
                break
            elif res < R[i]:
                res += 1
                locsteps -= 1
                steps = min(steps, locsteps)
                j += 1
            else:
                i += 1
                res = L[i]
                locsteps += L[i] - R[i-1]
                steps = min(steps, locsteps)
                if R[i] == L[i]:
                    {{completion}}
                j += 1
        ans.append(steps)
        
for a in ans:
    print(a)
        
            
",ones += 1,locsteps += 1
"from sys import stdin
input=lambda :stdin.readline()[:-1]

def solve():
  n=int(input())
  a=list(map(int,input().split()))
  s=set(a)
  mex=0
  while mex in s:
    mex+=1
  if mex+1 not in s:
    if mex!=n:
      print('Yes')
    else:
      {{completion}}
    return
  left=n
  right=-1
  for i in range(n):
    if a[i]==mex+1:
      left=min(left,i)
      right=i
  b=a.copy()
  for i in range(n):
    if left<=i<=right:
      b[i]=mex
  t=set(b)
  mex2=0
  while mex2 in t:
    mex2+=1
  if mex+1==mex2:
    print('Yes')
  else:
    print('No')


for _ in range(int(input())):
  solve()",print('No'),"print('No')
    return
  mex=mex+1
  left=-1
  right=-1
  for i in range(n):
    if a[i]==mex:
      left=min(left,i)
      right=i
  b=a.copy()
  for i in range(n):
    if left<=i<=right:
      b[i]=mex
  t=set(b)
  mex2=0
  while mex2 in t:
    mex2+=1
  if mex+1==mex2:
    print('Yes')
  else:
    print('No')

def solve2():
  n=int(input())
  a=list(map(int,input"
"#Solve Function
def solve():

    n = int_i()
    a = list_i()

    st = set(a)
    mx = n
    for i in range(n):
        if i not in st:
            {{completion}}
    if mx == n:
        return 'No'
    if mx + 1 not in st:
        return 'Yes'
    x = set()
    for i in range(n):
        if a[i] == mx + 1:
            break
        if a[i] < mx:
            x.add(a[i])
    for i in range(n - 1, -1, -1):
        if a[i] == mx + 1:
            break
        if a[i] < mx:
            x.add(a[i])
    if len(x) == mx:
        return 'Yes'
    return 'No'


def main():
    test_cases = int_i() 
    for i in range(test_cases):
        x = solve()
        if x is not None: print(x)


#Import Region
import sys
from math import comb, gcd
from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
inp = lambda : sys.stdin.readline().rstrip('\r\n')
int_i = lambda : int(inp())
list_i = lambda x=int : list(map(x, inp().strip().split()))
mult_i = lambda x=int : map(x, inp().strip().split())

main()

","mx = i
            break","st.remove(a[i])
            mx = max(mx, a[i])"
"from sys import stdin
input = lambda: stdin.readline()[:-1]


MX = 2*10**5 + 5


vs = [0]*(3*10**5 + 20)
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    for i in a:
        t = i if i < MX else MX
        vs[t] += 1
    mex = 0
    d = n
    mxp = 0
    while vs[mex] != 0:
        if vs[mex] > mxp:
            mxp = vs[mex]
        d -= vs[mex]
        mex += 1
    l, r = -1, -1
    for i in range(n):
        if a[i] == mex + 1:
            if l == -1:
                l = i
            r = i
    if l == r == -1:
        if mxp > 1 or d > 0:
            print(""YES"")
        else:
            print(""NO"")
    elif l == r:
        print(""YES"")
    else:
        for i in range(l, r+1):
            t = a[i] if a[i] < MX else MX
            vs[t] -= 1
            if a[i] < mex + 1 and vs[t] < 1:
                {{completion}}
        else:
            print(""YES"")
    for i in a:
        t = i if i < MX else MX
        vs[t] = 0

","print(""NO"")
                break","mex += 1
            if vs[mex] > 0:
                mex -= 1
            if mex == i:
                print(""YES"")
                break"
"import sys
 
def sol():
    input = sys.stdin.readline
    m,n,ay,ax,by,bx = tuple(map(int,input().split()))
    gap = by - ay - 1
    
    if gap < 0:return print(""Draw"")
    if gap & 1:
        if ax == bx :return print(""Bob"")
        if ax < bx and bx - 2 <= gap //2:return print(""Bob"")
        if ax > bx and n - bx - 1 <= gap // 2:return print(""Bob"")
    
    else:
        if abs(ax - bx) < 2:{{completion}}
        if ax < bx and n - ax - 1 <= gap //2:return print(""Alice"")
        if ax > bx and ax - 2 <= gap // 2:return print(""Alice"")

    return print(""Draw"")

tc= int(input())
for _ in range(tc):
    sol()","return print(""Alice"")","return print(""Bob"")
        if ax < bx and ax - 2 <= gap //2:return print(""Bob"")
        if ax > bx and bx - 2 <= gap //2:return print(""Bob"")
    
    if gap > 0:
        if ax == bx :return print(""Alice"")
        if ax < bx and bx - 2 <= gap //2:return print(""Alice"")
        if ax > bx and n - bx - 1 <= gap // 2:return print(""Alice"")
    
    else:
        if abs(ax - bx) < 2:return print(""Alice"")"
"test_cases = int(input())
answers = []
for i in range(test_cases):
    clues = list(map(int,input().split("" "")))
    if clues[2] > clues[4] or clues[0]==1:
        answers.append(""Draw"")
    elif(clues[2]%2==0 and clues[4]%2==0) or (clues[2]%2!=0 and clues[4]%2!=0):
        if clues[3] == clues[5]:
            answers.append(""Bob"")
        elif clues[3]<clues[5]:
            if clues[5]-1 > abs((clues[2]-clues[4])//2):
                answers.append(""Draw"")
            else:
                {{completion}}
        elif clues[3]>clues[5]:
            if clues[1]-clues[5] > abs((clues[2]-clues[4])//2):
                answers.append(""Draw"")
            else:
                answers.append(""Bob"")
    else:
        if clues[3] == clues[5]:
            answers.append(""Alice"")
        elif abs(clues[3]-clues[5])==1:
            answers.append(""Alice"")
        elif clues[3]<clues[5]:
            if clues[1]-clues[3] > abs((clues[2]-clues[4])//2):
                answers.append(""Draw"")
            else:
                answers.append(""Alice"")
        elif clues[3]>clues[5]:
            if clues[3]-1 > abs((clues[2]-clues[4])//2):
                answers.append(""Draw"")
            else:
                answers.append(""Alice"")
for j in answers:
    print(j)
","answers.append(""Bob"")","answers.append(""Bob"")"
"import sys


def solution(h, w, xa, ya, xb, yb):
    # h, w, xa, ya, xb, yb = 6, 5, 2, 2, 5, 3
    if xa >= xb:
        return 'Draw'
    if not (xb - xa) % 2:
        t = (xb - xa) // 2
        if ya > yb:
            return 'Draw' if yb + t < min(w, ya + t) else 'Bob'
        else:
            return 'Draw' if yb - t > max(1, ya - t) else 'Bob'
    else:
        t = (xb - xa) // 2
        if ya < yb:
            return 'Draw' if ya + t + 1 < min(w, yb + t) else 'Alice'
        else:
            {{completion}}

# with open(""input.txt"", ""r"") as f:
#     lines = f.readlines()

for i, line in enumerate(sys.stdin):
# for i, line in enumerate(lines):
    if i == 0: continue
    line = map(int, line.strip().split())
    sys.stdout.write(solution(*line)+'\n')
","return 'Draw' if ya - t - 1 > max(1, yb - t) else 'Alice'","s = 'Draw' if ya - t > max(1, yb - t) else 'Alice'
            if s == 'Draw':
                return 'Draw'
            else:
                return s"
"import sys
input = sys.stdin.readline 

for _ in range(int(input())):
    n = int(input()) 
    a = list(map(int, input().split())) 
    s = 0 
    for i in range(n):
        if(i % 2 == 0):
            s -= a[i] 
        else:
            {{completion}} 
    if(n % 2 or s >= 0):
        print(""YES"")
    else:
        print(""NO"")",s += a[i],"s += a[i] 
"
"import sys

def semi_sortable(arr, n:int) -> bool:
    if n % 2 != 0:
        return True
    sign = 1
    s = 0
    for num in arr:
        s += sign * num
        sign = -sign
    if s > 0:
        return False
    else:
        return True


i = -1
for line in sys.stdin:
    nums = [int(x) for x in line.strip().split()]
    if i == -1:
        i += 1
    else:
        if i % 2 == 0:
            n = nums[0]
        else:
            if semi_sortable(nums, n):
                print(""Yes"")
            else:
                {{completion}}
        i += 1
","print(""No"")","n = nums[0]
                nums[0] = nums[1]
                nums[1] = n
                nums = nums[2:]
                nums.sort()
                i = 0
                while nums[0] > nums[1]:
                    nums[0] -= 1
                    nums[1] += 1
                    nums = nums[2:]
                    nums.sort()"
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    A = list(map(int, input().split()))

    for i in range(0, n, 2):
        if i == n - 1:
            {{completion}}
        if i == n - 2:
            return ""YES"" if A[i] <= A[i + 1] else ""NO""
        A[i + 2] -= A[i + 1] - A[i]
    
    return 
    
T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","return ""YES""","A[i] -= A[i + 1]
            A[i + 1] += A[i]
            return ""YES"" if A[i] <= A[i + 1] else ""NO"""
"from sys import stdin
def input(): return stdin.readline()[:-1]

INF = 10**18

from collections import deque

def solve():
    N = int(input())
    string = input().strip()
    g = []
    for i in range(N):
        a,b = map(int, input().split())
        a -= 1
        b -= 1
        g.append((a,b))
    
    bfs = deque([0])

    order = []
    while bfs:
        node  = bfs.popleft()
        order.append(node)
        for next_node in g[node]:
            if next_node != -1:
                {{completion}}

    # print(order)
    dp = [INF] * (N)

    for node in reversed(order):
        if g[node][0] == -1 and g[node][1] == -1:
            # leaf node
            dp[node] = 0
            continue

        l, r = INF, INF

        if g[node][0] != -1:
            l = dp[g[node][0]]
            if string[node] != 'L':
                l += 1
        
        if g[node][1] != -1:
            r = dp[g[node][1]]
            if string[node] != 'R':
                r += 1

        dp[node] = min(l, r)
        
    print(dp[0])
for _ in range(int(input())):
    solve()",bfs.append(next_node),bfs.append(next_node)
"import sys
from collections import deque, defaultdict, Counter
t = int(sys.stdin.readline().strip())
for _ in range(t) : 
    n = int(sys.stdin.readline().strip())
    node = 'x' + sys.stdin.readline().strip()
    l = [0 for i in range(n + 1)]
    r = [0 for i in range(n + 1)]
    p = [0 for i in range(n + 1)]
    dp = [0 for i in range(n + 1)]
    for i in range(1, n + 1) : 
        a, b = map(int, sys.stdin.readline().strip().split())
        l[i] = a
        r[i] = b
        p[a] = i
        p[b] = i
    dfs = []
    if l[1] : dfs.append(l[1])
    if r[1] : dfs.append(r[1])
    while dfs : 
        now = dfs.pop()
        if l[p[now]] == now : 
            dp[now] = dp[p[now]] + (node[p[now]] != 'L')
        else : 
            {{completion}}
        if l[now] : dfs.append(l[now])
        if r[now] : dfs.append(r[now])
    m = 10 ** 6
    for i in range(1, n + 1) : 
        if l[i] == 0 and r[i] == 0 : m = min(m, dp[i])
    print(m)",dp[now] = dp[p[now]] + (node[p[now]] != 'R'),"dfs.append(p[now])
        if r[p[now]] == now : 
            dp[now] = dp[p[now]] + (node[p[now]] != 'R')
        else : 
            dfs.append(p[now])
    m = 10 ** 6
    for i in range(1, n + 1) : 
        if l[i] == 0 and r[i] == 0 : m = min(m, dp[i])
    print(m)
<|/ a tags=algorithm,python,dynamic-programming |>"
"def II():
    return(int(input()))
def LMI():
    return(list(map(int,input().split())))
def I():
    return(input())
def MII():
    return(map(int,input().split()))
import sys
input=sys.stdin.readline
# import io,os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# from collections import Counter
# int(math.log(len(L)))
# import math
# from collections import defaultdict
# mod=10**9+7
from collections import deque
import  math





def t():
    n=II()
    s=I()[:-1]
    child=[(0,0)]
    for i in range(n):
        l,r=MII()
        child.append((l,r))
    D=deque()
    D.append(1)
    dp=[0]*(n+1)
    Parent=[0]*(n+1)
    Parent[1]=1
    while D:
        a=D.popleft()
        for j in range(2):
            if child[a][j]==0:continue
            if j==0:
                if s[a-1]!=""L"":
                    dp[child[a][j]]=dp[a]+1
                else:
                    dp[child[a][j]]=dp[a]
            else:
                if s[a-1]!=""R"":
                    dp[child[a][j]]=dp[a]+1
                else:
                    {{completion}}

            D.append(child[a][j])
    ans=math.inf
    for i in range(1,n+1):
        if child[i]==(0,0):
            ans=min(ans,dp[i])
    print(ans)






if __name__==""__main__"":

    for _ in range(II()):
        t()
    # t()",dp[child[a][j]]=dp[a],"dp[child[a][j]]=dp[a]
            if dp[child[a][j]]<ans:
                ans=dp[child[a][j]]"
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')


N = int(1e6)+1
f = [0]*N

for _ in range(int(input())):
    n = int(input())
    a = sorted(map(int, input().split()))
    ans = 0

    for x in a: f[x] += 1

    for i, x in enumerate(a):
        if i and a[i-1] == x: continue 
        ans += f[x] * (f[x]-1) * (f[x]-2)
        for k in range(2, N):
            if x*k*k >= N: {{completion}}
            ans += f[x] * f[x*k] * f[x*k*k]

    print(ans)
    for x in a: f[x] = 0",break,break
"# https://codeforces.com/contest/1822

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!

N = 10 ** 6 + 2
case = [-1] * N
cnt = [0] * N


def solve_case(t):
    global case, cnt

    _ = int(input())
    a = list(map(int, input().split()))  # 1 <= a[i] <= 10**6

    mx = max(a)
    v = []
    for x in a:
        if case[x] != t:
            case[x] = t
            cnt[x] = 1
            v += [x]
        else:
            cnt[x] += 1

    ans = 0
    for x in v:
        if cnt[x] >= 3:
            ans += cnt[x] * (cnt[x] - 1) * (cnt[x] - 2)
        b = 2
        while x * b * b <= mx:
            if case[x * b] == case[x * b * b] == t:
                {{completion}}
            b += 1

    print(ans)


for t in range(int(input())):
    solve_case(t)
",ans += cnt[x] * cnt[x * b] * cnt[x * b * b],ans += cnt[x] * b * b
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')
from array import array

N = int(1e6)+1
f = array('i', [0]*N)

for _ in range(int(input())):
    n = int(input())
    a = sorted(map(int, input().split()))
    ans = 0

    for x in a: f[x] += 1

    for i, x in enumerate(a):
        if i and a[i-1] == x: continue 
        ans += f[x] * (f[x]-1) * (f[x]-2)
        for k in range(2, N):
            if x*k*k >= N: {{completion}}
            ans += f[x] * f[x*k] * f[x*k*k]

    print(ans)
    for x in a: f[x] = 0",break,break
"import sys

# 1到1000的质数表
prime = [True] * 1001
prime[0] = prime[1] = False
ps = []
for i in range(2, 1001):
    if prime[i]:
        ps.append(i)
        for j in range(i * i, 1001, i):
            prime[j] = False

def doubleDiv(x):
    div = []
    for p in ps:
        if p * p > x:
            break
        c = 0
        while x % p == 0:
            c += 1
            x //= p
        if c > 1:
            div.append((p,c//2))
    if x > 1:
        sq = int(x ** 0.5)
        if sq * sq == x:
            div.append((sq, 1))
    ans = [1]
    for p,c in div:
        temp = [p ** i for i in range(1, c + 1)]
        ans += [a * b for a in ans for b in temp]
    # print(ans)
    return ans

t = int(sys.stdin.readline())
for _ in range(t):
    n = int(sys.stdin.readline())
    a = list(map(int, sys.stdin.readline().split()))
    from collections import Counter
    c = Counter(sorted(a))
    ans = 0
    for x in c.values():
        ans += x*(x - 1)*(x - 2)
    for x,v in c.items():
        for k in doubleDiv(x):
            if k != 1:
                {{completion}}
    print(ans)
",ans += v * c[x//k] * c[x//k//k],"ans += v*k
    # print(ans)
    ans *= 2"
"# https://codeforces.com/contest/1822

import sys
from math import isqrt

input = lambda: sys.stdin.readline().rstrip()  # faster!


def sieve(mx):
    primes = [2]
    is_prime = [False] * 2 + [True] * (mx - 1)
    is_prime[4::2] = [False] * ((mx - 4) // 2 + 1)
    for i in range(3, mx + 1, 2):
        if is_prime[i]:
            primes += [i]
            is_prime[i * i::2 * i] = [False] * (((mx + 1) - i * i - 1) // (2 * i) + 1)
    return primes


P = sieve(1_001)


def double_divisors(n):
    dpf = []
    for p in P:
        c = 0
        while n % p == 0:
            n //= p
            c += 1
        if c >= 2:
            dpf += [(p, c // 2)]
    if n > 1:
        rt = isqrt(n)
        if rt ** 2 == n:
            dpf += [(rt, 1)]
    div = [1]
    for (p, e) in dpf:
        cpy = div.copy()
        for x in cpy:
            for i in range(1, e + 1):
                div += [x * (p ** i)]
    return div


def solve_case():
    n = int(input())
    a = list(map(int, input().split()))  # 1 <= a[i] <= 10**9
    a.sort()

    cnt = {}
    c = 0
    for i in range(n):
        if i == 0 or a[i] == a[i - 1]:
            c += 1
        else:
            cnt[a[i - 1]] = c
            c = 1
    cnt[a[-1]] = c

    ans = 0
    for x, c in cnt.items():
        if c >= 3:
            ans += c * (c - 1) * (c - 2)
        for d in double_divisors(x):
            if d != 1:
                x1 = x // d
                x2 = x1 // d
                if x1 in cnt and x2 in cnt:
                    {{completion}}

    print(ans)


for _ in range(int(input())):
    solve_case()
",ans += cnt[x] * cnt[x1] * cnt[x2],ans += (cnt[x1] + cnt[x2])
"import sys
from math import isqrt
input = sys.stdin.readline

def sieve_of_eratosthenes(n):
    sieve = [0] * (n + 1)
    for x in range(2, n + 1):
        if sieve[x] == 0:
            for y in range(2 * x, n + 1, x):
                sieve[y] = x
    return [p for p in range(2, n + 1) if sieve[p] == 0]


primes = sieve_of_eratosthenes(1000)
out = []

for _ in range(int(input())):
    n = int(input())    
    A = list(map(int, input().split()))
    A.sort() # to avoid hacks due to collision chains

    cnt = dict()
    for a in A:
        cnt[a] = cnt.get(a, 0) + 1
    
    ans = 0
    for a, c in cnt.items():
        ans += c * (c - 1) * (c - 2)

        square_factors = []
        x = a
        
        for p in primes:
            t = 0
            while x % p == 0:
                x //= p
                t += 1
            if t // 2 != 0:
                square_factors.append((p, (t // 2)))
        
        sqrt = isqrt(x)
        if x > 1 and sqrt * sqrt == x:
            square_factors.append((sqrt, 1))
        
        B = []
        for f, e in square_factors:
            m = len(B)
            for exp in range(1, e + 1):
                for i in range(m):
                    {{completion}}
                B.append(f ** exp)
        
        for b in B:
            ans += c * cnt.get(a // b, 0) * cnt.get(a // b // b, 0)

    out.append(ans)

print(""\n"".join(map(str, out)))",B.append(B[i] * f ** exp),B[i] = B[i] * f
"import sys
input = sys.stdin.readline

def solve():
    {{completion}}

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","n = int(input())
    return 26 + (n - 4) * (n + 6)","n, = map(int, input().split())
    chocolate = 0
    for i in range(n):
        chocolate += i
    return chocolate"
"import sys


def solution(n):
    res = 1 + n*4 + (n-1) + (2+(n-2)*2)*(n-2)//2
    sys.stdout.write(str(res)+""\n"")


def main():
    tests_n = int(sys.stdin.readline().strip())
    for t in range(tests_n):
        {{completion}}


if __name__ == ""__main__"":
    main()
","n = int(sys.stdin.readline().strip())
        solution(n)",solution(int(sys.stdin.readline().strip()))
"import sys

test_cases = int(sys.stdin.buffer.readline())
answers = [0] * test_cases

for answer in range(test_cases):
    {{completion}}

sys.stdout.write('\n'.join(map(str, answers)))","n = int(sys.stdin.buffer.readline())
    answers[answer] = n * 4 + n + (n - 1) * (n - 2)","size = int(sys.stdin.buffer.readline())
    chocolate = 0
    for n in range(size):
        chocolate += n
    answers[answer] = chocolate"
"import sys
ci = sys.stdin.readline

for _ in range(int(ci())):
    n, k, x = list(map(int, ci().split()))
    a = sorted(map(int, ci().split()))
    total = sum(a)
    for i in range(min(x, n)):
        total -= a[n-1-i] * 2
    res = total
    for i in range(min(k, n)):
        total += a[n-1-i]
        if n - x - i - 1 >= 0:
            {{completion}}
        res = max(res, total)
    print(res)",total -= a[n-x-i-1] * 2,total -= a[n-1-i] * a[n-1-i - n - x - i - 1]
"import sys

def solve():
    n,k,x = map(int, sys.stdin.readline().split())
    ls = list(map(int, sys.stdin.readline().split()))
    ls.sort(reverse=True)
    ls.append(0)

    res,idx = 0,x
    tmp = 0
    for i in range(k):
        if idx < n:
            tmp += ls[i]-2*ls[idx]
            res = max(tmp,res)
            idx += 1
        else:
            {{completion}}
    for i in range(x):
        ls[i] = -ls[i]
    print(sum(ls)+res)

for i in range(int(input())):
    solve()","tmp += ls[i]
            res = max(tmp,res)","tmp -= ls[i]
            res = min(tmp,res)
            idx -= 1
    ls = ls[:x]"
"import sys
t = int(sys.stdin.readline().strip())
for _ in range(t) : 
    n, k, x = map(int, sys.stdin.readline().strip().split())
    node = [*map(int, sys.stdin.readline().strip().split())]
    node.sort()
    node = [0] + node
    pres = [0 for i in range(n + 1)]
    for i in range(1, n + 1) : 
        {{completion}}
    ans = -(pres[n] - pres[n - x]) + pres[n - x]
    for i in range(n - 1, n - k - 1, -1) : 
        ans = max(ans, -(pres[i] - pres[max(0, i - x)]) + pres[max(i - x, 0)])
    print(ans)
    ",pres[i] = pres[i - 1] + node[i],"pres[i] = pres[i - 1] + node[i - 1]
    pres[n] = pres[n] - node[n]"
"import sys
input = sys.stdin.readline

n,L,R=map(int,input().split())

# UnionFind

Group = [i for i in range(n+1)] # グループ分け
Nodes = [1]*(n+1) # 各グループのノードの数

def find(x):
    while Group[x] != x:
        x=Group[x]
    return x

def Union(x,y):
    if find(x) != find(y):
        if Nodes[find(x)] < Nodes[find(y)]:
            
            Nodes[find(y)] += Nodes[find(x)]
            Nodes[find(x)] = 0
            Group[find(x)] = find(y)
            
        else:
            {{completion}}

for i in range(n):
    x,y=map(int,input().split())
    Union(x-1,y-1)

LIST=[]
for i in range(n):
    if find(i)==i:
        LIST.append(Nodes[i])

A=LIST
XOR=0
for a in A:
    if a>=L+R:
        continue
    b=a%(L+R)
    XOR^=b//L
 
if XOR==0:
    print(""Bob"")
else:
    print(""Alice"")
","Nodes[find(x)] += Nodes[find(y)]
            Nodes[find(y)] = 0
            Group[find(y)] = find(x)","
            Nodes[find(y)] -= Nodes[find(x)]
            Nodes[find(x)] = 0
            Group[find(x)] = find(y)
            
def UnionFind():
    
    for i in range(n+1):
        Group[i] = i
        
for i in range(n):
    x,y=map(int,input().split())
    Union(x-1,y-1)

LIST=[]
for i in range(n):
    if find(i)==i:
        LIST.append(Nodes[i])

A=LIST
XOR=0
for a in A:
    if a>=L+R:
        continue
    b=a%(L+R)
    XOR^=b//L
 
if "
"from sys import stdin
input=lambda :stdin.readline()[:-1]

from collections import defaultdict

class UnionFind():
  def __init__(self,n):
    self.n=n
    self.parents=[-1]*n

  def find(self,x):
    if self.parents[x]<0:
      return x
    else:
      {{completion}}

  def union(self,x,y):
    x=self.find(x)
    y=self.find(y)

    if x==y:
      return

    if self.parents[x]>self.parents[y]:
      x,y=y,x

    self.parents[x]+=self.parents[y]
    self.parents[y]=x

  def size(self,x):
    return -self.parents[self.find(x)]

  def same(self,x,y):
    return self.find(x)==self.find(y)

  def members(self,x):
    root=self.find(x)
    return [i for i in range(self.n) if self.find(i)==root]

  def roots(self):
    return [i for i, x in enumerate(self.parents) if x< 0]

  def group_count(self):
    return len(self.roots())

  def all_group_members(self):
    group_members=defaultdict(list)
    for member in range(self.n):
      group_members[self.find(member)].append(member)
    return group_members

n,l,r=map(int,input().split())
uf=UnionFind(n)
for i in range(n):
  a,b=map(lambda x:int(x)-1,input().split())
  uf.union(a,b)

grundy=0
g=uf.all_group_members()
for i in g:
  s=len(g[i])
  if l+r>s:
    grundy^=s//l
if grundy:
  print('Alice')
else:
  print('Bob')","self.parents[x]=self.find(self.parents[x])
      return self.parents[x]","parent=self.parents[x]
      self.parents[x]=self.find(parent)
      return self.parents[x]"
"import sys
def input(): return sys.stdin.readline().strip()


class DisjointSet:
    def __init__(self, n):
        self.f = [i for i in range(n)]
        self.siz = [1]*n

    def get(self, x):
        while x != self.f[x]:
            {{completion}}
        return x

    def unite(self, x, y):
        x = self.get(x)
        y = self.get(y)
        if x == y:
            return False
        self.siz[x] += self.siz[y]
        self.f[y] = x
        return True

    def size(self, x):
        return self.siz[self.get(x)]


n, l, r = map(int, input().split())
ds = DisjointSet(n)
for _ in range(n):
    a, b = map(int, input().split())
    ds.unite(a-1, b-1)


def get(a, l, r):
    return a % (l+r)//l


ans = 0
for i in range(n):
    if i == ds.get(i):
        a = ds.size(i)
        if l <= a < l+r:
            ans ^= a//l


if ans:
    print(""Alice"")
else:
    print(""Bob"")
","self.f[x] = self.f[self.f[x]]
            x = self.f[x]","old = self.f[x]
            self.f[x] = self.f[old]
            x = old"
"for c,*s in[*open(0)][1:]:
    {{completion}}",print(10**s.count('?')*(8*(c>'9')+(c>'0'))),"s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    s=s.replace('?','*')
    "
"for x,*s in[*open(0)][1:]:{{completion}}",print(10**s.count('?')*(8*(x>'9')+(x>'0'))),"
    s=s.replace('?','0')
    s=int(s)
    if s<0:
        s=s*-1
    if s%1==0:
        print s
<|/ file source=github ext=.py |>"
"for y,*p in[*open(0)][1:]:{{completion}}",print(10**p.count('?')*(8*(y>'9')+(y>'0'))),"
    y=y.strip()
    if y=='':
        continue
    y=int(y)
    if y<0:
        continue
    s=str(y)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
    s=s.replace('?',0)
"
"import sys
input = sys.stdin.readline

n,s,t=map(int,input().split())
s-=1
t-=1

mod=998244353

E=[[] for i in range(n)]

for i in range(n-1):
    x,y=map(int,input().split())
    x-=1
    y-=1
    E[x].append(y)
    E[y].append(x)

D=[-1]*n
D[s]=0
Q=[s]
FROM=[-1]*n

while Q:
    x=Q.pop()
    if x==t:
        continue

    for to in E[x]:
        if D[to]==-1:
            D[to]=0
            FROM[to]=x
            Q.append(to)

ANS=[-1]*n

now=t
count=0
while now!=s:
    ANS[now]=count
    now=FROM[now]
    count+=1

ANS[now]=count

ANS2=[0]*n

now=t
while now!=s:
    now=FROM[now]
    if ANS[now]>0:
        Q=[now]
        while Q:
            x=Q.pop()
            ANS2[x]=len(E[x])*ANS[now]%mod
            for to in E[x]:
                if ANS[to]==-1 and ANS2[to]==0:
                    {{completion}}
        
ANS2[t]=1

print(*ANS2)
",Q.append(to),"ANS2[to]=1
                    Q.append(to)"
"import sys
from collections import deque

n, s, t = map(int, input().split())
s-=1
t-=1
G = [[] for i in range(n)]

for _ in range(n-1):
    u, v = map(int, sys.stdin.readline().split())
    G[u-1].append(v-1)
    G[v-1].append(u-1)


prev = [s for i in range(n)]
vis = [False for i in range(n)]
stk = deque([s])

while stk:

    u = stk.pop()

    vis[u] = True
    for v in G[u]:
        if not vis[v]:
            prev[v] = u
            stk.append(v)



## Get path from s to t


thePath = []
theAnswer = [0 for i in range(n)]
theAnswer[t] = 1

cur = prev[t]


while cur != s:
    #print(cur, s)
    thePath.append(cur)
    cur = prev[cur]

thePath.append(s)
thePath.reverse()


visited2 = [False for i in range(n)]
for x in thePath:
    visited2[x] = True

visited2[t] = True
MOD = 998244353
for i, nd in enumerate(thePath):
    theChildren = []

    for v in G[nd]:
        if not visited2[v]:
            theChildren.append(v)

    theNumber = len(thePath)-i

    theAnswer[nd] = ((1 if nd == s else 2)*theNumber + theNumber*(len(theChildren)))%MOD



    for child in theChildren:
        st = deque([child])
        while st:
            cur = st.pop()
            visited2[cur] = True
            num_children = 0
            for v in G[cur]:
                if not visited2[v]:
                    {{completion}}

            theAnswer[cur] = theNumber*(num_children+1)%MOD


print(*theAnswer)
","st.append(v)
                    num_children += 1","num_children += 1
                    st.append(v)"
"import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    n, s, t = readInts()
    mo = 998244353
    graph = [[] for _ in range(n)]
    for _ in range(n-1):
        u, v = readInts()
        u -= 1
        v -= 1
        graph[u].append(v)
        graph[v].append(u)

    par = [-1] * n
    st = [t-1]
    par[t-1] = -2
    while st:
        node = st.pop()
        for nei in graph[node]:
            if par[nei] == -1:
                st.append(nei)
                par[nei] = node

    ans = [0] * n
    dp = [0] * n
    path = [False]*n
    path[t-1] = True
    node = s-1
    while node != t-1:
        path[node] = True
        node = par[node]

    st = [t-1]
    vis = {t-1}
    while st:
        node = st.pop()
        for nei in graph[node]:
            if nei not in vis:
                vis.add(nei)
                if path[nei]:
                    dp[nei] = dp[par[nei]] + 1
                else:
                    {{completion}}
                st.append(nei)

    ans[s-1] += 1
    for i in range(n):
        for nei in graph[i]:
            ans[nei] += dp[i] % mo
            ans[nei] %= mo
    return ans


print(*solve())",dp[nei] = dp[par[nei]],"dp[nei] = dp[par[nei]] + dp[par[nei]]
                ans[nei] += dp[nei] % mo
                ans[nei] %= mo"
"for s in[*open(0)][1:]:{{completion}}
			 	      			  								 	    	","print((max(map(len,(s[:-1]+s[:-2]).split('0')))+1)**2//4)","
	n = len(s)
	table = [[0]*n for i in range(n)]
	for i in range(n):
		table[i][i] = 1
	for i in range(1, n):
		for j in range(1, n):
			table[i][j] = table[i-1][j-1] + table[i-1][j]
	print max(table)
<|/ file ext=.py |>"
"#start for loop and print for output
for srt in[*open(0)][1:]:{{completion}}","print((max(map(len,(srt[:-1]+srt[:-2]).split('0')))+1)**2//4)","
    srt=srt.strip()
    srt=srt.split()
    srt=srt[0]
    srt=srt.replace('0','1')
    srt=srt.replace('1','0')
    srt=srt.replace('1','1')
    srt=srt.replace('0','0')
    srt=srt.replace('1','0')
    srt=srt.replace('1','1')
    srt=srt.replace('0','0')
    srt=srt.replace('1','0')
    srt=srt.replace('1','1')
    srt=srt.replace('0','0')
    srt=srt.replace('1','0')
    srt="
for p in[*open(0)][1:]:{{completion}},"print((max(map(len,(p[:-1]+p[:-2]).split('0')))+1)**2//4)","
    s=p.split()
    s="""".join(s)
    s=s.replace('0','1')
    s=s.replace('1','0')
    s=s.replace('1','1')
    s=s.replace('0','0')
    s=s.replace('1','1')
    s=s.replace('0','0')
    s=s.replace('1','1')
    s=s.replace('0','1')
    s=s.replace('1','0')
    s=s.replace('0','0')
    s=s.replace('1','1')
    s=s.replace('0','1')
    s=s.replace('1','0')
    s=s.replace('0','1')
    s=s.replace('1','0')
    s=s.replace('0"
"for kl in range(int(input())):
    {{completion}}
    
   ","qr, ui = map(int, input().split())
    p = [input() for lk in range(qr)]
    print(p.count(p[0]))","n, k = list(map(int, input().split()))
    
    Y = 0
    N = 0
    
    for i in range(n):
        t, k = input().split()
        
        for j in range(k):
            if t[j] == ""+"":
                Y += 1
            elif t[j] == ""-"":
                N += 1
    
    if Y > N:
        print(Y - N)
    elif Y < N:
        print(N - Y)
    else:
        print(N - Y)"
"def solve():
    n, k = map(int, input().split())
    s = input()
    result = n
    
    for _ in range(n - 1):
        {{completion}}
    
    print(result)
            
    
if __name__ == ""__main__"":
    for test in range(int(input())):
        solve()
        ",result -= (input() != s),"agree, disagree = s.split('+')
        agree = int(agree)
        disagree = int(disagree)
        
        if agree > disagree:
            result -= 1
        elif agree < disagree:
            result += 1
        else:
            result += 1
            
        if result > k:
            break"
"t = input()
t = int(t)

for _ in range(t):
    n , k = map(int , input().split())

    mylist = []
    cnt = 0

    for i in range(n):
        s = input()
        mylist.append(s)

        if mylist[i] == mylist[0]:
            {{completion}}

    print(cnt)
     		 	   	   		    	 	    		",cnt += 1,"cnt += 1
        else:
            cnt -= 1"
"import sys
from collections import defaultdict, deque
from math import inf
MOD = 10**9 + 7

stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

t = int(input())

# if k > c move root to the nearest diameter end point, otherwise return the max distance from the root * k

def solve():
    n,k,c = na()
    G = [[] for _ in range(n)]
    for _ in range(n-1):
        a,b = na()
        a-=1
        b-=1
        G[a].append(b)
        G[b].append(a)

    def dfs(s):
        dist = [0]*n
        q = [[s,-1]]
        while q:
            a,p = q.pop()
            for b in G[a]:
                if b == p: {{completion}}
                dist[b] = dist[a]+1
                q.append([b,a])
        return dist

    dist_r = dfs(0)
    p = max([d,i] for i,d in enumerate(dist_r))[1]
    dist_p = dfs(p)
    q = max([d,i] for i,d in enumerate(dist_p))[1]
    dist_q = dfs(q)

    ans = 0
    for a in range(n):
        ans = max(ans, max(dist_p[a], dist_q[a])*k - dist_r[a]*c)
    print(ans)




for _ in range(t):
    solve()
",continue,"continue
                dist[b] = dist[a]+1
                q.append([b,a])
        return dist

    dist_r = dfs(0)
    p = max([d,i] for i,d in enumerate(dist_r))[1]
    dist_p = dfs(p)
    q = max([d,i] for i,d in enumerate(dist_p))[1]
    dist_q = dfs(q)

    ans = 0
    for a in range(n):
        ans = max(ans, max(dist_p[a], dist_q[a])*k - dist_r[a]*c)
    print(ans)

def solve():
    n,k,c = na()
    G = [[] for _ in range(n)]
    for _ in range(n-1):"
"# taken from 207141044

def solve():
    n, k, c = read_ints()
    tree = [[] for _ in range(n)]
    for _ in range(n-1):
        u, v = read_ints()
        tree[u-1].append(v-1)
        tree[v-1].append(u-1)

    depth = [-1] * n
    depth[0] = 0
    queue = [0]
    last_node = 0
    for node in queue:
        last_node = node
        for child in tree[node]:
            if depth[child] == -1:
                {{completion}}

    max_depth = depth[last_node]
    res = k * max_depth
    if k <= c:
        return res

    queue = [last_node]
    depth2 = [-1] * n
    depth2[last_node] = 0
    for node in queue:
        for child in tree[node]:
            if depth2[child] == -1:
                depth2[child] = depth2[node] + 1
                queue.append(child)

    for i in range(n):
        res = max(res, k * depth2[i] - c * depth[i])

    return res


def main():
    t = int(input())
    output = []
    for _ in range(t):
        ans = solve()
        output.append(ans)

    print_lines(output)


def input(): return next(test).strip()
def read_ints(): return [int(c) for c in input().split()]
def print_lines(lst): print('\n'.join(map(str, lst)))


if __name__ == ""__main__"":
    import sys
    from os import environ as env
    if 'COMPUTERNAME' in env and 'L2A6HRI' in env['COMPUTERNAME']:
        sys.stdout = open('out.txt', 'w')
        sys.stdin = open('in.txt', 'r')

    test = iter(sys.stdin.readlines())

    main()
","cur_depth = depth[node] + 1
                depth[child] = cur_depth
                queue.append(child)","depth[child] = depth[node] + 1
                queue.append(child)"
"import sys
input = sys.stdin.readline
t=int(input())
for _ in range(t):
  n=int(input())
  A=[]
  for i in range(n):
    l,r=map(int,input().split())
    A.append((l,r))
  ng=-1
  ok=10**9
  while ok-ng>1:
    mid=(ok+ng)//2
    mi=0
    ma=0
    flg=True
    for l,r in A:
      mi=max(mi-mid,l)
      ma=min(ma+mid,r)
      if mi>ma:
        {{completion}}
    if flg:
      ok=mid
    else:
      ng=mid
  print(ok)","flg=False
        break",flg=False
"from sys import stdin


def inp(): return stdin.readline().rstrip(""\r\n"")


def check(l,k):
    a,b = 0, 0
    for i in l:
        a = max(a - k, i[0])
        b = min(b + k, i[1])
        if a > b:
            return False
    else:
        return True

for _ in range(int(inp())):
    n = int(inp())
    arr = []
    for __ in range(n):
        a, b = [int(x) for x in inp().split()]
        arr.append((a,b))
    l, r = -1, 10 ** 9
    while r - l > 1:
        mid = (r + l) // 2
        if check(arr, mid):
            r = mid
        else:
            {{completion}}
    print(r)
",l = mid,"l = mid
    if r - l > 1:
        r = r - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - 1
    r = r + 1
    if r > n:
        r = n - "
"T=int(input())
from sys import stdin, setrecursionlimit
input = stdin.readline
readline = stdin.readline

for _ in range(T):
  N=int(input())
  A=[];mi=0
  for i in range(N):
    l,r=map(int, input().split())
    A.append((l,r))
    mi=max(mi,l)
  if mi==0:
    print(0)
  else:
    ng,ok=0,10**9+10
    while (ok-ng)>1:
      f=1;x,y=0,0;mid=(ok+ng)//2
      for l,r in A:
        ll,rr=x-mid,y+mid
        if rr<l or r<ll:
          f=0
          break 
        else:
          {{completion}}
      if f==1:
        ok=mid 
      else:
        ng=mid 
    print(ok)","x=max(l,ll);y=min(r,rr)","x,y=l,r
      if f==1:
        ok=mid 
      else:
        ng=mid 
    print(ok)
<|/ file filename=Polycarp.py |>"
"for _ in range(int(input())):
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    a.sort()
    b.sort()
    ans = 0
    for i in range(n):
        {{completion}}
    print(ans)","ans += max(a[i]-b[n-1-i], b[m-1-i]-a[i])",ans += abs(a[i] - b[i])
"a = int(input())
for _ in range(a):
    n ,m = tuple(map(int,input().split(' ')))
    a = list(map(int,input().split(' ')))
    b = list(map(int,input().split(' ')))
    a.sort()
    b.sort(reverse= True)
    i1 = 0
    i2 = n-1
    o1 = 0
    o2 = m-1
    ans = 0
    while i1 <= i2:
        mi = abs(a[i1]-b[o1])
        ma = abs(a[i2]-b[o2])
        if mi >= ma:
            ans += mi
            o1 +=1
            i1 +=1
        else:
            {{completion}}
    print(ans)


","ans += ma
            o2 -= 1
            i2 -= 1","ans += ma
            o2 -=1
            i2 -=1
    if o1 == 0:
        ans += abs(a[i1]-b[o1])
    if o2 == 0:
        ans += abs(a[i2]-b[o2])"
"t = int(input())
for _ in range(t):
    _ = input()
    a = [int(x) for x in input().split("" "")]
    b = [int(x) for x in input().split("" "")]
    a.sort()
    b.sort(reverse=True)
    left = 0
    right = -1
    total_diff = 0
    for _ in a:
        l_diff = abs(b[left]-a[left])
        r_diff = abs(a[right]-b[right])
        if l_diff > r_diff:
            total_diff += l_diff
            left += 1
        else:
            {{completion}}
    print (total_diff)
","total_diff += r_diff
            right -= 1","right -= 1
    if right < 0:
        total_diff += abs(a[right]-b[right])"
"import sys
from collections import deque
input=sys.stdin.readline
def custom_tree_traversal():
    q=deque([node for node in range(n) if count[node]==1])
    ans=0
    while q:
        child=q.popleft()
        visited[child] = True
        for parent in graph[child]:
            if (not visited[parent]):
                count[parent]-=1
                sub_tree_size[parent]+=sub_tree_size[child]
                if count[parent]==1:
                    {{completion}}
                ans+=2*sub_tree_size[child]*(n-sub_tree_size[child])
    return ans
mod=10**9+7
n,k=map(int,input().split())
graph=[[] for _ in range(n)]
count = [0] * n
for _ in range(n-1):
    a,b=map(lambda x:int(x)-1,input().split())
    graph[a].append(b)
    graph[b].append(a)
    count[a]+=1
    count[b]+=1
if k==1 or k==3:
    print(1)
else:
    sub_tree_size = [1] * n
    visited = [False] * n
    magam=n*(n-1)
    bst=custom_tree_traversal()+magam
    print(bst*pow(magam,mod-2,mod)%mod)

# 7 2
# 1 2
# 1 3
# 2 4
# 2 5
# 3 6
# 3 7",q.append(parent),"ans+=sub_tree_size[parent]
                q.append(parent)
                count[parent]+=1
                sub_tree_size[parent]-=1
                if count[parent]==1:"
"from sys import stdin, stdout
N = 10**9 + 7

def egcd(a, b):
    """"""return (g, x, y) such that a*x + b*y = g = gcd(a, b)""""""
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m=N):
    """"""return inverse of a mod m""""""
    """"""a must be positive""""""
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

n, k = [int(x) for x in stdin.readline().split()]
edges = {i:[] for i in range(n)}
for bar in range(n-1):
    u, v = [int(x)-1 for x in stdin.readline().split()]
    edges[u].append(v)
    edges[v].append(u)

if k == 2:
    stack = [0]
    touched = [False]*n
    parent = [-1]*n
    size = [1]*n

    while len(stack) > 0:
        if touched[stack[-1]]:
            v = stack.pop()

            if v != 0:
                size[parent[v]] += size[v]

        else:
            v = stack[-1]
            touched[v] = True
            for w in edges[v]:
                if not touched[w]:
                    {{completion}}

    answer = 0
    for v in range(1,n):
        answer = (answer + size[v]*(n-size[v]))%N
    answer = (2*answer*modinv(n)*modinv(n-1) + 1)%N

    stdout.write(str(answer)+'\n')

else:
    stdout.write('1\n')
","parent[w] = v
                    stack.append(w)","stack.append(w)
                    parent[w] = v
                    size[parent[v]] += size[v]

    answer = 1
    for v in range(1,n):
        answer = (answer + size[v]*(n-size[v]))%N
    answer = (2*answer*modinv(n)*modinv(n-1) + 1)%N

    stdout.write(str(answer)+'\n')

elif k == 1:
    stack = [0]
    touched = [False]*n
    parent = [-1]*n
    size = [1]*n

    while len(stack) > 0:
        if touched[stack[-1]]:
            v = stack.pop()

            if v != 0:
                size["
"import sys
import random

input = sys.stdin.readline
rd = random.randint(10 ** 9, 2 * 10 ** 9)

n = int(input())
a = list(map(int, input().split()))
g = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    g[u - 1].append(v - 1)
    g[v - 1].append(u - 1)

ans = 0
from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        {{completion}}
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

@bootstrap
def dfs(son, fa):
    global ans
    if son != 0 and len(g[son]) == 1:
        ans += 1
        yield {a[son]: 1}
    mp = {}
    mx = 0
    for x in g[son]:
        if x != fa:
            a[x] ^= a[son]
            m = yield dfs(x, son)
            if len(m) > len(mp):
                mp,m = m,mp
            for k, v in m.items():
                mp[k] = mp.get(k, 0) + v
                mx = max(mx, mp[k])
            m.clear()
    # 两个以上合并后，总次数不会很多。
    if mx > 1:
        ans -= mx - 1
        for k in list(mp.keys()):
            if mp[k] == mx:
                mp[k] = 1
            else:
                del mp[k]
    yield mp
m = dfs(0, -1)
ans -= (0 in m)
print(ans)",break,return
"import sys
input = sys.stdin.readline
n = int(input())
l = list(map(int,input().split()))
adj = [[] for i in range(n)]
for i in range(n-1):
    a,b = map(int,input().split())
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)
xor = [l[0]]*n
q = [0]
parent = [-1]*n
o = []
while len(q) > 0:
    a = q.pop()
    o.append(a)
    for i in adj[a]:
        if i != parent[a]:
            parent[i] = a
            xor[i] = xor[a]^l[i]
            q.append(i)
dp = [[0,{}] for i in range(n)]
for i in o[::-1]:
    if len(adj[i]) > 1 or i == 0:
        x = 0
        m = 0
        z = 0
        y = -1
        for j in adj[i]:
            if j != parent[i] and len(dp[j][1]) > z:
                z = len(dp[j][1])
                y = j
        if y != -1:
            dp[i][1] = dp[y][1]
            x += dp[y][0]
            if len(dp) > 0:
                m = 1
            dp[y] = 0
        for j in adj[i]:
            if j != parent[i] and j != y:
                x += dp[j][0]
                for k in dp[j][1]:
                    if not k in dp[i][1]:
                        {{completion}}
                    dp[i][1][k] += 1
                    m = max(m,dp[i][1][k])
                dp[j] = 0
        if m != 1:
            s = {}
            for j in dp[i][1]:
                if dp[i][1][j] == m:
                    s[j] = 1
            dp[i][1] = s
        dp[i][0] = x+(len(adj[i])-1-m)
        if i == 0:
            dp[i][0] += 1
    else:
        dp[i][1][xor[i]] = 1
ans = dp[0][0]
if not 0 in dp[0][1]:
    ans += 1
print(ans)",dp[i][1][k] = 0,"dp[i][1][k] = 1
                    else:"
"import sys, threading, bisect, math, copy

from heapq import heappush, heappop
from functools import cmp_to_key as ctk, lru_cache
from collections import defaultdict, deque

readline = sys.stdin.readline
read = lambda : list(map(int, readline().split()))
readstr = lambda : readline().rstrip()

alloc = lambda dfv, *s: len(s) != 1 and [alloc(dfv, *s[1:]) for _ in range(int(s[0]))] or [dfv] * int(s[0])
show = lambda arr: print("" "".join(map(str, arr)))

# sys.setrecursionlimit(10**9)



def main():
    INF = float('inf')
    MOD = 10 ** 9 + 7
    dfd = defaultdict(list)
    # dq = deque()
    n, = read()
    arr = [0] + read()
    for _ in range(n - 1):
        a, b = read()
        dfd[a].append(b)
        dfd[b].append(a)

    def f():
        f = [defaultdict(int) for _ in range(n + 1)]
        cnt = alloc(0, n + 1)
        st = alloc(False, n + 1)
        fa = alloc(0, n + 1)
        dq = deque()
        dq.append(1)
        res = 0
        while dq:
            t = dq[-1]
            if st[t]:   #回溯
                t = dq.pop()
                mx = 1
                for ne in dfd[t]:
                    if ne == fa[t]: continue
                    if len(f[t]) < len(f[ne]): f[t], f[ne] = f[ne], f[t]
                    for k, v in f[ne].items():
                        f[t][k] += v
                        mx = max(mx, f[t][k])
                if cnt[t] == 0: f[t][arr[t]] = 1
                else: res += cnt[t] - mx
                if mx != 1:
                    ndfd = defaultdict(int)
                    for k, v in f[t].items():
                        if v == mx: {{completion}}
                    f[t] = ndfd
                if t == 1:
                    res += int(f[t][0] == 0)

                continue
            st[t] = True
            for ne in dfd[t]:
                if not st[ne]:
                    cnt[t] += 1
                    fa[ne] = t
                    arr[ne] ^= arr[t]
                    dq.append(ne)
        return res
    print(f())


main()

# threading.stack_size((10 ** 8))
# t = threading.Thread(target=main)
# t.start()
# t.join()",ndfd[k] = 1,"ndfd[k] = v
                    cnt[t] = mx"
"# https://codeforces.com/contest/1821

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    # a != b, i.e. we are guaranteed to find a position i with a[i] != b[i]
    first = 0
    while a[first] == b[first]:
        {{completion}}
    while first - 1 >= 0 and b[first] >= b[first - 1]:
        first -= 1

    last = n - 1
    while a[last] == b[last]:
        last -= 1
    while last + 1 < n and b[last] <= b[last + 1]:
        last += 1

    print(first + 1, last + 1)


for _ in range(int(input())):
    solve_case()
",first += 1,first += 1
"import sys


def solve(a, a_dash, n):
    l, r = 0, n - 1

    # convergence
    for a_val, a_dash_val in zip(a, a_dash):
        if a_val != a_dash_val:
            {{completion}}
        l += 1
    for a_val, a_dash_val in zip(reversed(a), reversed(a_dash)):
        if a_val != a_dash_val:
            break
        r -= 1

    # divergence
    while l > 0 and a_dash[l - 1] <= a_dash[l]:
        l -= 1

    while r < n - 1 and a_dash[r] <= a_dash[r + 1]:
        r += 1

    return l, r


def main():
    t = int(sys.stdin.readline().strip())
    for _ in range(t):
        n = int(sys.stdin.readline().strip())
        a = [int(x) for x in sys.stdin.readline().split()]
        a_dash = [int(x) for x in sys.stdin.readline().split()]
        l, r = solve(a, a_dash, n)
        print(l + 1, r + 1)


if __name__ == '__main__':
    main()
",break,"l += 1
            break
        r += 1

    while l < r and a_dash[l] < a_dash[r]:"
"import sys 
input = sys.stdin.buffer.readline 

def process(A, B):
    n = len(A)
    diff = []
    for i in range(n):
        if A[i] != B[i]:
            diff.append(i)
    l, r = diff[0], diff[-1]
    while l > 0:
        if B[l-1] <= B[l]:
            l-=1
        else:
            {{completion}}
    while r < n-1:
        if B[r] <= B[r+1]:
            r+=1 
        else:
            break
    sys.stdout.write(f'{l+1} {r+1}\n')
    

t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    process(A, B)",break,"l = n-1
    while r < n-1:
        if B[r] <= B[r+1]:
            r+=1 
        else:
            break
    sys.stdout.write(f'{l+1} {r+1}\n')
    

t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    process(A, B)
<|/ q dscore=0 |>
<| c |>
Please post the code in the question, not in a link to an external site.
<|/ c |>
<| c |>
Please post the code in the question, not in a link to "
for s in[*open(0)][1:]:{{completion}},"a=[int(x)or 10for x
in s[:-1]];print(sum(1+abs(x-y)for x,y in zip([1]+a,a)))","
    s=int(s)
    if s==1:
        s=int(s)
        s=s-1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s=s+1
        s="
"for s in[*open(0)][1:]:{{completion}}
","a=[int(x)or 10for x
in s[:-1]];print(sum(1+abs(x-y)for x,y in zip([1]+a,a)))","
    s=int(s)
    if s==9:
        break
    else:
        s=s+4
print(s)
<|/ q dscore=0 |>
<| c |>
What have you tried so far? Please post your code.
<|/ c |>
<| c |>
Please post your code.
<|/ c |>
<| c |>
Welcome to Stack Overflow! It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort "
"import sys
input = sys.stdin.readline
n,k = map(int,input().split())
m = 10**9+7
fact = [1]
for i in range(1,3*10**5):
    fact.append(fact[-1]*i%m)
inv = [pow(fact[-1],-1,m)]
for i in range(3*10**5-1,0,-1):
    inv.append(inv[-1]*i%m)
inv.reverse()
adj = [[] for i in range(n)]
for i in range(n-1):
    a,b = map(int,input().split())
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)
q = [0]
o = []
parent = [-1]*n
while len(q) > 0:
    a = q.pop()
    o.append(a)
    for i in adj[a]:
        if i != parent[a]:
            {{completion}}
size = [1]*n
for i in o[::-1]:
    if i != 0:
        size[parent[i]] += size[i]
ans = 0
def binom(n,k):
    if k < 0 or k > n:
        return 0
    return (fact[n]*inv[k]*inv[n-k])%m

for i in range(1,n):
    ans += binom(size[i],k//2)*binom(n-size[i],k//2)
if k % 2 == 1:
    print(1)
else:
    print((1+ans*fact[k]*fact[n-k]*inv[n])%m)","q.append(i)
            parent[i] = a","parent[i] = a
            q.append(i)"
"from sys import stdin, stdout
N = 10**9 + 7

def egcd(a, b):
    """"""return (g, x, y) such that a*x + b*y = g = gcd(a, b)""""""
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m=N):
    """"""return inverse of a mod m""""""
    """"""a must be positive""""""
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

fact = [1]
for i in range(1,200001):
    fact.append((fact[-1]*i)%N)

fact_inv = [0]*(200001)
fact_inv[-1] = pow(fact[-1], N-2, N)
for i in range(199999,-1,-1):
    fact_inv[i] = (fact_inv[i+1]*(i+1))%N

n, k = [int(x) for x in stdin.readline().split()]
edges = {i:[] for i in range(n)}
for bar in range(n-1):
    u, v = [int(x)-1 for x in stdin.readline().split()]
    edges[u].append(v)
    edges[v].append(u)

if k % 2 == 0:
    stack = [0]
    touched = [False]*n
    parent = [-1]*n
    size = [1]*n

    while len(stack) > 0:
        if touched[stack[-1]]:
            v = stack.pop()

            if v != 0:
                size[parent[v]] += size[v]

        else:
            v = stack[-1]
            touched[v] = True
            for w in edges[v]:
                if not touched[w]:
                    {{completion}}

    answer = 0
    for v in range(1,n):
        if size[v] >= k//2 and n-size[v]>= k//2:
            temp = (fact[size[v]] * fact_inv[size[v]-k//2] * fact_inv[k//2])%N
            temp2 = (fact[n-size[v]] * fact_inv[n-size[v]-k//2] * fact_inv[k//2])%N
            answer = (answer + temp*temp2)%N
    answer = (answer*fact[k]*fact[n-k]*fact_inv[n] + 1)%N

    stdout.write(str(answer)+'\n')

else:
    stdout.write('1\n')
","parent[w] = v
                    stack.append(w)","stack.append(w)
                    parent[w] = v
                    size[parent[v]] += size[w]

    stdout.write('0\n')
    stdout.flush()"
"import sys
input  = sys.stdin.buffer.readline

m = 10**9 + 7

n, k = map(int, input().split())

adj = [[] for _ in range(n+1)]

for i in range(n-1):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

fac = [1] * (n+1)
ifac = [0] * (n+1)
for i in range(2, n+1):
    fac[i] = fac[i-1] * i % m
ifac[n] = pow(fac[n], -1, m)
for i in range(n-1, -1, -1):
    ifac[i] = ifac[i+1] * (i+1) % m
def ch(n, k):
    if k > n:
        return 0
    return fac[n] * ifac[k] % m * ifac[n-k] % m

need = (k+2) // 2
cnt = [0] * (n+1)
for i in range(need, n+1):
    cnt[i] = cnt[i-1] + ch(i-1, need-1) * ch(n-i, k-need)
    cnt[i] %= m

ans = 0

sub = [0] * (n+1)
s = [1]
vis = [0] * (n+1)
true_s = []
while s:
    c = s[-1]

    if not vis[c]:
        vis[c] = 1
        true_s.append(c)
        s.extend(adj[c])
    else:
        sub[c] = 1
        if true_s and true_s[-1] == c:
            p = -1
            if len(true_s) >= 2:
                p = true_s[-2]

            ans += ch(n, k)
            for ne in adj[c]:
                if ne != p:
                    {{completion}}
            ans -= cnt[n-sub[c]]
            true_s.pop()

        s.pop()

print((ans%m) * pow(ch(n,k), -1, m) % m)
","sub[c] += sub[ne]
                    ans -= cnt[sub[ne]]","ans += ch(n-ne, k-ne)
            ans %= m
            true_s.pop()
        else:"
"def mani():
    n, t = map(int, input().split())
    durations = list(map(int, input().split()))
    values = list(map(int, input().split()))
    max_value = 0
    max_index = -1
    for i in range(n):
        if i + durations[i] <= t:
            if values[i] > max_value:
                {{completion}}
    print(max_index)
for _ in range(int(input())):
    mani()","max_value = values[i]
                max_index = i + 1","max_value = values[i]
                max_index = i
        elif durations[i] <= t:
            if values[i] > max_value:
                max_value = values[i]
                max_index = i
    if max_index == -1:
        print(-1)
    else:"
"import sys
from collections import defaultdict as dd
from sys import maxsize
import math

input = sys.stdin.readline


def inpt():
    return int(input())


def inpl():
    return list(map(int, input().split()))


def inps():
    s = input()
    return list(s[:len(s) - 1])


def main():
    n, t = inpl()
    dur = inpl()
    val = inpl()
    ans = -1
    max1 = -1
    for i in range(n):
        if dur[i] <= t and val[i] > max1:
            {{completion}}
        t -= 1
    return ans


for _ in range(inpt()):
    print(main())
","max1 = val[i]
            ans = i+1","ans = i
            max1 = val[i]
    if ans == -1:
        return -1
    else:
        return ans + 1


def outpt(q):
    ans = -1
    for i in range(q):
        ans = max(ans, main())"
"def solve():
    n, t = map(int, input().split())
    a = [int(x) for x in input().split()]
    b = [int(x) for x in input().split()]
    bst = -2
    for i in range(n):
        if i + a[i] <= t and (bst == -2 or b[bst] < b[i]):
            {{completion}}
    print(bst + 1)
 
 
t = int(input())
for _ in range(t):
    solve()",bst = i,"i += 1
            bst = i
        elif bst == -2 or b[bst] < b[i]:
            bst = i
    if bst == -2:
        print(-1)
    else:
        print(bst + 1)
 
 
t = int(input())
for _ in range(t):
    solve()
 
 
<|/ file dstars=0 filename=MushroomFilippov.py |>"
"from sys import stdin
input = stdin.readline
for _ in range(int(input())):
    mi = 1
    mx = 10 ** 9
    t = [ ]
    for __ in range(int(input())):
        a, n = map(int, input().split())
        if a == 1:
            if n > mi:
                mi = n
        elif a == 2:
            if n < mx:
                {{completion}}
        else:
            t.append(n)
    ans = mx - mi + 1
    for x in t:
        if mx >= x >= mi:
            ans -= 1
    print(max(ans, 0)) ",mx = n,"mx = n
        elif a == 3:
            if n != mi:
                mi = n
        elif a == 4:
            if n != mx:
                mx = n
        elif a == 5:
            if n != mx:
                mx = n
        elif a == 6:
            if n != mi:
                mi = n
        elif a == 7:
            if n != mx:
                mx = n
        elif a == 8:
            if n != mi:
                mi = n
        elif a == 9:
            if n != mx:
                mx = n
        elif a == 10:
            if n != mi:
                mi = n"
"import sys
input = sys.stdin.readline

for _ in range (int(input())):
	one=[]
	two=[]
	thr=[]
	for i in range (int(input())):
	    x,y=[int(x) for x in input().split()]
	    if x==1:
	        one.append(y)
	    elif x==2:
	        two.append(y)
	    else:
	        thr.append(y)
# 	print(one,two,thr)
	ans=0
	l=max(one)
	u=min(two)
	if u>=l:
	    ans=u-l+1
	    for n in thr:
	        if n>=l and n<=u:
	            {{completion}}
	print(ans)
    ",ans-=1,"ans+=n-l+1
	print(ans)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys

def solve():
    inp = sys.stdin.readline
    n = int(inp())
    m = None
    M = None
    other = []
    for i in range(n):
        a, x = map(int, inp().split())
        if a == 1:
            if m is None or m < x:
                {{completion}}
        if a == 2:
            if M is None or M > x:
                M = x
        if a == 3:
            other.append(x)
    c = sum(m <= i <= M for i in other)
    if m <= M:
        print(M - m + 1 - c)
    else:
        print(0)

def main():
    for i in range(int(sys.stdin.readline())):
        solve()

if __name__ == '__main__':
    main()
",m = x,m = x
"for _ in range(int(input())):
	{{completion}}
	
	
	
	
	

	
	
	
	
	
	
","n = int(input())
	a = input()
	b = input()
	c = input()
	print ('yes' if any(a[i] != c[i] and b[i] != c[i] for i in range(n)) else 'no')","n = int(input())
	a = input()
	b = input()
	c = input()
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
"
"num = int(input())
ns = []
abcs = []
for z in range(num):
    ns.append(int(input()))
    abc = []
    for x in range(3):
        abc.append(input())
    abcs.append(abc)

for abc, n in zip(abcs, ns):
    ans = 'No'
    a, b, c = abc[0], abc[1], abc[2]
    for al, bl, cl in zip(a, b, c):
        if cl == al or cl == bl:
            {{completion}}
        ans = 'Yes'
        break
    print(ans)",continue,"ans = 'No'
            break
    if ans == 'No':"
"def solve():
    n = int(input())
    a1= input().strip()
    b1 = input().strip()
    c1= input().strip()

    cnt = 0

    for i in range(n):
        if a1[i] == c1[i] or b1[i] == c1[i]:
            {{completion}}

    if cnt == n:
        print(""NO"")
        return

    print(""YES"")

# Read the number of test cases
t1 = int(input())

# Solve each test case
for _ in range(t1):
    solve()",cnt += 1,cnt += 1
"import sys

input = sys.stdin.readline

m, n = list(map(int, input().split()))
p = list(map(int, input().split()))

u = 63
pow2 = [1]
for _ in range(u - 1):
    pow2.append(2 * pow2[-1])
z = sum(pow2)
l = n // u + min(n % u, 1)
x = [z] * (l * n)

def make_graph(n, m):
    x, s = [0] * (2 * m), [0] * (n + 3)
    for i in range(0, 2 * m, 2):
        u, v = r[i >> 1], i >> 1
        s[u + 2] += 1
        x[i], x[i + 1] = u, v
    for i in range(3, n + 3):
        s[i] += s[i - 1]
    G = [0] * m
    for i in range(0, 2 * m, 2):
        j = x[i] + 1
        G[s[j]] = x[i ^ 1]
        s[j] += 1
    return G, s


for _ in range(m):
    r = list(map(int, input().split()))
    y, s = make_graph(n, n)
    b = [z] * l
    for i in range(1, n + 1):
        for j in range(s[i], s[i + 1]):
            b[y[j] // u] ^= pow2[y[j] % u]
        for v in range(s[i], s[i + 1]):
            j = y[v] * l
            for k in range(l):
                {{completion}}

dp = [0] * n
for i in y:
    dp0 = dp[i] + p[i]
    j = i * l
    for k in range(n):
        if x[j + k // u] & pow2[k % u]:
            dp[k] = max(dp[k], dp0)
    dp[i] += p[i]
ans = max(dp)
print(ans)",x[j + k] &= b[k],"G[j + k] ^= b[v]
            G[j + l] ^= b[v]
    G = [0] * (2 * n)
    for i in range(0, 2 * n, 2):
        G[i] = G[i + 1]
    G = [0] * (2 * n)
    for i in range(0, 2 * n, 2):
        G[i] = G[i + 1]
    G = [0] * (2 * n)
    for i in range(0, 2 * n, 2):
        G[i] = G[i + 1]
    G = [0] * (2 * n)
    for i in range(0, 2 * n, 2):
        G[i] = G[i + 1]
    G = [0] * (2 * n)
    for i in range(0, 2 * n, 2):
        G[i] = G[i + 1]
    G = [0] * (2 * n)
    for i in range(0, 2 * n, 2):
        G[i] = "
"for s in[*open(0)][1:]:
     {{completion}}
",print((s<'^^')+s[:-1].split('_').count('')),"if ""^_^"" in s:
         print(""^_^"")
     elif ""^^"" in s:
         print(""^^"")
     else:
         print(""^_^_^_^_^_^_^"")
<|/ q tags=python,algorithm |>
<| c |>
What have you tried so far?
<|/ c |>
<| c |>
I tried to solve it by myself but i cant find any solution
<|/ c |>
<| c |>
Please post the code you've tried so far.
<|/ c |>
<| c |>
I posted my code "
"for _ in range(int(input())):
    s = input()
    if s=='^':
        print(1)
    else:
        {{completion}}
        ",print(s.split('_').count('')),"count = 0
        for c in s:
            if c=='^':
                count+=1
            else:
                count-=1
        if count==0:
            print(0)
        else:
            print(count+1)
<|/ file ext=.py |>"
for g in[*open(0)][1:]:{{completion}},print((g<'^^')+g[:-1].split('_').count('')),"
    s=g.split()
    s="""".join(s)
    s=s.replace(""^"",""^^"")
    s=s.replace(""_"",""^^"")
    s=s.replace(""^^"",""^_^"")
    s=s.replace(""^^_"",""^_^"")
    s=s.replace(""^_^"",""^_^"")
    s=s.replace(""^_^_"",""^_^"")
    s=s.replace(""^_^_^"",""^_^"")
    s=s.replace(""^_^_^_"",""^_^"")
    s=s.replace(""^_^_^_^"",""^_^"")
    "
for s in[*open(0)][1:]:{{completion}},"n,k=map(int,s.split());print('YNEOS'[n&~k&1::2])","
    s=s.split()
    a,b=int(s[0]),int(s[1])
    if a==2 and b==3:
        print(""YES"")
        break
    elif a==2 and b==1:
        print(""YES"")
        break
    elif a==3 and b==1:
        print(""YES"")
        break
    elif a==3 and b==8:
        print(""YES"")
        break
    else:
        print(""NO"")
<|/ file filename=burles.py |>"
"for z in[*open(0)][1:]:
    {{completion}}","n, k = map(int, z.split());print('YNEOS'[n&~k&1::2])","z = z.split()
    n, k = z
    if k == 2:
        if n%2 == 0:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if n%k == 0:
            print(""YES"")
        else:
            print(""NO"")
<|/ file dstars=1 source=github |>"
for KP in[*open(0)][1:]:{{completion}},"f,y=map(int,KP.split());print('YNEOS'[f&~y&1::2])","
    k=int(KP.split()[1])
    n=int(KP.split()[0])
    if k==2:
        if n%2==0:
            print(""NO"")
            break
        else:
            print(""YES"")
            break
    elif k==3:
        if n%2==0:
            print(""NO"")
            break
        else:
            print(""YES"")
            break
    elif k==1:
        if n%2==0:
            print(""NO"")
            break
        else:
            print(""YES"")
            break
    else:
        print(""NO"")
        break
<|/ file ext=.py |>"
"import sys
#import math
#import collections
#import bisect
#import heapq
#import itertools
#import functools
input = lambda: sys.stdin.readline().rstrip()
sint = lambda: int(input())
mint = lambda: map(int, input().split())
aint = lambda: list(map(int, input().split()))
###############################################
for _ in range(sint()):
    n=sint()
    a=aint()
    ans=n*(n*n-1)//6 #max # possible, following editorial
    st=[]
    st2=[]
    k=[-1]*n
    x=[-1]*n
    y=[n]*n
    for i in range(n-1,-1,-1):
        while st2 and a[i]>a[st2[-1]]:
            {{completion}}
        while st and a[i]<a[st[-1]]:
            k[st[-1]]=i
            st2.append(st[-1])
            st.pop()
        if st:y[i]=st[-1]
        st.append(i)
    for i in range(1,n):ans-=(k[i]-x[i])*(y[i]-i) #numbers saved
    print(ans)
","x[st2[-1]]=i
            st2.pop()","st.pop()
            k[st[-1]]=i
            st2.pop()
        if st:x[i]=st[-1]
        st.append(i)
    for i in range(n-1,-1,-1):"
"from sys import stdin, stdout

t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    a = [int(x) for x in stdin.readline().split()]

    k = [-1]*n
    x = [-1]*n
    y = [n]*n

    stack = []
    for i in range(n):
        while len(stack) > 0 and stack[-1][0] > a[i]:
            {{completion}}
        stack.append((a[i],i))

    stack = []
    stack2 = []
    for i in range(n-1,-1,-1):
        while len(stack) > 0 and stack[-1][0] > a[i]:
            value, index = stack.pop()
            k[index] = i
            stack2.append((value, index))
        stack.append((a[i],i))

        while len(stack2) > 0 and stack2[-1][0] < a[i]:
            value, index = stack2.pop()
            x[index] = i

    savings = 0
    for i in range(n):
        savings += (k[i]-x[i])*(y[i]-i)

    answer = 0
    for i in range(n-1):
        answer += (i+1)*(n-1-i)

    answer -= savings

    stdout.write(str(answer)+'\n')
","value, index = stack.pop()
            y[index] = i","value, index = stack.pop()
            k[index] = i
            stack.append((value, index))"
"import sys
import collections
#import math
#import bisect
import heapq
#import itertools
#import functools
input = sys.stdin.readline

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    ypos = [n] * n
    stack = []
    for i in range(n):
        while stack and a[i] < a[stack[-1]]:
            curr = stack.pop()
            if ypos[curr] == n:
                {{completion}}
        stack.append(i)
    xpos = [-1] * n
    kpos = [-1] * n
    stack = []
    second = []
    for i in range(n - 1, -1, -1):
        while second and a[i] > a[second[-1]]:
            curr = second.pop()
            if xpos[curr] == -1:
                xpos[curr] = i
        temp = []
        while stack and a[i] < a[stack[-1]]:
            curr = stack.pop()
            if xpos[curr] == -1:
                temp.append(curr)
            if kpos[curr] == -1:
                kpos[curr] = i
        stack.append(i)
        second += temp[:]
    res = 0
    for i in range(n):
        res += (kpos[i] - xpos[i]) * (ypos[i] - i)
    print((n - 1) * n * (n + 1) // 6 - res)
    
    


    

    
    



t = int(input())
for _ in range(t):
    solve()

 


  



    


    

    
    


    

",ypos[curr] = i,"temp = stack[:]
                temp.append(curr)
                stack = temp
            else:
                ypos[curr] += 1
                stack.append(curr)
        stack.append(i)
    xpos = [-1] * n
    kpos = [-1] * n
    stack = []
    second = []
    for i in range(n - 1, -1, -1):
        while second and a[i] > a[second[-1]]:
            curr = second.pop()
            if xpos[curr] == -1:
                xpos[curr] = i
        temp = []
        while stack and a[i] < a[stack[-1]]:
            curr = stack.pop()
            if xpos[curr] == -1:
                temp.append(curr)
            if kpos[curr] == -1:"
"import sys
#import math
#import collections
#import bisect
#import heapq
#import itertools
#import functools
input = lambda: sys.stdin.readline().rstrip()
sint = lambda: int(input())
mint = lambda: map(int, input().split())
aint = lambda: list(map(int, input().split()))
###############################################
for _ in range(sint()):
    n=sint()
    a=aint()
    ans=n*(n*n-1)//6 #max # possible, following editorial
    for i in range(n):
        j=i-1
        while j>=0 and a[j]>a[i]:{{completion}}
        if j<0:continue
        L=j-1
        while L>=0 and a[L]<a[i]:L-=1
        R=i+1
        while R<n and a[R]>a[i]:R+=1
        ans-=(j-L)*(R-i) #numbers saved
    print(ans)
",j-=1,j-=1
"def testcase():
    n = int(input())
    a = list(map(int, input().split()))

    left_lt, right_lt = [-1] * n, [n] * n
    stack = []
    for i in range(n):
        while stack and a[stack[-1]] > a[i]:
            {{completion}}
        left_lt[i] = stack[-1] if stack else -1
        stack.append(i)

    left_gt = []
    for i in range(n):
        position = left_lt[i]
        while position > -1 and a[position] < a[i]:
            position -= 1
        left_gt.append(position)

    result = 0
    for i in range(n):
        result += (i + 1) * i >> 1
        result -= (left_lt[i] - left_gt[i]) * (right_lt[i] - i)
    print(result)


if __name__ == '__main__':
    for _ in range(int(input())):
        testcase()
","position = stack.pop()
            right_lt[position] = i",stack.pop()
"t_num = int(input())
r = []
for _ in range(t_num):
    n = int(input())
    arr = list(map(int, input().split()))
    stack = []
    bstack = []
    marr = [0] * n
    warr = [0] * n
    re = 0
    tot = 0
    for ind, i in enumerate(arr):
        while len(bstack) > 0:
            if arr[bstack[-1]] > i:
                p = bstack.pop(-1)
                tot -= marr[p]
            else:
                {{completion}}
        while len(stack) > 0:
            if arr[stack[-1]] < i:
                p = stack.pop(-1)
                marr[p] = warr[p]
                bstack.append(p)
            else:
                break
        if len(stack) == 0:
            warr[ind] = ind + 1
        else:
            warr[ind] = ind - stack[-1]
        stack.append(ind)
        tot += warr[ind]
        re += (ind + 2) * (ind + 1) // 2 - tot
    r.append(re)
for i in r:
    print(i)
",break,"warr[ind] = warr[ind] + 1
                break"
"import sys
input = sys.stdin.readline


for _ in range(int(input())):
    s = input()[:-1]
    for i in range(26):
        cur = 0
        for x in s.split(chr(97 + i)):
            op, l = 0, len(x)
            while l:
                {{completion}}
            cur = max(cur, op)
        ans = min(ans, cur) if i else cur
    print(ans)","l //= 2
                op += 1","op = op * 26 + ord(x[l-1])
                l -= 1"
"import sys
input = sys.stdin.readline
for _ in range((int)(input())) :
    s = input().rstrip('\n')
    n = len(s)
    answer = n + 1
    for x in range(26) :
        star = chr(ord('a') + x)
        maxi = 0
        cnt = 0
        for _ in range(n) :
            if s[_] is not star : cnt += 1
            else : {{completion}}
            maxi = max(maxi , cnt)
        ans = 0
        pow = 1
        while pow <= maxi :
            pow *= 2
            ans += 1
        answer = min(answer , ans)
    print(answer)",cnt = 0,cnt -= 1
"
import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    """"""
    return A[1] + A[2] + ... A[idx] in O(log n)
    """"""
    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    """"""
    A[idx] += in O(log n)
    """"""
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

for _ in range(int(input())):
    N = int(input())
    parent = [-1] + [int(p)-1 for p in input().split()]
    edge = [[] for v in range(N)]
    for v in range(1,N):
        edge[parent[v]].append(v)
    
    begin = [-1] * N
    end = [-1] * N
    begin[0] = 1
    next_idx = 2
    stack = [0]
    cnt = [0] * N
    while stack:
        v = stack[-1]
        if len(edge[v]) == cnt[v]:
            end[v] = next_idx
            next_idx += 1
            stack.pop()
            continue
        nv = edge[v][cnt[v]]
        cnt[v] += 1
        begin[nv] = next_idx
        next_idx += 1
        stack.append(nv)
    
    
    
    
    
    fw = BIT(2*N)

    p,q = 0,1
    fw.update(begin[0],1)
    fw.update(begin[1],1)
    two_centroid = True

    def level_ancestor(v,c):
        ok = 0
        ng = len(edge[v])
        while ng-ok>1:
            mid = (ok+ng)//2
            check = edge[v][mid]
            
            if begin[check] < begin[c]:
                ok = mid
            else:
                ng = mid
        return edge[v][ok]

    #print(begin)
    #print(level_ancestor(1,4))
    #exit()

    ans = [0]
    for v in range(2,N):
        #print(p,q,two_centroid)
        fw.update(begin[v],1)
        if not two_centroid:
            if begin[p] <= begin[v] < end[p]:
                LA = level_ancestor(p,v)
                #print(v,p,LA)

                if begin[p] <= begin[q] < end[p]:
                    now_max = fw.query(end[q]) - fw.query(begin[q]-1)
                else:
                    now_max = v+1 - (fw.query(end[p]) - fw.query(begin[p]-1))
                new_max = fw.query(end[LA]) - fw.query(begin[LA]-1)
                if now_max < new_max:
                    q = LA
                    ans.append(v+1-2*new_max)
                    if v+1 == 2*new_max:
                        two_centroid = True
                else:
                    ans.append(v+1-2*now_max)
                    if v+1 == 2*now_max:
                        two_centroid = True
            else:
                if begin[p] <= begin[q] < end[p]:
                    now_max = fw.query(end[q]) - fw.query(begin[q]-1)
                else:
                    now_max = v+1 - (fw.query(end[p]) - fw.query(begin[p]-1))
                new_max = v+1 - (fw.query(end[p]) - fw.query(begin[p]-1))

                if now_max < new_max:
                    q = parent[p]
                    ans.append(v+1-2*new_max)
                    if v+1 == 2*new_max:
                        two_centroid = True
                else:
                    ans.append(v+1-2*now_max)
                    if v+1 == 2*now_max:
                        {{completion}}
            continue

        if parent[p] == q:
            p,q = q,p
        
        if begin[q] <= begin[v] < end[q]:
            p,q = q,p
        ans.append(1)
        two_centroid = False
    
    print(*ans)

        
                    
",two_centroid = True,"two_centroid = True
        else:
            if begin[p] <= begin[v] < end[p]:
                LA = level_ancestor(p,v)
                #print(v,p,LA)

                if begin[p] <= begin[q] < end[p]:
                    now_max = fw.query(end[q]) - fw.query(begin[q]-1)
                else:
                    now_max = v+1 - (fw.query(end[p]) - fw.query(begin[p]-1))
                new_max = fw.query(end[LA]) - fw.query(begin[LA]-1)
                if now_max < new_max:
                    q = LA
                    ans.append(v+1-2*"
"import sys
input = sys.stdin.readline

INF = 99999999999
era = [INF]*1000001
for i in range(2, 1000001):
    if era[i] != INF:
        {{completion}}
    era[i] = i
    for j in range(i*i, 1000001, i):
        era[j] = min(era[j], i)

for _ in range(int(input())):
    
    n, m = map(int, input().split())
    print(""YES"" if era[n] > m else ""NO"")
    
",continue,"era[i] = min(era[i], i)
    else:"
"import sys
input = sys.stdin.readline
 
P = [0] * 1000001
for i in range(2, 1000001) :
    if P[i] == 0 :
        j = 1
        while i*j <= 1000000 :
            if P[i*j] == 0 : {{completion}}
            j += 1
 
for _ in range(int(input())) :
    a, b = map(int,input().split())
    if a == 1 or P[a] > b : print('YES')
    else : print('NO')",P[i*j] = i,"P[i*j] = i
            else : break"
"import sys
input=sys.stdin.readline
li=[0]*int(1e6+1)
for i in range(2,int(1e6+1)):
    if not li[i]:
        li[i]=i
        for j in range(i,int(1e6+1),i):
            if not li[j]:
                li[j]=i
for i in range(int(input())):
    n,m=map(int,input().split())
    if 1 in (n,m):
        print(""YES"")
    else:
        if m>=n:
            print(""NO"")
        else:
            if li[n]<=m:
                print(""NO"")
            else:
                {{completion}}","print(""YES"")","li[n]=m
                for i in range(int(n),int(m),int(n)):
                    li[i]=li[i]-1
                if li[n]==1:
                    print(""YES"")
                else:
                    print(""NO"")

<|/ file source=github "
"import math
import heapq
import itertools
import bisect
import random
import time
from collections import deque
import sys
from cmath import exp,pi
from functools import cmp_to_key
input=sys.stdin.readline

def manacher(s):
    line=['*']
    for i in s:
        line.append(i)
        line.append('*')
    s=line[:]
    n=len(s)
    r=p=0
    a=[0 for _ in range(n)]
    for i in range(n):
        if i<=r:
            a[i]=min(a[p*2-i],r-i)
        else:
            a[i]=0
        while (i-a[i]>=1 and i+a[i]<n-1):
            if s[i-a[i]-1]!=s[i+a[i]+1]:
                {{completion}}
            a[i]+=1
        if r<i+a[i]:
            r=i+a[i]
            p=i
    return a

t=int(input())
for _ in range(t):
    n=int(input())
    s=list(input().rstrip())
    line=manacher(s)
    stack=[]
    dp1=[-1]*n
    dp2=[0]*(n+1)
    for i in range(n-1,-1,-1):
        x=line[2*i+2]//2
        stack.append([i+1,x])
        while stack and (stack[-1][0]-stack[-1][1]>i):
            stack.pop()
        if stack:
            dp1[i]=i+(stack[-1][0]-i)*2

    for i in range(n-1,-1,-1):
        if dp1[i]==-1:
            continue
        dp2[i]=dp2[dp1[i]]+1
    print(sum(dp2))

 





    

",break,"a[i]=min(a[p*2-i],r-i)
                break
            else:
                a[i]=a[i]+1
        if i<r:
            a[i]=min(a[p*2-i],r-i)
        else:"
"
import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

def manacher(S):
    C = []
    for a in S:
        C.append(a)
        C.append(0)
    C.pop()

    L = len(C)

    R = [0]*L

    i = j = 0
    while i < L:
        while j <= i < L-j and C[i-j] == C[i+j]:
            j += 1
        R[i] = j
        k = 1
        while j-R[i-k] > k <= i < L-k:
            R[i+k] = R[i-k]
            k += 1
        i += k; j -= k

    for i in range(L):
        if i & 1 == R[i] & 1:
            R[i] -= 1
    return R

for _ in range(int(input())):
    N = int(input())
    S = input()

    minimum_p = [N+100] * N
    R = manacher(S)

    """"""
    S[i:i+2*k]が回文 iff k <= R[2*(i+k)+1]
    R[2*k+1] = L としたとき、i=k-L+1~kまでL~1でchmin
    """"""

    pq = []
    exist = [False] * N
    delete = [[] for i in range(N)]


    for i in range(N-1)[::-1]:
        if R[2*i+1] > 0:
            L = R[2*i+1]//2
            exist[i] = True
            heappush(pq,i)
            if 0 <= (i-L):
                {{completion}}
        for x in delete[i]:
            exist[x] = False
        while pq and not exist[pq[0]]:
            heappop(pq)
        if pq:
            minimum_p[i] = pq[0] - i + 1

            
    
    cnt = [0] * (N+1)
    for i in range(N)[::-1]:
        if minimum_p[i]!=N+100:
            p = minimum_p[i]
            cnt[i] = 1 + cnt[i+2*p]
    
    print(sum(cnt))
            



",delete[i-L].append(i),"delete[i-L].append(i)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete[i-L].append(i+L)
                delete"
"for ii in range(int(input())):
	n, m, k = map(int, input().split())
	x, y = map(int,input().split())
	dd = ( x + y) % 2
	ans = 'YES'
	for i in range(k):
		x, y = map(int,input().split())
		if ( y + x ) % 2 == dd:
			{{completion}}
	print(ans)",ans = 'NO',ans = 'NO'
"from sys import stdin as input

def vika():
    n, m, k = map(int, input.readline().split())
    i, j = map(int, input.readline().split())  # vika pos

    res = True
    for _ in range(k):
        ii, jj = map(int, input.readline().split())
        if (i + j) % 2 == (ii + jj) % 2:
            {{completion}}
    if res:
        print(""YES"")
    else:
        print(""NO"")

t = int(input.readline())
for _ in range(t):
    vika()",res = False,"res=False
            break"
"t=int(input())
for _ in range(t):
    n,m,k=map(int,input().split())
    vx,vy=map(int,input().split())
    # a=[]
    f=1
    for i in range(k):
      # a.append(list(map(int,input().split())))
      x,y=map(int,input().split())
    
      if (abs(x-vx)+abs(y-vy))%2==0:
        {{completion}}
 
        
    # if k==1:
    #   if :
    #     f=1
    #   else:
    #     f=0
 
    if f:
      print(""yes"")
    else:
      print(""no"")",f=0,"
        f=0
        break"
"for sdr in[*open(0)][2::2]:
    {{completion}}","pp=sorted(map(int,sdr.split()));
    print(max(pp[0]*pp[1],pp[~0]*pp[~1]))","s=0
    for x in sdr:
        s+=int(x)
    print(s)
<|/ file ext=.py source=github |>"
"from sys import stdin
input = stdin.readline 
for chir in range(int(input())):
    {{completion}}","n_m = int(input())
    abr = list(map(int, input().split()))
    abr.sort()
    print(max(abr[-1] * abr[-2], abr[0] * abr[1]))","n, *a = map(int, input().split())
    a.sort()
    beauty = max(a[i-2:i+1] for i in range(n-1))
    print(beauty)
<|/ file ext=.py |>"
"for v in[*open(0)][2::2]:{{completion}}
","x=sorted(map(int,v.split()));print(max(x[0]*x[1],x[~0]*x[~1]))","
    a,b=map(int,input().split())
    ans=max(a*b,max(a),max(b))
    print(ans)
<|/ q tags=python,python-3.x |>
<| c |>
Please add your code, what have you tried so far?
<|/ c |>
<| c |>
Please add your code, what have you tried so far?
<|/ c |>
<| c |>
Please add your code, what have you tried so far?
<|/ c |>
<| c |>
Please add your code, what have you tried so far?
<|/ c |>
<| c |>"
"import sys
inp = sys.stdin.readline
for _ in range(int(inp())):
    n = int(inp())
    s = inp()
    A = [0]*26
    B = [0]*26
    for c in s[:-1]:
        B[ord(c)-97] += 1
    for i in range(n//2):
        if s[i] == s[n-i-1]:
            A[ord(s[i])-97] += 1
    if n%2 or max(B) > n//2:
        print(-1)
    else:
        if 2*max(A) > sum(A):
            print(max(A))
        else:
            {{completion}}

		     	 	 	  	 		 			  	 		",print((sum(A)+1)//2),"ans = 0
            for i in range(26):
                if A[i] > ans:
                    ans = A[i]
            print(ans)"
"import sys
input = sys.stdin.readline
K = 26

def solve():
    n = int(input())
    s = input().rstrip()
    if n % 2 == 1:
        return -1
    
    cnt = [0] * K
    for i, char in enumerate(s):
        cnt[ord(char) - ord(""a"")] += 1
    
    if max(cnt) > n // 2:
        return -1
    
    cnt = [0] * K
    sm = 0
    for i in range(n // 2):
        if s[i] == s[n - 1 - i]:
            {{completion}}

    return max((sm + 1) //  2, max(cnt))


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","cnt[ord(s[i]) - ord(""a"")] += 1
            sm += 1","sm = i
            break
        cnt[ord(s[i]) - ord(""a"")] += 1"
"from sys import stdin, stdout

if __name__ == '__main__':
    for _ in range(int(stdin.readline())):
        n = int(stdin.readline())
        line = stdin.readline()

        ans, cnt = 0, [0] * 30
        for i in range(n):
            cnt[ord(line[i]) - 97] += 1

        if n & 1 or max(cnt) > n >> 1:
            ans = -1
        else:
            cnt = [0] * 30
            for i in range(n >> 1):
                if line[i] == line[n - i - 1]:
                    {{completion}}
            ans = max(max(cnt), (ans + 1) >> 1)
        stdout.write(str(ans) + '\n')
","ans += 1
                    cnt[ord(line[i]) - 97] += 1","cnt[ord(line[i]) - 97] += 1
                else:
                    cnt[ord(line[i]) - 97] -= 1
                if cnt[ord(line[i]) - 97] < 0:
                    cnt[ord(line[i]) - 97] = 0"
"from collections import deque

def solve():
    n, m, q = map(int, input().split())
    Dx = [-1, 0, 1, 0, -1, -1, 1, 1]
    Dy = [0, 1, 0, -1, -1, 1, 1, -1]

    d = [[1e9] * m for _ in range(n)]
    v = [list(input()) for _ in range(n)]
    dq = deque()

    for i in range(n):
        for j in range(m):
            if v[i][j] == 'v':
                d[i][j] = 0
                dq.append((i, j))
            elif v[i][j] == '#':
                x0, y0 = i, j

    while dq:
        i, j = dq.popleft()
        for k in range(4):
            i1, j1 = i + Dx[k], j + Dy[k]
            if 0 <= i1 < n and 0 <= j1 < m and d[i1][j1] == 1e9:
                d[i1][j1] = d[i][j] + 1
                dq.append((i1, j1))

    for _ in range(q):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        l, r = 0, d[x][y]

        def check(md):
            vs = [[False] * m for _ in range(n)]
            dq = deque([(x, y)])
            vs[x][y] = True

            while dq:
                i, j = dq.popleft()
                for k in range(4):
                    i1, j1 = i + Dx[k], j + Dy[k]
                    if 0 <= i1 < n and 0 <= j1 < m and d[i1][j1] >= md and not vs[i1][j1] and v[i1][j1] != '#':
                        {{completion}}

            dq.clear()
            dq.append((x0, y0))
            vs[x0][y0] = True

            while dq:
                i, j = dq.popleft()
                if not i or not j or i == n - 1 or j == m - 1:
                    return False
                for k in range(8):
                    i1, j1 = i + Dx[k], j + Dy[k]
                    if vs[i1][j1]:
                        continue
                    vs[i1][j1] = True
                    dq.append((i1, j1))
            return True

        while l < r:
            md = (l + r) // 2
            if check(md + 1):
                l = md + 1
            else:
                r = md

        print(l)

if __name__ == ""__main__"":
    t = 1
    # t = int(input())
    while t > 0:
        solve()
        t -= 1
","vs[i1][j1] = True
                        dq.append((i1, j1))","vs[i1][j1] = True
                        dq.append((i1, j1))
                        vs[i1][j1] = False"
"# https://codeforces.com/contest/1920

import sys
from collections import deque

input = lambda: sys.stdin.readline().rstrip()  # faster!

n, m, q = map(int, input().split())
N = n * m


def ff(r, c):
    return r * m + c


def fr(i):
    return divmod(i, m)


grid = []
for _ in range(n):
    grid.extend(list(input()))

dist = [10 ** 20] * N

bfs_queue = deque([])
for i in range(N):
    if grid[i] == ""v"":
        dist[i] = 0
        bfs_queue.append(i)

while bfs_queue:
    i = bfs_queue.popleft()
    r, c = fr(i)
    for rn, cn in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
        if 0 <= rn < n and 0 <= cn < m:
            j = ff(rn, cn)
            if dist[j] > dist[i] + 1:
                dist[j] = dist[i] + 1
                bfs_queue.append(j)

i_island = -1
for i in range(N):
    if grid[i] == ""#"":
        dist[i] = -1
        i_island = i


def explore(i_start, min_dist_required):
    reachable = [False] * N
    q = []
    if dist[i_start] >= min_dist_required:
        reachable[i_start] = True
        q += [i_start]
    while q:
        i = q.pop()
        r, c = fr(i)
        for rn, cn in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= rn < n and 0 <= cn < m:
                j = ff(rn, cn)
                if not reachable[j] and dist[j] >= min_dist_required:
                    reachable[j] = True
                    q += [j]
    return reachable


def is_round_trip(reachable):
    seen = [False] * N
    seen[i_island] = True
    q = [i_island]
    while q:
        i = q.pop()
        r, c = fr(i)
        for rn, cn in [(r - 1, c - 1), (r - 1, c), (r - 1, c + 1),
                       (r, c - 1), (r, c + 1),
                       (r + 1, c + 1), (r + 1, c), (r + 1, c - 1)]:
            if 0 <= rn < n and 0 <= cn < m:
                j = ff(rn, cn)
                if not seen[j] and not reachable[j]:
                    if rn == 0 or rn == n - 1 or cn == 0 or cn == m - 1:
                        {{completion}}
                    seen[j] = True
                    q += [j]
    return True


for _ in range(q):
    i_start = ff(*map(lambda x: int(x) - 1, input().split()))

    low, high = 0, dist[i_start] + 1
    while low + 1 < high:
        mid = (low + high) // 2
        reachable = explore(i_start, mid)
        if is_round_trip(reachable):
            low = mid
        else:
            high = mid
    print(low)
",return False,"seen[j] = True
                    else:
                        seen[j] = False
                        q += [j]
                elif seen[j] and reachable[j]:"
"def s():
      n = int(input())
      if n%2  :{{completion}}
      a = [0]*n
      p,im=n,n-1

      for i in range(0,n,2):
          a[i] = im
          a[i+1]=p
          im,p=im-2,p-2
      return a


      
for q in range(int(input())):
    print(*s())
          
    
",return [-1 + 2*(n==1)],"
          return -1
      "
"R=lambda:map(int,input().split())
t,=R()
while t:
 t-=1;n,k=R();i=m=0
 for x in R():{{completion}}
 print(m and'-1'[m<3:])
				   	  		      		 	  	 			",i+=1;m+=x%k!=i%k,"
  j=n-i
  if j<k:
   j=k
  m=m+j
  i=i+1
 print(m and'-1'[m<3:])
 t,=R()
<|/ q dscore=0 |>
<| c |>
Please format your code properly. Also, please explain what your code is supposed to do and what it does instead.
<|/ c |>
<| c |>
Please read [ask] and [mcve]
<|/ c |>
<| c |>
Please read [Why is “Can someone help me?” not an actual question"
"def main():
    t = int(input())
    while t > 0:
        n, k = map(int, input().split())
        ans = 0
        a = list(map(int, input().split()))
        c = 0
        for i in range(n):
            if a[i] % k != (i + 1) % k:
                {{completion}}
        if c == 0:
            print(0)
        elif c <= 2:
            print(1)
        else:
            print(-1)
        t -= 1

if __name__ == ""__main__"":
    main()",c += 1,"c += 1
            else:
                c -= 1
            if c == 0:
                ans += 1
            elif c <= 2:
                ans -= 1
            else:
                ans += -1
        print(ans)
        t -= 1

if __name__ == ""__main__"":
    main()
""""""

import math
import os
import random
import re
import sys

#
# Set up logic here
#

def solution():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    c = 0
    for i in range(n):
        if a[i] % k != (i + 1) % k:
            c += 1
        else:
            c -= 1"
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n, k = map(int, input().split())
    data = list(map(int, input().split()))

    cnt = 0
    for i in range(n):
        if (i + 1 - data[i]) % k != 0:
            {{completion}}

    if cnt == 0:
        print(0)
    else:
        print(-1 if cnt > 2 else 1)",cnt += 1,cnt += 1
"import sys
input = sys.stdin.readline 

for _ in range(int(input())):
    n = int(input()) 
    a = list(map(int, input().split())) 
    d = {} 
    for i in a:
        j = 2
        while(j * j <= i): 
            while(i % j == 0):
                i = i // j 
                if(j in d):
                    d[j] += 1 
                else:
                    {{completion}} 
            j += 1 
        if(i != 1):
            if i in d:
                d[i] += 1
            else:
                d[i] = 1 
    ans, r = 0, 0 
    for i in d:
        ans += d[i] // 2 
        r += d[i] % 2 
    ans += r // 3 
    print(ans)",d[j] = 1,"d[j] = 1 
                j += 1 
        if(i != 1):
            if i in d:
                d[i] += 1
            else:
                d[i] = 1 
    ans, r = 0, 0 
    for i in d:
        ans += d[i] // 2 
        r += d[i] % 2 
    ans += r // 3 
    print(ans)
<|/ a dscore=0 |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| a tags=python,algorithm |>
<code>
import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    a = list(map("
"import sys


def strongly_composite(a):
    factors = {}
    for n in a:
        i = 2
        while i * i <= n:
            while n % i == 0:
                if i in factors:
                    factors[i] += 1
                else:
                    {{completion}}
                n = n // i
            i += 1
        if n in factors and n != 1:
            factors[n] += 1
        elif n != 1:
            factors[n] = 1
    s = 0
    extra = 0
    for factor in factors:
        s += factors[factor]  // 2
        extra += (factors[factor] % 2)
    return s + (extra // 3)

i = 0
for line in sys.stdin:
    a = [int(x) for x in line.strip().split()]
    if i == 0:
        i += 1
    else:
        if i % 2 == 0:
            print(strongly_composite(a))
        i += 1


",factors[i] = 1,factors[i] = 1
"#author : Sushmanth

from sys import stdin
input = stdin.readline
 
inp = lambda : list(map(int,input().split()))
    
def answer():

    pf = dict()
    for i in range(n):

        j , x = 2 , a[i]
        while(j * j <= x):

            if(x % j == 0):
                count = 0
                while(x % j == 0):
                    {{completion}}

                pf[j] = pf.get(j , 0) + count

            j += 1

        if(x != 1):
            pf[x] = pf.get(x , 0) + 1


    ans , extra = 0 , 0
    for i in pf.keys():
        ans += (pf[i] // 2)
        extra += (pf[i] % 2)

    ans += (extra // 3)
    return ans
 
for T in range(int(input())):

    n = int(input())
    a = inp()

    print(answer())
","count += 1
                    x //= j","x //= j
                    count += 1"
"I = lambda: map(int,input().split())
for _ in range(int(input())):
    {{completion}}","n,m= I();b = list(I())
    b.sort()
    print(max(b[-2]-b[0],b[-1]-b[1])*(min(n,m)-1)+(b[-1]-b[0])*(n*m-min(n,m)))","N,M = I()
    A = list(map(int, input().split()))
    ans = 0
    for i in range(1,N+1):
        for j in range(1,M+1):
            ans += max(A[i-1,j-1]-A[i-1,j],A[i-1,j-1]-A[i-1,j-1]-A[i-1,j])
    print(ans)
<|/ file filename=luotianyi.py |>"
"t = int(input())
for i in range(t):
    h,w = map(int,input().split())
    if h > w: {{completion}}
    a = list(map(int,input().split()))
    a.sort()
    x = abs(a[h*w-1]-a[0])
    ans = x*h*(w-1)+(x-min(a[h*w-1]-a[h*w-2],a[1]-a[0]))*(h-1)
    print(ans)

 	 	        												  					","h,w = w,h","h,w = w,h"
"t = int(input())
for _ in range(t):
    {{completion}}
    ","n,m = map(int,input().split())
    l = list(map(int,input().split()))
    low = min(l)
    high = max(l)
    l.remove(high)
    l.remove(low)
    low2 = min(l)
    high2 = max(l)
    
    indl = min(n,m)
    indh = max(n,m)
 
 
    jin = indl*(indh-1)*(high-low)
    jin = jin + (indl-1)*(high2-low)
    
    rm = indl*(indh-1)*(high-low)
    rm = rm + (indl-1)*(high-low2)
    print(max(rm,jin))","n, m = map(int, input().split())
    b = [int(i) for i in input().split()]
    
    sum = 0
    for i in range(1, n+1):
        for j in range(1, m+1):
            sum += max(min(b[i-1:i+2], b[j-1:j+2]) - b[i-1:i+2], b[j-1:j+2]) - min(b[i-1:i+2], b[j-1:j+2])
    print(sum)
<|/ file filename=luotianyi.py |>"
"# https://codeforces.com/contest/1826

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n = int(input())
    b = list(map(int, input().split()))

    ps = [0] * n
    ps[0] = b[0] + 0
    for i in range(n):
        {{completion}}

    ss = [0] * n
    ss[n - 1] = b[n - 1] - (n - 1)
    for i in range(n - 2, -1, -1):
        ss[i] = max(ss[i + 1], b[i] - i)

    ans = 0
    for i in range(1, n - 1):
        ans = max(ans, b[i] + ps[i - 1] + ss[i + 1])
    print(ans)


for _ in range(int(input())):
    solve_case()
","ps[i] = max(ps[i - 1], b[i] + i)","j = i + 1
        while j < n and b[j] < b[i]:
            j += 1
        ps[i] = b[j] - i"
"import sys
from array import array

input = lambda: sys.stdin.buffer.readline().decode().rstrip()
inp = lambda dtype: [dtype(x) for x in input().split()]
debug = lambda *x: print(*x, file=sys.stderr)
sum_n = lambda n: (n * (n + 1)) // 2
get_bit = lambda x, i: (x >> i) & 1
ceil_ = lambda a, b: a // b if (a >= 0) ^ (b > 0) else (abs(a) + abs(b) - 1) // abs(b)
Mint, Mlong, out = 2 ** 30 - 1, 2 ** 62 - 1, []

for _ in range(1, int(input()) + 1):
    n, a = int(input()), array('i', inp(int))
    ans = a[:]

    lst = a[0]
    for i in range(1, n - 1):
        lst -= 1
        ans[i] += lst
        if a[i] >= lst: {{completion}}

    lst = a[-1]
    for i in range(n - 2, 0, -1):
        lst -= 1
        ans[i] += lst
        if a[i] >= lst: lst = a[i]

    out.append(max(ans[1:-1]))
print('\n'.join(map(str, out)))
",lst = a[i],lst = a[i]
"import sys, math
input = sys.stdin.readline

ansg = []
def solve():
    n = int(input())
    a = [*map(int,input().split())]
    left = [a[i]+i for i in range(n)]
    right = [a[i]-i for i in range(n)]
    for i in range(1,n):
        {{completion}}
    for i in range(n-2, -1,-1):
        right[i] = max(right[i+1], right[i])
    ans = 0
    for i in range(1,n-1):
        ans = max(ans, left[i-1]+a[i]+right[i+1])
    ansg.append(ans)

if __name__ == ""__main__"":
    cases = int(input())
    for _ in range(cases):
        solve()
    print('\n'.join(map(str,ansg)))","left[i] = max(left[i], left[i-1])","left[i] = max(left[i-1], left[i])"
"import sys
input = sys.stdin.buffer.readline

from random import randrange
from collections import defaultdict

MAXN = 6*10**5+1
MOD = 998244353

fac = [1] * MAXN
ifac = [0] * MAXN

for i in range(2, MAXN):
    fac[i] = fac[i-1] * i % MOD
ifac[MAXN-1] = pow(fac[MAXN-1], -1, MOD)
for i in range(MAXN-2, -1, -1):
    ifac[i] = ifac[i+1] * (i+1) % MOD

def rbs(n):
    # = n/2th catalan num
    return 0 if n&1 else fac[n] * (ifac[n//2]**2 % MOD) % MOD * pow(n//2+1, -1, MOD) % MOD

for _ in range(int(input())):
    n, k = map(int, input().split())

    events = [[] for _ in range(n+2)]

    for seg in range(k):
        l, r = map(int, input().split())
        x = randrange(1<<60)
        events[l].append(x)
        events[r+1].append(x)

    length = defaultdict(int)

    active_hash = 0
    for i in range(1, n+1):
        for x in events[i]:
            {{completion}}

        length[active_hash] += 1

    ans = 1

    for x in length.values():
        ans = (ans * rbs(x)) % MOD

    print(ans)
",active_hash ^= x,active_hash = active_hash * x + i
"import sys
input = lambda :sys.stdin.readline()[:-1]
ni = lambda :int(input())
na = lambda :list(map(int,input().split()))
yes = lambda :print(""yes"");Yes = lambda :print(""Yes"");YES = lambda : print(""YES"")
no = lambda :print(""no"");No = lambda :print(""No"");NO = lambda : print(""NO"")
#######################################################################
from random import randint
from collections import defaultdict
mod = 998244353
nn = 10**6
fact = [1] * nn
for i in range(nn - 1):
    fact[i + 1] = fact[i] * (i + 1) % mod
invfact = [1] * nn
invfact[nn - 1] = pow(fact[nn - 1], mod - 2, mod)
for i in range(nn - 1)[::-1]:
    invfact[i] = invfact[i + 1] * (i + 1) % mod
 
def binom(x, y):
    if x < 0 or y < 0 or x - y < 0:
        return 0
    return fact[x] * invfact[y] % mod * invfact[x - y] % mod

c = [binom(i * 2, i)*pow(i+1,mod-2, mod)%mod for i in range(nn//2)]

for _ in range(ni()):
    n, k = na()
    a = [na() for i in range(k)]
    if n % 2:
        print(0)
        continue
    f = [0] * (n+1)

    for i in range(k):
        v = randint(1, 1<<64-1)
        f[a[i][0]-1] ^= v
        f[a[i][1]] ^= v
    
    for i in range(n):
        f[i+1] ^= f[i]
    d = defaultdict(int)
    for i in range(n):
        d[f[i]] += 1
    #print(d)
    ans = 1
    for x in d:
        if d[x] % 2:
            {{completion}}
        ans *= c[d[x]//2]
        ans %= mod
    print(ans)","ans = 0
            break","ans *= x
        else:"
"import sys
input = sys.stdin.readline
import random
# 逆元递推公式
cmbMOD = 998244353
cmbN = 3 * 10 ** 5 + 10
cmbfact = [1, 1]  # fact[n] = (n! mod MOD)
cmbfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod MOD)
cmbinv = [0, 1]  # factinv 計算用

for i in range(2, cmbN + 1):
    cmbfact.append((cmbfact[-1] * i) % cmbMOD)
    cmbinv.append((-cmbinv[cmbMOD % i] * (cmbMOD // i)) % cmbMOD)
    cmbfactinv.append((cmbfactinv[-1] * cmbinv[-1]) % cmbMOD)


def cmb(n, r):
    if n < r:
        return 0
    else:
        return cmbfact[n] * cmbfactinv[r] * cmbfactinv[n - r] % cmbMOD


t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    f = False
    flag = [0] * n
    cnt = [0] * (n + 1)
    flag[0] = 1
    flag[-1] = -1
    for _ in range(k):
        l, r = map(int, input().split())
        l -= 1
        r -= 1
        if flag[l] == -1:
            {{completion}}
        flag[l] = 1
        rd = random.randint(1000000000, 9999999999)
        cnt[l] ^= rd
        if flag[r] == 1:
            f = True
        flag[r] = -1
        cnt[r + 1] ^= rd
    if n % 2:
        print(0)
        continue
    for i in range(1, n):
        cnt[i] ^= cnt[i - 1]
    from collections import Counter
    c = Counter(cnt[:-1])
    ans = 1
    for v in c.values():
        if v % 2:
            f = True
            break
        ans *= cmb(v, v // 2) * cmbinv[v // 2 + 1] % cmbMOD
        ans %= cmbMOD
    if f:
        print(0)
    else:
        print(ans)
",f = True,"flag[l] = 1
        if flag[r] == -1:
            flag[r] = 1
        if flag[l] == flag[r]:
            f = True
        if flag[l] == flag[r] == 1:
            f = True
        if flag[l] == flag[r] == -1:
            f = True
        if flag[l] == flag[r] == 1:
            f = True
        if flag[l] == flag[r] == -1:
            f = True
        if flag[l] == flag[r] == 1:
            f = True
        if flag[l] == flag[r] == -1:
            f = True
        if flag[l] == flag[r] == 1:
            f = True
        if flag[l] == flag[r] == -1:
            f = True
        if flag[l] == flag[r"
"def calculate_min_rooms():
    t = int(input())
    results = []

    for _ in range(t):
        n, m = map(int, input().split())
        a = list(map(int, input().split()))
        c1 = a.count(-1)
        c2 = a.count(-2)
        a = sorted(set(i for i in a if i > 0))
        ans = max(c1, c2) + len(a)
        l = 0
        r = len(a)

        for i in a:
            {{completion}}

        results.append(min(ans, m))

    return results
if __name__ == ""__main__"":
    results = calculate_min_rooms()
    for result in results:
        print(result)
","r -= 1
            ans = max(ans, 1 + min(i - 1, c1 + l) + min(m - i, c2 + r))
            l += 1","l += i
            r -= i

        if l == 0 and r == 0:
            ans = m
        elif l == 0 and r > 0:
            ans = m
        elif l > 0 and r == 0:
            ans = m
        elif l > 0 and r > 0:
            ans = min(ans, l)"
"t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    b = list(map(int, input().split()))
    b_1 = b.count(-1)
    b_2 = b.count(-2)
    a = set()
    for i in range(len(b)):
        if b[i] > 0:
            {{completion}}
    a = sorted(a)
    val = 0
    for i in range(len(a)):
        val = max(val, min(a[i] - 1 - i, b_1) + min(m - a[i] - (len(a) - i - 1), b_2) + len(a))
    print(max(val, min(m, len(a) + max(b_1, b_2))))
",a.add(b[i]),"a.add(b[i])
    a.add(m)"
"import sys 
input = sys.stdin.buffer.readline 

def process(m, A):
    n = len(A)
    seats = [0 for i in range(m+1)]
    suffix = 0
    prefix = 0
    for x in A:
        if x==-1:
            suffix+=1 
        elif x==-2:
            prefix+=1 
        else:
            seats[x] = 1 
    S = sum(seats)
    if S==0:
        answer = min(m, max(prefix, suffix))
    else:
        before = 0
        answer = min(m, max(prefix+S, suffix+S))
        for i in range(1, m+1):
            if seats[i]==1:
                {{completion}}
    sys.stdout.write(f'{answer}\n')
                
              
        
    
    return 
    
t = int(input())
for i in range(t):
    n, m = [int(x) for x in input().split()]
    A = [int(x) for x in input().split()]
    process(m, A)","before+=1 
                after = S-before 
                left_side = min(i, before+suffix)
                right_side = min(m-i, after+prefix)
                answer = max(answer, left_side+right_side)","before = i
                break
        if before==0:
            answer = min(m, max(prefix+S, suffix+S))
        else:
            before = before-1
            after = before+m
            while after<n:
                if seats[after]==1:
                    before = after
                    break
                else:
                    after+=1
            answer = min(m, max(prefix+S, suffix+S))
            if before<n:
                answer = max(answer, before)
            if after<n:
                answer = max(answer, after)
            if before<n and after<n:
                answer = max(answer, before+after)
            if before<n and after<n "
"import sys

input = sys.stdin.buffer.readline

from math import gcd

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))

    ans = 0

    for i in range(n//2):
        {{completion}}

    print(ans)
","ans = gcd(ans, a[i]-a[n-1-i])","ans = ans + a[i]%n

    for i in range(n//2, -1, -1):
        ans = ans + a[i]%n"
"from sys import stdin, stdout
from math import gcd

for _ in range(int(stdin.buffer.readline())):
    n = int(stdin.buffer.readline())
    nums = list(map(int, stdin.buffer.readline().split()))

    answer = 0
    
    for index in range(n >> 1):
        {{completion}}

    stdout.write(f""{answer}\n"")
","answer = gcd(answer, abs(nums[index] - nums[n - 1 - index]))","divisor = gcd(nums[index], n)
        
        if nums[index] % divisor == 0:
            answer = max(answer, nums[index] // divisor)"
"from math import gcd
import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    A = list(map(int, input().split()))
    ans = 0
    for i in range(n // 2):
        if A[i] == A[n - i - 1]:
            continue
        if ans == 0:
            ans = abs(A[i] - A[n - i - 1])
        else:
            {{completion}}
    print(ans)
","ans = gcd(ans, abs(A[i] - A[n - i - 1]))","ans = gcd(ans, abs(A[i] - A[n - i - 1]))"
"for _ in range(int(input())):
    ans = 0
    done = -1
    for i in range(4):
        a, b = map(int, input().split())
        if(done==-1):
            if (i == 0):
                ans = a
            elif (ans != a):
                {{completion}}
    print(ans*ans)
","ans -= a
                done = 1","done = 1
            else:
                ans = ans + b
        else:
            if (i == 0):
                ans = a
            elif (ans != a):
                done = 1
            else:
                ans = ans + b"
"
n=int(input())
l=[]
for i in range(n):
    t=[]
    for i in range(4):
        {{completion}}
    x=max(abs(t[0][0]-t[1][0]),abs(t[1][0]-t[2][0]))
    y=max(abs(t[0][1]-t[1][1]),abs(t[1][1]-t[2][1]))
    l.append(x*y)
for i in l:
    print(i)




    ","t.append(list(map(int,input().split())))","l.append(input().split())
    t[0]=[int(l[0]),int(l[1])]
    t[1]=[int(l[2]),int(l[3])]"
"
nbc=int(input())
for i in range (nbc):
    a1,a2=map(int,input().split())
    b1,b2=map(int,input().split())
    c1,c2=map(int,input().split())
    d1,d2=map(int,input().split())
    if a1==b1:
        s=((a2-b2)**2)
    elif a1==c1:
        {{completion}}
    elif a1==d1:
        s=((a2-d2)**2)
    print(s)",s=((a2-c2)**2),s=((a2-c2)**2)
"def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        b = list(map(int, input().split()))
        res = 0
        nums = [[] for _ in range(n * 2 + 1)]
        f = [0] * (n * 2 + 1)
        for i in range(n):
            nums[a[i]].append(b[i])
        for i in range(1, int((n * 2) ** 0.5 + 10 ** -6) + 1):
            for j in nums[i]:
                if i * i - j > 0:
                    res += f[i * i - j]
                f[j] += 1
            for k in range(i + 1, (n * 2) // i + 1):
                for j in nums[k]:
                    if i * k - j > 0:
                        {{completion}}
            for j in nums[i]:
                f[j] -= 1
        print(res)

solve()
",res += f[i * k - j],"res += f[i * k - j]
                    f[j] += 1"
"# https://codeforces.com/contest/1831

import sys
from math import isqrt

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n = int(input())  # 2 <= n <= 2*10**5
    a = list(map(int, input().split()))  # 1 <= a[i] <= n
    b = list(map(int, input().split()))  # 1 <= b[i] <= n

    mem = [[] for _ in range(n + 1)]
    for va, vb in zip(a, b):
        mem[va] += [vb]

    ans = 0
    cnt = [0] * (n + 1)

    for va1 in range(1, isqrt(2 * n) + 1):

        if not mem[va1]:
            continue

        for vb1 in mem[va1]:
            vb2 = va1 * va1 - vb1
            if 1 <= vb2 <= n:
                ans += cnt[vb2]
            cnt[vb1] += 1

        for va2 in range(va1 + 1, n + 1):
            if va1 * va2 > 2 * n:
                break
            for vb2 in mem[va2]:
                vb1 = va1 * va2 - vb2
                if 1 <= vb1 <= n:
                    {{completion}}

        # undo count (faster than recreating array)
        for vb1 in mem[va1]:
            cnt[vb1] -= 1

    print(ans)


for _ in range(int(input())):
    solve_case()
",ans += cnt[vb1],"ans += cnt[vb1]
                cnt[vb1] += 1"
"import sys
input = sys.stdin.readline

from math import gcd, isqrt
# import bisect #-->For bisect.bisect_left=lower_bound and bisect_right=upper_bound)

t = 1
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    D = [[] for _ in range(n+1)]
    for i in range(n):
        D[a[i]].append(b[i])

    mb = max(b)*2
    nm = isqrt(mb)
    ans = 0
    f = [0]*(n+1)
    for i in range(1, nm + 1):
        for j in D[i]:
            x = i * i - j
            if (0 < x <= n):
                ans += f[x]
            f[j] += 1
        for j in range(i+1, min(mb//i,n)+1):
            for k in D[j]:
                x = i * j - k
                if (0 < x <= n):
                    {{completion}}
        for j in D[i]:
            f[j] -= 1
    print(ans)",ans += f[x],"ans += f[x]
            f[k] += 1
    for j in range(n+1):
        f[j] -= 1
    for i in range(n+1):"
"from sys import stdin
input = stdin.readline


MD = 10**9 + 7


f = [[i & j for j in range(64)] for i in range(64)]

for _ in range(int(input())):
    n, k = map(int, input().split())
    dp = [0]*64
    for i in map(int, input().split()):
        for j in range(64):
            {{completion}}
        dp[i] += 1
    ans = 0
    for i in range(64):
        if bin(i).count(""1"") == k:
            ans += dp[i]
    print(ans % MD)","dp[f[j][i]] += dp[j]
            dp[f[j][i]] %= MD","bit = i & 1
            if bit == 1:
                dp[j] += 1
    for i in range(64):
        if dp[i] >= k:"
"import sys

R = lambda:map(int, sys.stdin.readline().rstrip().split())

def find(lst):
    ans = 0
    for i in range(len(lst)):
        if lst[i] == '1':
            ans += 1
    return ans
    
def solve():
    n, k = R()
    lst = list(R())
    arr = set(lst)
    dp = [0] * 64
    for i in range(n):
        for j in range(64):
            if dp[j] != 0:
                {{completion}}
        dp[lst[i]] += 1
    ans = 0
    for i in range(64):
        now = i
        cntOne = 0
        while now:
            cntOne += now & 1
            now >>= 1
        if cntOne == k:
            ans += dp[i]
            ans %= 1000000007
    print(ans)

t ,= R()
for _ in range(t):
    solve()
","dp[j & lst[i]] += dp[j]
                dp[j & lst[i]] %= 1000000007","dp[j] = 0
            if arr & set(range(64)) & set(range(64)):
                dp[j] += 1
    for i in range(64):
        if dp[i] != 0:
            dp[i] = 0
        if find(lst) == k:"
"import sys

input = lambda: sys.stdin.readline().rstrip()

MOD = 10 ** 9 + 7
d_cnt = [0] * 64  # d_cnt[i] -- кол-во единиц в двоичном представлении числа i

for i in range(1, 64):
    d_cnt[i] = d_cnt[i // 2] + (i & 1)


def solution(n, k, a):
    cnt = [0] * 64
    for i in a:
        cnt[i] += 1

    for j in range(6):
        bit = 1 << j
        for i in range(1 << 6):
            if i & bit == 0:
                {{completion}}

    dp = [2 ** cnt[i] for i in range(64)]

    for j in range(6):
        bit = 1 << j
        for i in range(1 << 6):
            if i & bit == 0:
                dp[i] -= dp[i | bit]

    res = sum([dp[i] for i in range(64) if d_cnt[i] == k])
    if k == 6:
        res -= 1

    return res % MOD


for _ in range(int(input())):
    n, k = [int(i) for i in input().split()]
    a = [int(i) for i in input().split()]
    print(solution(n, k, a))
",cnt[i] += cnt[i | bit],"cnt[i] -= 1

    if k == 6:
        cnt += [0]"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    q = (n+1)*n//2
    if n == 1:
        print(1)
        continue
    if q % n == n//2 and n % 2 == 0:
        d = [n, n-1]
        for i in range(1, (n-2)//2+1):
            {{completion}}
        print(' '.join(map(str, d)))
    else:
        print(-1)","d.append(i*2)
            d.append(d[-2]-2)","d.append((n-i)*(i+1)//2+i)
        d.sort()"
"n_val, a_val, x_val, y_val, m_val, k_val = map(int, input().split())
mod = 998244353
dp = [0] * k_val
pref = 0
res = 0
for idx in range(n_val):
    for i in range(k_val - 1, 0, -1):
        {{completion}}
    pref += a_val
    pref %= mod
    dp[0] += pref
    for i in range(k_val):
        dp[i] %= mod
    res ^= dp[-1] * (idx + 1)
    a_val = (a_val * x_val + y_val) % m_val
print(res)
",dp[i] += dp[i - 1],pref = (pref * a_val + dp[i]) % mod
"import sys
import collections
#import math
#import bisect
#import heapq
#import itertools
#import functools
input = sys.stdin.readline

n, a, x, y, m, k = map(int, input().split())
M = 998244353
arr = [a] * n
for i in range(1, n):
    arr[i] = (arr[i-1] * x + y) % m

def pre(ls):
    for i in range(1, n):
        {{completion}}

for _ in range(k + 1):
    pre(arr)
res = 0
for i in range(n-k+1):
    res ^= arr[i] * (i + k)
print(res)
",ls[i] = (ls[i] + ls[i-1]) % M,"arr[i] = (arr[i-1] * x + y) % m
        arr[i] ^= arr[i] * (i + k)"
"from sys import stdin
input = stdin.readline

MOD = 998244353

from math import *
from collections import Counter, deque

n,a,x,y,m,k = map(int,input().split())

B = [0] * (k+1)

res = 0
for i in range(k, n+1):
    B[0] += a
    B[0] %= MOD

    for j in range(1, k+1):
        {{completion}}

    res ^= B[-1] * i

    # new a value
    a = (a*x + y) % m
    
print(res)","B[j] += B[j-1]
        B[j] %= MOD","
        B[j] += B[j-1] * i
        B[j] %= MOD

    for j in range(k+1, n+1):
        B[j] += B[j-1] * i
        B[j] %= MOD"
"n, q = map(int, input().split())
a = list(map(int, input().split()))
a.sort()

pr = [10**9 for i in range(n + 1)]
for i in range(n):
	pr[i + 1] = min(pr[i], a[i] - i)

s = sum(a) - n * (n - 1) // 2

ans = []
for k in map(int, input().split()):
	if k < n:
		ans.append(min(pr[k] + k, a[k]))
		continue
	if k % 2 == n % 2:
		ns = s - pr[n] * n
		ans.append(pr[n] + k - (max(0, (k - n) // 2 - ns) + n - 1) // n)
	else:
		{{completion}}

print(*ans)","nmn = min(pr[n - 1], a[n - 1] - k)
		ns = (s + (n - 1) - k) - nmn * n
		ans.append(nmn + k - (max(0, (k - (n - 1)) // 2 - ns) + n - 1) // n)","ns = s - pr[n] * n
		ans.append(pr[n] + k - (max(0, (k - n) // 2 - ns) + n - 1) // n)"
"from sys import stdin
input = stdin.buffer.readline
from math import ceil

n, _ = map(int, input().split())
a = sorted(map(int, input().split()))
mins = [0]
sum_ = a[0]
for i in range(1, n):
    if a[i] - i <= a[mins[-1]] - mins[-1]:
        mins.append(i)
    else:
        mins.append(mins[-1])
    sum_ += a[i] - i
sum_ -= a[n - 1] - (n - 1)

ans = []
for k in map(int, input().split()):
    if k <= n:
        m = a[mins[k - 1]] + k - mins[k - 1]
        if k != n:
            m = min(m, a[k])
    else:
        left = ( k - n + ((k - n) % 2)) // 2
        m = a[mins[n - 1]] + k - mins[n - 1]
        if (k - n) % 2:
            {{completion}}
        left -= sum_ + k * (n - 1) - m * (n - 1)
        left -= a[n - 1] - m
        if (k - n) % 2 == 0:
            left -= k - (n - 1)
        if left > 0:
            m -= ceil(left / n)
    ans.append(m)
print(*ans)
 		 			  			 	 	 	   	 	  	 	","m = min(m, a[n - 1])","m -= k - n - left
        else:
            m -= k - n - left + k
        m -= a[n - 1] - m
        m -= k - n - left
        m -= a[mins[n - 1]] - m
        m -= k - n - left + k
        m -= a[n - 1] - m"
"import sys 
input = sys.stdin.readline 
def solve():
    n, q = map(int, input().split())
    ls = sorted( list ( map(int, input().split() ) ) )
    ks = list(map(int,input().split()))
    mi,pre,ans,sm = 10e9,[10e9],[],0
    for i in range(n):
    	mi = min(mi,ls[i]-i)
    	pre.append(mi)
    	sm+=ls[i]-i
    
    for i in ks :
    	if i < n:
    		ans.append(pre[i+1]+i)
    		continue
    	if i % 2 == n % 2:
    		hsla  = sm - pre[n] * n
    		ans.append(pre[n] + i - (max(0, (i - n) // 2 - hsla) + n - 1) // n)
    	else:
    		{{completion}}
    print(*ans)
#for i in range(int(input())):
solve()","mi = min(pre[n - 1], ls[n - 1] - i)
    		hsla = (sm + (n - 1) - i) - mi * n
    		ans.append(mi + i - (max(0, (i - (n - 1)) // 2 - hsla) + n - 1) // n)","hsla  = sm - pre[n] * n
    		ans.append(pre[n] + i - (max(0, (i - n) // 2 - hsla) + n - 1) // n)
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
"
"# -*- coding: utf-8 -*-
""""""
Created on Fri Dec  1 17:46:36 2023

@author: Lenovo
""""""

from functools import lru_cache
@lru_cache(None)

def dfs(n,m):
    if n==m:
        {{completion}}
    if n%3!=0 or n<m:
        return 0
    return dfs(n//3,m)+dfs(n//3*2,m)

t=int(input())
for i in range(t):
    n,m=map(int,input().split())
    if n==m:
        print(""YES"")
        continue
    elif n<m:
        print(""NO"")
        continue
    else:
        flag=dfs(n,m)
        print(""YES"" if flag else ""NO"")",return 1,"flag=True
    else:"
"for i in range(int(input())):
    n, k = map(int, input().split())
    if k <= n:
        x = [n]
        while(n%3 == 0):
            x.append(n//3)
            n = n//3
        if k % x[-1] == 0:
            r = len(x)
            for i in range(len(x)-1,-1,-1):
                if k%x[i] == 0:
                    {{completion}}
            t = k//x[r]
            for i in range(r+1):
                if t == 2**i:
                    print(""yes"")
                    break
            else:
                print(""no"")
        else:
            print(""no"")
    else:
        print(""no"")",r -= 1,"r = i
                    break"
"import sys

sys.setrecursionlimit(10**8)

INF = float(""inf"")

input = sys.stdin.readline
def read_str(): return input().rstrip()
def read_int(): return int(input().rstrip())
def read_lst(): return list(map(int, input().rstrip().split()))
def read_map(): return map(int, input().rstrip().split())
def ok(b): print(""YES"" if b else ""NO"")

mem = {}
def ck(n, m):
    if n == m:
        return True
    elif n % 3 != 0:
        {{completion}}
    elif (n, m) in mem:
        return mem[(n, m)]
    else:
        result = ck(n // 3, m) or ck(n // 3 * 2, m)
        mem[(n, m)] = result
        return result

def solve():
    n, m = read_map()
    ok(ck(n, m))

if __name__ == ""__main__"":
    for _ in range(read_int()):
        solve()
",return False,"ok(False)
        return False"
"n, q = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
prefix = [10**9 for i in range(n + 1)]
for i in range(n):
    prefix[i + 1] = min(prefix[i], a[i] - i)
s = sum(a) - n * (n - 1) // 2
result = []
for k in map(int, input().split()):
    if k < n:
        result.append(prefix[k + 1] + k)
        continue
    if k % 2 == n % 2:
        new_sum = s - prefix[n] * n
        result.append(prefix[n] + k - (max(0, (k - n) // 2 - new_sum) + n - 1) // n)
    else:
        {{completion}}
print(*result)
","new_min = min(prefix[n - 1], a[n - 1] - k)
        new_sum = (s + (n - 1) - k) - new_min * n
        result.append(new_min + k - (max(0, (k - (n - 1)) // 2 - new_sum) + n - 1) // n)","mid = n // 2
        new_sum = s - prefix[mid] * mid
        result.append(prefix[mid] + k - (max(0, (k - n) // 2 - new_sum) + mid - 1) // mid)
        prefix[mid] = prefix[mid] + k - (max(0, (k - n) // 2 - new_sum) + mid - 1) // mid
        prefix[n] = prefix[n] + k - (max(0, (k - n) // 2 - new_sum) + n - 1) // n
print(*result)
<|/ a dscore=0 |>"
"import os 
if os.path.exists('in.txt'):
    file = open('in.txt') 
    input =  file.readline 
from itertools import *  
from functools import * 
from heapq import *
from collections import * 
import math
inf = 1<<63
readi = lambda: int(input()) 
readis = lambda: list(map(int,input().split()))
reads = lambda: input().rstrip() 
readss = lambda: input().split()  
def solution(): 
    n , m = readis()  
    a = readis() 
    q = readis() 
    R = [] 
    if n == 1:
        for x in q:
            if x & 1 : R.append(a[0]+(x+1)//2) 
            else : {{completion}}  
        print(*R)
        return 
    a.sort() 
    s = sum(a) 
    mi0 = [inf] * (n+1)
    for i in range(n-1,-1,-1):
        mi0[i] = min(mi0[i+1],a[i])
    mi = [inf] * n  
    for i in range(n):
        a[i] -= i 
        mi[i] = min(a[i],mi[i-1])  
    for x in q:
        if x <= n : 
            res = min(mi[x-1] + x ,mi0[x])
        elif (x-n)&1:  
            d = (x-n+1)//2 
            res = min(mi[-2]+x,a[-1]+n-1,math.floor((s+(x+x-n+2)*(n-1)//2-d)/n))
        else : 
            d = (x-n) // 2 
            res = min(mi[-1]+x,math.floor((s+(x+x-n+1)*n//2-d)/n)) 
        R.append(res) 
    print(*R)
for i in range(1):
    solution() 
",R.append(a[0]-x//2),"R.append(a[0]-(x+1)//2) 
        print(*R)
        return 
    if n == 2:
        for x in q:
            if x & 1 : R.append(a[0]+(x+1)//2) 
            else : R.append(a[0]-(x+1)//2) 
        print(*R)
        return 
    if n == 3:
        for x in q:
            if x & 1 : R.append(a[0]+(x+1)//2) 
            else : R.append(a[0]-(x+1)//2) 
        print(*R)
        return 
    if n == 4:
        for x in q:
            if x & 1 : R.append(a[0]+(x+1)//2) 
            else : R.append(a[0]-(x+1)//"
"n, q = map(int, input().split())

a = list(map(int, input().split()))
a = sorted(a)
ar_k = list(map(int, input().split()))
s = ''

prev_min = [0]
id_ = 0

for i in range(1, n):
    if a[i] + n - i < a[id_] + n - id_:
        id_ = i
    prev_min.append(id_)

sum_prev = sum(a)

for x in ar_k:
    if x < n:
        ans = min(a[prev_min[x - 1]] + x - prev_min[x - 1], a[x])

    else:
        if (x - n) % 2:
            sum_ = sum_prev + (x + (x - (n - 1) + 1)) * (n - 1) // 2
            mini = a[prev_min[n - 1 - 1]] + x - prev_min[n - 1 - 1]
            mini = min(mini, a[-1])
            k = x - (n - 1)
        else:
            {{completion}}

        ans = (sum_ - k // 2) // n
        ans = min(mini, ans)
    s += str(ans) + ' '

print(s)
","sum_ = sum_prev + (x + (x - n + 1)) * n // 2
            mini = a[prev_min[n - 1]] + x - prev_min[n - 1]
            k = x - n","sum_ = sum_prev + (x + (n - 1)) * (n - 1) // 2
            mini = a[prev_min[n - 1 - 1]] + x - prev_min[n - 1 - 1]
            mini = min(mini, a[-1])
            k = x"
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    best = 0
    for i in range(n):
        for j in range(m):
            if A[i][j]:
                current = A[i][j]
                A[i][j] = 0
                q = [(i, j)]
                while q:
                    x, y = q.pop()
                    for dx, dy in (x + 1, y), (x - 1, y), (x, y - 1), (x, y + 1):
                        if 0 <= dx < n and 0 <= dy < m and A[dx][dy]:
                            {{completion}}
                best = max(best, current)
    print(best)
","current += A[dx][dy]
                            A[dx][dy] = 0
                            q.append((dx, dy))","A[dx][dy] = 0
                            q.append((dx, dy))
                A[i][j] = current"
"import sys
rln=sys.stdin.buffer.readline
rl=lambda:rln().rstrip(b'\r\n').rstrip(b'\n')
ri=lambda:int(rln())
rif=lambda:[*map(int,rln().split())]
rt=lambda:rl().decode()
rtf=lambda:rln().decode().split()
inf=float('inf')
dir4=[(-1,0),(0,1),(1,0),(0,-1)]
dir8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'
 
def solve():
  m,n=rif()
  g=[rif() for _ in range(m)]
 
  def bfs(si,sj):
    vol=g[si][sj]
    que=[(si,sj)]
    g[si][sj]=0
    for i,j in que:
      for di,dj in dir4:
        ni,nj=i+di,j+dj
        if not (0<=ni<m and 0<=nj<n):
          {{completion}}
        if g[ni][nj]==0:
          continue
        vol+=g[ni][nj]
        que.append((ni,nj))
        g[ni][nj]=0
    return vol
 
  ans=0
  for i in range(m):
    for j in range(n):
      if g[i][j]==0:
        continue
      ans=max(ans,bfs(i,j))
  print(ans)
 
t=ri()
for _ in range(t):
  solve()",continue,"continue
        if g[ni][nj]==0:
          continue
        vol+=g[ni][nj]
        que.append((ni,nj))
        g[ni][nj]=0
    return vol
 
  ans=0
  for i in range(m):
    for j in range(n):
      if g[i][j]==0:
        continue
      ans=max(ans,bfs(i,j))
  print(ans)
 
t=ri()
for _ in range(t):
  solve()
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
"
"#!/usr/bin/python3

import bisect
import collections
import heapq
import io
import math
import os
import random
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
# Mod = 1000000007
Mod = 998244353

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def euk(x, y):
    if y:
        p, q, g = euk(y, x % y)
        return (q, p - (x // y) * q, g)
    return (1, 0, x)

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

T = 1
T = int(_input())
for _ in range(T):
  n, m = map(int, _input().split())
  g = [list(map(int, _input().split())) for _ in range(n)]
  def go(r, c):
    if not g[r][c]:
      return 0
    q = [(r, c)]
    s = g[r][c]
    g[r][c] = 0
    for r, c in q:
      for r1, c1 in ((r - 1, c), (r, c + 1), (r + 1, c), (r, c - 1)):
        if 0 <= r1 < n and 0 <= c1 < m and g[r1][c1]:
          {{completion}}
    return s
  a = 0
  for r in range(n):
    for c in range(m):
      a = max(a, go(r, c))
  print(a)","s += g[r1][c1]
          g[r1][c1] = 0
          q.append((r1, c1))","q.append(euk(r1, c1))
          s = max(s, g[r1][c1])
          g[r1][c1] = 0"
"import sys
input=sys.stdin.readline
can_value=[0]*1000001
for i in range(1,1415):
    last_value_in_last_row=i*(i-1)//2
    for j in range(1,i+1):
        current_can=last_value_in_last_row+j
        if current_can>10**6:
            break
        if j==1:
            can_value[current_can]=can_value[current_can-i+1]# right
        elif j==i:
            {{completion}}
        else:
            can_value[current_can]=can_value[current_can-i+1]+can_value[current_can-i]-can_value[current_can -2*i+2]
        can_value[current_can]+=current_can**2
for _ in range(int(input())):
    print(can_value[int(input())])","can_value[current_can]=can_value[current_can - i]# left",can_value[current_can]=can_value[current_can-i+1]+can_value[current_can-i]#down
"import sys
input = lambda: sys.stdin.readline()
fprint = lambda *args: print(*args, flush=True)
ii = lambda: int(input())
si = lambda: input().strip()
mint = lambda: map(int, input().split())
lint = lambda: list(mint())
from math import sqrt, ceil
T = ii()

for _ in range(T):
    n = ii()
    layer = ceil(sqrt(n * 2 + 0.25) - 0.5)
    ans = 0
    left, right = n, n
    for l in range(layer, 0, -1):
        {{completion}}
    print(ans)","ans += (right * (right + 1) * (right * 2 + 1) - left * (left - 1) * (left * 2 - 1)) // 6
        left = (l-1) * (l-2) // 2 + max(left - l * (l-1) // 2 - 1, 1)
        right = (l-1) * (l-2) // 2 + min(right - l * (l-1) // 2, l - 1)","left, right = right, left + right
        ans += right * right
    ans += right * left"
"import sys


def input():
    return sys.stdin.readline().strip()


ans = [0] * 2000007
a = [[0] * 1500 for _ in range(1500)]
curr = 1
for i in range(1, 1500):
    for j in range(i - 1, 0, -1):
        {{completion}}
for _ in range(int(input())):
    n = int(input())
    print(ans[n])
","a[j][i - j] = (a[j - 1][i - j] + a[j][i - j - 1] - a[j - 1][i - j - 1] + curr * curr)
        ans[curr] = a[j][i - j]
        curr += 1","ans[curr] += a[j][i - 1]
    a[i][0] = 1
    a[i][i] = 1
    a[i][i - 1] = 1
    a[i - 1][i] = 1
    a[i - 1][i - 1] = 1
    a[i - 1][j] = 1
    a[i][j - 1] = 1
    a[j][i] = 1
    a[j][i - 1] = 1
    a[j][j - 1] = 1
    a[j][j - 1] = 1
    a[j][i] = 1
    a[j][i - 1] = 1
    a[j][j - 1] = 1
    a[j][i - 1] = 1
    a[j][i - 1] = 1
    a[j][i - 1] = 1
    a[j][i - 1] = 1
    a[j][i - 1] = 1
    a[j][i - 1] = 1
    a[j"
"import sys
input = sys.stdin.readline


def f(w):
    d = [0]*(2*n+1)
    a, c = 0, 0
    for i in range(n):
        if w[i] == a:
            c += 1
        else:
            {{completion}}
    d[a] = max(d[a], c)
    return d


for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    a1 = f(a)
    a2 = f(b)
    c = max(a1[i]+a2[i] for i in range(2*n+1))
    print(c)
","d[a] = max(d[a], c)
            c = 1
            a = w[i]","c -= 1
            d[a] = max(d[a], c)
            a, c = w[i], 0
    d[a] = max(d[a], c)
    return d


for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    a1 = f(a)
    a2 = f(b)
    c = max(a1[i]+a2[i] for i in range(2*n+1))
    print(c)
'''
import sys
input = sys.stdin.readline


def f(w):
    d = [0]*(2*n+1)
    a, c = 0, 0
    for i in range(n):
        if w[i] == a:
            c += 1
        else:
            "
"import sys

t=int(sys.stdin.readline())
for _ in range(t):
    n=int(sys.stdin.readline())
    a=list(map(int,sys.stdin.readline().split()))
    b=list(map(int,sys.stdin.readline().split()))

    la=[0]*(2*n+10)
    lb=[0]*(2*n+10)

    cnt=1
    for i in range(1,n):
        if a[i]==a[i-1]:
            cnt+=1
        else:
            {{completion}}
    la[a[n-1]]=max(la[a[n-1]],cnt)

    cnt=1
    for i in range(1,n):
        if b[i]==b[i-1]:
            cnt+=1
        else:
            lb[b[i-1]]=max(lb[b[i-1]],cnt)
            cnt=1
    lb[b[n-1]]=max(lb[b[n-1]],cnt)

    ans=0
    for i in range(1,2*n+1):
        ans=max(ans,la[i]+lb[i])
    print(ans)","la[a[i-1]]=max(la[a[i-1]],cnt)
            cnt=1","la[a[i-1]]=max(la[a[i-1]],cnt)
            cnt=1
    la[a[n-1]]=max(la[a[n-1]],cnt)

    cnt=1
    for i in range(1,n):
        if b[i]==b[i-1]:
            cnt+=1
        else:
            lb[b[i-1]]=max(lb[b[i-1]],cnt)
            cnt=1
    lb[b[n-1]]=max(lb[b[n-1]],cnt)

    ans=0
    for i in range(1,2*n+1):
        ans=max(ans,la[i]+lb[i])
    print(ans)
<|/ q dscore=0 |>
<| c |>
Please post "
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    cnt_r1 = [0] * (n * 2 + 1)
    cnt_r2 = [0] * (n * 2 + 1)

    prev = -1
    cnt = 0
    for x in A:
        if x == prev:
            cnt += 1
        else:
            {{completion}}
        cnt_r1[x] = max(cnt_r1[x], cnt)

    prev = -1
    cnt = 0
    for x in B:
        if x == prev:
            cnt += 1
        else:
            prev = x
            cnt = 1
        cnt_r2[x] = max(cnt_r2[x], cnt)

    print(max(x + y for x, y in zip(cnt_r1, cnt_r2)))","prev = x
            cnt = 1","prev = x
            cnt = 1"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    d = [[] for i in range(n+1)]
    for i in range(n-1):
        a, b = map(int, input().split())
        d[a].append((b, i))
        d[b].append((a, i))
    x = [(0, 0) for i in range(n+1)]
    q = [(1, -1)]
    while q:
        a, b = q.pop()
        for i, j in d[a]:
            if i != b:
                if j < x[a][0]:
                    x[i] = (j, x[a][1]+1)
                else:
                    {{completion}}
                q.append((i, a))
    print(max(i[1] for i in x)+1)
","x[i] = (j, x[a][1])","x[i] = (x[a][0], j)
            else:
                x[i] = (x[a][0], j)
            if x[i][1] > x[a][1]:"
"from sys import stdin,stdout

for _ in range(int(stdin.readline())):
    n = int(stdin.readline())
    adjList = [[] for _ in range(n)];
    for i in range(n - 1):
        u,v = map(lambda x: int(x) - 1, stdin.readline().split())
        adjList[u].append((v,i + 1))
        adjList[v].append((u,i + 1))
    visited = [-1 for _ in range(n)]; visited[0] = 1
    entry = [-1 for _ in range(n)]
    frontier = [0]; ans = 0
    while frontier:
        immd = []
        for u in frontier:
            for v,t in adjList[u]:
                if visited[v] == -1:
                    if t > entry[u]:
                        visited[v] = visited[u]
                    else:
                        {{completion}}
                    entry[v] = t
                    immd.append(v)
                    ans = max(ans,visited[v])
        frontier = immd
    stdout.write(f""{ans}\n"")
    
    
    
        
    
",visited[v] = visited[u] + 1,"entry[v] = t
                        immd.append(v)
                        ans = max(ans,visited[v])
        frontier = immd
    stdout.write(f""{ans}\n"")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import sys
from collections import deque
input = sys.stdin.readline

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for i in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append((i, v))
        G[v].append((i, u))
    
    drawn = [False] * n   
    q = deque([(-1, 0, 1)])
    ans = 0
    while q:
        e, u, d = q.popleft()
        if drawn[u]:
            continue
        
        drawn[u] = True
        ans = d
        for ne, v in G[u]:
            if drawn[v]:
                continue
            if ne > e:
                q.appendleft((ne, v, d))
            else:
                {{completion}}

    return ans

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","q.append((ne, v, d + 1))","q.appendleft((e, u, d))"
for s in[*open(0)][1:]:{{completion}},"print((len(s)-2,-1)[len({*s})<3])","
    s=s.lower()
    s=s[::-1]
    s=s[::-1]
    if s==s[::-1]:
        print(len(s))
    else:
        print(-1)
<|/ file filename=Palindrome.py ext=.py |>"
"test = int(input())

for _ in range(test):

    s = input()

    if len(set(s)) <= 1:
        {{completion}}
    
    l = len(s)

    print(l - 1)
           ","print(-1)
        continue","
        print(-1)
        
        continue"
"
for x in[*open(0)][1:]:{{completion}}","print((len(x)-2,-1)[len({*x})<3])","
    s=x.strip()
    s=s.lower()
    s=s.replace(' ','')
    s=s.replace('\n','')
    s=s.replace('\r','')
    s=s.replace('\t','')
    s=s.replace('\v','')
    s=s.replace('\f','')
    s=s.replace('\a','')
    s=s.replace('\e','')
    s=s.replace('\v','')
    s=s.replace('\a','')
    s=s.replace('\e','')
    s=s.replace('\v','')
    s=s.replace('\a','')
    s=s.replace('\"
"import sys
input = sys.stdin.readline

MOD = 1000000007

def inverse(a):
    return pow(a, -1, MOD)

def solve():
    n, m = map(int, input().split())
    a = sorted(list(map(int, input().split())))
    li = []

    ans = 0
    
    freq = {}
    
    for i in range(n):
        freq[a[i]] = freq.get(a[i], 0) + 1
        
        if freq[a[i]] == 1:
            {{completion}}

    n = len(li)

    r = 0
    c = 1
    for l in range(n):
        while r < n and li[r] - li[l] < m:
            c *= freq[li[r]]
            c %= MOD
            r += 1

        if r - l != m:
            continue

        ans += c
        ans %= MOD
    
        c *= inverse(freq[li[l]])
        c %= MOD

    print(ans % MOD)


for _ in range(int(input())):
    solve()",li.append(a[i]),"li.append(a[i])
    
    freq = {k: v for k, v in sorted(freq.items(), key=lambda item: item[1])}
    
    li = list(sorted(li))"
"from collections import Counter

import sys
input = sys.stdin.readline
MOD = 10**9 + 7

def read_array(factory):
    return [factory(num) for num in input().strip().split()]
def print_array(arr):
    print("" "".join(map(str, arr)))

def solve(a, m):
    if m == 1:
        return len(a)

    c = Counter(a)
    vals = sorted(c.keys())

    ans = 0
    prod = None
    for i in range(len(vals)-m+1):
    # i = 0
    # while i < len(vals)-m+1:
        l, r = i, i+m-1  # l, r both incl.

        if prod is None:
            prod = 1
            for k in range(l, r+1):
                {{completion}}
        else:
            # prod //= c[vals[l-1]]
            prod = (prod * pow(c[vals[l-1]], -1, MOD)) % MOD
            prod = (prod * c[vals[r]]) % MOD

        if vals[r] - vals[l] != m-1:
            # There is a gap, so we can never find it a magnificient
            # dance as long as that gap is present
            # i = r
            # prod = None
            continue
        # else:
        #     i += 1

        # prod = 1
        # for k in range(l, r+1):
        #     prod = (prod * c[vals[k]]) % MOD

        ans = (ans + prod) % MOD

    return int(ans)

if __name__ == ""__main__"":
    # Read in input:
    t = int(input())

    # Call solution:
    for _ in range(t):
        n, m = read_array(int)
        a = read_array(int)
        ans = solve(a, m)
        print(ans)

",prod = (prod * c[vals[k]]) % MOD,prod = (prod * c[vals[k]]) % MOD
"# https://codeforces.com/contest/1833

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!

MOD = 10 ** 9 + 7


def solve_case():
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    a.sort()

    b, cnt = [], []
    for i, v in enumerate(a):
        if i == 0 or v != a[i - 1]:
            b += [v]
            cnt += [1]
        else:
            cnt[-1] += 1
    n = len(b)

    ans = 0

    r = [0] * n
    for i in range(n + 1 - m):
        if b[i + m - 1] == b[i] + m - 1:
            if m >= 5 and i > 0 and r[i - 1] != 0:
                r[i] = r[i - 1] * cnt[i + m - 1] * pow(cnt[i - 1], -1, MOD) % MOD
            else:
                r[i] = 1
                for j in range(m):
                    {{completion}}
            ans = (ans + r[i]) % MOD

    print(ans)


for _ in range(int(input())):
    solve_case()
",r[i] = r[i] * cnt[i + j] % MOD,"r[i] += r[i + j + 1] * pow(cnt[i + j + 1], -1, MOD) % MOD
        else:
            r[i] = 0

    for i in range(n):
        if r[i] != 0:"
"import sys
ip=sys.stdin.readline
R=lambda:list(map(int,ip().split()))
for _ in range(int(ip())):
    n=int(ip()); a=R(); dic=[0]*(n+1); t=0; ans,res=0,0
    for i in range(1,n+1):
        if not dic[i]:
            tmp=t; j=i
            while not dic[j]: dic[j]=t; t+=1; j=a[j-1]
            if dic[j]<tmp: continue
            if t-dic[j]==2: ans+=1
            else: {{completion}}
    print(res+int(ans>0), res+ans)
",res+=1,"ans,res=ans,res+t"
"import sys

input = sys.stdin.buffer.readline

infinity = 10 ** 10

for _ in range(int(input())) :
    n = int(input())
    a = [int(x) - 1 for x in input().split()]

    mentioned = [False] * n
    for x in a :
        mentioned[x] = True

    minimum = 0
    maximum = 0
    visited = [0] * n
    once = False
    for i in range(n) :
        if mentioned[i]:
            continue
        j = i
        while visited[j] == 0 :
            visited[j] = 1
            j = a[j]

        if visited[j] == 1 :
            maximum += 1
            once = True

        j = i
        while visited[j] == 1 :
            visited[j] = 2
            j = a[j]

    for i in range(n) :
        if visited[i] == 2 :
            continue

        j = i
        while visited[j] == 0 :
            visited[j] = 2
            j = a[j]

        if a[a[j]] != j :
            minimum += 1
        else :
            {{completion}}

        maximum += 1

    print(minimum + once, maximum)
",once = True,"maximum += 1

    print(minimum + once, maximum)
    once = False
    minimum = 0
    maximum = 0
    visited = [0] * n
    once = False
    for i in range(n) :
        if mentioned[i]:
            continue
        j = i
        while visited[j] == 0 :
            visited[j] = 1
            j = a[j]

        if visited[j] == 1 :
            maximum += 1
            once = True

        j = i
        while visited[j] == 1 :
            visited[j] = 2
            j = a[j]

    for i in range(n) :
        if visited[i] == 2 :
            continue

        j = i
        while visited[j] == "
"import sys

input = sys.stdin.readline


############ ---- Input Functions ---- ############
def inp():
    return int(input())


def inlt():
    return list(map(int, input().split()))


def insr():
    s = input()
    return list(s[: len(s) - 1])


def invr():
    return map(int, input().split())


for _ in range(inp()):
    n = inp()
    a = inlt()
    dic = [0 for _ in range(n)]
    c = b = 0
    t = 0
    for i in range(n):
        if not dic[i]:
            temp = t
            j = i
            while not dic[j]:
                dic[j] = t
                t += 1
                j = a[j] - 1
            if dic[j] < temp:
                continue
            if t - dic[j] == 2:
                b += 1
            else:
                {{completion}}
    print(c + min(b, 1), c + b)
",c += 1,c += 1
"
for s in open(0).readlines()[2::2]:

    a = s.split()


    n = len(a)
    b = [0] * 101
    r = i = -1


    for x in a:
        {{completion}}


    for x in b:
        i += 1
        n -= x
        r = (r, i)[n == i]


    print(r)
",b[int(x)] += 1,"i += 1
        b[i] = x
        b[i] = b[i] * -1"
"for _ in range(int(input())):
    n = int(input())
    res = n
    a =sorted([int(i)for i in input().split()])
    if a[-1] == 0:print(0)
    else:
      for i in range(n):
            
            if a[i] == n-i:{{completion}}
            if a[i] > n-i:res = n-i;break
      if a[-1] == 0:print(0)
      else:print(res)
  
      
",res = -1;break,"res = n-i;break
            if a[i] < n-i:res = n-i;break"
"n = int(input())
for i in range(n):
    a = int(input())
    b = [0] * (a + 10)
    res = list(map(int,input().split()))
    for q in res:
        b[q] += 1


    flag = 0
    sum1 = 0
    for j in range(a):
        sum1 += b[j]
        if a - sum1 == j:
            {{completion}}
    if flag == 0:
        print(""-1"")
","print(j)
            flag = 1
            break","flag = 1
            break"
"import sys

input = sys.stdin.buffer.readline

MOD = 10**9 + 7

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    a.sort()
    b.sort()

    ans = 1
    cnt = 0
    for i in range(n-1, -1, -1):
        while a and a[-1] > b[i]:
            {{completion}}

        ans = (ans * cnt) % MOD
        cnt -= 1

    print(ans)
","cnt += 1
            a.pop()","cnt += 1
            a.pop()
        while b and b[-1] > a[i]:
            cnt += 1
            b.pop()"
"# يا لثارات الحسين
import bisect
from sys import stdin
input = lambda: stdin.readline().rstrip()
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().strip().split()))[:n]
    a.sort()
    b = list(map(int, input().strip().split()))[:n]
    b.sort()
    possible = True

    # number of elements in a bigger than the ith element in b:
    # pointers: i and j
    j = 0
    i = 0
    ans = 1

    while i < n and j < n:
        if a[j] <= b[i]:
            j += 1
        else:
            {{completion}}
        if j == n:
            possible = False
    if possible is True:
        print(ans % (1000000007))
    else:
        print(0)
","ans *= (i - j + 1)
            ans %= 1000000007
            i += 1","i += 1
            ans *= j
            j = 0"
"import sys

input = sys.stdin.readline


def int_var(): return int(input())
def int_lt(): return list(map(int, input().split()))
def str_lt(): return list(input()[:-1])
def int_tup(): return map(int, input().split())


mod = 10 ** 9 + 7
def solve(n, a, b):
    a, b = sorted(a), sorted(b) + [float(""inf"")]
    i, j, res = 0, 0, 1
    while i < n and j <= n:
        if a[i] > b[j]:
            j += 1
        else:
            {{completion}}
    return res % mod


if __name__ == '__main__':
    for t in range(int_var()):
        n = int_var()
        a, b = int_lt(), int_lt()
        print(solve(n, a, b))
","res = res * (j - i) % mod
            i += 1","i += 1
        res *= j
        j += 1
    res %= mod
    if i == n:
        res *= n
        res %= mod
    return res


def solve2(n, a, b):
    a, b = sorted(a), sorted(b) + [float(""inf"")]
    i, j, k = 0, 0, 1
    res = 0
    while i < n and j <= n:
        if a[i] > b[j]:
            j += 1
        else:
            i += 1
        res *= j
        j += 1
    res %= mod
    if i == n:
        res *= n
        res %= mod
    return res


def solve3(n, a, b):
"
"import sys
input = sys.stdin.buffer.readline
from math import lcm

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))

    exist = [0] * (2*n + 2)  # Easy upper bound of n+1th prime => 13*n
    # For 2*n+1, realize that since lcm doubles as we decrease L for fixed R
    # => at most n lcms in range [n+1, 2n+1] => one must not exist via pigeonhole

    lcms = []
    for x in a:
        for j in range(len(lcms)):
            lcms[j] = lcm(lcms[j], x)
        lcms.append(x)

        nlcms = []
        for x in lcms:
            if x < len(exist) and (not nlcms or nlcms[-1] != x):
                {{completion}}

        lcms = nlcms
        for x in lcms:
            exist[x] = 1

    for x in range(1, len(exist)):
        if not exist[x]:
            print(x)
            break
",nlcms.append(x),"nlcms.append(x)
            else:
                exist[x] = 1
                nlcms.append(x)"
"import math
from collections import defaultdict,deque
import io
import os
import sys
import heapq
input = sys.stdin.readline
# sys.setrecursionlimit(2000)
mod=1000000007
N=5000000
def lcm(x,y):
	return x*y//math.gcd(x,y)

def mex(s):
	i=1
	while i in s:
		i+=1
	return i

for _ in range(int(input())):
	# n,m=map(int,input().split())
	# q = int(input())
	n=int(input().strip())
	# la=list(map(int,input().split()))
	# s1=input().strip()
	# s2=input().strip()
	# lans=[]
	ans=set()
	lc=set()
	l=list(map(int,input().split()))
	for i in l:
		temp=set()
		if i<N:
			temp.add(i)
		for j in lc:
			x=lcm(i,j)
			if x<N:
				{{completion}}
		lc=temp
		ans|=lc
	# print(lc)
	print(mex(ans))",temp.add(x),"temp.add(x)
		if len(temp)>1:"
"import os,sys,collections,heapq,itertools,functools
if os.path.exists('in.txt'):
    file = open('in.txt') 
    input =  file.readline 
else : 
    input = sys.stdin.readline  
from functools import reduce , lru_cache
from itertools import accumulate,chain,combinations,count 
from itertools import groupby,permutations,product,zip_longest
from heapq import heapify,heappush,heappop,heapreplace,merge,nlargest,nsmallest
from collections import Counter,defaultdict,deque 
from bisect import bisect_left, bisect_right
from math import comb,floor,ceil,inf ,gcd ,sqrt ,atan2
import  operator  
from copy import copy 
readi = lambda: int(input()) 
readis = lambda: list(map(int,input().split()))
reads = lambda: input().rstrip() 
readss = lambda: input().split()     
def solution():  
    n = readi() 
    a = readis() 
    vis = [1] * n 
    inf = n * 60 
    mask = (1<<60) - 1 
    B = [] 
    for x in a: 
        A,B = B,[x] if x < inf else [] 
        for y in A:
            if B and B[-1] % y:
                z = y // gcd(x,y) * x 
                if z >= inf: {{completion}} 
                B.append(z)  
        for y in B:
            vis[y//60] |= 1<<y%60 
    for i,x in enumerate(vis):
        if x != mask:
            for j in range(60):
                if x & 1 << j == 0 : 
                    print(i*60+j)
                    return 

for i in range( readi() ):
    solution()  ",break,"
                    z = inf 
                else: 
                    z = z 
            else: 
                z = y 
            if z < mask: 
                mask = z 
                B = []"
for g in[*open(0)][2::2]:{{completion}},"print(max(map(len,g[::2].split(""1""))))","
    g = g.split()
    g = list(map(int, g))
    g.sort()
    g.reverse()
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    g.append(1)
    g.append(0)
    "
"for s in[*open(0)][2::2]:
         {{completion}}","print(max(map(len,s[::2].split('1'))))","if s.isspace():
             print len(s)
         else:
             print 0
<|/ q dscore=0 |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| a dscore=0 "
for t in[*open(0)][2::2]:{{completion}},"print(max(map(len,t[::2].split('1'))))","
    n, *a = map(int, input().split())
    ans = 0
    for i in range(n):
        if a[i] == 0:
            ans += 1
        else:
            ans = max(ans, i - ans)
    print(ans)
<|/ file dstars=1 filename=longest_blank_space.py "
"import sys
input = sys.stdin.readline
####################################################
for tc in range(1):
    n,m,k=map(int, input().split())
    a=sorted(int(i) for i in input().split())
    if n<k:print(m+1,0);continue
    x=(a[k-1]+1)//2
    y=0
    pL=0
    pR=0
    chk=0
    for i in a:
        for j in [-2,-1,0,1,2]:
            v=i+j
            if v<=chk or v>m:{{completion}}
            chk=v
            while pL<n and a[pL]<=v:pL+=1 #cut right, check to left
            while pR<n and a[pR]<v:pR+=1  #cut left, check to right
            L=0 if pL<k else (v+a[pL-k])//2+1
            R=m if pR>n-k else (v+a[pR+k-1]+1)//2-1
            if R-L+1>x:x=R-L+1;y=v
    print(x,y)
",continue,break
"import sys
 
#input functions
readint = lambda: int(sys.stdin.readline())
readints = lambda: map(int,sys.stdin.readline().split())
readar = lambda: list(map(int,sys.stdin.readline().split()))
flush = lambda: sys.stdout.flush()

def f(n,m,k,ar,x,bl,bh):
    #bl = binrank(n,ar,x,False) #lowest index
    #bh = binrank(n,ar,x,True) #highest index
    #determine min cap
    minc = 0
    if bh >= k:
        lim = ar[bh-k]
        dist = x-lim
        req = (dist//2)+1
        minc = lim+req
    #determine max cap
    maxc = m
    ll = bl+k-1
    if ll < n:
        lim = ar[ll]
        dist = lim-x
        req = (dist//2)
        maxc = x+req
        if dist % 2 == 0: maxc -= 1
    #print(x,minc,maxc)
    return maxc-minc+1
 
 
    
def solve(n,m,k,ar):
    if k > n: return m+1,0
    ans = 0
    lr = 0
    hr = ar.count(0) #O(n) should be fine here
    best = f(n,m,k,ar,0,lr,hr)
    x = max(ar[0]-2,0)
    for i in range(n):
        x = max(x,ar[i]-2)
        while x <= m:
            # c = f(n,m,k,ar,x)
            while lr != n:
                if x > ar[lr]: lr += 1
                else: {{completion}}
            while hr != n:
                if x >= ar[hr]: hr += 1
                else: break
            c = f(n,m,k,ar,x,lr,hr)
            if c > best:
                best = c
                ans = x
            if ar[i]+2 == x: break
            x += 1            
    return best,ans
    
 
n,m,k = readints()
ar = readar()
ar.sort()
a,b = solve(n,m,k,ar)
if a >= 0: print(a,b)
else: print(0,0)",break,"break
            c = f(n,m,k,ar,x,lr,hr)
            if c > best:
                best = c
                ans = x
            if ar[i]+2 == x: break
            x += 1
    return best,ans
    
 
n,m,k = readints()
ar = readar()
ar.sort()
a,b = solve(n,m,k,ar)
if a >= 0: print(a,b)
else: print(0,0)
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
"
"import sys
import bisect
N = 1000003
def fun(x):
    global ans, pos
    la, ra = 0, 0
    if x > arr[n - 1]: ra = m - x + 1
    else:
        l, r = 0, n - 1
        while l < r:
            mid = (l + r) // 2
            if arr[mid] >= x: r = mid
            else: {{completion}}
        if l + k - 1 >= n: ra = m - x + 1
        else: ra = (arr[l + k - 1] + x + 1) // 2 - 1 - x + 1
    if x < arr[0]: la = x + 1
    else:
        l, r = 0, n - 1
        while l < r:
            mid = (l + r + 1) // 2
            if arr[mid] <= x: l = mid
            else: r = mid - 1
        if l - k + 1 < 0: la = x + 1
        else: la = x - ((arr[l - k + 1] + x) // 2 + 1) + 1
    ha = la + ra - 1
    if ha > ans or (ha == ans and x < pos):
        if 0 <= x <= m: ans = ha; pos = x

n, m, k = map(int, input().split()); arr = list(map(int, input().split()))
arr.sort(); ans, pos = 0, 0
fun(0); fun(1); fun(arr[0] - 1); fun(arr[0] - 2)
for i in range(n): fun(arr[i])
for i in range(n): fun(arr[i] + 1)
for i in range(n): fun(arr[i] + 2)
for i in range(n): fun(arr[i] - 1)
for i in range(n): fun(arr[i] - 2)
print(ans, pos)",l = mid + 1,l = mid + 1
"import collections
import sys
import heapq

input = sys.stdin.readline

def inp():
    return (int(input()))
def inlt():
    return (list(map(int, input().split())))
def insr():
    s = input()
    return (list(s[:len(s) - 1]))
def invr():
    return (map(int, input().split()))


def solution():
    k = inp()
    galaxies = inlt()
    n = 2 << k
    pre_xor = [0]
    for num in galaxies:
        pre_xor.append(pre_xor[-1]^num)

    mem_high_bits = [-1] * (1 << k)
    mem_high_bits[0] = 0
    mem_low_bits = [(-1, -1) for _ in range(1 << k)]

    for i in range(1, n+1):
        if mem_high_bits[pre_xor[i] >> k] != -1:
            whole_xor = pre_xor[mem_high_bits[pre_xor[i] >> k]] ^ pre_xor[i]
            start, end = mem_low_bits[whole_xor]
            if start == -1:
                mem_low_bits[whole_xor] = (mem_high_bits[pre_xor[i] >> k], i)
            else:
                if end < mem_high_bits[pre_xor[i] >> k] + 1:
                    print(f""{start + 1} {end} {mem_high_bits[pre_xor[i] >> k] + 1} {i}"")
                else:
                    {{completion}}
                return
        mem_high_bits[pre_xor[i] >> k] = i


if __name__ == '__main__':
    t = inp()
    for i in range(t):
        solution()
","print(f""{min(start + 1, mem_high_bits[pre_xor[i] >> k] + 1)} {max(start + 1, mem_high_bits[pre_xor[i] >> k] + 1)-1} {end+1} {i}"")","print(f""{start} {end} {i}"")"
"import sys

input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))

    from math import gcd
    ans = 0
    for i in range(n):
        {{completion}}
    print(ans)","ans = gcd(ans, abs(i - a[i] + 1))","j = n - i
        k = gcd(n, j)
        if j % k == 0:
            ans = max(ans, i + j)"
"from sys import stdin, stdout
from math import gcd

t = int(stdin.buffer.readline())

answers = [''] * t

for _ in range(t):
    stdin.readline()
    answer = 0
    for num, val in enumerate(map(int, stdin.readline().split()), 1):
        {{completion}}

    answers[_] = str(answer) + '\n'

stdout.write('\n'.join(answers))
","answer = gcd(answer, abs(val - num))","answer = max(answer, num - val)
    answer = gcd((answer + 1), 2)"
"import sys
from math import gcd
input = sys.stdin.readline

if __name__ == '__main__':
    for _ in range(int(input())):
        n = int(input())
        v = [int(i) for i in input().split()]
        a = [0] * n
        for i in range(n):
            {{completion}}
        x = a[0]
        for i in a:
            x = gcd(x, i)
        print(x)
",a[i] = abs(v[i] - i - 1),a[v[i]] = i
"import sys
def input():
    return sys.stdin.readline().strip()

for _ in range(int(input())):
    n,m = map(int,input().split())
    c = [0]*(n+1)
    for i in range(m):
        {{completion}}
    ones = c.count(1)
    x = n - ones - 1
    print(x, ones//x)
","u,v = map(int,input().split())
        c[u]+=1
        c[v]+=1","u, v = map(int,input().split())
        c[u] += 1
        c[v] += 1"
"import sys
from math import gcd
input=sys.stdin.readline
for _ in range(int(input())):
    n,m=map(int,input().split())
    cnt=[0]*n
    for i in range(m):
        for j in map(int,input().split()):
            {{completion}}
    tmp = [i for i in cnt if i!=1]
    tmp.sort()
    if tmp[0]==tmp[1]:
        print(tmp[-1],tmp[0]-1)
    else:
        print(tmp[0],tmp[1]-1)",cnt[j-1]+=1,"cnt[j]+=1
    cnt.sort()"
"# https://codeforces.com/contest/1829

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n, m = map(int, input().split())
    order = [0] * n
    for _ in range(m):
        {{completion}}

    n_centre = 1
    n_leaves = sum(order[i] == 1 for i in range(n))
    n_middle = n - n_centre - n_leaves

    print(n_middle, n_leaves // n_middle)


for _ in range(int(input())):
    solve_case()
","u, v = map(lambda x: int(x) - 1, input().split())
        order[u] += 1
        order[v] += 1","u, v = map(int, input().split())
        order[u] += 1
        order[v] += 1"
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')


for _ in range(int(input())):
    n = int(input())
    g = [[] for _ in range(n+1)]

    for i in range(1, n):
        u, v = map(int, input().split())
        g[u] += [(v, i)]
        g[v] += [(u, i)]

    ans = []

    def dfs(u, p, i, ans):
        nodes = 1
        for v, j in g[u]:
            if v == p: {{completion}}
            nodes += dfs(v, u, j, ans)

        if nodes == 3:
            if i: ans += [i]
            return 0
        
        return nodes

    
    if dfs(1, 0, 0, ans):
        print(-1)
    else:
        print(len(ans))
        print(*ans)",continue,"nodes += 1
            if j == i: nodes += 1
            if j == p and v != u: nodes += 1"
"import sys
input = sys.stdin.readline


def solve():
    n = int(input())
    
    adj = [[] for vertice in range(n+1)]

    for edge in range(1, n):
        a,b = map(int, input().strip().split())
        adj[a].append((b,edge))
        adj[b].append((a, edge))
    if n%3:
        print(-1)
        return
    size = [0] * (n+1)
    cut = []
    def dfs(curr, par):
        for child, edgenum in adj[curr]:
            if child == par:
                {{completion}}
            
            dfs(child, curr)

            size[curr] += size[child]

            #if the size of the child is % 3 then we have to cut

            if size[child] % 3 == 0:
                cut.append(edgenum)
            
        size[curr] += 1

    dfs(1, -1)
    #a cut tree has to have n//3 - 1 cuts
    #print(cut)
    if len(cut) != (n//3) - 1:
        print(-1)
    else:
        print(len(cut))
        print(*cut)
                
            
            
        

for tc in range(int(input())):
    solve()",continue,"size[curr] -= 1
                cut.append(edgenum)
                continue"
"from collections import *
from heapq import *
from bisect import *
from itertools import *
from functools import *
from math import *
from string import *
import operator
import sys

input = sys.stdin.readline


def solve():
    n = int(input())
    adj = [[] for _ in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        adj[a].append((b, i + 1))
        adj[b].append((a, i + 1))

    if n % 3:
        print(-1)
        return

    def dfs(u, par):
        total = 0
        for v, i in adj[u]:
            if v == par:
                {{completion}}
                
            ct = dfs(v, u)

            if ct == -1:
                return -1

            if ct == 0:
                ans.append(i)
                continue

            total += ct

        if 1 + total < 3:
            return 1 + total

        return 0 if total + 1 == 3 else -1

    ans = []
    balance = dfs(0, -1)

    if balance != 0:
        print(-1)
    else:
        print(len(ans))
        print(*ans)


def main():
    tests = int(input())
    for _ in range(tests):
        solve()


if __name__ == ""__main__"":
    main()
",continue,"ans.append(i)
                continue"
"import sys

input = sys.stdin.readline

t = int(input())

for _ in range(t):
    n, m = map(int, input().split())
    li = [list(map(int, input().split())) for _ in range(n)]

    mi = 10**18
    min_y = 10**18
    max_x = 0
    for x,y in li:
        {{completion}}

    ans = 0
    for x,y in li:
        ans = max(ans, y - x + 1 - mi,min(max_x,y + 1) - x,y - max(x - 1,min_y))
    print(2*ans)","mi = min(mi, y - x + 1)
        min_y = min(min_y, y)
        max_x = max(max_x, x)","mi = min(mi, y - x + 1)
        min_y = min(min_y, y - x)
        max_x = max(max_x, y + 1)"
"from sys import stdin


def solve():
    n, m = map(int, stdin.readline().split())
    I = []

    for _ in range(n):
        a, b = map(int, stdin.readline().split())
        I.append((a, b))

    s1 = min(I, key=lambda x: x[1])
    s2 = min(I, key=lambda x: x[1] - x[0])
    s3 = max(I, key=lambda x: x[0])

    res = 0

    for a1, b1 in I:
        for a2, b2 in s1, s2, s3:
            size = b1 - a1 + 1

            if b2 < a1 or a2 > b1:
                intersection = 0
            elif a1 <= a2 and b2 <= b1:
                {{completion}}
            else:
                intersection = min(b2 - a1, b1 - a2) + 1

            res = max(res, size - intersection)

    print(res * 2)


for _ in range(int(stdin.readline())):
    solve()
",intersection = b2 - a2 + 1,"intersection = min(b2 - a1, b1 - a2)"
"import sys
input = sys.stdin.buffer.readline

def solve():
	n, m = map(int, input().split())
	l, r, leng = [0] * n, [0] * n, [0] * n
	for i in range(n):
		{{completion}}
	
	ans = max(0, max(leng) - min(leng))
	
	maxL = max(l)
	minR = min(r)
	
	for i in range(n):
		caseInside = leng[i]
		leftCase = maxL - l[i]
		rightCase = r[i] - minR
		ans = max(ans, min(caseInside, max(leftCase, rightCase)))	
	
	return ans*2


for _ in range(int(input())):
	print(solve())","l[i], r[i] = map(int, input().split())
		l[i] -= 1
		leng[i] = r[i] - l[i]","l[i], r[i], leng[i] = map(int, input().split())
	
	for i in range(n):
		leng[i] = max(l[i], r[i])"
for s in[*open(0)][2::2]:{{completion}},"print(len({*zip(s,s[1:-1])}))","
    melodies+=s
print(melodies)

<|/ file ext=.py source=github |>"
"for x in [*open(0)][2::2]:
    {{completion}}","print(len({*zip(x[:-2],x[1:-1])}))","melody = [x.strip() for x in input().split()]
    melody = ''.join(melody)
    melody = [melody[i:i+2] for i in range(0, len(melody)-2, 2)]
    melody = ''.join(melody)
    melody = [melody[i:i+2] for i in range(0, len(melody)-2, 2)]
    melody = ''.join(melody)
    melody = [melody[i:i+2] for i in range(0, len(melody)-2, 2)]
    melody = ''.join(melody)
    melody = [melody[i:i+2] for i in range(0, len(melody)-2, 2)]
"
for r in[*open(0)][2::2]:{{completion}},"print(len({*zip(r,r[1:-1])}))","
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r::2]
    melody = [*open(0)][r"
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    m1, m2, m3 = 1e19, 1e19, 1e19
    for i in range(n):
        n, a = input().split()
        if a == ""01"":
            {{completion}}
        if a == ""10"":
            m2 = min(m2, int(n))
        if a == ""11"":
            m3 = min(m3, int(n))
    if min(m1 + m2, m3) == 1e19:
        print(-1)
        continue
    print(min(m1 + m2, m3))","m1 = min(m1, int(n))","d1 = int(n)
        if a == ""10"":
            m2 = min(m2, int(n))
        if a == ""11"":
            m3 = min(m3, int(n))
    if min(m1 + m2, m3) == 1e19:
        print(-1)
        continue
    print(min(m1 + m2, m3))
<|/ q dscore=0 |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
"
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    mapper = {}
    mapper[""00""] = 1e9
    mapper[""01""] = 1e9
    mapper[""10""] = 1e9
    mapper[""11""] = 1e9
    for _ in range(n):
        {{completion}}

    ans = min(mapper[""11""], mapper[""10""] + mapper[""01""])
    print(-1 if ans==1e9 else ans)

t = int(input())
for _ in range(t):
    solve()     
","time, skills = input().split();
        time = int(time)
        mapper[skills] = min(mapper[skills],time)","book, minutes = input().split()
        mapper[book] = int(minutes)"
"from sys import stdin
import math

def main():
    t = int(stdin.readline().strip())
    for _ in range(t):
        n = int(stdin.readline().strip())
        skillOne, skillTwo, final = math.inf, math.inf, math.inf
        for _ in range(n):
            m, s = stdin.readline().strip().split()
            if s == '11':
                if int(m) < final:
                    final = int(m)
            else:
                if s[0] == '1' and skillOne > int(m):
                    {{completion}}
                if s[1] == '1' and skillTwo > int(m):
                    skillTwo = int(m)
        if final == math.inf and (skillOne == math.inf or skillTwo == math.inf):
            print(-1)
        elif final < skillOne + skillTwo:
            print(final)
        else:
            print(skillOne + skillTwo)
        
main()",skillOne = int(m),"skillOne = int(m)
                elif s[0] == '2' and skillTwo > int(m):
                    skillTwo = int(m)
                elif s[0] == '1' and skillOne > int(m):
                    skillOne = int(m)
                elif s[0] == '2' and skillTwo > int(m):
                    skillTwo = int(m)
                elif s[0] == '1' and skillOne > int(m):
                    skillOne = int(m)
                elif s[0] == '2' and skillTwo > int(m):
                    skillTwo = int(m)
                elif s[0] == '1' and skillOne > int(m):
                    skillOne = int(m)
                elif s[0] == '2' and skillTwo > int(m):
                    skillTwo = int(m)
                elif s[0] == '1"
"import sys
input = sys.stdin.buffer.readline

MOD = 998244353


k = int(input())
n = 1 << k

a = list(map(int, input().split()))

ans = 1

while ans and n != 1:
    a_new = []
    placed = 0

    for i in range(0, n, 2):
        if a[i] > a[i + 1]:
            a[i], a[i + 1] = a[i + 1], a[i]

        if a[i+1] == -1:
            ans = ans * 2 % MOD
            a_new.append(-1)
            placed += 1
        elif a[i] == -1:
            if a[i+1] <= n//2:
                placed += 1
                a_new.append(a[i+1])
            else:
                {{completion}}
        else:
            if a[i + 1] > n//2 >= a[i]:
                a_new.append(a[i])
            else:
                ans = 0

    for i in range(2, placed+1):
        ans = ans * i % MOD

    a = a_new
    n >>= 1

print(ans)
",a_new.append(-1),"ans = ans * 2 % MOD
                a_new.append(-1)
                placed += 1"
"import sys

def fact(n):
    ret=1
    for i in range(n):
        ret=(ret*(i+1))%mod
    return ret

def calc(a,k):
    global ans
    next=[]
    ng=pow(2,k-1)
    ok=pow(2,k)
    cho=ng
    cnt=0
    for i in range(0,ok,2):
        if ng<a[i]<=ok and ng<a[i+1]<=ok:
            print(0)
            sys.exit()
        if a[i]!=-1 and a[i+1]!=-1:
            if ng<a[i]<=ok:
                cho-=1
                next.append(a[i+1])
            elif ng<a[i+1]<=ok:
                cho-=1
                next.append(a[i])
            else:
                print(0)
                sys.exit()
        elif a[i]==-1 and a[i+1]==-1:
            cnt+=1
            next.append(-1)
        else:
            if ng<a[i]<=ok:
                cho-=1
                next.append(a[i+1])
            elif ng<a[i+1]<=ok:
                {{completion}}
            elif a[i]==-1:
                next.append(a[i+1])
            elif a[i+1]==-1:
                next.append(a[i])
    ans=(ans*fact(cho)*pow(2,cnt,mod))%mod
    if len(next)!=1:
        calc(next,k-1)

ans=1
mod=998244353
k=int(input())
a=list(map(int,input().split()))
if k==0:
    print(1)
    sys.exit()
calc(a,k)
print(ans)","cho-=1
                next.append(a[i])","cho-=1
                next.append(a[i])
            else:
                print(0)
                sys.exit()
    if len(next)!=1:
        calc(next,k-1)
    else:
        cho+=1
        next.append(-1)
    ans=cho
    cho=ng
    cnt=0
    for i in range(0,ok,2):
        if ng<a[i]<=ok and ng<a[i+1]<=ok:
            print(0)
            sys.exit()
        if a[i]!=-1 and a[i+1]!=-1:
            if ng<a[i]<=ok:
                cho-=1
                next.append(a[i+1])
            elif ng<a[i+1]<=ok:
                cho-=1
                next.append("
"import sys
from heapq import heappushpop, heappush
from itertools import accumulate


# def input():
#     return sys.stdin.readline()


for _ in range(int(input())):
    n, k = map(int, input().split())
    a = [int(x) for x in input().split()]
    s = list(accumulate(sorted(a), initial=0))
    l, r = s[(k+1)//2]-1, s[k]-s[k//2]+1
    while l < r:
        m = (l+r) >> 1
        left = [0]*(n+1)
        hp = []
        t = 0
        for i in range(n):
            val = a[i]
            if t + val <= m:
                heappush(hp, -val)
                t += val
            elif len(hp) and -hp[0] > val:
                {{completion}}
            left[i+1] = len(hp)
        hp = []
        t = 0
        for i in range(n-1, -1, -1):
            val = a[i]
            if t + val <= m:
                heappush(hp, -val)
                t += val
            elif len(hp) and -hp[0] > val:
                t += hp[0]
                t += val
                heappushpop(hp, -val)
            if len(hp) + left[i] >= k:
                r = m
                break
        else:
            l = m + 1
    print(r)
","t += hp[0]
                t += val
                heappushpop(hp, -val)","t += hp[0]
                t += val
                heappushpop(hp, -val)
            if len(hp) + left[i] >= k:
                r = m
                break
        else:
            l = m + 1
    print(r)
""""""
import sys
from heapq import heappushpop, heappush
from itertools import accumulate


def input():
    return sys.stdin.readline()


for _ in range(int(input())):
    n, k = map(int, input().split())
    a = [int(x) for x in input().split()]
    s = list(accumulate(sorted(a), initial=0))
    l, r = s[(k+1)//2]-1, s[k]-s[k//2]+1
    while l < r:"
"from bisect import bisect_left, bisect_right
from collections import Counter, deque
from functools import lru_cache
from math import factorial, comb, sqrt, gcd, lcm, log2
from copy import deepcopy
import heapq

from sys import stdin, stdout


input = stdin.readline


def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        L = list(map(int, input().split()))
        sorted_L = sorted(L)
        pre = [0]
        for i in range(n):
            pre.append(pre[-1] + sorted_L[i])
        left = pre[(k + 1) // 2]
        right = pre[k] - pre[k // 2]
        while left < right:
            middle = (left + right) // 2

            left_L = [0] * (n + 1)
            stack = []
            sum_value = 0
            for i in range(n):
                num = L[i]
                if sum_value + num <= middle:
                    heapq.heappush(stack, -num)
                    sum_value += num
                elif len(stack) > 0 and -num > stack[0]:
                    {{completion}}

                left_L[i + 1] = len(stack)
            # print(middle, left_L)
            # right = [0] * n
            stack = []
            stack_len = 0
            sum_value = 0
            for i in range(n - 1, -1, -1):
                num = L[i]
                if sum_value + num <= middle:
                    heapq.heappush(stack, -num)
                    sum_value += num
                elif len(stack) > 0 and -num > stack[0]:
                    sum_value += num + stack[0]
                    heapq.heapreplace(stack, -num)
                # print(middle, i, stack_len, stack)
                if len(stack) + left_L[i] >= k:
                    right = middle
                    break

            else:
                left = middle + 1

        print(left)


if __name__ == ""__main__"":
    main()
","sum_value += num + stack[0]
                    heapq.heapreplace(stack, -num)","sum_value += num + stack[0]
                    heapq.heapreplace(stack, -num)
                left_L[i + 1] = left_L[i] + stack_len + stack[-1]"
"import random
import sys
from math import gcd, lcm, sqrt, isqrt, perm
from collections import Counter, defaultdict, deque
from functools import lru_cache, reduce, cmp_to_key
from itertools import accumulate, combinations, permutations
from heapq import nsmallest, nlargest, heappushpop, heapify, heappop, heappush
from copy import deepcopy
from bisect import bisect_left, bisect_right
from string import ascii_lowercase, ascii_uppercase
inf = float('inf')
MOD = 10**9+7
input = lambda: sys.stdin.readline().strip()
I = lambda: input()
II = lambda: int(input())
MII = lambda: map(int, input().split())
LI = lambda: list(input().split())
LII = lambda: list(map(int, input().split()))
GMI = lambda: map(lambda x: int(x) - 1, input().split())
LGMI = lambda: list(map(lambda x: int(x) - 1, input().split()))

def solve():
    n, k = MII()
    a = LII()
    def check(v):
        pre = [0] * (n+1)
        cur, h = 0, []
        for i in range(n):
            x = a[i]
            if cur+x <= v:
                heappush(h, -x)
                cur += x
            elif h and -h[0] > x:
                {{completion}}
            pre[i+1] = len(h)

        cur, h = 0, []
        for i in range(n-1, -1, -1):
            x = a[i]
            if cur+x <= v:
                heappush(h, -x)
                cur += x
            elif h and -h[0] > x:
                cur -= -h[0]
                cur += x
                heappushpop(h, -x)
            if len(h)+pre[i] >= k:
                return True
        return False

    s = list(accumulate(sorted(a), initial=0))
    left, right = s[(k+1)//2]-1, s[k]-s[k//2]+1
    while left+1 != right:
        mid = (left+right)//2
        if check(mid):
            right = mid
        else:
            left = mid
    print(right)

    return

T = II()
for _ in range(T):
    solve()
","cur -= -h[0]
                cur += x
                heappushpop(h, -x)","cur -= -h[0]
                cur += x
                heappushpop(h, -x)
            if len(h)+pre[i] >= k:
                return True
        return False

    s = list(accumulate(sorted(a), initial=0))
    left, right = s[(k+1)//2]-1, s[k]-s[k//2]+1
    while left+1 != right:
        mid = (left+right)//2
        if check(mid):
            right = mid
        else:
            left = mid
    print(right)

    return

def solve1():
    n, k = MII()
    a = LII()
    def check(v):
        pre = [0] * (n+1)
        for i in range(n):
            x = a[i]
"
"import sys
input = sys.stdin.readline

def solve():
    A, B, C, k = map(int, input().split())
    
    al = 10 ** (A - 1)
    ah = 10 ** A - 1
    bl = 10 ** (B - 1)
    bh = 10 ** B - 1
    cl = 10 ** (C - 1)
    ch = 10 ** C - 1
    
    if ch < al + bl or cl > ah + bh:
        return -1

    for a in range(al, ah + 1):
        low = max(cl - a, bl)
        high = min(ch - a, bh)
        x = max(0, high - low + 1)
        if k - x > 0:
            k -= x
        else:
            {{completion}}
    
    return -1


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","b = low + k - 1
            return f""{a} + {b} = {a + b}""","k += 1
            break
    
    return str(k) + "" + "" + str(cl - k) + "" + "" + str(ch - k) + "" = "" + str(al)"
"import sys

R = sys.stdin.readline
inf = int(1e18)
mod = int(1e9) + 7


def get_int() -> int:
    return int(R())


def get_str() -> str:
    return R().strip()


def get_int_list() -> list:
    return list(map(int, R().strip().split(' ')))


def init_matrix(n_, m_, value_=0) -> list:
    return [[value_] * m_ for _ in range(n_)]


def solve():
    a, b, c, k = get_int_list()

    va, var = 10 ** (a - 1), 10 ** a - 1
    vb, vbr = 10 ** (b - 1), 10 ** b - 1
    vc, vcr = 10 ** (c - 1), 10 ** c - 1

    for i in range(va, var + 1):
        le = max(vc - i, vb)
        ri = min(vcr - i, vbr)

        cnt = max(ri - le + 1, 0)

        if k > cnt:
            k -= cnt
        else:
            {{completion}}

    print(-1)


for _ in range(get_int()):
    solve()
","print(f'{i} + {le + k - 1} = {i + le + k - 1}')
            return","ans = str(i + 1) + str(b + 1) + str(c + 1)
            print(ans)
            return"
"import sys 
input = sys.stdin.buffer.readline 



def process(A, B, C, K):
    L = []
    min_c = 10**(C-1)
    max_c = 10**C-1 
    min_b = 10**(B-1)
    max_b = 10**B-1 
    K0 = 0 
    for a in range(10**(A-1), 10**A):
        l, r = max(min_c-a, min_b), min(max_c-a, max_b)
        if l <= r:
            if K0+(r-l+1) >= K:
                b = K-K0+l-1 
                c = a+b 
                sys.stdout.write(f'{a} + {b} = {c}\n')
                return 
            else:
                {{completion}}
    sys.stdout.write('-1\n')
    return
        
        
        
        
    
    
    
T = int(input())
for i in range(T):
    A, B, C, K = [int(x) for x in input().split()]
    process(A, B, C, K)",K0+=(r-l+1),"K0 += (r-l+1)
                L.append(a)
                
    if len(L) < K:
        sys.stdout.write('-1\n')
        return
    
    L.sort()
    sys.stdout.write(str(L[K])+'\n')
    return
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys

input = sys.stdin.buffer.readline

MOD = 10**9+7

for _ in range(int(input())):
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    ans = 0

    # COMPLEMENTARY counting!
    m_choose_len_sub = 1
    for len_sub in range(n):
        {{completion}}

    ans = (pow(k, m, MOD) - ans) % MOD

    print(ans)


","ans = (ans + m_choose_len_sub * pow(k-1, m-len_sub, MOD)) % MOD

        m_choose_len_sub = m_choose_len_sub * (m-len_sub) % MOD
        m_choose_len_sub = m_choose_len_sub * pow(len_sub+1, -1, MOD) % MOD","len_sub = len_sub + 1
        m_choose_len_sub = m_choose_len_sub * (len_sub + 1)

    for j in range(1, k + 1):
        ans = ans + (m_choose_len_sub - 1) * (j - 1)
        ans = ans % MOD

    print(ans)


for _ in range(int(input())):
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    ans = 0

    m_choose_len_sub = 1
    for len_sub in range(n):
        len_sub = len_sub + 1
        m_choose_len_sub = m_choose_len_sub * (len_sub + 1)

    for j in range(1, k"
"import sys

# sys.setrecursionlimit(10000)


def input_general():
    return sys.stdin.readline().rstrip('\r\n')


def input_num():
    return int(sys.stdin.readline().rstrip(""\r\n""))


def input_multi(x=int):
    return map(x, sys.stdin.readline().rstrip(""\r\n"").split())


def input_list(x=int):
    return list(input_multi(x))


def power(p, x, e):
    base = x
    answer = 1
    while e:
        if e & 1:
            {{completion}}

        base = (base * base) % p
        e >>= 1

    return answer


def inv(p, x):
    return power(p, x, p - 2)


def main():
    n, m, k = input_multi()
    P = 1000000007
    nums = input_list()

    answer = power(P, k, m) - power(P, (k - 1), m)
    # print(answer)
    fact = 1
    for i in range(1, n):
        fact = (fact * (m + 1 - i) * inv(P, i)) % P
        answer = (answer - fact * power(P, (k - 1), (m - i))) % P
        # print(answer, fact)

    print(answer % P)


if __name__ == ""__main__"":
    cases = input_num()

    for _ in range(cases):
        main()
",answer = (answer * base) % p,"answer *= base
        e >>= 1"
"import sys
input = sys.stdin.readline
from collections import deque
from bisect import bisect_left, bisect_right
from heapq import *
#from math import *
mod = 1000000007

for _ in range(int(input())):
    
    n, m, k = map(int, input().split())
    arr = list(map(int, input().split()))
    if k == 1:
        {{completion}}
    ans = pow(k, m, mod) 
    c = pow(k-1, m, mod)
    r = m
    u = 1
    for i in range(1, n+1):
        ans -= c
        ans %= mod
        c *= r
        c %= mod
        c *= pow(k-1, -1, mod)
        c %= mod
        c *= pow(u, -1, mod)
        c %= mod
        r -= 1
        u += 1
    print(ans)
    
","print(1)
        continue","ans = 1
        for i in range(1, n+1):
            ans *= i
            ans %= mod
        print(ans)
        continue
    
    arr = deque(arr)
    arr.rotate(-1)
    
    ans = 1
    
    for i in range(1, n+1):
        ans *= i
        ans %= mod
    
    ans *= k
    ans %= mod
    
    ans *= pow(k-1, m, mod)
    ans %= mod
    
    ans *= pow(k-1, n, mod)
    ans %= mod
    
    ans *= pow(k-1, n, mod)"
"from sys import stdin
from math import ceil
def inp(): return stdin.readline().rstrip(""\r\n"")


for _ in range(int(inp())):
    n = int(inp())
    l = [int(x) for x in inp().split()]
    flag = 0
    c = 1
    p = l[0]
    for i in l:
        if i < p:
            if flag != -1:
                c += 1
                flag = -1
        elif i > p:
            if flag != 1:
                {{completion}}
        p = i
        #print(i,c,p,flag)
    print(c)






","c += 1
                flag = 1","c += 1
                flag = 1
        else:
            flag = 0
            c += 1"
"import sys

input = sys.stdin.buffer.readline

for _ in range(int(input())) :
    n = int(input())
    a = [int(x) for x in input().split()]

    b = [a[0]]
    for i in range(1, n) :
        if b[-1] == a[i] :
            {{completion}}

        if len(b) == 1 :
            b.append(a[i])
            continue

        if a[i] >= b[-1] >= b[-2] or a[i] <= b[-1] <= b[-2] :
            b.pop()

        b.append(a[i])
    
    print(len(b))
",continue,"b.append(a[i])
            continue"
"import sys
lines = list(map(str.strip, sys.stdin.readlines()))

for line in lines[2::2]:
    nums = list(map(int, line.split("" "")))
    if len(nums) == 1:
        print(1)
        continue
    contrast = sum([abs(nums[i] - nums[i-1]) for i in range(1, len(nums))])
    if contrast == 0:
        print(1)
        continue
    start = 1
    while start < len(nums) and nums[start] == nums[0]:
        start += 1
    increasing = nums[start] >= nums[0]
    # print(nums, start)
    result = 2
    for i in range(start, len(nums)):
        if increasing:
            if nums[i] < nums[i-1]:
                increasing = False
                result += 1
        else:
            if nums[i] > nums[i-1]:
                {{completion}}
    print(result)
    ","increasing = True
                result += 1","increasing = True
                result += 1
    # print(nums, start, increasing, result)"
"from heapq import heappop, heappush
from sys import stdin


def solve(n, s, queries):
    s = list(map(lambda x : int(x == ""(""), s))
    minheap, maxheap = [], []
    for i in range(n):
        if i % 2 == s[i]:
            heappush(minheap, i)
            heappush(maxheap, -i)
    if n % 2:
        for _ in range(len(queries)): print(""NO"")
        return
    for q in queries:
        q -= 1
        s[q] ^= 1
        if q % 2 == s[q]:
            heappush(minheap, q)
            heappush(maxheap, -q)
        while minheap and s[minheap[0]] != minheap[0] % 2:
            heappop(minheap)
        while maxheap and s[-maxheap[0]] != -maxheap[0] % 2:
            heappop(maxheap)
        if minheap and minheap[0] % 2 == 0 or maxheap and -maxheap[0] % 2 == 1:
            print(""NO"")
        else:
            {{completion}}
        
        
   
n, q = map(int, input().split())
s = stdin.readline()[:-1]
queries = [int(stdin.readline()[:-1]) for _ in range(q)]
solve(n, s, queries)","print(""YES"")","s[minheap[0]] ^= 1
            s[-maxheap[0]] ^= 1
            print(""YES"")"
"import sys
input = lambda:sys.stdin.readline().rstrip('\r\n')
for _ in range(int(input())):
    n,k = map(int,input().split())
    nlist = list(map(int,input().split()))
    nlist.sort()
    ans = 0
    pre = [0]
    for i in range(n):
        {{completion}}
    for i in range(k+1):
        ans = max(ans,pre[n-k+i]-pre[2*i])
    print(ans)",pre.append(pre[-1]+nlist[i]),"ans = max(ans,pre[i]-pre[i-1])
        pre.append(pre[i]+nlist[i])
    pre.sort()
    ans = 0"
"import math
import sys
from bisect import bisect_right

input = sys.stdin.readline

q = int(input())
for _ in range(q):
    _, k = [int(x) for x in input().strip().split()]
    nums = sorted([int(x) for x in input().strip().split()])
    i = 2 * k
    j = len(nums) - 1
    ans = s = sum(nums[i:])
    while i - 2 >= 0:
        {{completion}}
    print(ans)","s -= nums[j]
        j -= 1
        s += nums[i - 2] + nums[i - 1]
        i -= 2
        ans = max(ans, s)","ans += nums[i - 2]
        i -= 2
    while j >= 0:
        ans += nums[j]
        j -= 1
    ans = ans % 1000000007"
"from collections import defaultdict, deque
from sys import stdin

input = stdin.readline

def get():
    return [int(i) for i in input().split(' ')]
 
t = int(input()) 

for _ in range(t):
    n, k = get() 
    nums = get() 
    nums.sort() 

    res = 0

    psum = [0] * (n + 1)
    for i in range(n):
        {{completion}}
    for i in range(k + 1):
        cur = psum[n - (k - i)] - psum[2 * i]
        res = max(cur, res)
    
    print(res)

    

    



    ",psum[i + 1] = psum[i] + nums[i],"j = nums[i]
        psum[j + 1] = psum[j] + 1
    "
"for _ in range(int(input())):
	n = int(input())
	a = list(map(int, input().split()))
	
	if n == 1:
		{{completion}}
	
	i = a.index(n - 1 if a[0] == n else n)
	if i == n - 1:
		i = n
		
	j = i - 2
	while j > 0 and a[j] > a[0]:
		j -= 1
	print(*(a[i:] + a[j+1:i][::-1] + a[:j+1]))","print(*a)
		continue","print(*a)
		
	for i in range(1, n):
		j = n - 1
		while j > 0 and a[j] > a[0]:
			j -= 1
		a[i], a[j] = a[j], a[i]
	
	i = a.index(n - 1 if a[0] == n else n)
	if i == n - 1:
		i = n
		
	j = i - 2
	while j > 0 and a[j] > a[0]:
		j -= 1
	print(*(a[i:] + a[j+1:i][::-1] + a[:j+1]))
<|/ file ext=.py |>"
"def solve():
    n = int(input())
    a = [int(i) for i in input().split()]
    if n == 1: print(a[0]); return;
    r = a.index(n)
    if r == 0:
        r = a.index(n - 1)
    if r != n-1:
        r -= 1
    res = a[r + 1:] + [a[r]]
    i = r - 1
    while i >= 0:
        if a[i] > a[0]:
            res.append(a[i])
            i -= 1
        else:
            {{completion}}
    print(*res)


for _ in range(int(input())):
    solve()","res.extend(a[:i+1])
            break","i -= 1
    res.insert(0, a[0])"
"# -*- coding: utf-8 -*-
# @Author: chatting
# @Date:   2023-05-20 20:03:35
# @Last Modified by:   10592
# @Last Modified time: 2023-05-20 20:55:44



t = int(input())
while t:
	
	t -= 1
	n = int(input())
	a = list(map(int, input().split()))
	if n == 1:
		{{completion}}
	i = a.index(n - 1 if a[0] == n else n)
	if i == n - 1:
		i = n
	j = i - 2
	while j > 0 and a[j] > a[0]:
		j -= 1
	print(*(a[i:] + a[j+1:i][::-1] + a[:j+1]))

","print(*a)
		continue","print(*a)
		break
	"
"import sys
ci = sys.stdin.readline
def sol(n, c):
    C = [0] + c + [n+1]
    dp = [0] + [-1]*(n+1)
    for i in range(1, n+2):
        if C[i] < C[i-1]:
            break
        dp[i] = 0
    res = [0]*n
    for k in range(n):
        newDp = [0] + [n+1]*(n+1)
        for i in range(1, n+2):
            if C[i] > C[i-1]:
                newDp[i] = newDp[i-1]
            for l in range(i-1):
                if C[i] < C[l] or dp[l] == -1:
                    {{completion}}
                newDp[i] = min(newDp[i], dp[l] + i - l - 1)
        res[k] = newDp[-1]
        dp = newDp
    return res
t = int(ci())
for _ in range(t):
    n = int(ci())
    c = list(map(int, ci().split()))
    print(*sol(n, c))",continue,"newDp[i] = min(newDp[i], dp[l] + i - l - 1)
                else:"
"import sys
input=sys.stdin.readline

t=int(input())
for _ in range(t):
    n=int(input())
    a=[*map(int,input().split())]
    dp=[[0]*n for _ in range(n+1)]
    dp[0][0]=1
    for j in range(n+1):
        if j==0:
            for i in range(n):
                if i>0:
                    if a[i]>a[i-1]: dp[j][i]=dp[j][i-1]+1
                    else: {{completion}}
        else:
            for i in range(1,n):
                maxi=0
                if a[i-1]<a[i]:maxi=dp[j][i-1]
                for k in range(i-1):
                    if a[k]<a[i]: maxi=max(maxi,dp[j-1][k])
                dp[j][i]=maxi+1
            if i==n-1: dp[j][i]=max(dp[j-1][i],dp[j][i])
##    print(*dp,sep=""\n"")
    ans=[0] * (n+1)
    for j in range(n+1):
        maxi=max(dp[j])
        if dp[j][-1]==maxi:
            ans[j]=max(ans[j],maxi)
            if j>0: ans[j]=max(ans[j-1],ans[j])
        else:
            ans[j]=max(ans[j],dp[j][-1])
            if j>0: ans[j]=max(ans[j-1],ans[j])
            if j<n:
                ans[j+1]=max(ans[j],ans[j+1],maxi)
##        print(f""{j}:{ans}"")
    print(*[n-i for i in ans[1:]])",break,"dp[j][i]=dp[j-1][i-1]+1
                else:
                    if a[i]>a[n-1]: dp[j][i]=dp[j][i-1]+1
                    else: dp[j][i]=dp[j-1][i-1]+1"
"import math
import sys

try:
    sys.stdin = open(""input.txt"", ""r"")
except FileNotFoundError:
    pass

input = sys.stdin.readline

if __name__ == ""__main__"":
    t = int(input().strip())
    for _ in range(t):
        {{completion}}
","n, k, g = map(int, input().split())
        max_saving_per_person = math.ceil(g / 2) - 1
        total_savings = n * max_saving_per_person
        result = min(total_savings // g, k) * g
        print(result)","n, k, g = map(int, input().strip().split())
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
"
"from sys import stdin, stdout
    
for _ in range(int(stdin.readline())):
    n,k,g=map(int,stdin.readline().split())
    if k*g-(((g+1)//2)-1)*n<0:
        {{completion}}
    stdout.write(str(k*g-((((k*g-(((g+1)//2)-1)*n+g-1)//g)*g))) + '\n')","stdout.write(str(k*g) + '\n')
        continue","stdout.write('-1\n')
        continue
    if k*g-(((g+1)//2)-1)*n>0:
        stdout.write('-1\n')
        continue
    if k*g-(((g+1)//2)-1)*n==0:
        stdout.write('-1\n')
        continue
    stdout.write(' '.join([str(k*g-((((k*g-(((g+1)//2)-1)*n+g-1)//g)*g))),str(k*g-((((k*g-(((g+1)//2)-1)*n+g-1)//g)*g))%g)]) + '\n')
    stdout.write(' '.join([str(k*g-((((k*g"
"import sys

def calculate_result(n, k, g):
    if k * g - (((g + 1) // 2) - 1) * n < 0:
        return k * g
    else:
        {{completion}}


def main():
    test_cases = int(sys.stdin.readline())
    results = []

    for _ in range(test_cases):
        n, k, g = map(int, sys.stdin.readline().split())
        result = calculate_result(n, k, g)
        results.append(result)

    for result in results:
        print(result)


if __name__ == '__main__':
    main()
",return k * g - ((((k * g - (((g + 1) // 2) - 1) * n + g - 1) // g) * g)),"rounding_value = ((g + 1) // 2) - 1
        rounding_value = rounding_value if rounding_value % 2 == 0 else rounding_value + 1
        return ((k * g) - (((g + 1) // 2) - 1) * n) + rounding_value"
"import sys
input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n, m = map(int,input().split())
    r = int(input())
    shots = {}
    for _ in range(r):
        t, d, coord = map(int,input().split())
        if shots.get(t, -1) == -1:
            shots[t] = []
        shots[t].append((d, coord))

    dp = [[[0] * (r + 1) for _ in range(m + 1)] for _ in range(n + 1)]
    dp[0][0][0] = 1

    for i in range(n + 1):
        for j in range(m + 1):
            for k in range(r + 1):
                t = i + j + k
                possible = 1
                for d, coord in shots.get(t, []):
                    possible &= (d != 1 or coord != i) and (d != 2 or coord != j)
                if possible:
                    if r != 0:
                        {{completion}}
                    if i != 0:
                        dp[i][j][k] |= dp[i - 1][j][k]
                    if j != 0:
                        dp[i][j][k] |= dp[i][j - 1][k]

    for k in range(r + 1):
        if dp[n][m][k]:
            print(n + m + k)
            break
    else:
        print(-1)",dp[i][j][k] |= dp[i][j][k - 1],"dp[i][j][k] |= dp[i][j][k - 1]
                    if j != 0:
                        dp[i][j][k] |= dp[i][j][k - 1]
                    if k != 0:
                        dp[i][j][k] |= dp[i][j][k - 1]"
"from collections import defaultdict
from sys import stdin

def solve(n,m,r,hshots,vshots):
    dp = [[[False] * (r+1) for _ in range(m + 1)] for _ in range(n + 1)]

    dp[0][0][0]=True
    for b in range(n+1):
        for j in range(m+1):
            for k in range(r+1):
                t = b+j+k 
                if t not in hshots[b] and t not in vshots[j]:
                    if b and dp[b-1][j][k]:
                        {{completion}}
                        
                    if j and dp[b][j-1][k]:
                        dp[b][j][k] = True
                        
                    if k and dp[b][j][k-1]:
                        dp[b][j][k] = True
                        
    ans = -1 
    for a in range(r+1):
        if dp[n][m][a] :
            ans = n+m+a
            break
    return ans
        

for _ in range(int(stdin.readline())):
    n, m = map(int, stdin.readline().split())
    vshots = defaultdict(set)
    hshots = defaultdict(set)
    r = int(stdin.readline())
    for _ in range(r):
        t, d, c = map(int, stdin.readline().split())
        if d == 1:
            hshots[c].add(t)
        else:
            vshots[c].add(t)
    print(solve(n,m,r,hshots,vshots))
    ",dp[b][j][k] = True,"dp[b][j][k] = True
                        
                    if j and dp[b][j-1][k]:
                        dp[b][j][k] = True
                        
                    if k and dp[b][j][k-1]:
                        dp[b][j][k] = True
                        
    dp[n][m][r] = True
    
    for b in range(n+1):
        for j in range(m+1):
            for k in range(r+1):
                t = b+j+k 
                if t not in hshots[b] and t not in vshots[j]:
                    if b and dp[b-1][j][k]:
                        dp[b][j][k] = True"
"import sys
input = sys.stdin.readline
INF = 10 ** 12

def solve():
    n, m = map(int, input().split())
    r = int(input())
    shots = dict()
    for _ in range(r):
        t, d, c = map(int, input().split())
        d -= 1
        if t not in shots:
            shots[t] = []
        shots[t].append((d, c))
    
    S = list(shots.keys())
    S.sort()
    dp = [[INF] * (m + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    last = 0

    for t in S:
        moves = t - last
        stack = []
        for i in range(n + 1):
            for j in range(m + 1):
                if dp[i][j] != INF:
                    stack.append((i, j, dp[i][j], moves))
        
        while stack:
            i, j, d, mleft = stack.pop()
            if d != dp[i][j] or mleft == 0:
                continue

            if i + 1 <= n and dp[i + 1][j] > d + 1:
                dp[i + 1][j] = d + 1
                stack.append((i + 1, j, d + 1, mleft - 1))
            
            if j + 1 <= m and dp[i][j + 1] > d + 1:
                dp[i][j + 1] = d + 1
                stack.append((i, j + 1, d + 1, mleft - 1))

        if dp[n][m] < t:
            return dp[n][m]

        for d, c in shots[t]:
            if d == 0:
                for j in range(m + 1):
                    dp[c][j] = INF
            else:
                for i in range(n + 1):
                    {{completion}}
                
        for i in range(n + 1):
            for j in range(m + 1):
                if dp[i][j] < t:
                    dp[i][j] = t
        
        last = t
    
    ans = INF
    for i in range(n + 1):
        for j in range(m + 1):
            if dp[i][j] == INF:
                continue
            ans = min(ans, dp[i][j] + n - i + m - j)
    
    return -1 if ans == INF else ans


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))",dp[i][c] = INF,"dp[i][j] = INF
                
                for i in range(n + 1):
                    for j in range(m + 1):
                        if dp[i][j] == INF:
                            continue
                        if j + 1 <= m and dp[i][j + 1] > d + 1:
                            dp[i][j + 1] = d + 1
                            stack.append((i, j + 1, d + 1, mleft - 1))
                        if i + 1 <= n and dp[i + 1][j] > d + 1:
                            dp[i + 1][j] = d + 1
                            stack.append((i + 1, j, d + 1, mleft - 1))"
"for _ in range(int(input())):
    x,y = input().split()
    if len(x)<len(y):
        x='0'*(len(y)-len(x))+x
    n = len(y)
    sum=0
    for i in range(n):
        if int(x[i])==int(y[i]):
            {{completion}}
        sum+=int(y[i])-int(x[i]) + 9*(n-i-1)
        break
    print(sum)        
",continue,"sum+=int(y[i])-int(x[i])
            break
        else:
            sum+=int(y[i])-int(x[i])+9*(n-i-1)
    print(sum)
for _ in range(int(input())):
    x,y = input().split()
    if len(x)<len(y):
        x='0'*(len(y)-len(x))+x
    n = len(y)
    sum=0
    for i in range(n):
        if int(x[i])==int(y[i]):
            sum+=int(y[i])-int(x[i])
            break
        else:"
"test= int(input())

for t in range(test):
    l,r= input().split("" "")
    if(l==r): 
        print(0)
        continue
    a,b=0,0
    aFlag,bFlag=False,False
    
    if(len(l)<len(r)): l= '0'*(len(r)-len(l)) + l
    
    for i in range(len(r)):
        if(l[i] != r[i]): 
            {{completion}}","print ((int(r[i])-int(l[i]))+9*(len(r)-i-1))
            break","a += int(l[i])-int(r[i])
            aFlag = True
        else: 
            b += int(l[i])
            bFlag = True
            
    if(aFlag and bFlag):
        print(a+b)
    elif(aFlag):
        print(b)
    elif(bFlag):
        print(a)
    else:
        print(""Invalid input"")
<|/ file ext=.py filename=Fedy"
"for i in range(int(input())):
    a,b = [x for x in input().split()]
    length=max(len(a),len(b))
    a=a.zfill(length);b=b.zfill(length)

    res=0
    for i in range(length):
        if not a[i] or not b[i]:
            res+=int(a[i])+int(b[i])
        elif a[i]==b[i]:
            {{completion}}
        else:
            res+=(abs(int(a[i])-int(b[i]))+9*(length-(i+1)))
            break

    print(res)",continue,res+=int(a[i])
"# https://codeforces.com/problemset/problem/1833/C
import fileinput

for i, line in enumerate(fileinput.input()):
    if i == 0 or i % 2 == 1:
        # Skip the number of testcases and numbers of array elements
        continue
    a = list(map(int, line.split()))
    if min(a) % 2 == 1:
        # If the min number is odd then all even numbers can be made odd by subtracting min(a)
        print('YES')
    elif any(num % 2 == 1 for num in a):
        # If the minimum is even and the array contains odd numbers
        {{completion}}
    else:
        # All number are even
        print('YES')
",print('NO'),"odd_nums = [num for num in a if num % 2 == 1]
        odd_nums.sort()
        odd_nums.reverse()
        print('YES' if odd_nums == a else 'NO')"
"t = int(input())
l1 = []
for i in range(t):
    c1 = 0
    c2 = 0
    n = int(input())
    a = input()
    b = input()
    b1 = b[::-1]
    for j in range(n):
        if a[j] != b[j]: {{completion}}
        if a[j] != b1[j]: c2 += 1
    d1 = c1 // 2 * 2 + c1
    d2 = (c2 + 1) // 2 * 2 - 1 + c2
    if c2 == 0: d2 = 2
    ans = min(d1, d2)
    l1 += [ans]
print(*l1, sep='\n')",c1 +=1,c1 += 1
"for i in range(int(input())):
    a=int(input());b=input().count('-')
    if b>a//2//2*2:print(b-a//2//2*2)
    elif b%2:{{completion}}
    else:print(0)",print(1),print(b-a//2)
"t=int(input())
for _ in range(t):
    n=int(input())
    l=input().split().count(""-1"")
    if(l>n//2):
        print(l+(n//2)%2-n//2)
    else:
        {{completion}}",print(l%2),"ans=0
        for i in range(n):
            if(i%2==0):
                ans=ans+l
            else:
                ans=ans+n-l
        print(ans)
<|/ file ext=.py source=github |>"
"for _ in range(int(input())):
    n=int(input())
    k=list(input().split()).count(""-1"")

    if k<=n//2:
        if k%2==0:
            print(0)
        else:
            print(1)
    else:
        if n//2%2==0:
            print(k-n//2)
        else:
            {{completion}}
        
",print(k-n//2+1),"k=k//2
            print(k+1)"
"import sys
input = sys.stdin.readline
K = 200
def solve():
    n, q = map(int, input().split())
    A = list(map(int, input().split()))
    queries = [[] for _ in range(n + 1)]
    res = [0] * q

    for i in range(q):
        s, d, k = map(int, input().split())
        s -= 1

        if d >= K:
            ans = 0
            for j in range(k):
                {{completion}}
            res[i] = ans
        else:
            queries[d].append((s, k, i))

    for d in range(min(K, n + 1)):
        if not queries[d]:
            continue

        P = [0] * (n + d)
        G = [0] * (n + d)

        for i, a in enumerate(A):
            j = i // d
            P[i + d] += a + P[i]
            G[i + d] += (j + 1) * a + G[i]

        for s, k, i in queries[d]:
            ns = s + (k - 1) * d
            res[i] = G[ns + d] - G[s] - (s // d) * (P[ns + d] - P[s])

    return "" "".join(map(str, res))

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))
",ans += (j + 1) * A[s + j * d],"ans += A[s + j * d]
            ans += A[s + d * k]"
"from sys import stdin

n_tests = int(stdin.readline())
for test_id in range(n_tests):
    n, q = [int(w) for w in stdin.readline().split()]
    nums = [int(w) for w in stdin.readline().split()]
    assert len(nums) == n
    
    queries = []
    cost_diff = [-2 * n] * n
    for i in range(q):
        s, d, k = [int(w) for w in stdin.readline().split()]
        if k > 3:
            cost_diff[d] += k - 4
        queries.append((s - 1, d, k))
    
    cumsums = {}
    cumsums2 = {}
    for d in range(1, n):
        if cost_diff[d] <= 0:
            continue
        s = []
        si = []
        for i, val in enumerate(nums):
            s.append(val if i < d else val + s[i - d])
            si.append(val * (i // d + 1) if i < d else val * (i // d + 1) + si[i - d])
        cumsums[d] = s
        cumsums2[d] = si
    result = []
    for s, d, k in queries:
        if d in cumsums and k > 3:
            result.append(
                cumsums2[d][s + d * (k - 1)] - (cumsums2[d][s - d] if s >= d else 0) -
                (
                    cumsums[d][s + d * (k - 1)] - (cumsums[d][s - d] if s >= d else 0)
                ) * (s // d)
            )
        else:
            res = 0
            for i in range(k):
                {{completion}}
            result.append(res)
    print("" "".join(str(x) for x in result))
",res += nums[s + i * d] * (i + 1),res = res + nums[s + i * d]
"from sys import stdin
def input(): return stdin.readline()[:-1]


def solve():
    N, Q = map(int, input().split())
    Arr = list(map(int, input().split()))
    
    K = int(N ** 0.5) + 1
    
    # MAKE DP OF SIZE N X K
    dp = [[0 for _ in range(N)] for _ in range(K)]
    
    for k in range(1, K):
        for i in range(N-1, -1, -1):
            if i + k < N:
                dp[k][i] = dp[k][i+k] + Arr[i]
            else:
                dp[k][i] = Arr[i]
                
    # making it a suffix
    for k in range(1, K):
        for i in range(N-1, -1, -1):
            if i + k < N:
                dp[k][i] += dp[k][i+k]
    
    ANS = [] 
    for _ in range(Q):
        s, delta, k = map(int, input().split())
        s -= 1
        
        if delta < K:
            temp = 0
            temp += dp[delta][s]
            if s + delta*(k) < N:
                temp -= dp[delta][s+delta*(k)]
                x = dp[delta][s+delta*(k)]
                if (s + delta*(k+1)) < N:
                    {{completion}}
                temp -= k * x
            ANS.append(temp)
        else:
            temp = 0
            for i in range(1, k+1):
                temp += Arr[s + (i-1) * delta] * i
            ANS.append(temp)
            
    
    print(*ANS)
for _ in range(int(input())):
    solve()",x -= dp[delta][s+delta*(k+1)],"x += dp[delta][s+delta*(k+1)]
                    temp += k * x
                else:
                    temp += k * x
            else:
                temp += k * x
            ANS.append(temp)
        else:
            temp = 0
            for i in range(1, k+1):
                temp += dp[delta][i] * i
            ANS.append(temp)
            
    
    print(*ANS)
for _ in range(int(input())):
    solve()
<|/ a dscore=0 |>"
"for s in [*open(0)][1:]: 
    {{completion}}","n, k = map(int, s.split())
    print((n - 2) // k + 2)","n, k = map(int, s.split())
    arr = [int(i) for i in input().split()]
    arr.sort()
    count = 0
    for i in range(1, n//k+1):
        if arr[i*k-1] == 1 and arr[i*k] == 1:
            count += 1
    if count < n:
        print(count)
<|/ file source=github ext=.py |>"
for v in[*open(0)][1:]:{{completion}},"n,k=map(int,v.split());print((n-2)//k+2)","
    a,b=v.split()
    a,b=int(a),int(b)
    if a<b and a%k==0 and b%k==0:
        ones=0
        for i in range(1,a//k+1):
            if a[i]==1:
                ones+=1
        for i in range(1,b//k+1):
            if b[i]==1:
                ones+=1
        if ones==a:
            print(ones)
<|/ file ext=.py |>"
for ok in[*open(0)][1:]:{{completion}},"kl,mk=map(int,ok.split());print((kl-2)//mk+2)","
    ok = ok.split()
    n, k = map(int, ok)
    arr = list(map(int, input().split()))
    arr.sort()
    count = 0
    for i in range(1, n//k):
        if arr[i-1] == 1 and arr[n-i-1] == 1:
            count += 1
    if count < k:
        print(0)
    else:
        print(1)
<|/ file source=github filename=GoodArray.py "
"import os,sys,collections,heapq,itertools,functools
if os.path.exists('in.txt'):
    file = open('in.txt') 
    input =  file.readline 
else : 
    input = sys.stdin.readline  
from functools import reduce 
from itertools import accumulate,chain,combinations,count 
from itertools import groupby,permutations,product,zip_longest
from heapq import heapify,heappush,heappop,heapreplace,merge,nlargest,nsmallest
from collections import Counter,defaultdict,deque 
from bisect import bisect_left, bisect_right
from math import comb,floor,ceil,inf ,gcd  ,sqrt ,atan2
import  operator 
readi = lambda: int(input()) 
readis = lambda: list(map(int,input().split()))
reads = lambda: input().rstrip() 
readss = lambda: input().split()     

def solution():
    n = readi()  
    right = []
    left = []
    up = [ ]
    down = [] 
    p1,p2,p3,p4 = [] , [] ,[] ,[]
    for _ in range(n):
        a,b,c,d = readis()  
        x = a-b 
        y = c - d 
        if x > 0 and y > 0 : p1.append((x,y))
        elif x < 0 and y > 0 : {{completion}}
        elif x < 0 and y < 0 : p3.append((x,y))
        elif x > 0 and y < 0 : p4.append((x,y))
        elif x > 0 : right.append((x,y))
        elif x < 0 : left.append((x,y)) 
        elif y > 0 : up.append((x,y))
        elif y < 0 : down.append((x,y)) 
    res = 0  
    x,y = 0,0  
    for dx,dy in chain(right,p1,up,p2):
        x += dx 
        y += dy 
    left = [(-x,-y) for x,y in right] + left  
    p3 = sorted([(-x,-y) for x,y in p1] + p3,key = lambda x:x[1]/x[0])
    down = [(-x,-y) for x,y in up] + down 
    p4 = sorted([(-x,-y) for x,y in p2] + p4,key = lambda x:x[1]/x[0])
 
    for dx,dy in chain(left,p3,down,p4):
        x += dx 
        y += dy 
        res = max(res,x*x+y*y)  
    for dx,dy in chain(left,p3,down,p4):
        x -= dx 
        y -= dy 
        res = max(res,x*x+y*y) 
    print(res)
for i in range( 1 ):
    solution() ","p2.append((x,y))","p2.append((x,y))"
"from sys import stdin
input=lambda :stdin.readline()[:-1]

def solve():
  n=int(input())
  a=list(map(int,input().split()))
  a=[n-i for i in a]+[0]
  m=int(input())
  stc=[]
  res=[]
  for i in range(n+1):
    ai=a[i]
    tmp=[]
    while stc and stc[-1][0]>=ai:
      h,l=stc.pop()
      tmp.append((h,l))
    L=i
    if tmp:
      L=tmp[-1][1]
      now=ai
      for h,l in tmp[::-1]:
        {{completion}}
    if ai!=0:
      stc.append((ai,L))
  res.sort(key=lambda x:-x[0])
  ans=0
  for d,c in res:
    x=min(c,m//d)
    ans+=(d-1)*x
    m-=d*x
    c-=x
    if c>0 and m>0:
      ans+=m-1
      m=0
  print(ans)

  
  
for _ in range(int(input())):
  solve()
","res.append((i-l,h-now))
        now=h","now+=h
        if now>=L:
          L=l
          break
    res.append((L,ai))
    for j in range(i+1,n+1):
      if j!=i and a[j]==ai:
        ai-=1
        stc.append((j,ai))
  res.sort(key=lambda x:-x[0])
  ans=0
  for d,c in res:
    x=min(c,m//d)
    ans+=(d-1)*x
    m-=d*x
    c-=x
    if c>0 and m>0:
      ans+=m-1
      m=0
  print(ans)

for _ in range(int(input())):"
"import sys
from array import array

input = lambda: sys.stdin.buffer.readline().decode().rstrip()
inp = lambda dtype: [dtype(x) for x in input().split()]
debug = lambda *x: print(*x, file=sys.stderr)
sum_n = lambda n: (n * (n + 1)) // 2
get_bit = lambda x, i: (x >> i) & 1
ceil_ = lambda a, b: a // b if (a >= 0) ^ (b > 0) else (abs(a) + abs(b) - 1) // abs(b)
Mint, Mlong, out = 2 ** 30 - 1, 2 ** 62 - 1, []


def solve(a, eq):
    stk = array('i')

    for i in range(n):
        ma = 0
        while stk and a[i] > a[stk[-1]]:
            ma = max(ma, a[stk.pop()])

        if stk and (a[i] != a[stk[-1]] or eq == 0):
            val = max(i - stk[-1] - 2, 0)
            mem[val] += (a[i] - ma) * val
        elif not stk and i:
            {{completion}}

        stk.append(i)

for _ in range(1, int(input()) + 1):
    n = int(input())
    a = array('i', inp(int))
    m, ans = int(input()), 0
    mem = [0] * n
    mem[n - 1] = (n - max(a)) * (n - 1)
    solve(a, 0)
    solve(a[::-1], 1)

    for i in range(n - 1, 0, -1):
        mi = min(m, mem[i] + ceil_(mem[i], i))
        m -= mi
        div, mod = divmod(mi, i + 1)
        ans += max(0, div) * i + max(0, mod - 1)

    out.append(ans)

print('\n'.join(map(str, out)))
",mem[i - 1] += (a[i] - ma) * (i - 1),"mem[i - 1] += 1
            stk.append(i)
        elif eq == 1 and stk and a[i] != a[stk[-1]]:
            mem[i - 1] += 1
            stk.append(i)
        elif eq == 1 and stk and a[i] == a[stk[-1]]:
            mem[i - 1] += 2
            stk.append(i)
        elif eq == 0 and stk and a[i] != a[stk[-1]]:
            mem[i - 1] += 2
            stk.append(i)
        elif eq == 0 and stk and a[i] == a[stk[-1]]:
            mem[i - 1] += 1
            stk.append(i)
"
"from sys import gettrace, stdin

if not gettrace():
    def input():
        return next(stdin)[:-1]


def solve():
    n = int(input())
    aa = [int(a) for a in input().split()]
    aa.append(n)
    m = int(input())
    sc = [0]*(n+1)
    stack = [(n+1, -1)]
    b = 0
    for i,a in enumerate(aa):
        while stack and a >= stack[-1][0]:
            sc[i - stack[-1][1]-1] += stack[-1][0] - b
            b = stack[-1][0]
            stack.pop()
        sc[i - stack[-1][1] - 1] += a - b
        stack.append([a,i])
        b = a
    res = 0
    for i in range(n, 1, -1):
        if m >= sc[i]*i:
            m -= sc[i]*i
            res += sc[i]*(i-1)
        else:
            {{completion}}
    print(res)






def main():
    for _ in range(int(input())):
        solve()


if __name__ == ""__main__"":
    main()
","res += (m//i)*(i-1) + max(0, m%i-1)
            break","m -= sc[i]
            res += sc[i]
    res += sc[0]"
"import sys
 
input = sys.stdin.readline
 
for _ in range(int(input())):
    l = int(input())
    d = {}
    for i in range(l):
        a,b = map(int, input().split())
        if a not in d: {{completion}}
        d[a].append(b)
    
    a = 0
    for c in d.keys():
        d[c].sort(reverse=True)
        a += sum(d[c][:c])
  
    print(a)",d[a] = [],d[a] = []
"import sys
input_func = sys.stdin.readline

test_cases = int(input_func())
for _ in range(test_cases):
    num_pairs = int(input_func())
    value_pairs = {}
    for __ in range(num_pairs):
        key, value = map(int, input_func().split())
        value_pairs.setdefault(key, []).append(value)
    total_sum = 0

    for key, values in value_pairs.items():
        if key >= len(values) or len(values) == 1:
            total_sum += sum(values)
        else:
            {{completion}}
    print(total_sum)
","values.sort()
            total_sum += sum(values[-key:])","value_sum = 0
            for value in values:
                value_sum += value
            if value_sum > total_sum:
                total_sum = value_sum
    print(total_sum)
<|/ file source=github filename=4.py |>"
"import sys

input = sys.stdin.buffer.readline


for _ in range(int(input())):
    n = int(input())
    l = [[] for _ in range(n)]

    for i in range(n):
        a, b = map(int, input().split())
        l[a - 1].append(b)

    [l1.sort(reverse=True) for l1 in l]
    
    ans = 0
    for i in range(n):
        for j in range(min(len(l[i]), i + 1)):
            {{completion}}
    print(ans)",ans += l[i][j],"ans += l[i][j]
            
    ans -= sum(l[0])"
"rd=lambda: list(map(int,input().split()))
for _ in range(int(input())):
  n=int(input())
  a=[rd() for i in range(n)]
  a.sort(key=lambda x:x[1])
  A=-1
  R=-1 
  c=0
  for x,y in a:
    if x <= R: continue 
    if A >=x:
      A=-1
      c+=1;R=y 
    else: {{completion}}
  print(n-c*2)",A=y,"
      A=x
      c+=1;R=y
  print(c)"
"rd=lambda: list(map(int,input().split()))
for _ in range(int(input())):
  n=int(input())
  a=[rd() for i in range(n)]
  a.sort(key=lambda x:x[1])
  A=0 
  R=-1 
  c=0
  for x,y in a:
    if x <= R: continue 
    if A and A[-1]>=x:
      A=0
      c+=1;R=y 
    else: {{completion}}
  print(n-c*2)","A=[x,y]","
      A+=x 
      R=y 
  if A: 
    print(A[-1]-c*2)
  else:"
"rd=lambda: list(map(int,input().split()))
for _ in range(int(input())):
  n=int(input())
  a=[rd() for i in range(n)]
  a.sort(key=lambda x:x[1])
  A=-1
  R=-1 
  c=0
  for x,Y in a:
    if x <= R: continue 
    if A >=x:
      A=-1
      c+=1;R=Y 
    else: {{completion}}
  print(n-c*2)",A=Y,"
      A=x
      c+=1;R=Y
  if c==n//2: 
    print(n-c*2)
  else: "
"from sys import stdin, stdout
from collections import defaultdict

# apply addition to segment lazily, query max on segment
class LazySegmentTree:
    def __init__(self, data, default=-10**10, func=max): # need to change default is func = min
        """"""initialize the lazy segment tree with data""""""
        self._default = default
        self._func = func

        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
        self._lazy = [0] * (2 * _size)

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __len__(self):
        return self._len

    def _push(self, idx):
        """"""push query on idx to its children""""""
        # Let the children know of the queries
        q, self._lazy[idx] = self._lazy[idx], 0

        self._lazy[2 * idx] += q
        self._lazy[2 * idx + 1] += q
        self.data[2 * idx] += q
        self.data[2 * idx + 1] += q

    def _update(self, idx):
        """"""updates the node idx to know of all queries applied to it via its ancestors""""""
        for i in reversed(range(1, idx.bit_length())):
            self._push(idx >> i)

    def _build(self, idx):
        """"""make the changes to idx be known to its ancestors""""""
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]
            idx >>= 1

    def add(self, start, stop, value):
        """"""lazily add value to [start, stop)""""""
        start = start_copy = start + self._size
        stop = stop_copy = stop + self._size
        while start < stop:
            if start & 1:
                {{completion}}
            if stop & 1:
                stop -= 1
                self._lazy[stop] += value
                self.data[stop] += value
            start >>= 1
            stop >>= 1

        # Tell all nodes above of the updated area of the updates
        self._build(start_copy)
        self._build(stop_copy - 1)

    def query(self, start, stop, default=-10**10): # need to change default is func = min
        """"""func of data[start, stop)""""""
        start += self._size
        stop += self._size

        # Apply all the lazily stored queries
        self._update(start)
        self._update(stop - 1)

        res = default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""LazySegmentTree({0})"".format(self.data)

n, k, A = [int(x) for x in stdin.readline().split()]
points = []
for i in range(n):
    points.append([int(x) for x in stdin.readline().split()])

x_to_points = defaultdict(list) # {x:[id, id, id,...]}
total_cost = 0
for i in range(n):
    x_to_points[points[i][0]].append(i)
    total_cost += points[i][2]

savings = LazySegmentTree([0]*(k+2))

for a in range(k-1,-1,-1):
    savings.add(a+2,k+2,-A)
    for id in x_to_points[a]:
        y = points[id][1]
        c = points[id][2]
        savings.add(k-y+1,k+2,c)

    savings.add(a,a+1,savings.query(a+1,k+2))

best_saving = savings.query(0,1)
stdout.write(str(total_cost-best_saving)+'\n')
","self._lazy[start] += value
                self.data[start] += value
                start += 1","start += 1
                self._lazy[start] += value
                self.data[start] += value"
"import os,sys,collections,heapq,itertools,functools,operator,random
if os.path.exists('in.txt'):                                    
    file = open('in.txt')                                       
    input =  file.readline                                      
else :                                                          
    input = sys.stdin.readline                                  
from functools import reduce , lru_cache                        
from itertools import accumulate,chain,combinations,count       
from itertools import groupby,permutations,product,zip_longest  
from heapq import heapify,heappush,heappop,heapreplace,merge,nlargest,nsmallest
from collections import Counter,defaultdict,deque               
from bisect import bisect_left, bisect_right                    
from math import comb,floor,ceil,inf ,gcd ,sqrt ,atan2          
from copy import copy                                           
from random import randint                                      
readi = lambda: int(input())                                    
readis = lambda: list(map(int,input().split()))                 
reads = lambda: input().rstrip()                                
readss = lambda: input().split()                                

class SEGMENTTREE_ADD_MAX:
    def __init__(self,n=10**9,q=10**5): 
        self.N =  1 << (n+2).bit_length() 
        self.A = defaultdict(int) if n > q*n.bit_length() else [0]*(self.N*2)
    def update(self, l, r, x):
        A,N = self.A,self.N 
        if l <= 0:
            r += N+1
            while r > 1 :
                if r & 1:  A[r ^ 1] += x
                tmp = max(A[r], A[r ^ 1])
                A[r] -= tmp;A[r ^ 1] -= tmp;A[r >> 1] += tmp
                r >>= 1 
        elif r>=N-1:
            l += N-1
            while l > 1 :
                if ~l & 1: {{completion}}
                tmp = max(A[l], A[l ^ 1])
                A[l] -= tmp;A[l ^ 1] -= tmp;A[l >> 1] += tmp
                l >>= 1
        elif l == r:
            A,N = self.A,self.N 
            l += N 
            A[l] += x 
            while l > 1 :
                tmp = max(A[l], A[l ^ 1])
                A[l] -= tmp;A[l ^ 1] -= tmp;A[l >> 1] += tmp
                l >>= 1
        elif l < r:
            l += N-1
            r += N+1
            while l ^ r ^ 1:
                if ~l & 1: A[l ^ 1] += x
                if r & 1:  A[r ^ 1] += x
                tmp = max(A[l], A[l ^ 1])
                A[l] -= tmp;A[l ^ 1] -= tmp;A[l >> 1] += tmp
                tmp = max(A[r], A[r ^ 1])
                A[r] -= tmp;A[r ^ 1] -= tmp;A[r >> 1] += tmp
                l >>= 1;r >>= 1
            while l > 1 :
                tmp = max(A[l], A[l ^ 1])
                A[l] -= tmp;A[l ^ 1] -= tmp;A[l >> 1] += tmp
                l >>= 1
    def query(self, l, r):
        A,N = self.A,self.N 
        l += N 
        r += N 
        S = T = 0
        if l ^ r : 
            while l ^ r ^ 1:
                S += A[l] ; T += A[r]
                if ~l & 1 : S = max(S,A[l^1])
                if r & 1  : T = max(T,A[r^1])
                l >>= 1 ; r >>= 1 
        S = max(A[l]+S,A[r]+T) 
        while l > 1: 
            l >>= 1 ; S += A[l]
        return S

def solution():                                                 
    n,k,A = readis() 
    t = SEGMENTTREE_ADD_MAX(k,n) 
    E = [[] for _ in range(k+1)] 
    s = 0 
    for _ in range(n):
        a,b,c = readis() 
        E[k-b].append([a,c]) 
        s += c  
    dp = 0 
    for r in range(k+1):
        for l,c in E[r]:
            t.update(0,l,c) 
        dp = max(dp,t.A[1]-A*r)  
        t.update(r,r,dp+r*A)  
    print(s-dp)

    
    
for i in range( 1 if 1 else readi()  ):                                   
    solution()                                                  


",A[l ^ 1] += x,"A[l ^ 1] += x
                tmp = max(A[l], A[l ^ 1])
                A[l] -= tmp;A[l ^ 1] -= tmp;A[l >> 1] += tmp
                l >>= 1
        elif l == r:
            l += N-1
            r += N+1
            while l ^ r ^ 1:
                if ~l & 1: A[l ^ 1] += x
                if r & 1:  A[r ^ 1] += x
                tmp = max(A[l], A[l ^ 1])
                A[l] -= tmp;A[l ^ 1] -= tmp;A[l >> 1] += tmp"
"import collections, math, bisect, heapq, random, functools, itertools, copy, typing
import platform; LOCAL = (platform.uname().node == 'AMO')


import sys; input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda f=int: list(map(f, input().split()))

def make_arr(*args):
    def func(x):
        if len(args) == 1: return [x() for _ in range(args[0])]
        return [make_arr(*args[1:])(x) for _ in range(args[0])]
    return func

def debug(*args):
    if LOCAL:
        print('\033[92m', end='')
        printf(*args)
        print('\033[0m', end='')

def printf(*args):
    if LOCAL:
        print('>>>: ', end='')
    for arg in args:
        if isinstance(arg, typing.Iterable) and \
                not isinstance(arg, str) and \
                not isinstance(arg, dict):
            print(' '.join(map(str, arg)), end=' ')
        else:
            print(arg, end=' ')
    print()

# avaliable on Google, AtCoder
# sys.setrecursionlimit(10**6)
# import numpy as np
# import scipy

# d4 = [(1,0),(0,1),(-1,0),(0,-1)]
# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]
# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout
class UnionFind:
    def __init__(self, x) -> None:
        self.uf = [-1] * x
 
    def find(self, x):
        r = x
        while self.uf[x] >= 0:
            x = self.uf[x]
        while r != x:
            self.uf[r], r = x, self.uf[r]
        return x
 
    def same(self, x, y):
        return self.find(x) == self.find(y)

    def merge(self, x, y):
        ux, uy = self.find(x), self.find(y)
        self.uf[ux] += self.uf[uy]
        self.uf[uy] = ux
        return True 

    def union(self, x, y):
        ux, uy = self.find(x), self.find(y)
        if ux == uy:
            return False
        if self.uf[ux] >= self.uf[uy]:
            self.uf[uy] += self.uf[ux]
            self.uf[ux] = uy
        else:
            self.uf[ux] += self.uf[uy]
            self.uf[uy] = ux
        return True
 
    def count(self):
        return sum(f < 0 for f in self.uf)
 
    def valid(self):
        n = len(self.uf)
        for c in range(n):
            if self.uf[c] == -n:
                return True
        return False
    
    def roots(self):
        return [i for i, f in enumerate(self.uf) if f < 0]

    def groups(self):
        n = len(self.uf)
        ret = [[] for _ in range(n)]
        for i in range(n):
            f = self.find(i)
            ret[f].append(i)
        return ret
 
    def __print__(self):
        return self.uf

class Encodict:
    def __init__(self, func=lambda : 0):
        self.RANDOM = random.randint(0, 1<<32)
        self.default = func
        self.dict = {}
    
    def __getitem__(self, key):
        k = self.RANDOM ^ key
        if k not in self.dict:
            self.dict[k] = self.default()
        return self.dict[k]
    
    def __setitem__(self, key, item):
        k = self.RANDOM ^ key
        self.dict[k] = item

    def keys(self):
        return [self.RANDOM ^ i for i in self.dict]
    
    def items(self):
        return [(self.RANDOM ^ i, self.dict[i]) for i in self.dict]
    
    def sorted(self, by_value=False, reverse=False):
        if by_value:
            self.dict = dict(sorted(self.dict.items(), \
                key=lambda x:x[1], reverse=reverse))
        else:
            self.dict = dict(sorted(self.dict.items(), \
                key=lambda x:self.RANDOM^x[0], reverse=reverse))

def solve(cas):
    n, k, a = inp()
    mp = Encodict(list)
    for i in range(n):
        x, y, c = inp()
        mp[k-x-1].append((y, c))

    uf = UnionFind(k+1)
    cap = make_arr(k)(lambda:a)
    res = 0
    for r in range(k):
        for l, c in mp[r]:
            i = uf.find(l)
            while i <= r and c > 0:
                tmp = min(c, cap[i])
                res += tmp
                cap[i] -= tmp
                c -= tmp
                if cap[i] == 0:
                    {{completion}}
                i = uf.find(i)
    print(res)
            
cas = 1
for _ in range(cas):
    solve(_)

","uf.merge(i+1, i)","cap[i] = a
                    i += 1
                uf.merge(l, i)"
"import sys
input = sys.stdin.readline 

def solve():  
    n = int(input())
    a = list(map(int,input().split()))
    a.sort()

    l ,r = 0, int(1e9)
    while l < r:
        mid = (l+r) >> 1

        cnt , last = 1, 0
        for i, x in enumerate(a) :
            if x - a[last] > (mid << 1) :
                {{completion}}
        
        if cnt > 3 :
            l = mid+1
        else :
            r = mid 
    print(l)

    return

def main():
    t = int(input())
    for _ in range(t):
        solve()

if __name__ == ""__main__"":
    main()","last, cnt = i, cnt+1","cnt += 1
                last = i"
"import sys
input = sys.stdin.readline
 
t = int(input())
out = []
 
for _ in range(t):
    n = int(input())

    arr = list(map(int, input().split()))
    #arr = list({int(x) for x in input().split()})
    arr.sort()
    
    arr = set(arr)
    arr = list(arr)
    
    min_ = 0
    max_ = arr[-1]
    while min_ < max_:
        target = (min_ + max_) // 2
        
        now = 0
        i = 0
        for __ in range(3):
            now = arr[i] + target

            if now + target >= arr[-1]:
                max_ = target
                break
            
            min2 = 0
            max2 = len(arr)-1
            while min2 < max2:
                target2 = (min2 + max2) // 2

                if arr[target2] > now + target:
                    max2 = target2
                else:
                    {{completion}}

            i = min2
            
        else:
            min_ = target + 1

    out.append(str(min_) + ""\n"")
        
print("""".join(out))",min2 = target2 + 1,"min2 = target2
                
                if now + target >= arr[target2]:
                    max_ = target
                    break"
"import sys

input = lambda: sys.stdin.readline().rstrip()


def solution(n, a):
    a.sort()
    if len(a) < 4:
        return 0
    l, r = -1, 10 ** 9
    while l + 1 < r:
        mid = (l + r) // 2
        cnt, x = 1, a[0]
        for i in range(len(a)):
            if a[i] > x + 2 * mid:
                {{completion}}

        if cnt <= 3:
            r = mid
        else:
            l = mid

    return r


for _ in range(int(input())):
    n = int(input())
    a = [int(i) for i in input().split()]
    print(solution(n, a))","x = a[i]
                cnt += 1","cnt += 1
                x += mid - a[i]
            else:
                x += a[i]"
for a in[*open(0)][1:]:{{completion}},print('YNEOS'[len({*a[:len(a)-1>>1]})<2::2]),"
    s=a
    s=s.lower()
    s=s.replace(' ','')
    s=s.replace('\n','')
    s=s.replace('\t','')
    s=s.replace('\r','')
    s=s.replace('\v','')
    s=s.replace('\f','')
    s=s.replace('\a','')
    s=s.replace('\e','')
    s=s.replace('\i','')
    s=s.replace('\o','')
    s=s.replace('\v','')
    s=s.replace('\c','')
    s=s.replace('\e','')
    s=s.replace('\i"
"t=int(input())
while t>0:
    s=input()
    n=len(s)
    if len(set(s[:n//2]))>=2:
        print(""YES"")
    else:
        {{completion}}
    t=t-1","print(""NO"")","s=s[::-1]
        n=len(s)
        if n==1:
            print(""YES"")
        else:
            s=s[:n//2]+s[n//2:][::-1]
            n=len(s)
            if n==1:
                print(""YES"")
            else:
                s=s[:n//2]+s[n//2:][::-1]
                n=len(s)
                if n==1:
                    print(""YES"")
                else:
                    s=s[:n//2]+s[n//2:][::-1]
                    n=len(s)
                    if n==1:
                        print(""YES"")
                    else:
                        s=s[:n//2]+s[n//2:][::-1]
                        n=len(s)"
"for s in[*open(0)][1:]:{{completion}}
",print('YNEOS'[len({*s[:len(s)-1>>1]})<2::2]),"
    s=s.lower()
    s=s.replace(' ','')
    s=s.replace('\n','')
    s=s.replace('\t','')
    s=s.replace('\r','')
    s=s.replace('\v','')
    s=s.replace('\a','')
    s=s.replace('\e','')
    s=s.replace('\i','')
    s=s.replace('\o','')
    s=s.replace('\v','')
    s=s.replace('\a','')
    s=s.replace('\e','')
    s=s.replace('\i','')
    s=s.replace('\o','')
"
"from sys import stdin
from pprint import pprint

values = [
	[1, 10, 100, 1000, 10000], # if right is A
	[-1, 10, 100, 1000, 10000], # if right is B
	[-1, -10, 100, 1000, 10000], # if right is C
	[-1, -10, -100, 1000, 10000], # if right is D
	[-1, -10, -100, -1000, 10000]] # if right is E

for _ in range(int(stdin.readline())):
	s = stdin.readline().rstrip()
	acc = [[0, 0, 0, 0, 0]]
	for x in s:
		c = ord(x) - 65
		acc.append([values[i][c] + acc[-1][max(i, c)] for i in range(5)])
	hi, right, best = 0, 0, -1_000_000_000
	for i in range(len(s)-1, -1, -1):
		c = ord(s[i]) - 65
		for j in range(5):
			{{completion}}
		hi = max(hi, c)
		right += values[hi][c]
	print(best)","best = max(best, right + values[hi][j] + acc[i][max(j, hi)])","acc[j][c] -= acc[j][c+1]
			if acc[j][c] < 0:
				acc[j][c] = 0
		best = max(best, acc[-1][max(i, c)])"
"import sys
 
input = lambda: sys.stdin.readline().rstrip()  # faster!
 
VALUE = [1, 10, 100, 1_000, 10_000]
 
 
def value(a):
    res = 0
    max_digit = 0
    for ai in reversed(a):
        if ai >= max_digit:
            res += VALUE[ai]
            max_digit = ai
        else:
            res -= VALUE[ai]
    return res
 
 
def solve_case():
    s = input()
 
    a = [ord(c) - ord(""A"") for c in s]
    n = len(a)
 
    min_pos, max_pos = [n] * 5, [-1] * 5
    for i, ai in enumerate(a):
        min_pos[ai] = min(min_pos[ai], i)
        max_pos[ai] = max(max_pos[ai], i)
 
    ans = value(a)
    for d in range(5):
        if min_pos[d] != n:
            orig = a[min_pos[d]]
            for dn in range(5):
                if dn != d:
                    {{completion}}
            a[min_pos[d]] = orig
        if max_pos[d] != -1 and max_pos[d] != min_pos[d]:
            orig = a[max_pos[d]]
            for dn in range(5):
                if dn != d:
                    a[max_pos[d]] = dn
                    ans = max(ans, value(a))
            a[max_pos[d]] = orig
 
    print(ans)
 
 
for _ in range(int(input())):
    solve_case()","a[min_pos[d]] = dn
                    ans = max(ans, value(a))","a[min_pos[d]] = dn
                    ans = max(ans, value(a))"
"import sys
#import collections
import math
#import bisect
#import heapq
#import itertools
#import functools
input = sys.stdin.readline




def solve():
    s = input().rstrip()
    first = [-1] * 5
    last = [-1] * 5
    ls = list(s)
    for i, a in enumerate(s):
        j = ord(a) - 65
        if first[j] == -1:
            first[j] = i
        last[j] = i
    def calc(ls):
        res = 0
        prev = -1
        for a in reversed(ls):
            j = ord(a) - 65
            if j < prev:
                res -= 10 ** j
            elif j == prev:
                {{completion}}
            else:
                res += 10 ** j
                prev = j
        return res
    
    res = calc(ls)

    for k in range(5):
        if first[k] != -1:
            for j in range(k + 1, 5):
                ls[first[k]] = chr(65 + j)
                res = max(res, calc(ls))
                ls[first[k]] = chr(65 + k)
    for k in range(5):
        if last[k] != -1:
            for j in range(k):
                ls[last[k]] = chr(65 + j)
                res = max(res, calc(ls))
                ls[last[k]] = chr(65 + k)

    print(res)

    
    


    

    
    



t = int(input())
for _ in range(t):
    solve()",res += 10 ** j,"res = max(res, 10 ** j)"
"for _ in range(int(input())):
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    a.sort()
    if c >= 0:
        print(*a)
        continue
    a.reverse()
    l1 = [0]
    c *= -1
    for i in range(n-2):
        if a[i]-a[i+2] > c:
            l1.append(i+1)
    l1.append(n-1)
    ans = [a[0]]
    visited = [0]*n
    for i in range(len(l1)-1):
        x = l1[i]
        y = l1[i+1]
        if x == y:
            continue
        a1 = [a[x]]
        visited[x] = 1
        visited[y] = 1
        for j in range(x,y):
            if a[j]+c<a1[-1]:
                a1.append(a[j-1])
                visited[j-1] = 1
        a2 = [a[y]]
        for j in range(y,x,-1):
            if a2[-1]+c<a[j] and j <= y-2:
                if visited[j+1] == 0:
                    a2.append(a[j+1])
                    visited[j+1] = 1
                elif visited[j+2] == 0:
                    {{completion}}
        ans.pop()
        ans += a1
        for j in range(y,x,-1):
            if visited[j] == 0:
                ans.append(a[j])
        a2.reverse()
        ans += a2
    print(*ans)","a2.append(a[j+2])
                    visited[j+2] = 1","a2.append(a[j+2])
                    visited[j+2] = 1
                else:
                    a2.append(a[j+1])
                    visited[j+1] = 1
                    a2.append(a[j+2])
                    visited[j+2] = 1"
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')
I = lambda: int(input())
R = lambda: list(map(int, input().split()))
P = lambda x, y='\n': print(x, end=y)


for _ in range(I()):
    n, c = R()
    a = sorted(R())
    if c >= 0:
        print(*a)
        continue
    a,b,c=a[::-1],[0],-c
    s,f = [a[0]],[0] * n
    for i in range(n - 2):
        if a[i] - a[i + 2] > c:
            b.append(i + 1)
    b.append(n - 1)
    for i in range(len(b) - 1):
        x ,y= b[i],b[i + 1]
        if x == y:
            continue
        a1 = [a[x]]
        f[x] = f[y] = 1
        for j in range(x, y):
            if a[j] + c < a1[-1]:
                a1.append(a[j - 1])
                f[j - 1] = 1
        a2 = [a[y]]
        for j in range(y, x, -1):
            if a2[-1] + c < a[j] and j <= y - 2:
                if not f[j + 1] :
                    a2.append(a[j + 1])
                    f[j + 1] = 1
                elif not f[j + 2] :
                    {{completion}}
        s.pop()
        s += a1
        for j in range(y, x, -1):
            if not f[j]:
                s.append(a[j])
        a2=a2[::-1]
        s += a2
    print(*s)
","a2.append(a[j + 2])
                    f[j + 2] = 1","a2.append(a[j + 2])
                    f[j + 2] = 1
        s.pop()
        s += a1
        for j in range(y, x, -1):
            if not f[j]:
                s.append(a[j])
        a2=a2[::-1]
        s += a2
    print(*s)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import sys
t = int(input())
while t > 0:
    n, c = map(int, input().split())
    a = [0] + list(map(int, input().split()))
    ans = [0] * (n+1)
    if c >= 0:
        a.sort()
        print(*a[1:])
    elif n == 1:
        print(a[1])
    else:   
        v = sorted(a[1:])
        ans[1] = v[-1]
        ans[n] = v[0]
        v.pop()
        v.append(sys.maxsize)
        for i in range(2, n):
            flag = 1
            for j in range(1, len(v)-1):
                if v[j] >= ans[i-1] + c and v[j+1] - v[j-1] <= -c:
                    {{completion}}
            if flag:
                ans[i] = v[-2]
                v.pop()
                v.pop()
                v.append(sys.maxsize)
        print(*ans[1:n+1])
    t -= 1","ans[i] = v[j]
                    del v[j]
                    flag = 0
                    break","flag = 0
                    break"
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')
I = lambda: int(input())
R = lambda: list(map(int, input().split()))
P = lambda x, y='\n': print(x, end=y)


for _ in range(I()):
    n, c = R()
    a = sorted(R())
    if c >= 0:
        print(*a)
        continue
    a,b,c=a[::-1],[0],-c
    s,f = [a[0]],[0] * n
    for i in range(n - 2):
        if a[i] - a[i + 2] > c:
            b.append(i + 1)
    b.append(n - 1)
    for i in range(len(b) - 1):
        x ,y= b[i],b[i + 1]
        if x == y:
            continue
        a1 = [a[x]]
        f[x] = f[y] = 1
        for j in range(x, y):
            if a[j] + c < a1[-1]:
                a1.append(a[j - 1])
                f[j - 1] = 1
        a2 = [a[y]]
        for j in range(y, x, -1):
            if a2[-1] + c < a[j] and j <= y - 2:
                if not f[j + 1] :
                    a2.append(a[j + 1])
                    f[j + 1] = 1
                elif not f[j + 2] :
                    {{completion}}
        s.pop()
        s += a1
        for j in range(y, x, -1):
            if not f[j]:
                s.append(a[j])
        a2=a2[::-1]
        s += a2
    print(*s)
","a2.append(a[j + 2])
                    f[j + 2] = 1","a2.append(a[j + 2])
                    f[j + 2] = 1
        s.pop()
        s += a1
        for j in range(y, x, -1):
            if not f[j]:
                s.append(a[j])
        a2=a2[::-1]
        s += a2
    print(*s)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import math
import heapq
import itertools
import bisect
import random
import time
from collections import deque
import sys
from cmath import exp,pi
from functools import cmp_to_key
input=sys.stdin.readline

t=int(input())
for _ in range(t):
    n,c=map(int,input().split())
    arr=list(map(int,input().split()))
    if c>=0:
        arr.sort()
        print(*arr)
    else:
        arr.sort(reverse=True)
        line=[]
        ans=[]
        for i in range(n):
            if i==n-1 or arr[i+1]-arr[i]<c:
                last=arr[i]
                if len(line)!=0:
                    cur=line[0]
                    #print(line)
                    while (len(line))>0:
                        line.remove(cur)
                        ans.append(cur)
                        if len(line)==0:
                            break
                        p=0
                        #print(line)
                        for j in range(1,len(line)):
                            if line[j]-cur<c:
                                break
                            if j!=len(line)-1:
                                if line[j+1]-line[j-1]>=c:
                                    p=j
                            else:
                                if last-line[j-1]>=c:
                                    {{completion}}
                        cur=line[p]
                    
                ans.append(last)
            else:
                line.append(arr[i])
        print(*ans)
",p=j,"p=j
                        last=line[p]
                        cur=line[p]
                else:
                    last=arr[i]
                    cur=last
                    
                ans.append(last)
            else:
                line.append(arr[i])
        print(*ans)
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
"
"import sys
input = sys.stdin.buffer.readline

for _ in range(int(input())):
    maxpath, minpath = [1], [0]
    curmx, curmn = [1], [0]
    for _ in range(int(input())):
        line = iter(input().split())
        if next(line) == b'+':
            v, w = map(int,line)
            curmx.append(max(curmx[v - 1] + w, w))
            maxpath.append(max(maxpath[v - 1], curmx[-1]))
            curmn.append(min(curmn[v - 1] + w, w))
            minpath.append(min(minpath[v - 1], curmn[-1]))
        else:
            {{completion}}
","u, v, k = map(int,line)
            mx = maxpath[v - 1]
            mn = minpath[v - 1]
            print(""YES"" if mn <= k <= mx else ""NO"")","u, v, k = map(int, line)
            if k > 0:
                maxpath.append(max(maxpath[u - 1], curmx[-1]))
                minpath.append(min(minpath[u - 1], curmn[-1]))
                if curmx[-1] == maxpath[-1]:
                    maxpath.pop()
                    minpath.pop()
                    curmx.pop()
                    curmn.pop()
                else:
                    maxpath.append(max(maxpath[u - 1], curmx[-1]))
                    minpath.append(min(minpath[u - 1], curmn[-1]))
            else:
                maxpath.append(max(maxpath[u - 1], curmx[-1]))
                minpath.append(min(minpath"
"def II():
    return(int(input()))
def I():
    return(input())
def LMI():
    return(list(map(int,input().split())))
def MII():
    return(map(int,input().split()))
# mod=10**9+7
# from collections import Counter
import sys
input = sys.stdin.readline
import bisect
# input = lambda: sys.stdin.readline().rstrip()
# import io,os
# import math
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# from collections import defaultdict
# from collections import deque

def t():
    n=II()
    maxend=[0,1]
    minend=[0,1]
    maxtill=[0,1]
    mintill=[0,0]
    for _ in range(n):
        L=list(input().split())
        for i in range(1,len(L)):
            L[i]=int(L[i])
        if L[0]==""+"":
            p=L[1]
            w=L[2]
            maxend.append(max(w,maxend[p]+w))
            minend.append(min(w,minend[p]+w))
            maxtill.append(max(maxtill[p],maxend[-1]))
            mintill.append(min(mintill[p],minend[-1]))
        else:
            alp=maxtill[L[2]]
            bet=mintill[L[2]]
            if bet<=L[3]<=alp:
                print(""YES"")
            else:
                {{completion}}




if __name__==""__main__"":
    for _ in range(II()):
        t()

    # t()












","print(""NO"")","bisect.insort(maxend,L[3])
                bisect.insort(minend,L[3])
                bisect.insort(maxtill,L[3])
                bisect.insort(mintill,L[3])
                
    print(maxend[-1])
    print(minend[-1])
    print(maxtill[-1])
    print(mintill[-1])"
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')


for _ in range(int(input())):
    n = int(input())
    par = [0]*(n+5)
    mn = [0]*(n+5)
    mx = [0]*(n+5)

    mnNode = [0]*(n+5)
    mxNode = [0]*(n+5)
    u = 1

    mx[1] = mxNode[1] = 1

    for i in range(n):
        q = input().split()

        if q[0] == '+':
            u += 1
            p = int(q[1])
            x = int(q[2])

            mnNode[u] = min(mnNode[u], mnNode[p] + x)
            mxNode[u] = max(mxNode[u], mxNode[p] + x)
            mn[u] = min(mn[p], mnNode[u])
            mx[u] = max(mx[p], mxNode[u])

        else:
            {{completion}}","v = int(q[2])
            x = int(q[3])
            print('YES' if mn[v] <= x <= mx[v] else 'NO')","par[int(q[0])-1] = int(q[1])
            mn[int(q[0])-1] = int(q[2])
            mx[int(q[0])-1] = int(q[3])

    if mnNode[u] == mxNode[u]:
        print('No')
    else:
        print('Yes')

<|/ file source=github filename=Omsk.py "
"import sys
input = sys.stdin.readline

def solve():
    n, m, k = map(int, input().split())

    G = [[] for _ in range(n + m)]
    for _ in range(k):
        x1, y1, x2, y2 = [int(x) - 1 for x in input().split()]
        if y1 < y2:
            G[x1].append((n + y1, 1))
            G[n + y1].append((x1, 1))
        else:
            G[x1].append((n + y2, 0))
            G[n + y2].append((x1, 0))
    
    col = [-1] * (n + m)
    for i in range(n + m):
        if col[i] != -1:
            continue

        col[i] = 0
        stack = [i]
        while stack:
            u = stack.pop()
            for v, e in G[u]:
                if col[v] == -1:
                    col[v] = col[u] ^ e
                    stack.append(v)
                elif col[v] != col[u] ^ e:
                    {{completion}}
    
    return ""YES""

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","return ""NO""","col[v] = col[u] ^ e
                    break
    
    if col[n + m] == -1:
        return ""NO"""
"##from math import log,ceil
#e
t=int(input())
for _ in range(t):
##    n=int(input())
    n,m,k=map(int,input().split())
    kl=[]
    r=[[[],[],None] for i in range(n)]#r=1: [[same cols],[anti cols], pol_val]
    c=[[[],[],None] for i in range(m)]
    bg=r+c
    ini=True
    problem=False
    for i in range(k):
        x1,y1,x2,y2=map(int,input().split())
        if y2==y1+1:    #anti rd
            bg[n+y2-1][1].append(x2-1) #row x2 is anti to col y2 and vice versa
            bg[x2-1][1].append(n+y2-1)
        else:           #same ld
            bg[n+y1-1][0].append(x2-1)    #row x2 is same to col y2 and vice versa
            bg[x2-1][0].append(n+y1-1)
    #bipartite graph is complete
    #DFS on bg
##    for i in bg:
##        for j in i:
##            print(j)
    for i in range(n):
        if bg[i][2]!=None: continue
        st=[i]
        bg[i][2]=1
        while st:
            e=st.pop(-1)
            for nbr in bg[e][0]:    #same
                if bg[nbr][2]==None:
                    bg[nbr][2]=bg[e][2]
                    st.append(nbr)
                elif bg[nbr][2]!=bg[e][2]:
                    {{completion}}
            for nbr in bg[e][1]:    #anti
                if bg[nbr][2]==None:
                    bg[nbr][2]=-bg[e][2]
                    st.append(nbr)
                elif bg[nbr][2]==bg[e][2]:
                    problem=True
                    break
            if problem: break
        if problem: break
    if problem: print('no')
    else: print('yes')","problem=True
                    break","problem=True
                    break"
"import sys
from collections import deque
def input():
    return sys.stdin.readline().rstrip('\n')
show = sys.stdout.write
def print(s):
    return show(str(s)+'\n')


def work():
    n, m, k = map(int, input().split())
    tree = [list() for i in range(n+m-2)]
    for i in range(k):
        x1, y1, x2, y2=map(int, input().split())
        tree[x1-1].append((min(y1,y2)+n-2, int(y2 > y1)))
        tree[min(y1,y2)+n-2].append((x1-1, int(y2 > y1)))

    ans = [-1]*len(tree)
    
    for i in range(len(tree)):
        if ans[i] == -1:
            q = deque([i])
            ans[i]=0
            while q:
                cur = q.popleft()
                for j,k in tree[cur]:
                    if ans[j]==-1:
                        ans[j]=k^ans[cur]
                        q.append(j)
                    elif ans[j] != k^ans[cur]:
                        {{completion}}
    return 'YES'

for _ in range(int(input())):   
    print(work())
        
",return 'NO',"ans[j]=-1
                        break
    return ans

def solve():"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    req = 0
    temp = 0
    ind = 0
    n = int(input())
    status = [0] * (n + 1)
    for x in map(int, input().split()):
        {{completion}}
    print(req)
","temp = req
        req = max(req, status[x] - n + ind + 1)
        status[x] = max(status[x], temp + n - ind)
        ind = ind + 1","status[x] += 1
    status[0] -= 1
    status[-1] -= 1
    status[1] -= 1
    status[2] += 1
    status[3] += 1
    status[4] += 1
    status[5] += 1
    status[6] += 1
    status[7] += 1
    status[8] += 1
    status[9] += 1
    status[10] += 1
    status[11] += 1
    status[12] += 1
    status[13] += 1
    status[14] += 1
    status[15] += 1
    status[16] += 1
    status[17] += 1
    status[18] += 1
    status[19] += 1
    statu"
"import sys

for _ in range(int(input())):
    n = int(sys.stdin.readline())
    a = list(map(int, sys.stdin.readline().split()))
    dp = [0] * n
    dp[0] = 1
    min_dp = [11111111111111] * (n + 1)

    min_dp[a[0]] = 0

    for i in range(1, n):
        {{completion}}

    print(n - dp[-1])
","dp[i] = dp[i - 1] + 1

        dp[i] = min(dp[i], min_dp[a[i]])
        min_dp[a[i]] = min(min_dp[a[i]], dp[i - 1])","j = i
        while j > 0 and a[j - 1] > a[j]:
            j -= 1
        dp[i] = dp[j] + dp[j - 1]
        min_dp[i] = min(dp[i], min_dp[j] + 1)"
"import sys
ci = sys.stdin.readline
for _ in range(int(ci())):
    n = int(ci())
    pre = [94879487]*n
    a = list(map(lambda x: int(x)-1, ci().split()))
    dp = [0]*(n+1)
    dp[0] = n
    for i, num in enumerate(a):
        if pre[num] == 94879487:
            dp[i] = dp[i-1]
        else:
            {{completion}}
        pre[num] = min(pre[num], i - dp[i-1])
    print(dp[n-1])","dp[i] = max(dp[i-1], i - pre[num] + 1)","j = dp[pre[num]]
            dp[i] = dp[j] + 1"
"import sys
 
input = sys.stdin.readline
 
n, k = map(int, input().split())
a = list(map(int, input().split()))
index = []
for i in range(n):
    if a[i] == 1:
        index.append(i)
 
MOD = 10 ** 9 + 7
m = len(index)
dp = [[0] * 1501 for _ in range(1501)]
 
for i in range(k + 1):
    dp[0][i] = int(i % 2 == 0)
 
j0 = 0
for i in range(1, n + 1):
    if j0 < m and index[j0] < i:
        j0 += 1
    for j in range(min(i, m, j0 + 40) - 1,max(0, j0 - 40) -1,-1):
        dis = abs(index[j] - i + 1)
        for t in range(k, dis - 1, -1):
            {{completion}}
 
print(dp[m][k])","dp[j + 1][t] += dp[j][t - dis]
            dp[j + 1][t] %= MOD","dis -= t
            if dis < 0:
                dis += m
            dp[i][j] = dp[i - 1][j - t][dp[i - 1][j - t][j - t]] % MOD
 
print(dp[n][k])
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
"
"import sys

input = sys.stdin.readline

n, k = map(int, input().split())
a = list(map(int, input().split()))
index = []
for i in range(n):
    if a[i] == 1:
        index.append(i)

Mod = 10 ** 9 + 7
m = len(index)
dp = [[0] * 1501 for _ in range(1501)]
# 有几个球，花费了多少步。
for i in range(k + 1):
    dp[0][i] = int(i%2 == 0)
j0 = 0
for i in range(1,n + 1):
    if j0 < m and index[j0] < i:
        j0 += 1
    for j in range(min(i,m,j0 + 40) - 1,max(0,j0 - 40) -1,-1):
        dis = abs(index[j] - i + 1)
        for t in range(k,dis - 1,-1):
            {{completion}}
print(dp[m][k])","dp[j + 1][t] += dp[j][t - dis]
            dp[j + 1][t] %= Mod","dis = dis - t
            if dis <= 40:
                dp[i][j] = dp[i][j - t] + dp[i][j]
                break
            if dis > 40:
                dp[i][j] = dp[i][j - t] + dp[i][j - t - dis - 40]
                break
print(dp[n][k])
print(dp[m][k])
print(dp[m][k] % Mod)
<|/ a tags=algorithm,dynamic-programming |>"
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n, k, q = map(int, input().split())

    count = 0
    p = 0
    for c in map(int, input().split()):
        if c > q:
            if p >= k:
                {{completion}}
            p = 0
        else: p += 1
    if p >= k and p > 0: count += (p-k+1)*(p-k+2)//2
    #print(p,k)
    print(count)",count += (p-k+1)*(p-k+2)//2,"count += (p-k+1)*(p-k+2)//2
            p += 1
        elif c < q:"
"from sys import stdout, stdin
from math import comb

def solve(arr, n, d, t):
    i = 0
    ans = 0
    while i < n:
        if arr[i] > t:
            {{completion}}

        j = i + 1
        while j < n and arr[j] <= t:
            j += 1
        if j - i >= k:
            ans += comb(j - i - k + 2, j - i - k)
        i = j

    return str(ans)


ans = []
for _ in range(int(stdin.readline())):
    n, k, q = map(int, stdin.readline().split())
    arr = [int(x) for x in stdin.readline().split()]
    ans.append(solve(arr, n, k, q))

stdout.write('\n'.join(ans))
","i += 1
            continue","i += 1
            continue"
"import math, os, sys
from collections import defaultdict
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")
import sys
input = sys.stdin.readline

# Main code here.
def solve():
    n,k,q = map(int,input().split())
    arr = list(map(int, input().split()))

    cnt,res = 0, 0
    for val in arr:
        if val <= q: 
            cnt += 1
        else: 
            if cnt >= k: 
                {{completion}}
            cnt = 0 

    if cnt >= k: 
        res += ((cnt - k + 1)*(cnt - k +2)) // 2
    print(res)

for _ in range(int(input())):
    solve()
# solve()

sys.stdout.close() 
sys.stdin.close()",res += ((cnt - k + 1)*(cnt - k +2)) // 2,"res = (cnt - k + 1)*(cnt - k +2)//2
            print(res)"
"for p in[*open(0)][2::2]:
 y=[0]*100
 for x in p.split():{{completion}}
 print('YNEOS'[sorted(y)<y::2])",y[int(x)]-=1,"
  y[x]=y[x]+1"
"t = int(input())
for i in range(t) : 
  n = int(input())
  l = list(map(int,input().split()))
  l.sort()
  f = 0
  for j in range(l[n-1]) :
    if l.count(j) < l.count(j+1) :
      {{completion}}
  if f == 0 :
    print(""YES"")
  else :
    print(""NO"")","f = 1
      break",f = f+1
"for s in[*open(0)][2::2]:
 a=[0]*100
 for x in s.split():{{completion}}
 print('YNEOS'[sorted(a)<a::2])",a[int(x)]-=1,"
  a[int(x)]+=1"
"for _ in range(int(input())):
    {{completion}}","input()
    s1,s2=sum(map(int,input().split())),sum(map(int,input().split()))
    print('Tsondu' if s1>s2 else 'Tenzing' if s1<s2 else 'Draw')","n, m = map(int, input().split())
    monsters = [list(map(int, input().split())) for _ in range(n)]
    monsters_ability = [m[i] for m in monsters for i in range(m)]
    monsters_ability.sort()
    monsters_ability.append(0)
    monsters_ability.append(0)
    monsters_ability.sort()
    monsters_ability.append(0)
    monsters_ability.append(0)
    monsters_ability.sort()
    monsters_ability.append(0)
    monsters_ability.append(0)
    monsters_ability.sort()
    monsters_"
"t=int(input())
result=[]
for j in range(t):
    f=input()
    s=input()
    alist=[int(d) for d in s.split()]
    d=input()
    blist=[int(x) for x in d.split()]
    if sum(alist)==sum(blist):
        result.append(""Draw"")
    elif sum(alist)>sum(blist):
        {{completion}}
    else:
        result.append(""Tenzing"")
for res in result:
    print(res)","result.append(""Tsondu"")","alist.reverse()
        blist.reverse()
        result.append(""Tsondu"")
    elif sum(alist)<sum(blist):
        alist.reverse()
        blist.reverse()
        result.append(""Tenzing"")"
"import sys
 
def sol():
    input = sys.stdin.readline
    tuple(map(int,input().split()))

    nums1= sum(map(int,input().split()))
    nums2 = sum(map(int,input().split()))

    if nums1 == nums2:{{completion}}
    if nums1 > nums2:return print(""Tsondu"")
    print(""Tenzing"")

    
 
 
for _ in range(int(input())):
    sol()","return print(""Draw"")","return print(""Tsondu"")"
"import sys
input = sys.stdin.readline
for _ in range(int(input())):
    n, m = map(int,input().split())
    ok = []
    for i in range(m):
        l,r = map(int,input().split())
        ok.append((l,r))
    q = int(input())
    qs = [int(input()) for i in range(q)]
    l = 1
    r = q
    ans = -1
    while l <= r:
        m = (l+r)//2
        a = [0]*(n+1)
        for i in range(m):
            a[qs[i]] = 1
        psa = [0]*(n+1)
        for i in range(1,n+1):
            psa[i] = psa[i-1]+a[i]
        pos = False
        for x, y in ok:
            if (psa[y]-psa[x-1])*2 > y-x+1:
                {{completion}}
        if pos:
            r = m-1
            ans = m
        else:
            l = m+1
    print(ans)
",pos = True,"pos = True
                break"
"import sys
input = sys.stdin.readline
rounds = int(input())
for ii in range(rounds):
  out=0
  length,segl=map(int,input().split())
  seg=[]
  for r in range(segl):
    a1,a2=map(int,input().split())
    seg.append((a1,a2))
  change=[]
  cc=int(input())
  for l in range(cc):
    c=int(input())
    change.append(c)
  summ=[0]*(length+1)
  for c in change:
    summ[c]=1
  for r in range(1,len(summ)):
    summ[r]+=summ[r-1]
  # check if there is an answer
  for se in seg:
    l1=se[0]
    l2=se[1]
    if summ[l2]-summ[l1-1]>(l2-l1+1)//2:
      out=1
  if out==0:
    print(-1)
  else:
    # binary search for answer
    low=0
    high=len(change)-1
    while low<high:
      has=False
      mid=(low+high)//2
      cur=[0]*(length+1)
      for x in range(mid+1):
        cur[change[x]]=1
      for s in range(1,len(cur)):
        cur[s]+=cur[s-1]
      for s in seg:
        if cur[s[1]]-cur[s[0]-1]>(s[1]-s[0]+1)//2:
          {{completion}}
      if has:
        high=mid
      else:
        low=mid+1
      #print(low)
    print(low+1)","has=True
          break","has=True
          break"
"#!/usr/bin/python3

import bisect
import collections
import heapq
import io
import math
import os
import random
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
Mod = 1000000007
# Mod = 998244353

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def euk(x, y):
    if y:
        p, q, g = euk(y, x % y)
        return (q, p - (x // y) * q, g)
    return (1, 0, x)

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

T = 1
T = int(_input())
for _ in range(T):
  n, m = map(int, _input().split())
  a = [tuple(map(int, _input().split())) for _ in range(m)]
  q = int(_input())
  b = [int(_input()) for _ in range(q)]

  def test(k):
    c = [-1] * (n + 1)
    for i in range(k):
      c[b[i]] = 1
    for i in range(n):
      c[i + 1] += c[i]
    for l, r in a:
      if c[r] > c[l - 1]:
        {{completion}}
    return False

  lo, hi = 0, q + 1
  while lo < hi:
    mid = (lo + hi) // 2
    if test(mid):
      hi = mid
    else:
      lo = mid + 1
  print(lo if lo <= q else -1)
",return True,"x, y = euk(r, l - 1)
        if x != y:
          return False
    return True

  lo, hi = 0, q + 1
  while lo < hi:
    mid = (lo + hi) // 2
    if test(mid):
      hi = mid
    else:
      lo = mid + 1
  print(lo if lo <= q else -1)
  
  T = 1
  T = int(_input())
  for _ in range(T):
    n, m = map(int, _input().split())
    a = [tuple(map(int, _input().split())) for _ in range(m)]
    q = int(_input())
    b = [int(_input()) for _ in range(q)]

    def test(k):
      c = [-1]"
"import sys
input = sys.stdin.readline
 
for t in range(int(input())):
  n, x = map(int, input().split())
  res = 0
  for i in range(3):
    for zn in map(int, input().split()):
      if x | zn != x: {{completion}}
      res |= zn
  print(""Yes"" if res == x else ""No"")",break,"res += 1
      if zn != x: res += 1"
"def solve_B():
  n, x = map(int, input().split())
  k = 0
  for _ in range(3):
    a = list(map(int, input().split()))
    i = 0
    while i < n and (a[i] | x) == x:
      {{completion}}
  return ""Yes"" if x == k else ""No""
  
if __name__ == ""__main__"":
  t = int(input())
  sol = [solve_B() for _ in range(t)]
  for v in sol: print(v)","k |= a[i]
      i += 1","i += 1
    k += i
  k += n"
"from collections import defaultdict, deque
from sys import stdin, stdout
import heapq
from math import ceil 
 
input = stdin.readline
 
def get():
    return [int(i) for i in input().split(' ')]
 
def go():
    return int(input())
 
t = go()
 
 
for _ in range(t):
    n, x = get() 

    cur = 0 

    for _ in range(3):
        nums = get() 
        for num in nums:
            if x | num != x:
                {{completion}} 
            cur |= num

    print(""Yes"" if cur == x else ""No"") ",break,"heapq.heappushpop(cur, num)
            else:
                heapq.heappush(cur, num)
"
"from sys import stdin
input = stdin.buffer.readline

for _ in range(int(input())):
    n = int(input())
    ans = []
    last, mini, snd = -1, float('inf'), False
    for x in map(int,input().split()):
        if not snd:
            if x >= last:
                last = x
                ans.append('1')
                mini = min(mini, x)
            elif mini >= x:
                last = x
                ans.append('1')
                snd = True
            else:
                ans.append('0')
        else:
            if mini >= x >= last:
                last = x
                ans.append('1')
            else:
                {{completion}}
    print(''.join(ans))
",ans.append('0'),ans.append('0')
"import sys

m = sys.stdin
n = int(next(m)[:-1])
k = 0
for t in m:
   t = t[:-1]
   if k%2 == 0:
      j = int(t)
      k += 1
      continue
   line = map(int, t.split())
   if j == 2:
      print(""11"")
      continue
   elif j == 1:
      print(""1"")
      continue
   sys.stdout.write('11')
   first = next(line)
   lem = next(line)
   drops = (1 if first > lem else 0)
   for _ in range(2, j):
      t = next(line)
      if drops == 1:
         if first >= t and lem <= t:
            sys.stdout.write('1')
            #s += ""1""
            lem = t
         else:
            sys.stdout.write('0')
            #s += ""0""
      elif drops == 0:
         if lem > t and first >= t:
            drops += 1
            sys.stdout.write('1')
            #s += ""1""
            lem = t
         elif lem > t:
            {{completion}}
         else:
            sys.stdout.write('1')
            #s += ""1""
            lem = t
   sys.stdout.write('\n')
   k += 1","sys.stdout.write('0')
            #s += ""0""","sys.stdout.write('0')
            #s += ""0""
         elif first >= t:
            drops += 1
            sys.stdout.write('1')
            #s += ""1""
            lem = t"
"import sys
#import collections
import math
#import bisect
#import heapq
#import itertools
#import functools
input = sys.stdin.readline

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    flag = True
    ls = [1]
    prev = arr[0]
    for num in arr[1:]:
        if flag:
            if num >= prev:
                ls.append(1)
                prev = num
            else:
                if num > arr[0]:
                    ls.append(0)
                else:
                    flag = False
                    ls.append(1)
                    prev = num
        else:
            if num < prev:
                ls.append(0)
            else:
                if num > arr[0]:
                    ls.append(0)
                else:
                    {{completion}}
    print(''.join(map(str, ls)))
    

 


  



    


    

    
    



t = int(input())
for _ in range(t):
    solve()","ls.append(1)
                    prev = num","flag = False
                    ls.append(1)
                    prev = num
    if flag:
        ls.append(0)
    else:
        ls.append(1)
    "
"from sys import stdin, stdout

ans = []
for _ in range(int(stdin.readline())):
    n = int(stdin.readline())
    for x in range(2, 64):
        k = int(n**(1/x))
        if k < 2 or (n*(k-1) == k**(x+1) - 1):
            {{completion}}
    ans.append('YES' if k >= 2 else 'NO')

stdout.write('\n'.join(ans))
",break,"ans.append('YES' if k >= 2 else 'NO')
            break
    else:
        ans.append('NO')

stdout.write('\n'.join(ans))
""""""
<|/ file source=github |>"
"import sys, math
input = sys.stdin.readline
 
M = int(1e9) + 7    

def check(x, y):
    p = 1
    for i in range(1, y+1):
        p = 1 + x*p
    return p
 
def solve():
    n = int(input())
    
    for i in range(2, math.ceil(math.log(n) / math.log(2))):
        c = int(math.pow(n, 1/i))
        if check(c, i) == n:
            {{completion}}
    return 'NO'

 
for _ in range(int(input())):
    print(solve())",return 'YES',"k = i
            break
 
    if k > 1:
        return 'YES'
    else:"
"from math import floor
precompute=set()
for k in range(2,1000):
    base=k*(k+1)+1
    while base<=10**18:
        precompute.add(base)
        base=k*base+1
t=int(input())
for _ in range(t):
    n=int(input())
    if n<=12:
        if n==7:
            print(""YES"")
        else:
            print(""NO"")
    elif n in precompute:
        print(""YES"")
    else:
        answer=""NO""
        for p in range(2,6):
            k=floor(n**(1/p))
            while k**p>n:
                {{completion}}
            while (k+1)**(p)<=n:
                k+=1
            base=1+k
            for _ in range(2,p+1):
                base=k*base+1
            if base==n:
                answer=""YES""
        print(answer)",k-=1,"k+=1
            k=k-1"
for s in[*open(0)][2::2]:{{completion}},"a,b=map(s[:-1].split,'<>');print(max(map(len,a+b))+1)","
    s=s.strip()
    s=s.replace('>','')
    s=s.replace('<','')
    s=s.split(',')
    s=sorted(s)
    cost=0
    for i,x in enumerate(s):
        if x=='<':
            cost+=1
        else:
            cost-=1
        if cost==0:
            break
    print(cost)
<|/ file filename=ArrayCompatibleStrings.py source=github |>"
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
    
    dp = [0] * n
    stack = [0]
    par = [-1] * n
    while stack:
        v = stack.pop()
        if v >= 0:
            leaf = True
            for u in G[v]:
                if u != par[v]:
                    {{completion}}
            if leaf:
                dp[v] += 1
        else:
            v = ~v
            dp[par[v]] += dp[v]
            
    q = int(input())
    res = []
    for _ in range(q):
        x, y = [int(x) - 1 for x in input().split()]
        res.append(dp[x] * dp[y])
    return ""\n"".join(map(str, res))

    
T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","leaf = False
                    par[u] = v
                    stack.append(~u)
                    stack.append(u)","leaf = False
                    par[u] = v
                    stack.append(u)"
"from sys import stdin
import sys
def input(): return stdin.readline()[:-1]
ans = []
from collections import deque, defaultdict
def solve():
    N = int(input())
    graph = defaultdict(list)

    for _ in range(N-1):
        a,b = map(int, input().split())
        a -= 1
        b -= 1
        graph[a].append(b)
        graph[b].append(a)
    
    bfs = deque([0])
    visited = [False] * N
    parent = [-1] * N
    visited[0] = True
    order = []
    while bfs:
        node = bfs.popleft()
        order.append(node)
        for child in graph[node]:
            if not visited[child]:
                visited[child] = True
                parent[child] = node
                bfs.append(child)

    dp = [0] * N
    for node in reversed(order):
        if len(graph[node]) == 1 and node != 0:
            dp[node] = 1
        else:
            for child in graph[node]:
                if child != parent[node]:
                    {{completion}}
    for _ in range(int(input())):
        a,b = map(int, input().split())
        a -= 1
        b -= 1
        ans.append(dp[a] * dp[b])



    

for _ in range(int(input())):
    solve()

sys.stdout.write('\n'.join(map(str, ans)))",dp[node] += dp[child],"dp[child] = dp[node]
                    break
    "
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')
from math import inf
from collections import deque

for _ in range(int(input())):
    n, m = map(int, input().split())
    symp = int(input(), 2)
    time = []
    cure = []
    ill = []

    for i in range(m):
        time += [int(input())]
        cure += [int(input(), 2)]
        ill += [int(input(), 2)]

    dp = [inf]*(1<<n)
    dp[symp] = 0
    q = deque([symp])

    while q:
        x = q.popleft()
        for i in range(m):
            y = x
            y ^= (y & cure[i])
            y |= ill[i]
            if dp[y] > dp[x] + time[i]:
                {{completion}}
        
    print(dp[0] if dp[0] != inf else -1)","dp[y] = dp[x] + time[i]
                q += [y]","dp[y] = dp[x] + time[i]
                q.append(y)"
"import sys
from heapq import heappop, heappush
input = sys.stdin.readline
INF = 10 ** 9

def solve():
    n, m = map(int, input().split())
    s = int(input().rstrip(), base=2)
    edges = []
    for _ in range(m):
        d = int(input())
        x = int(input().rstrip(), base=2)
        y = int(input().rstrip(), base=2)
        edges.append((d, x, y))

    dist = [INF] * (1 << n)
    dist[s] = 0
    h = [(0, s)]
    
    while h:
        d, msk = heappop(h)
        if dist[msk] != d:
            continue

        for w, x, y in edges:
            nmsk = (msk & ~x) | y
            if dist[nmsk] > d + w:
                {{completion}}

    return dist[0] if dist[0] < INF else -1


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","dist[nmsk] = d + w
                heappush(h, (dist[nmsk], nmsk))","dist[nmsk] = d + w
                heappush(h, (dist[nmsk], nmsk))"
"import sys
input = sys.stdin.readline
def fg():
    return int(input())
def fgh():
    return [int(xx) for xx in input().split()]
def sd():
    print('YES')
def df():
    print('NO')
def tt():
    sys.stdout.flush()
M = 998244353
def intt(s):
    ans = 0
    for i in range(n - 1, -1, -1):
        ans += 2 ** i * int(s[n - i - 1])
    return ans
for __ in range(fg()):
    n, m = fgh()
    r = intt(input()[:-1])
    y = []
    z = []
    for i in range(m):
        d = fg()
        s1 = 2 ** n - 1 - intt(input()[:-1])
        s2 = intt(input()[:-1])
        y.append((s1, s2))
        z.append(d)
    o = [M] * (2 ** n)
    o[r] = 1
    for _ in range(10):
        for i in range(m):
            for j in range(2 ** n):
                {{completion}}
    print(o[0] % M - 1)
","e = y[i][0]
                f = y[i][1]
                o[(j & e) | f] = min(o[(j & e) | f], o[j] + z[i])","o[j] += y[i][j]
    for i in range(n):
        if o[i] == 1:
            df()
        else:
            sd()
            break
    if o[M] == 1:
        tt()
    else:
        sd()
        break
    if o[M] == M:
        tt()
    else:
        sd()
        break
    if o[M] == M - 1:
        tt()
    else:
        sd()
        break
    if o[M] == M - 2:
        tt()
    else:
        sd()
        break
    if o[M] == M - 3:
        tt()
    else:
        sd()
        break"
"from sys import stdin
input = stdin.buffer.readline

for _ in range(int(input())):
    n = int(input())
    ans = 0
    for _ in range(n):
        a, b = map(int,input().split())
        if a - b > 0:
            {{completion}}
    print(ans)",ans += 1,"ans += 1
        elif a - b < 0:
            ans -= 1"
"import sys


def main():
    q = int(sys.stdin.readline())

    res = []
    for _ in range(q):
        t = int(sys.stdin.readline())

        ans = 0
        for _ in range(t):
            a, b = map(int, sys.stdin.readline().split())
            if a > b:
                {{completion}}

        res.append(ans)

    print('\n'.join(map(str, res)))


if __name__ == '__main__':
    main()",ans += 1,"a, b = b, a
            ans += (a - b) // 2"
"from sys import stdin
 
input = stdin.readline
 
for _ in range(int(input())):
    MNR = int(input())
    L = list(map(int, input().split()))
    Res = max(L)
    if Res < 0:
        print(Res)
    else:
        {{completion}}","print(max(sum([li for li in L[::2] if li > 0]), sum([li for li in L[1::2] if li > 0])))","L.sort()
        L.insert(MNR-Res, Res)
        print(L)
<|/ file filename=mysterious-particles.py |>"
"# compiler on CodeForces: PyPy 3 64bit
import sys
input = lambda: sys.stdin.readline()[:-1]
print = lambda *args: sys.stdout.write(' '.join(map(str, args)) + '\n')

def solve(n, c):
    result = max(c)
    if result < 0:
        return result

    odd, even = 0, 0
    for i in range(n):
        if i % 2 == 0:
            even += max(c[i], 0)
        else:
            {{completion}}

    return max(odd, even)


for _ in range(int(input())):
    n = int(input())
    c = [int(e) for e in input().split()]
    print(solve(n, c))
","odd += max(c[i], 0)","odd += max(c[i], 0)"
"from sys import stdin as input

t = int(input.readline())

for _ in range(t):
    n = int(input.readline())
    p = list(map(int, input.readline().split()))

    if n == 1:
        print(p[0])
    else:
        p_odd = sum([p[i] for i in range(0, n, 2) if p[i] > 0])
        p_even = sum([p[i] for i in range(1, n, 2) if p[i] > 0])

        if p_odd == 0 and p_even == 0:
            max_odd = max([p[i] for i in range(0, n, 2)])
            max_even = max([p[i] for i in range(1, n, 2)])
            print(max(max_odd, max_even))
        else:
            {{completion}}","print(max(p_odd, p_even))","p_odd = sum([p[i] for i in range(0, n, 2) if p[i] > 0])
            p_even = sum([p[i] for i in range(1, n, 2) if p[i] > 0])

            if p_odd == 0 and p_even == 0:
                max_odd = max([p[i] for i in range(0, n, 2)])
                max_even = max([p[i] for i in range(1, n, 2)])
                print(max(max_odd, max_even))
            else:
                p_odd = sum([p[i] for i in range(0, n, 2) if p[i] > 0])
                p_even = sum([p[i] for i in range(1, n, 2) if p[i] > 0])

                if p_odd == 0 and p_even == 0:
                    max_odd = max([p[i] for i in range("
"import sys
t = int(sys.stdin.readline())
limit = 10**6

possible = set()
for i in range(2, 1000):
    outer = i*i
    x = 1 + i + i*i
    while x <= limit:
        possible.add(x)
        outer *= i
        x += outer

for _ in range(t):
    n = int(sys.stdin.readline())
    if n in possible:
        print(""YES"")
    else:
        {{completion}}
    ","print(""NO"")","possible.remove(n)
        print(""NO"")
<|/ file source=github |>"
"import math
n=int(input())
i=1
ls=[]
while(i<=n):
    ls+=[int(input())]
    i+=1
bigdic={}
i=2
while(i<=1000):
    j=3
    s=1+i+i**2
    while(s<=10**6):
        bigdic[s] = True
        s+=i**j
        j+=1
    i+=1
i=0

while(i<n):
    if(ls[i] in bigdic):
        print(""YES"")
    else:
        {{completion}}
    i+=1



","print(""NO"")","bigdic[ls[i]] = False
    print(""NO"")"
"import sys
input = sys.stdin.readline
s = set()
for i in range(2, 1000):
    count = 1 + i + (i**2)
    for j in range(3, 20):
        if count <= 10**6:
            s.add(count)
            count += i**j
        else:
            {{completion}}
for _ in range(int(input())):
    n = int(input())
    if n in s:
        sys.stdout.write(""YES"" + ""\n"")
    else:
        sys.stdout.write(""NO"" + ""\n"")
        ",break,"s.add(count)
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j
            count += i**j"
"def f(n):
    while n%2==0:
        n//=2
    return n
sieve=[0]*(10**6+1)
for i in range (2,10**6+1):
    if sieve[i]==0:
        for j in range (i,10**6+1,i):
            if sieve[j]==0:
                sieve[j]=i
from collections import defaultdict
x,q,M=map(int,input().split())
query=list(map(int,input().split()))
d=defaultdict(int)
res=1
x=f(x)
y=set()
cnt=0
while x>1:
    for i in range (2,int(x**(1/2))+1):
        if x%i==0:
            while x%i==0:
                d[i]+=1
                x//=i
            if (d[i]+1)%M==0:
                cnt+=1
                y.add(i)
            else:  
                {{completion}}
            break
    else:
        d[x]+=1
        res*=2
        break
for i in query:
    x=f(i)
    while x>1:
        tmp=sieve[x]
        if tmp in y:
            y.remove(tmp)
            cnt-=1
        else:
            res*=pow(d[tmp]+1,-1,M)
            res%=M
        while x%tmp==0:
            x//=tmp
            d[tmp]+=1
        if (d[tmp]+1)%M==0:
            y.add(tmp)
            cnt+=1
        else:
            res*=d[tmp]+1
            res%=M
    if cnt==0: print(res)
    else: print(0)","res*=d[i]+1
                res%=M","res*=d[i]+1
                res%=M"
"import sys
input = sys.stdin.buffer.readline
 
MAXN = 1000000
 
spf = [-1] * (MAXN + 2)
for i in range(2, MAXN + 1):
    if spf[i] == -1:
        for j in range(i + i, MAXN + 1, i):
            spf[j] = i
 
def calc(x):
    pfac = {}
    while spf[x] != -1:
        if pfac.get(spf[x], -1) == -1: pfac[spf[x]] = 0
        pfac[spf[x]] += 1
        x //= spf[x]
    if x != 1:
        if pfac.get(x, -1) == -1: pfac[x] = 0
        pfac[x] += 1
    res, ret = 1, 1
    for k, v in pfac.items():
        if k == 2:
            continue
        if used.get(k, -1) == -1:
            used[k] = 0
            res *= (v + 1)
        else:
            {{completion}}
        used[k] += v
    return res, ret
 
x, _, mod = map(int,input().split())
used = {}
ans = 1
c = 0
 
while x % 2 == 0:
    x //= 2
for i in range(3,int(x**.5)+1,2):
    if x % i == 0:
        v = 0
        while x % i == 0:
            v += 1
            x //= i
        if used.get(i, -1) == -1: used[i] = 0
        used[i] += v
        a = (v + 1)
        while a % mod == 0:
            c += 1
            a //= mod
        ans *= a
if x != 1:
    if used.get(x, -1) == -1: used[x] = 0
    used[x] += 1
    ans *= 2
 
for xi in map(int,input().split()):
    a, b = calc(xi)
    while a % mod == 0:
        c += 1
        a //= mod
    ans = (ans * a) % mod
    while b % mod == 0:
        c -= 1
        b //= mod
    ans = (ans * pow(b, -1, mod)) % mod
    print(0 if c else ans)","ret *= (used[k] + 1)
            res *= (used[k] + v + 1)","used[k] += v
            ans *= (v + 1)
            c += 1
            if c % mod == 0:
                ans *= pow(2, -1, mod)
                c -= 1
        if k == x:
            break
        if k > x:
            break
        if used.get(k, -1) == -1: used[k] = 0
        res *= (v + 1)
        if k > x:
            break
        if used.get(k, -1) == -1: used[k] = 0
        res *= (v + 1)
        if k > x:
            break
        if used.get(k, -1) == -1: used[k] = 0
        res *= (v + 1)
        if k > x:
            break
        if used."
"from collections import Counter
from functools import lru_cache
N = int(pow(10 ** 9, 0.5)) + 5
def get_prime_linear(n):
    global cnt
    for i in range(2, n + 1):
        if not st[i]:
            primes[cnt] = i
            cnt += 1
        for j in range(n):
            if primes[j] > n / i: break
            st[primes[j] * i] = True
            if i % primes[j] == 0: break 
primes, cnt, st = [0] * (N + 5), 0, [False] * (N + 5)
get_prime_linear(N)
prime1e3 = primes[:cnt]
@lru_cache(None)
def get_factor(n):
    res = []
    for i in prime1e3:
        if i * i > n:
            break
        while n % i == 0:
            n //= i
            res.append(i)
    if n > 1:
        res.append(n)
    return res

x,q,mod=list(map(int,input().split()))
a=list(map(int,input().split()))
cnt=Counter()
cur=1
f=get_factor(x)
z=0
calc=[0]*2000010
calc[1]=1
for i in range(2,2000010):
    calc[i] = (mod -  mod // i) * calc[mod % i] % mod
for j in f:
    if j%2:
        cnt[j]+=1
        cur=cur*(cnt[j]+1)*calc[cnt[j]%mod]%mod
for i in a:
    f=get_factor(i)
    for j in f:
        if j%2:
            cnt[j]+=1
            if cnt[j]%mod==mod-1:
                cur=cur*calc[cnt[j]%mod]%mod
                z+=1
            elif cnt[j]%mod==0:
                {{completion}}
            else:
                cur=cur*(cnt[j]+1)*calc[cnt[j]%mod]%mod
    print(cur if z==0 else 0)","cur=cur*(cnt[j]+1)%mod
                z-=1","cur=cur*(cnt[j]+1)*calc[cnt[j]%mod]%mod
                z+=1"
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')

 
def inputia(): return list(map(int,input().split()))

def inputInt(): return int(input())

for test in range(1):
    n,m,q = inputia()

    s = input()
    nxt = [-1] * (n + 1)
    
    def find(u):
        path = []
        while nxt[u] != -1 and nxt[u] != u:
            path.append(u)
            u = nxt[u] 
        for i in path: nxt[i] = u
        return u
    
    ptra = [-1] * n
    ra = []
    for _ in range(m):
        l, r = inputia()
        l-=1
        r-=1
        u = find(l)
        while u <= r:
            ptra[u] = len(ra)
            ra.append(u)
            nxt[u] = u + 1
            u = find(u)

    mx_rank = len(ra)

    arr = [1 if c == '1' else 0 for c in s]

    cnt = sum(arr)
    ans = sum([arr[ra[i]]^1 for i in range(min(cnt, mx_rank))])
    for _ in range(q):
        i = inputInt() - 1
        
        if ptra[i] != -1 and ptra[i] < cnt:
            ans += 1 if arr[i] else -1
        if arr[i] == 0:
            arr[i] = 1
            cnt += 1
            if (cnt <= mx_rank and arr[ra[cnt - 1]] == 0):
                ans += 1
        else:
            arr[i] = 0
            if cnt > 0 and cnt <= mx_rank and arr[ra[cnt - 1]] == 0:
                {{completion}}
            cnt -= 1
        print(ans)
        ",ans -= 1,ans -= 1
"class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n

    def find(self, node):
        node_copy = node
        while node != self.parent[node]:
            node = self.parent[node]
        while node_copy != node:
            self.parent[node_copy], node_copy = node, self.parent[node_copy]
        return node

    def union(self, a, b):# the parent of the group is always the biggest element
        a, b = self.find(a), self.find(b)
        a,b=(b,a) if a>b else a,b # b is always the bigger element
        if a != b:
            self.num_sets -= 1
            self.parent[a] = b
            self.size[b] += self.size[a]
            return True
        return False

import sys
input=sys.stdin.readline
n,m,q=map(int,input().split())
x=list(map(int,list(input().strip())))
sorted_by_importance=[]
union_find=UnionFind(n+1)
for _ in range(m):
    start,end=map(lambda z:int(z)-1,input().split())
    next=union_find.find(start)
    while next<=end:
        sorted_by_importance.append(next)
        union_find.union(next,next+1)
        next=union_find.find(next)

ones=x.count(1)
ans=min(len(sorted_by_importance),ones)
last_index=ones-1
included=[False]*n
for i in range(min(last_index+1,len(sorted_by_importance))):
    ans-=(x[sorted_by_importance[i]]==1)
    included[sorted_by_importance[i]]=True
for _ in range(q):
    index=int(input())-1
    if x[index]==0:
        last_index+=1
        if last_index<len(sorted_by_importance):
            ans+=(x[sorted_by_importance[last_index]]==0)
            included[sorted_by_importance[last_index]]=True
        ans-=included[index]
    else:
        if last_index<len(sorted_by_importance):
            {{completion}}
        ans+=included[index]
        last_index-=1
    x[index]=1-x[index]
    print(ans)","included[sorted_by_importance[last_index]] = False
            ans -= (x[sorted_by_importance[last_index]] == 0)","ans+=(x[sorted_by_importance[last_index]]==1)
            included[sorted_by_importance[last_index]]=True
        last_index+=1
        if last_index<len(sorted_by_importance):
            ans+=(x[sorted_by_importance[last_index]]==0)
            included[sorted_by_importance[last_index]]=True"
"from sys import stdin
# from sortedcontainers import SortedList
import functools
input=lambda:stdin.readline().strip()
n,m,q=map(int,input().split())
s=[0]+list(map(int,list(input())))
def find(x):
    if x==node[x]:
        return node[x]
    node[x]=find(node[x])
    return node[x]
node=[i for i in range(n+3)]
priority=[-1]*(n+1)
pri=1
# S=SortedList([i for i in range(n+2)])
for i in range(m):
    l,r=map(int,input().split())
    while l<=r:
        # print(l,node)
        l=find(node[l])
        if l<=r:
            {{completion}}
# print(priority,node)
length=pri-1
for i in range(1,n+1):
    if priority[i]==-1:
        priority[i]=pri
        pri+=1
priority[0]=0
# print(priority)
SUM=[0]*(n+1)
def lowbit(x):
    return x&(-x)
def update(index,d):
    while index<=n:
        SUM[index]+=d
        index+=lowbit(index)
def find(index):
    ret=0
    while index>0:
        ret+=SUM[index]
        index-=lowbit(index)
    return ret
# print(priority)
for i in range(1,n+1):
    if s[i]:
        update(priority[i],1)
# print(SUM)
for i in range(q):
    x=int(input())
    if s[x]==0:
        update(priority[x],1)
    else:
        update(priority[x],-1)
    s[x]^=1
    count=find(n)
    if count<=length:
        print(min(count,length)-find(count))
    else:
        print(length-find(length))

","priority[l]=pri
            pri+=1
            node[l]=r+1
            l+=1","s[l]+=s[r]
            s[r]-=s[l]
            r=find(node[r])
        else:
            l=find(node[l])
            r=find(node[r])
    # print(l,r)
    priority[find(node[l])]+=find(node[r])
    priority[find(node[r])]-=find(node[l])
    s[l]+=s[r]
    s[r]-=s[l]
    # print(s,node)"
"import sys
input = sys.stdin.readline
def solve():
    s, k = list(map(int, input().split()))
    r = s * k
    while k > 0 and s % 2 != 0:
        k -= 1
        s += s % 10
        r = max(r, k * s)
    if s % 10 == 0:
        print(r)
    else:
        t = max((5 * k - s) // 40 - 2, 0)
        s += 20 * t
        k -= 4 * t
        for j in range(min(20, k)):
            {{completion}}
        print(r)
for _ in range(int(input())):
    solve()","r = max(r, s * k)
            s += s % 10
            k -= 1","s += 10
            r = max(r, s * 10)
        if s % 10 == 0:
            print(r)
        else:
            t = max((5 * k - s) // 40 - 2, 0)
            s += 20 * t
            k -= 4 * t
            for j in range(min(20, k)):
                s += 10
                r = max(r, s * 10)
            if s % 10 == 0:
                print(r)
            else:
                t = max((5 * k - s) // 40 - 2, 0)
                s += 20 * t
                k -= 4 * t
                for j in range(min(20, k)):
                    s += 10
                    r = max(r, s * 10)
                if s % 10 == 0:
                    print(r)
                else:
"
"import sys

input = sys.stdin.readline

t = int(input())
for _ in range(t):
    s,k = map(int,input().split())
    if s%10 == 0:
        print(s * k)
        continue
    if s % 10 == 5:
        print(max(s * k,(s + 5) * (k - 1)))
        continue
    ans = 0
    while s % 10 != 2 and k:
        ans = max(ans,s * k)
        s += s % 10
        k -= 1
    # [2,4,6,8] fx = (s + 20 * x)*(k - 4 * x)

    def cal(x):
        return (s + 20 * x) * (k - 4 * x)

    left = 0
    right = k // 4
    while right - left >= 3:
        diff = right - left
        mid_left = left + diff // 3
        mid_right = left + 2 * diff // 3
        if cal(mid_left) < cal(mid_right):
            left = mid_left
        else:
            {{completion}}

    s += 20 * left
    k -= 4 * left

    for i in range(min(k + 1,60)):
        ans = max(ans,s * k)
        s += s % 10
        k -= 1
    print(ans)
",right = mid_right,"right = mid_right
    
    left = max(left,0)
    right = min(right,k)"
"import sys
input = sys.stdin.readline    

t=int(input())
for tests in range(t):
    s,k=map(int,input().split())

    ANS=s*k

    for i in range(10):
        s+=s%10
        k-=1
        ANS=max(ANS,s*k)

        if k==0:
            {{completion}}

    if k==0 or s%10==0:
        print(ANS)
        continue

    #print(ANS)

    kai=(20*k-4*s)//160

    ss=max(0,kai-30)

    s+=20*ss
    k-=4*ss

    for i in range(300):
        s+=s%10
        k-=1
        ANS=max(ANS,s*k)

        if k==0:
            break

    print(ANS)

    
",break,"ANS=0
            break"
"for s in[*open(0)][2::2]:
 t=r=0;d=1
 for x in map(int,s.split()):
  t+=abs(x)
  if x<0:{{completion}}
  if x>0:d=1
 print(t,r)",r+=d;d=0,r=abs(x)
"for s in[*open(0)][2::2]:
 t=r=0;d=1
 for x in map(int,s.split()):
  if x<0:{{completion}}
  if x>0:t+=x;d=1
 print(t,r)
 ",t-=x;r+=d;d=0,"t+=x;d=1
 print(t,r)
 t=r=0;d=1
 for x in map(int,s.split()):
  if x>0:t+=x;d=1
 print(t,r)
 t=r=0;d=1
 for x in map(int,s.split()):
  if x<0:t+=x;d=1
 print(t,r)
 t=r=0;d=1
 for x in map(int,s.split()):"
"for s in[*open(0)][2::2]:
 t=r=0;d=1
 for x in map(int,s.split()):
  if x<0:{{completion}}
  if x>0:t+=x;d=1
 print(t,r)",t-=x;r+=d;d=0,"t+=x;d=1
 print(t,r)
for s in[*open(0)][1::2]:
 t=r=0;d=1
 for x in map(int,s.split()):"
"import sys

input = sys.stdin.readline

# 结论题，思考异或关于2的幂次的性质，注意数据范围
n = int(input())
a = list(map(int, input().split()))

ans = 0
while n//2:
    n //= 2
    if all(a[i] == a[i + n] for i in range(n)):
        continue
    else:
        ans += n
        for i in range(n):
            {{completion}}
print(ans + (a[0] != 0))
",a[i] ^= a[i + n],"ans ^= a[i]
        n //= 2
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^= n
        ans ^"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

n, = I()

a = I()

def solve(a):
	if len(a) == 1:
		if a[0]:
			{{completion}}
		return 0
	half = len(a) // 2

	for i in range(half):
		if a[i] != a[i + half]:
			break
	else:
		return solve(a[:half])

	b = [a[i] ^ a[i + half] for i in range(half)]
	return half + solve(b)

print(solve(a))
",return 1,"print('-1')
			return -1
		print('0')
		return 0
	half = len(a) // 2

	for i in range(half):
		if a[i] != a[i + half]:
			break
	else:
		return solve(a[:half])

	b = [a[i] ^ a[i + half] for i in range(half)]
	return half + solve(b)

print(solve(a))
""""""
<|/ file source=github ext=.py |>"
"import sys
input = sys.stdin.buffer.readline

n = int(input())
a = list(map(int,input().split()))

ans = 0
size = n

while size != 1:
    if not all(a[i] == a[i + size // 2] for i in range(size // 2)):
        for i in range(size // 2):
            {{completion}}
        ans += size // 2
    size //= 2

print(ans if a[0] == 0 else ans + 1)",a[i] ^= a[i + size // 2],"a[size // 2 - 1 - i] = a[size // 2 - i]
        ans += 1
    else:"
"t = int(input())
for i in range(t):
    {{completion}}","n = int(input())
    print('Alice' if n >= 5 else 'Bob')","n, = map(int, input().split())
    board = [int(x) for x in input().split()]
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"for i in range(int(input())):
    kl=int(input())
    if kl<=4: 
        print(""Bob"")
    else: 
        {{completion}}
   	   	            		 	 	  	 	","print(""Alice"")","
        for i in range(kl):
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            "
"p= int(input())
while p:
	k = int(input())
	if k < 5:
		print(""Bob"")
	else:
		{{completion}}
	p -= 1
	  	   	 			  	 	 		 	    	   	","print(""Alice"")","for i in range(k):
			n= int(input())
			a= n
			b= n
			c= n
			d= n
			e= n
			f= n
			g= n
			h= n
			for i in range(n):
				if a==1:
					a= a-1
					b= b+1
					c= c+1
					d= d+1
					e= e+1
					f= f+1
					g= g+1
					h= h+1
				elif b==1:
					a= a+1
					b= b-1
					c= "
"for s in[*open(0)][1:]:{{completion}}
","n,k=map(int,s.split());print(min(n+1,1<<min(k,30)))","
    n, k = map(int, s.split())
    ans = 0
    for i in range(n):
        ans += (1 << i)
    print(ans)
<|/ file source=github |>"
"import math
for _ in range(int(input())):
    n , k = map(int , input().split())
    
    if k> 60:
        print(n+1)
    else:
        {{completion}}","print(min(2**k, n+1))","sum = 0
        for i in range(k):
            sum += math.pow(2,i)
        print(sum)
<|/ file source=github "
"testCases = int(input())

for testCase in range(testCases):
	{{completion}}","n, k = [int(i) for i in input().split()]
	print(min(1 + n, 1 << min(k, 30)))","n, k = map(int, input().split())
	
	count = 0
	
	for i in range(n):
		count += 2**i
		
	print(count)
<|/ file source=github filename=Toma.py "
"import sys

input = sys.stdin.readline


def solve():
    s = input()[:-1]
    m = int(input())
    l = input()[:-1]
    r = input()[:-1]
    start = 0
    mx = -1
    for i in range(m):
        digits = int(r[i]) - int(l[i]) + 1
        for d in range(digits):
            ch = chr(ord(l[i]) + d)
            id = s[start:].find(ch)
            if id == -1:
                {{completion}}
            mx = max(mx, id + start)
        start = mx + 1
    print(""NO"")


for _ in range(int(input())):
    solve()
","print(""YES"")
                return","mx = 0
                break
            if id > -1:"
"import sys
input=sys.stdin.readline

for i in range(int(input())):
    x=input().strip()
    tr=int(input())
    a=input().strip()
    b=input().strip()
    ind=0
    se=set()
    t=0
    u=ord(b[ind])-ord(a[ind])+1
    for i in x:
        if b[ind]>=i>=a[ind] and i not in se:
            se.add(i)
            t+=1
            if t==u:
                t=0
                ind+=1
                se=set()
                if ind==tr:
                  {{completion}}
                u=ord(b[ind])-ord(a[ind])+1

    else:
        print(""YES"")","print(""NO"")
                  break","print(""YES"")
                else:
                  print(""NO"")
                break
            else:"
"import sys
input = sys.stdin.readline
rounds = int(input())
for ii in range(rounds):
  out=0
  data=input()
  data=[d for d in data]
  if data[-1]=='\n':
    data.pop()
  length=int(input())
  left=input()
  right=input()
  ind=0
  ans='NO'
  for l in range(length):
    low=int(left[l])
    high=int(right[l])
    has=set()
    last=0
    while ind<len(data):
      if low<=int(data[ind])<=high:
        {{completion}}
      if len(has)==high-low+1:
        last=1
        break
      ind+=1
    #print(ind,has,l)
    if ind==len(data):
      ans='YES'
      break
    if last>0:
      ind+=1
  print(ans)",has.add(data[ind]),"has.add(data[ind])
      ind+=1
    if len(has)==length-1:
      last=1
      break
    ind+=1
    while ind<len(data):
      if low<=int(data[ind])<=high:
        has.add(data[ind])
      ind+=1
    if len(has)==length-1:
      last=1
      break
    ind+=1
    while ind<len(data):
      if low<=int(data[ind])<=high:
        has.add(data[ind])
      ind+=1
    if len(has)==length-1:
      last=1
      break
    ind+=1
    while ind<len(data):
      if low"
"for a in[*open(0)][1:]:{{completion}}
","print(sum(i!=j for i,j in zip(a,""codeforces"")))","
    s=input()
    s=s.lower()
    s=s.replace(' ','')
    s=s.replace('$','')
    s=s.replace(' ','')
    s=s.replace('(','')
    s=s.replace(')','')
    s=s.replace(',','')
    s=s.replace(':','')
    s=s.replace(';','')
    s=s.replace('!','')
    s=s.replace('?','')
    s=s.replace(',','')
    s=s.replace(':','')
    s=s.replace(';','')
    s=s.replace('!','')
    s=s.replace('?"
"for t in range(int(input())):
    a=input()
    b=""codeforces""
    count=0
    for i in range(len(b)):
        if(b[i]!=a[i]):
            {{completion}} 
    print(count)",count+=1,"count+=1
            break"
"t=int(input())

for _ in range(t):
    a=str(input().strip())
    b='codeforces'
    count=0

    for i in range(10):
        if a[i]!=b[i]:
            {{completion}}
    
    print(count)",count+=1,count+=1
"import sys

input = sys.stdin.readline

""""""

""""""


def solve():
    n, m = map(int, input().split())
    s = input().strip()

    l, r = [-1] * n, [n] * n

    j = n
    for i in range(n - 1, -1, -1):
        if s[i] == ""1"":
            {{completion}}
        r[i] = j

    j = -1
    for i in range(n):
        if s[i] == ""0"":
            j = i
        l[i] = j

    res = set()
    for _ in range(m):
        x, y = map(lambda x: int(x) - 1, input().split())
        x, y = r[x], l[y]
        if x > y:
            x = y = -1
        res.add((x, y))

    print(len(res))


for _ in range(int(input())):
    solve()
",j = i,j = i
"from sys import stdin


def main():
    n, m = stdin.readline().split()
    n, m = int(n), int(m)
    s = stdin.readline().strip()
    l, r = [], []
    for _ in range(m):
        ll, rr = stdin.readline().split()
        ll, rr = int(ll), int(rr)
        l.append(ll-1)
        r.append(rr-1)

    r1, l0 = [0] * n, [0] * n
    prev = -1
    for i in range(n):
        if s[i] == '0':
            l0[i] = i
        else:
            {{completion}}
        prev = l0[i]
    prev = n
    for i in range(n-1, -1, -1):
        if s[i] == '1':
            r1[i] = i
        else:
            r1[i] = prev
        prev = r1[i]

    unchanged = 0
    sett = set()

    for i in range(m):
        fl = r1[l[i]]
        fr = l0[r[i]]
        if fl >= fr:
            unchanged = 1
        else:
            sett.add((fl, fr))
    
    print(len(sett) + unchanged)


t = stdin.readline()
t = int(t)

for _ in range(t):
    main()
",l0[i] = prev,"prev = l0[i]
    prev = -1
    for i in range(n):
        if s[i] == '1':
            r1[i] = i
        else:
            r1[i] = prev
        prev = r1[i]

    unchanged = 0
    sett = set()

    for i in range(m):
        fl = r1[l[i]]
        fr = l0[r[i]]
        if fl >= fr:
            unchanged = 1
        else:
            sett.add((fl, fr))
    
    print(len(sett) + unchanged)


if __name__ == '__main__':
    main()
""""""
<|/ file ext=.py source=github |>"
"import sys
input = sys.stdin.readline
for _ in range(int(input())):
    n,m = map(int,input().split())
    s = input()
    S = set()
    L0 = [-1 for i in range(n)]
    R1 = [-1 for i in range(n)]
    if s[0] == ""1"":
        L0[0] = -1
    else:
        L0[0] = 0
    if s[-1] == ""1"":
        R1[-1] = n-1
    else:
        R1[-1] = n

    for i in range(1,n):
        if s[i] == ""0"":
            L0[i] = i
        else:
            {{completion}}
    for i in range(n-2,-1,-1):
        if s[i] == ""1"":
            R1[i] = i
        else:
            R1[i] = R1[i+1]
    # print(R1)
    # print(L0)
    S = set()
    for i in range(m):
        l,r = map(int,(input().split()))
        lR = R1[l-1]
        rL = L0[r-1]
        if lR<rL:
            S.add((lR,rL))
        else:
            S.add((-1,-1))
    print(len(S))



",L0[i] = L0[i-1],"R1[i] = L0[i-1]
    # print(L0)
    # print(R1)
    for i in range(1,n):
        if s[i] == ""1"":
            R1[i] = i
        else:
            R1[i] = R1[i-1]
    # print(R1)
    # print(L0)
    S = set()
    for i in range(m):
        l,r = map(int,(input().split()))
        lR = R1[l-1]
        rL = L0[r-1]
        if lR<rL:
            S.add((lR,rL))
        else:
            S.add((-1,-1))
    print(len(S))

for _ in range(int(input())):
    n,m = map(int,input().split())
    s = "
"import sys; ipt = sys.stdin.readline
M = 10**9+10

for _ in range(int(ipt())):
    N = int(ipt())
    L = []
    for _ in range(N):
        l,_,_,b = map(int,ipt().split())
        L.append(l*M+b)
    Q = int(ipt())
    X = list(map(int,ipt().split()))
    Y = [x*M+i for i,x in enumerate(X)]

    Y.sort()
    L.sort()

    my,ml = -1,-1
    py,pl = 0,0
    while py < Q and pl < N:
        assert not (my==py and ml==pl)
        my,ml = py,pl
        lim = Y[py]//M
        while pl < N:
            l,b = L[pl]//M,L[pl]%M
            if l > lim:
                {{completion}}
            lim = max(lim,b)
            pl += 1
        while py < Q:
            if Y[py]//M > lim:
                break
            X[Y[py]%M] = lim
            py += 1
    
    print(*X)
            ",break,"lim = l
            if b > lim:"
"import sys
from bisect import bisect as bis
input=sys.stdin.readline
print=sys.stdout.write
pyin=lambda:map(int,input().split())
    
    
for _ in range(int(input())):
    seg,arr=[],[];n=int(input())
    for _ in range(n):
        l,r,a,b=pyin();seg.append([l,b])
    q=int(input());loc=list(pyin())
    seg=sorted(seg,key=lambda x:x[0])
    
    for i in seg:
        if arr and i[0]<=arr[-1][1]:
            arr[-1][1]=max(arr[-1][1],i[1])
        else: {{completion}}
    ans=[i[0] for i in arr]
 
    for i in range(q):
        j=bis(ans,loc[i])-1
        if j>=0:
            loc[i]=max(loc[i],arr[j][1])
        
    print(' '.join(map(str,loc))+'\n')
   
    
    
",arr.append(i),"arr.append(i)
    "
"# https://codeforces.com/contest/1859

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n = int(input())  # 1 <= n <= 2*10**5
    portals = [tuple(map(int, input().split())) for _ in range(n)]  # (l, r, a, b)

    left, right = [], []
    for i in sorted(range(n), key=lambda x: portals[x][0]):
        l, r = portals[i][0], portals[i][3]  # l, b
        if right and right[-1] >= l:
            right[-1] = max(right[-1], r)
        else:
            left += [l]
            right += [r]

    ans = []
    _ = input()
    for x in map(int, input().split()):
        low, high = 0, len(left) - 1
        while low + 1 < high:
            mid = (low + high) // 2
            if left[mid] <= x:
                low = mid
            else:
                {{completion}}
        if left[low] <= x < right[low]:
            ans += [right[low]]
        elif left[high] <= x < right[high]:
            ans += [right[high]]
        else:
            ans += [x]
    print(*ans)


for _ in range(int(input())):
    solve_case()
",high = mid,"high = mid
        low, high = 0, len(left) - 1
        while low + 1 < high:
            mid = (low + high) // 2
            if left[mid] <= x < right[mid]:
                low = mid
            else:
                high = mid"
"for nik in[*open(0)][1:]:
    {{completion}}","nik=int(nik)
    print(nik*2-bin(nik).count('1'))","nik=int(nik)
    tree=[1]
    tree.append(2)
    tree.append(3)
    tree.append(4)
    tree.append(5)
    tree.append(10)
    tree.append(11)
    tree.append(12)
    tree.append(13)
    tree.append(14)
    tree.append(15)
    tree.append(16)
    tree.append(17)
    tree.append(18)
    tree.append(19)
    tree.append(20)
    tree.append(21)
    tree.append(22)
    tree.append(23)
    tree.append(24)
    tree.append(25)
    tree.append(26)
    tree.append(27)
    tree.append("
for n in[*open(0)][1:]:{{completion}},n=int(n);print(n*2-bin(n).count('1')),"
    s=0
    s=s+n
    print s
<|/ file ext=.py source=github |>"
"for k in[*open(0)][1:]:
    {{completion}}","k = int(k);
    print(k*2 - bin(k).count('1'))","k=int(k)
    s=0
    for j in range(1,k+1):
        s=s+j
    print(s)
<|/ q dscore=0 |>
<| c |>
What is your question?
<|/ c |>
<| c |>
Please read [ask] and [edit] your question accordingly.
<|/ c |>
<| c |>
Please read [Why is “Can someone help me?” not an actual question?](https://meta.stackoverflow.com/questions/284236/why-is-can-someone-help-me-not-an-actual-question)
<|/ c |>
<| c |>
Please "
"# O(n)

# As we iterate over fixed R, maintain # of valid subarrays via 2 monotonic stacks.

# Easy dnq works too: Find max in range then iterate over the smaller seg for endpoint 1.
# Binary search for the closest endpoint 2 that is valid. Can use sparse table for all ops.


import sys
input = sys.stdin.buffer.readline

n = int(input())
a = [1e7] + list(map(int, input().split()))

ans = 0

valid = 0
inc = []
dec = []
end = [None] * (n+1)
for i in range(n+1):
    while inc and a[i] > a[inc[-1]]:
        if end[inc[-1]]:
            true_i, dec_i = end[inc[-1]]

            if dec_i < len(dec) and dec[dec_i] == true_i:
                valid -= true_i - inc[-1]

                if dec_i == 0 or dec[dec_i-1] < inc[-2]:
                    valid += true_i - inc[-2]
                    end[inc[-2]] = (true_i, dec_i)
                    end[true_i] = (inc[-2], None)
                else:
                    {{completion}}

        inc.pop()

    while dec and a[i] < a[dec[-1]]:
        if end[dec[-1]]:
            valid -= dec[-1] - end[dec[-1]][0]

        dec.pop()

    inc.append(i)
    dec.append(i)
    end[i] = (i, len(dec)-1)

    ans += valid

print(ans)
","valid += true_i - dec[dec_i-1]
                    end[true_i] = (dec[dec_i-1], None)","end[true_i] = (dec[dec_i-1], dec[dec_i])
                    end[dec[dec_i-1]] = (dec[dec_i], dec[dec_i-1])
                    end[dec[dec_i]] = (dec[dec_i], true_i)
            else:
                end[inc[-1]] = (dec[dec_i], true_i)
                end[dec[dec_i]] = (dec[dec_i], true_i)
                end[true_i] = (dec[dec_i], dec[dec_i])
                end[dec[dec_i]] = (true_i, dec[dec_i])
        else:
            end[inc[-1]] = (i-1, i)
            end[i] = (i, i)
"
"import sys
input = sys.stdin.readline
ans = 0
n = int(input())
a = [None] * n
L_mx = [None] * n
L_mn = [None] * n
R_mx = [None] * n
R_mn = [None] * n
#
def solve(i):
#    print(i, L_mx[i], R_mx[i])
    ans = 0
    if i - L_mx[i] <= R_mx[i] - i:
        for j in range(L_mx[i] + 1, i):
            ans += max(0, (min(R_mn[j], R_mx[i]) - i)) * max(0, j - max(L_mx[i], L_mn[j]));
    else:
        ans += (R_mx[i] - i) * (i - L_mx[i]) - 1
#        print(ans)
        for j in range(i + 1, R_mx[i]):
            {{completion}}
        
    return ans
    
a = [int(x) - 1 for x in input().split()]
#print(len(a))
for i in range(0, n):
#    a[i] = int(input())
    x = i - 1
    while x > -1 and a[x] > a[i]:
        x = L_mn[x]
    L_mn[i] = x
    x = i - 1
    while x > -1 and a[x] < a[i]:
        x = L_mx[x]
    L_mx[i] = x
        
for i in range(n - 1, -1, -1):
    x = i + 1
    while x < n and a[x] > a[i]:
        x = R_mn[x]
    R_mn[i] = x
    x = i + 1
    while x < n and a[x] < a[i]:
        x = R_mx[x]
    R_mx[i] = x

for i in range(n - 1, -1, -1):
    ans += solve(i)
    
print(ans)

","ans -= max(0, (min(R_mn[j], R_mx[i]) - j)) * max(0, i - max(L_mx[i], L_mn[j]));","ans += max(0, (min(R_mn[j], R_mx[i]) - i)) * max(0, j - max(L_mx[i], L_mn[j]));"
"import sys
input = sys.stdin.readline

from bisect import bisect,bisect_left

n=int(input())
A=list(map(int,input().split()))
A.reverse()

MAX=[-1]
MIN=[-1]
Weight=[0]*n

ANS=0
NOW=0

for i in range(n):
    a=A[i]

    while MIN[-1]!=-1 and A[MIN[-1]]>a:
        ind=MIN.pop()

        x0=bisect(MAX,ind)
        
        if x0==len(MAX):
            {{completion}}

        ind=MAX[x0]

        if ind==-1:
            continue

        x=bisect_left(MAX,ind)
        ind1=MAX[x-1]

        x=bisect_left(MIN,ind)
        ind2=MIN[x-1]
        
        nec=ind-max(ind1,ind2)

        if Weight[MAX[x0]]!=nec:
            NOW=NOW-Weight[MAX[x0]]+nec
            Weight[MAX[x0]]=nec

    MIN.append(i)

    while MAX[-1]!=-1 and A[MAX[-1]]<a:
        ind=MAX.pop()
        NOW-=Weight[ind]

    MAX.append(i)

    j=len(MAX)-1
    ind=MAX[j]

    x=bisect_left(MAX,ind)
    ind1=MAX[x-1]

    x=bisect_left(MIN,ind)
    ind2=MIN[x-1]
    
    nec=ind-max(ind1,ind2)

    if Weight[MAX[j]]!=nec:
        NOW=NOW-Weight[MAX[j]]+nec
        Weight[MAX[j]]=nec

    #print(MAX,MIN,NOW,ANS,Weight)
    #print(NOW,ANS)

    ANS+=NOW

print(ANS-n)
        
        
    
",continue,"MAX.append(ind)
            Weight[ind]+=1
            continue"
"import math
import itertools
import random
from heapq import *
import sys
from collections import deque # Usage: d=deque([])
def input():return sys.stdin.readline().strip() # fast IO
#input=lambda:sys.stdin.readline().rstrip('\r\n')
# sys.setrecursionlimit(999999999) # Will MLE PyPy but not Python
debug=1
# Leeisateam

t=int(input())
for tc in range(t):
    n,q=map(int,input().split())
    d={}
    div = []
    l=0 # length of array so far
    for i in range(n):
        b,x=map(int,input().split())
        if l <= 10**19:
            if b==1:
                d[l]=x

                l += 1
            else: # b == 2
                {{completion}}
    div.append(l)
    
    a=list(map(int,input().split())) # list of queirse
    
    for i in range(len(a)):
        a[i]-=1
    
    ans=[]
    div.sort(reverse=1)
    #print(""div:"",div) # debu g
    #print(""d"",d) # debug
    for i in range(q):
        ai = a[i]
        done = 0
        for j in div:
            if ai in d:
                ans.append(d[ai])
                done = 1
                break
            else:
                ai = ai%j
        if done==0:
            ans.append(d[ai])

        """"""
        if done==0:
            print(""a[i]:"",a[i],end="" "")
        else:
            print(d[ai],end="" "")
        """"""
        

    print(*ans)","div.append(l)
                l *= x+1","div.append(l)
                l += x
        else:
            break
    div.append(l)
    
    a=list(map(int,input().split())) # list of queirse
    
    for i in range(len(a)):
        a[i]-=1
    
    ans=[]
    div.sort(reverse=1)
    #print(""div:"",div) # debu g
    #print(""d"",d) # debug
    for i in range(q):
        ai = a[i]
        done = 0
        for j in div:
            if ai in d:
                ans.append(d[ai])
                done = 1
                break
            else:
                ai = ai%j
        if done==0:
            ans.append("
"import sys
import math
#not identical

def solve():
    inp = sys.stdin.readline
    n, q = map(int, inp().split())
    a = [0, 0]
    for i in range(n):
        b, x = map(int, inp().split())
        if a[0] >= 1e18:
            continue
        if b == 1:
            a.append(x)
            a[0] += 1
        else:
            a = [a[0] * (x + 1), x + 1, a]
    res = [None] * q
    i = -1
    #print(a)
    for k in map(int, inp().split()):
        i += 1
        k -= 1
        v = -1
        b = a
        while True:
            #print(b, k)
            x = b[1]
            if x > 0:
                l = b[2]
                if k >= l[0] * x:
                    v = str(b[3 + k - l[0] * x])
                    break
                else:
                    {{completion}}
            else:
                v = str(b[2 + k])
                break
        res[i] = v
        #print(v)
    print(' '.join(res))

def main():
    for i in range(int(sys.stdin.readline())):
        solve()

if __name__ == '__main__':
    main()
","b = b[2]
                    k = k % l[0]","v = str(b[3 + k])
                    break"
"import math
import sys
input=sys.stdin.readline
F=lambda:[*map(int,input().split())]
INF=10**18+1
for _ in range(int(input())):
    N,Q=F()
    size=0;prv=0
    OP=[]
    for _ in range(N):
        a,b=F()
        if size<INF:
            if a==1:
                size+=1
                if a==prv:
                    OP[-1].append(b)
                else:
                    OP.append([b])
            else:
                size*=b+1
                if a==prv:OP[-1]*=(b+1)
                else:{{completion}}
            prv=a
    K=F()
    K=[k-1 for k in K]
    ANS=[0]*Q
    for n in range(len(OP)-1,-1,-1):
        if n%2==1:
            size//=OP[n]
        else:
            size-=len(OP[n])
        for k in range(Q):
            if ANS[k]>0:continue
            if n%2==1:
                K[k]%=size
            else:
                if K[k]>=size:ANS[k]=OP[n][K[k]-size]
    print(*ANS)",OP.append(b+1),"OP.append([b+1])
        else:
            OP.append([b])
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
            OP[-1].append(b)
"
"import sys

input = sys.stdin.readline

from math import gcd

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    s = set()
    for i in range(n):
        if a[i] == 0 and b[i] == 0:
            {{completion}}
        gc = gcd(a[i], b[i])
        a[i] //= gc
        b[i] //= gc
        s.add((a[i]%2, b[i]%2))
    if len(s) <= 1:
        print(""YES"")
    else:
        print(""NO"")
# for a in range(3):
#     for b in range(3):
#         x1 = []
#         x2 = []
#         t1 = a
#         t2 = b
#         for k in range(10):
#             x1.append(t1)
#             x2.append(t2)
#             t1,t2 = t2,abs(t1-t2)
#         x = 2*gcd(a,b)[1] + 1
#         print(a,b,x,"":"",x1,x2)
",continue,"s.add((0,0))
            continue"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()

import math
def fix(a, b):
	if a == 0 and b == 0:
		return -1
	elif a == 0:
		return 1
	elif b == 0:
		return 2
	g = math.gcd(a, b)
	a //= g
	b //= g
	if (a % 2) * (b % 2) == 1:
		return 0
	elif a % 2:
		return 2
	else:
		return 1

for _ in range(t):
	n, = I()
	a = I()
	b = I()

	seen = [False] * 3
	for i in range(n):
		ind = fix(a[i], b[i])
		if ind != -1:
			{{completion}}

	if sum(seen) <= 1:
		print(""YES"")
	else:
		print(""NO"")
",seen[ind] = True,"seen[ind] = True
			a[i] = 0
			b[i] = 0"
"t=int(input())
for i in range(t):
    n=int(input())
    aux1=input()
    a=list(map(int,aux1.split()))
    aux2=input()
    b=list(map(int,aux2.split()))
    r=1
    for j in range(0,n):
        if ((a[j]!=0) or (b[j]!=0)):
            while ((a[j]%2==0) and (b[j]%2==0)):
                a[j]=a[j]//2
                b[j]=b[j]//2
            if a[j]%2==0:
                m=0
            elif b[j]%2==0:
                {{completion}}
            else:
                m=2
            break        
    for k in range(j,n):
        if ((a[k]!=0) or (b[k]!=0)):
            while ((a[k]%2==0) and (b[k]%2==0)):
                a[k]=a[k]//2
                b[k]=b[k]//2
            if a[k]%2==0:
                n=0
            elif b[k]%2==0:
                n=1
            else:
                n=2
            if n!=m:
                r=0
                break

    if r:
        print('YES')
    else:
        print('NO')",m=1,m1=1
"t = int(input())
import sys
input = sys.stdin.readline
for _ in range(t):
    n, k = map(int, input().split())
    c = list(map(int, input().split()))
    indices = {}
    for i, v in enumerate(c):
        if v not in indices:
            {{completion}}
        indices[v].append(i)
    for key in indices:
        indices[key].append(len(c))
    result = len(c)
    for i in indices:
        steps = []
        prev = -1
        for j in indices[i]:
            steps.append(j - prev - 1)
            prev = j
        steps.sort()
        steps[-1] //= 2
        result = min(result, max(steps))
    print(result)",indices[v] = [],"indices[v] = [i]
        else:"
"import sys

input = lambda: sys.stdin.buffer.readline()
mi = lambda: map(int, input().split())
li = lambda: list(mi())

# input.strip() - for string
# input.split() - array

out = []

for _ in range(int(input())):
    n, k = mi()
    c = li()
    prev = [-1 for _ in range(k+1)]
    maxs1 = [0 for _ in range(k+1)]
    maxs2 = [0 for _ in range(k+1)]
    res = 1000000000

    for i in range(n):
        step = i - prev[c[i]] - 1
        if step > maxs1[c[i]]:
            maxs2[c[i]] = maxs1[c[i]]
            maxs1[c[i]] = step
        elif step > maxs2[c[i]]:
            {{completion}}

        prev[c[i]] = i

    for i in range(1,k+1):
        step = n - prev[i] - 1
        if step > maxs1[i]:
            maxs2[i] = maxs1[i]
            maxs1[i] = step
        elif step > maxs2[i]:
            maxs2[i] = step

    for i in range(1,k+1):
        res = min(res, max(maxs1[i] // 2, maxs2[i]))

    out.append(str(res))

print('\n'.join(out))",maxs2[c[i]] = step,"step = 0
            maxs2[c[i]] = step"
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n, k = map(int, input().split())
    colors = list(map(int, input().split()))
    pos = [-1] * k
    steps = [0] * k
    skipped = [0] * k

    for idx in range(n):
        color = colors[idx] - 1
        diff = idx - pos[color] - 1
        pos[color] = idx

        if skipped[color] < diff:
            steps[color] = max(skipped[color], diff // 2)
            skipped[color] = diff
        elif diff > steps[color]:
            {{completion}}

    for color in range(k):
        diff = n - pos[color] - 1
        pos[color] = n

        if skipped[color] < diff:
            steps[color] = max(skipped[color], diff // 2)
            skipped[color] = diff
        elif diff > steps[color]:
            steps[color] = diff

    print(min(steps))
",steps[color] = diff,"steps[color] = diff

    print(min(steps))
</code>
<|/ a tags=algorithm,python,dynamic-programming |>
<| a dscore=0 |>
<code>
import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n, k = map(int, input().split())
    colors = list(map(int, input().split()))
    pos = [-1] * k
    steps = [0] * k
    skipped = [0] * k"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

def dist(A, B) -> int:
  {{completion}}

# dist(A, B) + dist(A, C) = dist(A, X) + dist(X, C) + dist(A, X) + dist(X, B)
# 2 * dist(A, X) + dist(X, C) + dist(X, B)
# 2 * dist(A, X) + dist(B, C)
# dist(A, X) = (dist(A, B) + dist(A, C) - dist(B, C)) // 2
for _ in range(int(readline())):
  A = list(map(int, readline().split()))
  B = list(map(int, readline().split()))
  C = list(map(int, readline().split()))

  print((dist(A, B) + dist(A, C) - dist(B, C)) // 2 + 1)",return abs(A[0] - B[0]) + abs(A[1] - B[1]),"x, y = A
  x2, y2 = B
  return abs(x - x2) + abs(y - y2)"
"import sys,math,cmath,time
from bisect import bisect_left
start_time = time.time()


def solve():
    xA,yA=map(int,inps())
    xB,yB=map(int,inps())
    xC,yC=map(int,inps())
    cX=0
    cY=0
    if((xB>xA and xA>xC) or (xC>xA and xA>xB)):
        cX=0
    else:
        {{completion}}
    # print(cX)
    if((yB>yA and yA>yC) or (yC>yA and yA>yB)):
        cY=0
    else:
        cY=min(abs(yA-yC),abs(yA-yB))
    print(cX+cY+1)






def main():

    testcases = 1
    testcases = inp()
    for each_testcase in range(testcases):
        solve()
    # if not ONLINE_JUDGE:
    #     print(""Time Elapsed :"",time.time() - start_time,""seconds"")
    #     sys.stdout.close()

def inp():
    return(int(input()))
def inps():
    return(input().split())

ONLINE_JUDGE = __debug__ # to use file IO, use not __debug__ instead
if ONLINE_JUDGE:
    input = sys.stdin.readline

main()

","cX=min(abs(xA-xC),abs(xA-xB))","left=bisect_left([(xA,yA),(xB,yB),(xC,yC)],(xA,yA))
        right=bisect_left([(xA,yA),(xB,yB),(xC,yC)],(xB,yB))
        middle=bisect_left([(xA,yA),(xB,yB),(xC,yC)],(xC,yC))
        cX=middle-min(left,right)"
"import sys
input = sys.stdin.readline

def readList():
    {{completion}}
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    xa, ya = readInts()
    xb, yb = readInts()
    xc, yc = readInts()
    return 1 + max(0, min(xb, xc) - xa) + max(0, xa - max(xb, xc)) + max(0, min(yb, yc) - ya) + max(0, ya - max(yb, yc))


for _ in range(int(input())):
    print(solve())","return list(map(int, input().split()))","lst = []
    while True:
        lst.append(input())
        if lst[-1] == '.':
            break
    return lst"
"from sys import stdin

input = stdin.readline

for _ in range(int(input())):
    n, m, h = map(int, input().split())
    cost = (-1, -1)
    ans = 1
    for i in range(n):
        s = sorted(map(int, input().split()))
        ci, till, cnti = 0, 0, 0
        for j in range(m):
            if till + s[j] <= h:
                ci += till + s[j]
                till += s[j]
                cnti += 1
            else:
                {{completion}}
        if i == 0:
            cost = (cnti, -ci)
        elif (cnti, -ci) > cost:
            ans += 1
    #
    # print(*costs)
    print(ans)
",break,"cost = (cnti, -ci)
                ans += 1
                ci, till, cnti = 0, 0, 0
                "
"from sys import stdin,stdout
raw_input = lambda: stdin.readline().rstrip()
input = lambda: int(raw_input())
I=lambda: map(int, raw_input().split())
P=lambda x: stdout.write(str(x)+'\n') 
t = input()
for _ in range(t):
	n,m,h = I()
	lst = list(I())
	lst.sort()
	s = 0
	q = 0
	p = 0
	for x in lst:
		s += x
		if s<=h:
			q += 1
			p += s
		else:
			break
	res = 1
	for _ in range(n-1):
		lst = list(I())
		lst.sort()
		s1 = 0
		q1 = 0
		p1 = 0
		for x in lst:
			s1 += x
			if s1<=h:
				q1 += 1
				p1 += s1
			else:
				{{completion}}
		if q1>q or (q1==q and p1<p):
			res += 1
	P(res)",break,break
"import sys

read = sys.stdin.readline
write = sys.stdout.write


def score(timer):
    inp = sorted(list(map(int, read().split())))
    time = solved = pen = 0
    for i in inp:
        if time + i > timer:
            {{completion}}
        time += i
        solved += 1
        pen += time
    return solved, pen


def solve():
    par, q, total = map(int, read().split())
    rank = 1
    solved, pen = score(total)
    for _ in range(par - 1):
        temp_solve, temp_pen = score(total)
        if temp_solve > solved:
            rank += 1
        if temp_solve == solved and temp_pen < pen:
            rank += 1

    return str(rank)


for _ in range(int(read())):
    write(solve() + '\n')",break,"time += i
            solved += 1
        pen += time
    return solved, pen


def solve():
    par, q, total = map(int, read().split())
    rank = 1
    solved, pen = score(total)
    for _ in range(par - 1):
        temp_solve, temp_pen = score(total)
        if temp_solve > solved:
            rank += 1
        if temp_solve == solved and temp_pen < pen:
            rank += 1

    return str(rank)


for _ in range(int(read())):
    write(solve() + '\n')
""""""


def score(timer):
    inp = sorted(list(map(int, read().split())))
    time = solved = "
"#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Task A: ""Subtraction Game"".
# import sys
# input = sys.stdin.readline
# printt = sys.stdout.write

# t = int(input())
# for _ in range(t):
	# a, b = map(int, input().split())
	# printt(str(a + b) + '\n')

# Task B: ""Permutations & Primes"".
from itertools import permutations
import sys
input = sys.stdin.readline
printt = sys.stdout.write

# res = {1: [1], 2: [2, 1], 3: [2, 1, 3], 4: [2, 1, 4, 3], 5: [5, 2, 1, 4, 3]}
# prim = {(1): 1, (2, 1): 2, (5, 2, 1, 4, 3): 8}

t = int(input())

# def is_prime(n):
	# if n <= 1: return False
	# elif n in (2, 3, 5, 7): return True
	# elif n % 2 == 0 or n % 3 == 0: return False
	# for d in range(2, int(n**(1/2)) + 1):
		# if n % d == 0: return False
	# return True

# def MEX(l):
	# L = sorted(l)
	# for i, e in enumerate(L):
		# if e != i + 1: return i + 1
	# return L[-1] + 1

# def primality(L):
	# if tuple(L) in prim: return prim[tuple(L)]
	# n, P = len(L), 0
	# for l in range(n):
		# for r in range(l + 1, n):
			# if is_prime(MEX(L[l:r])): P += 1
	# prim[tuple(L)] = P
	# return P

# def computeRes(n):
	# if n in res: return res[n]
	# if n - 1 not in res: computeRes(n - 1)
	# L = res[n - 1]
	# m, l = 0, []
	# for i in range(n):
		# L1 = L[:i] + [n] + L[i:]
		# m1 = primality(L1)
		# if m1 > m: m, l = m1, L1
	# res[n] = l
	# return l

#T = []
for _ in range(t):
	n = int(input())
	if n == 1: printt('1' + '\n')
	elif n == 2: {{completion}}
	else:
		L = list(range(5, n + 1, 2)) + [2, 1] + list(range(4, n + 1, 2)) + [3]
		printt(' '.join(map(str, L)) + '\n')
",printt('2 1' + '\n'),"printt('2' + '\n')
	elif n == 3: printt('3' + '\n')
	elif n == 4:
		L = list(range(5, n + 1, 2)) + [2, 1] + list(range(4, n + 1, 2)) + [3]
		printt(' '.join(map(str, L)) + '\n')
	elif n == 5:
		L = list(range(5, n + 1, 2)) + [2, 1] + list(range(4, n + 1, 2)) + [3]
		printt(' '.join(map(str, L)) + '\n')
	elif n == 6:
		L = list(range(5, n + 1, 2)) + [2, 1] + list(range(4, n + 1, 2)) + [3]
		printt(' '.join(map(str, L)) + '\n')
	elif "
"import sys

input = sys.stdin.readline

""""""

"""""" 

M = 1 << 8 

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    can = {0}
    
    xor = 0
    for ai in a:
        xor ^= ai 
        can.add(xor)
    
    res = 0
    for x in can:
        for y in can:
            {{completion}}
    
    print(res)

for _ in range(int(input())):
    solve()","res = max(res, x ^ y)","if(x == y):
                continue
            if(xor&x):
                can.remove(x)
                can.remove(y) 
                res = max(res, x-y)"
"import sys
def input(): return sys.stdin.readline().strip()
def getints(): return map(int,sys.stdin.readline().strip().split())

for _ in range(int(input())):
    n = int(input())
    l = list(getints()) 

    ta = [l[-1]]
    for x in reversed(range(n-1)):
        ta.append(ta[-1] ^ l[x])
    s = list(set(ta))

    ans = max(l+s)
    for i in range(len(s)):
        for j in range(i+1,len(s)):
            {{completion}}
    print(ans)","ans = max(ans,s[i] ^ s[j])","ans = max(ans, l[i] + l[j] + s[i])"
"from sys import stdin


def inp(): return stdin.readline().rstrip(""\r\n"")


for _ in range(int(inp())):
    n = int(inp())
    arr = [int(x) for x in inp().split()]
    x = 0
    s = set()
    for i in arr:
        x = x ^ i
        s.add(x)
    l = list(s)
    l.append(0)
    #print(l)
    ans = 0
    for i in range(len(l)):
        for j in range(i,len(l)):
            {{completion}}
    print(ans)","ans = max(ans,l[i]^l[j])","ans = max(ans, l[i] + l[j])"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    a = [[0 for _ in range(n)] for _ in range(4)]

    for i in range(n):
        x, y = map(int, input().split())
        a[0][i] = x
        a[1][i] = y
        a[2][i] = x + y
        a[3][i] = y - x

    ans = 0
    for i in range(4):
        a[i].sort()

        cnt = 1
        for j in range(1, n):
            if a[i][j] != a[i][j - 1]:
                {{completion}}
            cnt += 1
        ans += cnt * (cnt - 1)
    print(ans)
","ans += cnt * (cnt - 1)
                cnt = 0","cnt += 1
            else:
                break
        for j in range(1, n):
            if a[i][j] != a[i][j + 1]:
                cnt += 1
            else:
                break
        for j in range(1, n):
            if a[i][j] != a[i + 1][j]:
                cnt += 1
            else:
                break
        for j in range(1, n):
            if a[i][j] != a[i + 1][j + 1]:
                cnt += 1
            else:
                break
        for j in range(1, n):
            if a[i][j] != a[i + 2][j]:
                cnt += 1
            else:
                break
        for j in range(1, n):
            if a[i][j] != a[i + 2][j + 1]:
                cnt += 1
            else:
                break
        for j in range(1, n):
            if a[i][j] != a[i + 3]["
"
import sys
input = sys.stdin.readline


def f(w):
    x, t, e = 10**10, 0, 0
    for i in w:
        if i == x:
            t += 1
        else:
            {{completion}}

    e += ff(t)
    return e


def ff(p):
    return p*(p-1)


for _ in range(int(input())):
    n = int(input())
    a, b, c, d = [], [], [], []
    for i in range(n):
        x, y = map(int, input().split())
        a.append(x)
        b.append(y)
        c.append(x-y)
        d.append(x+y)
    q = 0
    for j in a, b, c, d:
        j.sort()
        q += f(j)
    print(q)","e += ff(t)
            t = 1
            x = i","e += ff(i)
    return t


def ff(t):
    x, t, e = 10**10, 0, 0
    for i in t:
        if i == x:
            t += 1
        else:
            e += ff(i)
    return e


def ff(t):
    x, t, e = 10**10, 0, 0
    for i in t:
        if i == x:
            t += 1
        else:
            e += ff(i)
    return e


def ff(t):
    x, t, e = 10**10, 0, 0
    for i in t:
        if i == x:
            t += 1
        else:
            e += ff(i)
    return e


def ff(t):
    x, t, e = 10**10, 0, 0
    for i in t:"
"import sys
input = sys.stdin.readline

for _ in range (int(input())):
    n = int(input())
    ls = [n*[0],n*[0],n*[0],n*[0]]
    for i in range (n):
        x = [int(j) for j in input().rstrip().split()]
        ls[0][i] = x[0]
        ls[1][i] = x[1]
        ls[2][i] = x[0] - x[1]
        ls[3][i] = x[0] + x[1]
    s = 0
    for i in range(4):
        ls[i].sort()
        p = 0
        cnt = 0
        for j in ls[i]:
            if j==p:
                s+=cnt
                cnt+=1
            else:
                {{completion}}
            p = j
    s*=2
    print(s)
",cnt = 1,"cnt=0
                s+=cnt
                cnt+=1"
"for s in[*open(0)][2::2]:
 r='';p=0
 for x in s:
  if p==0:p=x
  elif x==p:{{completion}}
 print(r)",r+=p;p=0,"r+=x
  else:r+=p+x
 print r
 r=''
 p=0
 for x in s:
  if p==0:p=x
  elif x==p:r+=x
  else:r+=p+x"
"t = int(input())
for _ in range(t):
	n = int(input())
	s = input()
	ans = 'a'
	while len(s) != 0:
		for i in range(1,n):
			if s[i] == s[0]:
				{{completion}}
	print(ans[1:])","ans = ans + s[i]
				s = s[i+1:]
				break","ans += s[i-1]
				s = s[1:]
			else:
				ans += s[i]
				s = s[1:]
		ans += s[0]
		s = s[1:]
	print(ans)
<|/ file source=github ext=.py |>"
"inpt=int(input())
while inpt>0:
  o=int(input())
  a1=input()
  k=""""
  i=0
  while i<o:
    {{completion}}
  print(k)
  inpt-=1","k+=a1[i]
    i+=a1[i+1:].index(a1[i])+2","k=k+a1[i]
    i=i+1"
"for s in[*open(0)][2::2]:{{completion}}
","n=len(a:=sorted(map(int,s.split())));print(sum(a[n-n//2:])-sum(a[:n//2]))","
    s=int(s)
    ans=0
    for x in range(1,s+1):
        if x in a:
            ans=max(ans,x-min(a))
    print(ans)
<|/ q dscore=0 |>
<| c |>
What have you tried so far? What is your question?
<|/ c |>
<| c |>
Please show us what you've tried so far.
<|/ c |>
<| c |>
I edited the question, please check it out
<|/ c |>
<| a tags=python,algorithm |>
<code>
for s in open(0):
    s=int(s)
"
"for i in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()
    s = 0
    for i in range(n//2):
        {{completion}}
    print(s)",s += a[-1-i] - a[i],"s += a[i]
    s += a[n//2]
    s += a[n//2+1]"
for s in[*open(0)][2::2]:{{completion}},"n=len(a:=sorted(map(int,s.split())));print(sum(a[n-n//2:])-sum(a[:n//2]))","
    s=s.split()
    s=map(int, s)
    s=sorted(s)
    s=list(s)
    s=sorted(s)
    s=sum(s)
    print s
<|/ file source=github filename=Sasha.py |>"
"from sys import stdin
input = stdin.readline

n = int(input())
a = [0] + [int(x) for x in input().split()] + [0]
ans = 0
for i in range(1, n+1):
    if a[i-1]:
        pass
    elif a[i] == 0 and a[i+1]:
        {{completion}}
    else:
        ans += 1
print(ans)",a[i+1] -= 1,"ans += 1
    elif a[i] == 0 and a[i-1]:
        ans += 1
    elif a[i] == 1 and a[i+1]:
        ans += 1
    elif a[i] == 1 and a[i-1]:
        ans += 1
    elif a[i] == 2 and a[i+1]:
        ans += 1
    elif a[i] == 2 and a[i-1]:
        ans += 1
    elif a[i] == 2 and a[i+1]:
        ans += 1
    elif a[i] == 2 and a[i-1]:
        ans += 1
    elif a[i] == 2 and a[i+1]:
        ans += 1
    elif a[i] == 2 and a[i-1]:
        ans += 1
    elif a[i] == 2 and a[i+1]:
        ans += 1
    elif a[i] == 2 and a"
"def main():
    n = int(input())
    a = list(map(int, input().split()))
    res = 1
    lf = 0
    was2 = False
    for i in range(1, n):
        if a[i - 1] == 0 and lf < i - 1:
            {{completion}}
        if a[lf] != 0 or a[i] != 0:
            was2 = was2 or (a[i] == 2)
            continue
        if was2:
            continue
        res += 1
        lf = i
        was2 = a[i] == 2
    print(res)


if __name__ == ""__main__"":
    main()
","res += 1
            lf = i
            was2 = a[i] == 2
            continue","was2 = True
            continue"
"n=int(input())
ar=list(map(int,input().split()))

ans=0

if(n==1):
    ans=1
    print(ans)
else:
    if(ar[0]!=0):
        ans+=1
    else:
        if(ar[1]!=0):
            ar[1]-=1
        else:
            {{completion}}
    
    for i in range(1,n-1):
        if(ar[i-1]!=0):
            ar[i-1]-=1
        elif(ar[i]):
            ans+=1
        elif(ar[i+1]):
            ar[i+1]-=1
        else:
            ans+=1
    if(ar[-2]==0):
        ans+=1
    print(ans)",ans+=1,"ans+=1
    if(ar[2]!=0):
        ans+=1
    else:
        if(ar[3]!=0):
            ar[3]-=1
        else:
            ans+=1
    if(ar[4]!=0):
        ans+=1
    else:
        if(ar[5]!=0):
            ar[5]-=1
        else:
            ans+=1
    if(ar[6]!=0):
        ans+=1
    else:
        if(ar[7]!=0):
            ar[7]-=1
        else:
            ans+=1
    if(ar[8]!=0):
        ans+=1
    else:
        if(ar[9]!=0):
            ar[9]-=1
        else:
            ans+=1"
"t = int(input()) 
for _ in range(t):
    {{completion}}","n,k = list(map(int,input().strip().split("" "")))
    a = list(map(int,input().strip().split("" "")))
    mods = [v%k if v%k != 0 else k for v in a]
    print("" "".join(map(str,sorted(list(range(1,n+1)), key=lambda i:mods[i-1], reverse=True))))","n, k = map(int, input().split())
    arr = [int(i) for i in input().split()]
    arr.sort()
    arr.sort(reverse=True)
    print(arr)
<|/ file ext=.py filename=Monocarp.py |>"
"# https://codeforces.com/contest/1849

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


# inspired by misorin's very fast implementations, let's experiment with this
def f(val, n, idx):
    {{completion}}


def solve_case():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    b = sorted(f(k - (x - 1) % k, n, i) for i, x in enumerate(a))
    print(*[x % n + 1 for x in b])


for _ in range(int(input())):
    solve_case()
",return val * n + idx,"val = val * n
    if val > n:
        return val
    if val == 0:
        return idx
    return f(val - 1, n, idx - 1)"
"def solve(k,a):
    {{completion}}

t = int(input())
while(t>0):
    t = t-1
    n,k = map(int,input().split())
    a = [int(x) for x in input().split()]
    solve(k,a)","a = [x % k if x % k > 0 else k for x in a]
    return print(' '.join([str(x+1) for x in sorted(range(len(a)), key=lambda k: a[k], reverse=True)]))","a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()
    a.append(0)
    a.sort()"
"import sys

input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n, m = map(int, input().split())

    adj = [[] for _ in range(n+1)]

    for _ in range(m):
        a, b, d = map(int, input().split())
        adj[b].append((a,d))
        adj[a].append((b,-d))

    ans = ""YES""

    dist = [0] * (n+1)
    for c in range(1, n+1):
        if not dist[c]:
            s = [(c, 10**18)]

            while s:
                c, d = s.pop()

                if not dist[c]:
                    dist[c] = d

                    for ne, w in adj[c]:
                        s.append((ne, d + w))
                else:
                    if dist[c] != d:
                        {{completion}}

    print(ans)
","ans = ""NO""","ans = ""NO""
                        break"
"import sys
rln=sys.stdin.buffer.readline
rl=lambda:rln().rstrip(b'\r\n')
ri=lambda:int(rln())
rif=lambda:[*map(int,rln().split())]
rt=lambda:rl().decode()
rtf=lambda:rln().decode().split()
inf=float('inf')
dir4=[(-1,0),(0,1),(1,0),(0,-1)]
dir8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

def solve():
  n,m=rif()
  a=[[] for _ in range(n)]
  for i in range(m):
    x,y,d=rif()
    x,y=x-1,y-1
    a[x].append((y,-d))
    a[y].append((x,d))
  c=[inf]*n
  for x in range(n):
    if c[x]!=inf:
      continue
    c[x],s=0,[x]
    while s:
      x=s.pop()
      for y,d in a[x]:
        if c[y]==c[x]+d:
          {{completion}}
        if c[y]!=inf:
          print('NO')
          return
        c[y]=c[x]+d
        s.append(y)
  print('YES')

t=ri()
for _ in range(t):
  solve()
",continue,"continue
        if c[y]!=inf:
          print('NO')
          return
        c[y]=c[x]+d
        s.append(y)
  print('YES')

def solve1():
  n,m=rif()
  a=[[] for _ in range(n)]
  for i in range(m):
    x,y,d=rif()
    x,y=x-1,y-1
    a[x].append((y,-d))
    a[y].append((x,d))
  c=[inf]*n
  for x in range(n):
    if c[x]!=inf:
      continue
    c[x],s=0,[x]
    while s:
      x=s.pop()
      for y,"
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')

class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.dis = [0] * n
        self.num_sets = n
 
    def find(self, x):
        st = []
        while x != self.parent[x]: 
            st += [x]
            x = self.parent[x]
        d = 0
        while st: 
            y = st.pop()
            self.parent[y] = x
            self.dis[y] += d
            d = self.dis[y]
        return x
 
    def union(self, u, v, d):
        x, y = self.find(u), self.find(v)
        self.num_sets -= 1
        self.parent[y] = x
        self.dis[y] = d - self.dis[v] + self.dis[u]

 
for _ in range(int(input())):
    n, m = map(int, input().split())
    g = DSU(n+1)
    ans = 'YES'

    for i in range(m):
        a, b, d = map(int, input().split())
        if g.find(a) != g.find(b):
            g.union(a, b, d)
        elif g.dis[b] - g.dis[a] != d:
            {{completion}}

    print(ans)",ans = 'NO',"ans = 'NO'
            break"
"import sys,random,bisect
from collections import deque,defaultdict,Counter
from heapq import heapify,heappop,heappush
import math 
from types import GeneratorType
#from functools import cache  3.9
mod = int(1e9 + 7) #998244353
inf = int(1e20)
input = lambda :sys.stdin.readline().rstrip()
MI = lambda :map(int,input().split())
li = lambda :list(MI())
ii = lambda :int(input())
py = lambda :print(""YES"")
pn = lambda :print(""NO"")
 
def find(x):
    t=x
    while fa[x]!=x:
        x=fa[x]
    while t!=x:
        fa[t],t=x,fa[t]
    return x
 
t=ii()
 
for _ in range(t):
    n,m=li()
    fa=list(range(n))
    hrr=li()
    edges=[]
    for _ in range(m):
        u,v=li()
        u-=1
        v-=1
        edges.append([max(hrr[u],hrr[v]),u,v])
    edges.sort(key=lambda x:-x[0])
    q=ii()
    res=[0]*q
    qrr=[]
    for i in range(q):
        a,b,e=li()
        qrr.append([i,a-1,b-1,e])
    qrr.sort(key=lambda x:x[3]+hrr[x[1]])
    for i,a,b,e in qrr:
        while edges and hrr[a]+e>=edges[-1][0]:
            _,u,v=edges.pop()
            fa[find(v)]=find(u)
        if find(a)==find(b):
            res[i]=""YES""
        else:
            {{completion}}
    for i in res:
        print(i)","res[i]=""NO""","res[i]=""NO"""
"import sys
input = sys.stdin.readline
K = 10 ** 6

def solve():
    n, m = map(int, input().split())
    H = list(map(int, input().split()))
    
    events = []
    edges = []
    for i in range(m):
        u, v = [int(x) - 1 for x in input().split()]
        edges.append((u, v))
        events.append(max(H[u], H[v]) * K + i)
    
    q = int(input())
    queries = []
    for i in range(q):
        a, b, e = map(int, input().split())
        a -= 1
        b -= 1
        queries.append((a, b, e))
        events.append((H[a] + e) * K + m + i)

    par = [-1] * n
    size = [1] * n

    def find(u):
        v = u
        while par[u] >= 0:
            u = par[u]
        while v != u:
            par[v], v = u, par[v]
        return u

    def union(u, v):
        u, v = find(u), find(v)
        if u == v:
            return
        if size[u] < size[v]:
            u, v = v, u
        par[v] = u
        size[u] += size[v]


    res = [""NO""] * q
    events.sort()
    
    for z in events:
        i = z % K
        if i < m:
            u, v = edges[i]
            union(u, v)
        else:
            i -= m
            a, b, _ = queries[i]
            if find(a) == find(b):
                {{completion}}
    
    return ""\n"".join(res)

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","res[i] = ""YES""","res[z - m] = ""YES""
            else:
                res[z - m] = ""NO"""
"import sys,random,bisect
from collections import deque,defaultdict,Counter
from heapq import heapify,heappop,heappush
import math 
from types import GeneratorType
#from functools import cache  3.9
mod = int(1e9 + 7) #998244353
inf = int(1e20)
input = lambda :sys.stdin.readline().rstrip()
MI = lambda :map(int,input().split())
li = lambda :list(MI())
ii = lambda :int(input())
py = lambda :print(""YES"")
pn = lambda :print(""NO"")
 
def find(x):
    t=x
    while fa[x]!=x:
        x=fa[x]
    while t!=x:
        fa[t],t=x,fa[t]
    return x
 
t=ii()
 
for _ in range(t):
    n,m=li()
    fa=list(range(n))
    hrr=li()
    edges=[]
    for _ in range(m):
        u,v=li()
        u-=1
        v-=1
        edges.append([max(hrr[u],hrr[v]),u,v])
    edges.sort(key=lambda x:-x[0])
    q=ii()
    res=[0]*q
    qrr=[]
    for i in range(q):
        a,b,e=li()
        qrr.append([i,a-1,b-1,e])
    qrr.sort(key=lambda x:x[3]+hrr[x[1]])
    for i,a,b,e in qrr:
        while edges and hrr[a]+e>=edges[-1][0]:
            _,u,v=edges.pop()
            fa[find(v)]=find(u)
        if find(a)==find(b):
            res[i]=""YES""
        else:
            {{completion}}
    for i in res:
        print(i)
 
 
 ","res[i]=""NO""","res[i]=""NO"""
"from collections import Counter
for _ in range(int(input())):
 n=int(input())
 counts=[0]*(n+1); steps=[0]*(n+1)

 for i in map(int,input().split()):
  if i<=n: {{completion}}

 for i,v in enumerate(counts):
  if v==0: continue
  s=i
  while s<=n: steps[s] += v; s+=i
 print(max(steps))",counts[i]+=1,"counts[i]+=1
  else: steps[i-1]+=1"
"def solve(n, frogs):
    
    count = [0 for _ in range(n)]
    jumps = [0 for _ in range(n)]
    for e in frogs:
        if e <= n:
            {{completion}}
    
    for i in range(1,n+1):
        e  = i
        
        if (count[i-1] == 0): continue
        
        while e <= n :
           
            jumps[e-1] +=count[i-1] 
            e += i
    return(max(jumps))

def main():
    t = int(input())

    for _ in range(t):
        n = int(input())
        jumps = list(map(int, input().split()))

        print(solve(n, jumps))



if __name__ == ""__main__"":
    main()
			 			      	   				 			 	  	",count[e-1]+=1,"count[e-1] += 1
    
    for i in range(1,n+1):
        e  = i
        
        if (count[i-1] == 0): continue
        
        while e <= n :
           
            jumps[e-1] +=count[i-1] 
            e += i
    return(max(jumps))

def main():
    t = int(input())

    for _ in range(t):
        n = int(input())
        frogs = list(map(int, input().split()))

        print(solve(n, frogs))



if __name__ == ""__main__"":
    main()
			 			      	   				 			 	  	
			 			      	   				 			 	  	
			 			      	   "
"for t in range(int(input())):
    n = int(input())
    l = [int(x) for x in input().split()]

    arr = [0]*(n+1)
    for x in l:
        try:
            arr[x] +=1
        except:
            {{completion}}
    dp = [0]*(n+1)

    for i in range(1,n+1):
        c=  i 
        while c <= n:
            dp[c] += arr[i] 
            c+= i 


    print(max(dp))",pass,"arr[x] = 1

    arr.sort()"
"import sys

input = lambda: sys.stdin.readline().rstrip()


def solve():
    a = """".join(it for _ in range(3) for it in input())
    for i, j, k in [(0, 1, 2), (3, 4, 5), (6, 7, 8), (0, 3, 6), (1, 4, 7), (2, 5, 8), (0, 4, 8), (2, 4, 6)]:
        if a[i] == a[j] == a[k] and a[i] != '.':
            {{completion}}
    return ""DRAW ""


for _ in range(int(input())):
    print(solve())
",return a[i],"crosses = a[i:] + a[:j] + a[j:] + a[k:]
            if all(c == 'X' for c in crosses):
                return ""X""
            if all(c == 'O' for c in crosses):
                return ""O""
            if all(c == '+' for c in crosses):
                return ""+"""
"t=int(input())
l=[]
for i in range(t):
    a=input()
    b=input()
    c=input()
    r=""DRAW""
    if (a[0]==a[1] and a[1]==a[2])and(a[0]!="".""):
        r=a[0]
    elif ((b[0]==b[1] and b[1]==b[2])or(a[0]==b[0] and b[0]==c[0]))and(b[0]!="".""):
        {{completion}}
    elif ((c[0]==c[1] and c[1]==c[2]) or(a[2]==b[1] and b[1]==c[0]))and(c[0]!="".""):
             r=c[0]
    elif ((a[1]==b[1] and b[1]==c[1])or(a[0]==b[1] and b[1]==c[2]))and(b[1]!="".""):
             r=b[1]
    elif (a[2]==b[2] and b[2]==c[2])and(a[2]!="".""):
             r=a[2]
    l.append(r)
for i in l:
    print(i)",r=b[0],"
             r=b[0]"
"import sys, math, itertools, bisect
input = sys.stdin.readline
 
def ok(x): print('YES' if x else 'NO')
P = 1000000007
 
#### Type your code here! ####
T = int(input())
for _ in range(T):
    a1, a2, a3 = list(input().rstrip())
    a4, a5, a6 = list(input().rstrip())
    a7, a8, a9 = list(input().rstrip())
    if a1 == a2 == a3 != '.': print(a1)
    elif a4 == a5 == a6 != '.': {{completion}}
    elif a7 == a8 == a9 != '.': print(a9)
    elif a1 == a4 == a7 != '.': print(a1)
    elif a2 == a5 == a8 != '.': print(a2)
    elif a3 == a6 == a9 != '.': print(a3)
    elif a1 == a5 == a9 != '.': print(a1)
    elif a3 == a5 == a7 != '.': print(a3)
    else: print(""DRAW"")
##############################  ",print(a4),print(a4)
"import sys
input = sys.stdin.readline

t = int(input())
fin = []

import heapq

for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    out = 0
    ch = 0
    add = []

    for v in a:
        uc = (v - ch) % k
        dc = (-uc) % k
        uc = k - dc

        ch -= dc
        heapq.heappush(add, uc)

        if ch < 0:
            {{completion}}

    fin.append(out)
print('\n'.join(map(str, fin)))
","ch += k
            out += heapq.heappop(add)","heapq.heappop(add)
            ch = k

        out += add[0]"
"from heapq import heappop, heappush
import sys
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
fast_print = lambda p: sys.stdout.write(str(p) + ""\n"") 
 
def solve(n, k, a):
  b = [ele % k for ele in a]
  ascents = []
  total = 0
  prev = 0
  for i in range(len(b)):
    if b[i] > prev:
      heappush(ascents, b[i] - prev)
      total += heappop(ascents)
    else:
      {{completion}}
    prev = b[i]
  return total
 
t = int(input())
for _ in range(t):
  n, k = [int(component) for component in input().split("" "")]
  a = list(map(int,sys.stdin.readline().split()))
  fast_print(solve(n, k, a))","heappush(ascents, k + b[i] - prev)","heappush(ascents, 0)
      total += heappop(ascents)"
"import sys
import heapq
input = sys.stdin.readline
 
t = int(input())
for _ in range(t):
    n,k = map(int,input().split())
    a = [0] + list(map(int,input().split()))
    q = []
    ans = 0
    for i in range(1,n+1):
        a[i] %= k
        if a[i] > a[i - 1]:
            heapq.heappush(q, a[i] - a[i - 1])
            ans += heapq.heappop(q)
        else:
            {{completion}}
    print(ans)","heapq.heappush(q, k - a[i - 1] + a[i])","heapq.heappush(q, a[i])
            ans += heapq.heappop(q)
    ans -= a[n - 1]"
"from sys import stdin,stdout

for _ in range(int(stdin.readline())):
    n,k = map(int,stdin.readline().split())
    arr = list(map(int,stdin.readline().split()))
    j,x = 0,1
    for i in range(k):
        while j < n and arr[j] <= x + j:
            {{completion}}
        x += j
    stdout.write(f""{x}\n"")
    
    
",j += 1,"j += 1
        arr[j] = arr[j] - x"
"import sys
input = sys.stdin.readline

rounds = int(input())
for ii in range(rounds):
  out=0
  length,day=map(int,input().split())
  arr=list(map(int,input().split()))
  if arr[0]!=1:
    print(1)
    continue
    
  ind=0
  small=1
  for d in range(day):
    while ind<length and arr[ind]<=small+ind:
      {{completion}}
    small+=(ind)
  print(small)",ind+=1,"ind+=1
    small+=ind
    ind-=1
    out+=1
  print(out)
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
"
"import sys
input = sys.stdin.readline
output = sys.stdout.write

t = int(input().strip())
for _ in range(t):
    n, k = map(int, input().strip().split())
    a = list(map(int, input().strip().split()))
    for i in range(n):
        a[i]-=i+1
    ans, id = 1, 0
    for i in range(k):
        while id<n and a[id]<ans:
            {{completion}}
        ans+=id
    output(str(ans)+'\n')",id+=1,"ans+=id
            id+=1
        if id==n:
            break
        id+=1"
"m=int(input())
for e in range(m):
	s=int(input())
	i=list(map(int,input().split()))
	l=[0 for o in range(s+1)]
	n=0
	h=0
	for o in i:
		h=o-n
		n=o
		if 1<=h<=s:
			{{completion}}
	print(""YES"" if sum(l)==(s-2 if i[-1]==s*(s+1)//2 else s-1) and i[-1]<=s*(s+1)//2 else ""NO"")",l[h]=1,"l[h]+=1
		else:
			l[h]-=1
	print(sum(l))"
"def sol(n,l):
    isn=[False]*(n+1)
    l=[0]+l
    sum1=n*(n+1)//2
    x=0
    keys=0
    for i in range(n-1):
        temp=l[i+1]-l[i]
        if temp>n:
            if keys!=0:
                {{completion}}
            
            keys=temp
            x+=1
            continue

        if x>1:
            return 'NO'

        
        if isn[temp]:
            if keys!=0:
                return 'NO'

            keys=temp
            continue
        else:
            isn[temp]=True
            sum1-=temp
    
    if keys==sum1 or keys==0:
        return 'YES'
    else:
        return 'NO'

from sys import stdin
for _ in range(int(input())):
    n=int(stdin.readline())
    l=list(map(int,stdin.readline().split()))
    print(sol(n,l)) 
",return 'NO',"isn[temp]=True
                sum1-=temp
            return 'NO'"
"import sys

input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n = int(input())
    a = [0] + list(map(int, input().split()))

    other = -1
    s = set()
    for i in range(1,n):
        sub = a[i] - a[i - 1]
        if sub <= 0:
            print(""NO"")
            break
        if sub in s or sub > n:
            if other != -1:
                {{completion}}
            other = sub
        s.add(sub)
    else:
        if other == -1:
            print(""YES"")
        elif a[-1] == n*(n + 1)//2:
            print(""YES"")
        else:
            print(""NO"")
","print(""NO"")
                break","s.add(other)
                other = -1
            else:
                print(""NO"")
                break
        elif sub in s:"
"import sys
input = sys.stdin.readline
 
def highest_set_bit(xy):
    return xy.bit_length() - 1
 
def lowest_set_bit(xy):
    return highest_set_bit(xy ^ (xy - 1))
 
 
nr = int(input())
A = [int(xy) for xy in input().split()]
 
prefix_sum = [0]
for a in A:
    prefix_sum.append(prefix_sum[-1] + a)
 
best = 0
 
bitset = 1
mask = (1 << nr) - 1
 
for i in range(nr):
    bitset |= (bitset >> i) << (A[i] + i)
 
    j = highest_set_bit(bitset)
    if j >= nr:
        {{completion}}
 
    bitset &= mask
 
bitset = bin(bitset)[2:][::-1]
for j in range(len(bitset)):
    if bitset[j] == '1':
        best = max(best, prefix_sum[j + 1] - j)
 
print(best)","j = lowest_set_bit(bitset >> nr) + nr
        best = max(best, prefix_sum[-1] - j)","j = nr - 1
 
    bitset &= ~(1 << j)"
"import sys
input = sys.stdin.readline
B = 63

ones = [1] * B
for i in range(1, B):
    ones[i] = ones[i - 1] | (1 << i)

n = int(input())
A = list(map(int, input().split()))

m = (2 * n + B + 5) // B
dp = [0] * m
dp[0] = 1
sm = 0
first = 0
ans = 0

for i, a in enumerate(A):
    sm += a
    ans = max(ans, sm - first)
    
    # Update DP by shifting A[i] bits to the left
    if a:
        b, r = divmod(a, B)
        for j in range(m - 1 - b, first // B - 1, -1):
            if dp[j] == 0:
                continue
            
            if j + b + 1 < m:
                dp[j + b + 1] |= dp[j] >> (B - r)
            
            dp[j + b] |= (dp[j] & ones[B - 1 - r]) << r


    # Card gets removed from deck
    bi, ri = divmod(i, B)
    dp[bi] &= ones[B - 1] ^ (1 << ri)

    if i == first:
        # Find the index of the first unlocked card
        found = False
        for j in range(bi, m):
            if dp[j] == 0:
                continue
            
            k = 0
            mask = dp[j]
            while mask:
                if mask & 1:
                    {{completion}}
                mask >>= 1
                k += 1
            
            first = j * B + k
            found = True
            break
        
        if not found:
            break
    
print(ans)",break,"dp[j + k] = dp[j]
                "
"import sys
input = sys.stdin.readline

def highest_set_bit(x):
    return x.bit_length() - 1

def lowest_set_bit(x):
    return highest_set_bit(x ^ (x - 1))


n = int(input())
A = [int(x) for x in input().split()]

prefix_sum = [0]
for a in A:
    prefix_sum.append(prefix_sum[-1] + a)

best = 0

bitset = 1
mask = (1 << n) - 1

for i in range(n):
    bitset |= (bitset >> i) << (A[i] + i)

    j = highest_set_bit(bitset)
    if j >= n:
        {{completion}}

    bitset &= mask

bitset = bin(bitset)[2:][::-1]
for j in range(len(bitset)):
    if bitset[j] == '1':
        best = max(best, prefix_sum[j + 1] - j)

print(best)



","j = lowest_set_bit(bitset >> n) + n
        best = max(best, prefix_sum[-1] - j)","j = n - 1
    bitset &= (1 << j) - 1"
"# Answer = sum of distance s[i] moves before it is deleted
# Use LOE to calculate by considering trajectory of s[i] and s[i+1]

# STUCK FROM NOT THOROUGHLY UNDERSTANDING STATE => EQUIVALENCE:
# At first, I thought you had to keep track of |S| to find probability of transitions.
# If we move j != i/i+1 with prob 1-(2/|S|), instead of i/i+1, it seems like a separate case.
# However, in this case, we *haven't moved* i/i+1 yet!
# Thus, summing over all probs, it's equivalent to say we have prob 1 of moving i/i+1 irrespective of |S|!


MOD = 10**9 + 7

n, m = map(int, input().split())
s = list(map(int, input().split())) + [m+1]

dp = [[0] * (m+2) for i in range(m+2)]

inv2 = pow(2, -1, MOD)
for i in range(m, 0, -1):
    for j in range(m+1, i, -1):
        if j == m+1:
            dp[i][j] = (dp[i + 1][j] + 1) % MOD
        else:
            {{completion}}

ans = 0

for i in range(n):
    ans += dp[s[i]][s[i+1]]

print(ans % MOD)
",dp[i][j] = (dp[i + 1][j]+1 + dp[i][j+1]) * inv2 % MOD,"prob = (dp[i + 1][j] + 1) % MOD
            if j != i:
                prob = (dp[i][j] + inv2 * dp[i + 1][j]) % MOD
            dp[i][j] = prob"
"x,y=map(int,input().split())
a=list(map(lambda x:int(x)-1,input().split()))
 
ans=y*x-sum(a)
 
mod=10**9+7
inv2=pow(2,mod-2,mod)
 
dp=[[0]*(y+1) for i in range(y+1)]
for i in range(x-1):
  dp[a[i+1]][a[i]]=1
for j in range(y):
  for k in range(j):
    {{completion}}
for i in range(y):
  ans-=dp[i][i]*(y-i)
  ans%=mod
print(ans)","dp[j][k]%=mod
    dp[j][k+1]+=dp[j][k]*inv2%mod
    dp[j+1][k]+=dp[j][k]*inv2%mod","k=k+j
    dp[k][j]=(dp[k][j]*inv2) % mod
 "
"
import sys
sys.setrecursionlimit(10**5)
n,m=map(int,input().split())
MOD=10**9+7
h=(MOD+1)//2

S=[*map(int,input().split())]
memo=[[-1]*(m+2) for a in range(m+2)]

def dp(i,j):

    if j==m+1:
        {{completion}}
    if j==i:
        return 0
    if memo[i][j] != -1:
        return memo[i][j]
    
    temp=(h*(1+dp(i+1,j))+h*dp(i,j+1))%MOD
    
    memo[i][j]=temp

    return temp
#t=0
o=0
S.append(m+1)

for i in range(n):

    o+=dp(S[i],S[i+1])


print(o%MOD)

""""""
30 500
5 11 19 27 38 40 43 47 48 49 53 56 71 77 85 90 93 98 100 107 114 116 119 128 136 139 156 157 159 160
""""""",return j-i,"
        return memo[i][j]"
"t = int(input())
for _ in range(t):
    {{completion}}","n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(sum(sorted(abs(i - j) for i, j in zip(a[1:], a))[:n-k]))","n, k = map(int, input().split())
    power = []
    for i in range(1, n + 1):
        power.append(0)
    power.append(0)
    for i in range(1, n + 1):
        for j in range(1, k + 1):
            if i - j >= 0:
                power[i] += abs(int(input()) - int(input()))
    power.sort()
    power = power[::-1]
    print(power[k - 1])
<|/ file source=github |>"
"a=lambda:[int(i) for i in input().split()]
for _ in range(*a()):
    {{completion}}","n,d=a()
    u=a()
    s = [abs(u[i]-u[i+1]) for i in range(n-1)]
    print(sum(sorted(s,reverse=True)[d-1:]))","s=a()
    k=a()
    res=sum(abs(s-k[i])**2 for i in range(1,k[-1]+1))
    print(res)
<|/ q tags=python-3.x,python |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far"
"for _ in range(int(input())):
    n,k= map(int, input().split(' '))
    a= list(map(int, input().split(' ')))
    diff= []
    for i in range(1,n):
        {{completion}}
    diff.sort()
    print(sum(diff[:n-k]))",diff.append(abs(a[i]-a[i-1])),diff.append(abs(a[i-1]-a[i]))
"import sys
input = sys.stdin.readline
 
def topo_order(graph):
    n = len(graph)
    in_deg = [0] * n
    for node in range(n):
      for nei in graph[node]:
        in_deg[nei] += 1
    
    reversed_topo = [node for node in range(n) if in_deg[node] == 0]
    for node in reversed_topo:
      for nei in graph[node]:
        in_deg[nei] -= 1
        if in_deg[nei] == 0:
          {{completion}}
    return reversed_topo[::-1]
 
for _ in range(int(input())):
    n, k = [int(x) for x in input().split()]
    cost = [int(x) for x in input().split()]
    free_potitions = [int(x) - 1 for x in input().split()]
    for node in free_potitions:
        cost[node] = 0
    graph = [[int(x) - 1 for x in input().split()][1:] for _ in range(n)]
    
    topo = topo_order(graph)
    for node in topo:
        if not graph[node]:
            continue
        s = 0
        for nei in graph[node]:
            s += cost[nei]
        cost[node] = min(cost[node], s)
    
    print(*cost)",reversed_topo.append(nei),reversed_topo.append(nei)
"import sys
input = sys.stdin.readline

def dfs(to, g, cost, done):
    stack = [to]

    while stack:
        vertex = stack[-1]
        done[vertex] = True

        all_neighbours_done = True
        make = 0
        for neighbor in g[vertex]:
            if not done[neighbor]:
                {{completion}}

            make += cost[neighbor]

        if all_neighbours_done:
            if g[vertex]:
                cost[vertex] = min(cost[vertex], make)
            stack.pop()
    

def solve():
    n, k = map(int, input().split())
    cost = list(map(int, input().split()))
    has = list(map(lambda x: (int(x) - 1), input().split()))
    g = []
    for i in range(n):
        m = list(map(lambda x: (int(x) - 1), input().split()))
        if len(m) > 1:
            g.append(m[1:])
        else:
            g.append([])
    
    done = [False] * n
    for v in has:
        done[v] = True
        cost[v] = 0
    
    for to in range(0, n):
        if not done[to]:
            dfs(to, g, cost, done)
    
    print("" "".join(map(str, cost)))

for t in range(int(input())):
    #if t != 0: continue
    solve()","all_neighbours_done = False
                stack.append(neighbor)","stack.append(neighbor)
                all_neighbours_done = False
            else:
                make = min(make, cost[neighbor])"
"#from itertools import product, permutations, combinations, accumulate, compress
#from collections import deque # deque([iterable[, maxlen]]) #appendleft popleft rotate
#from collections import Counter as Counter_, defaultdict as defaultdict_
#from heapq import heapify, heappop, heappush, nlargest # func(heapifiedlist, item)
#from bisect import bisect_left, bisect_right, insort # func(sortedlist, item)
#from sys import setrecursionlimit # sadness on pypy: allocates mucho RAM for that depth

import os, sys
def input(): return sys.stdin.buffer.readline().rstrip(b'\r\n')
def dbp(*args, **kwargs): print(*args, file=sys.stderr, **kwargs)

def a_str(): return input().decode('ascii')
def get_int_list(): return [int(x) for x in input().split()]
def minus_one(): return [int(x)-1 for x in input().split()]
def join_str(l, sep=' '): return sep.join([str(x) for x in l])



def do_thing():
	n, k = get_int_list()
	costs = get_int_list()
	plist = minus_one() # unlimited supply of
	recipies = [minus_one()[1:] for _ in range(n)]

	ans = []

	for p in plist:
		costs[p] = 0

	seen = [0] * n
	for sv in range(n):
		if seen[sv] == 2:
			continue
		q = [sv]
		while q:
			v = q.pop()
			if seen[v] == 2:
				continue
			elif seen[v] == 1:
				ccost = sum(costs[j] for j in recipies[v]) if recipies[v] else costs[v]
				costs[v] = min(costs[v], ccost)
				seen[v] = 2
			else:
				seen[v] = 1
				q.append(v)
				for cv in recipies[v]:
					{{completion}}
	
	return join_str(costs)

if __name__ == ""__main__"":
	maxcc = 1
	maxcc = int(input())
	for cc in range(maxcc):
		print(do_thing())
",q.append(cv),"costs[cv] = min(costs[cv], costs[v])
				break
		ans.append(costs[sv])
	return ans

def do_thing2():
	n, k = get_int_list()
	costs = get_int_list()
	plist = minus_one() # unlimited supply of
	recipies = [minus_one()[1:] for _ in range(n)]

	ans = []

	for p in plist:
		costs[p] = 0

	seen = [0] * n
	for sv in range(n):
		if seen[sv] == 2:
			continue
		q = [sv]
		while q:
			v = q.pop()
			if seen"
"import sys
input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n, k = map(int,input().split())
    if k > 29:
        print(0)
        continue
    ans = 0
    for i in range(n):
        if i > n - i: {{completion}}
        f1 = n - i
        f2 = i
        seq = [n, f1, f2]
        length = 3
        while f1 - f2 <= f2:
            f3 = f1 - f2
            f1 = f2
            f2 = f3
            length += 1
            seq.append(f3)
        if length >= k:
            ans += 1

    print(ans)",break,continue
"# /**
#  *     author: brownfox2k6
#  *    created: 23/07/2023 22:00:55 Hanoi, Vietnam
# **/

import sys
input = sys.stdin.readline
print = sys.stdout.write

a = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,
     144, 233, 377, 610, 987, 1597, 2584, 4181,
     6765, 10946, 17711, 28657, 46368, 75025,
     121393, 196418, 317811]

def solve():
    n, k = map(int, input().split())
    if k >= 29:
        {{completion}}
    first, second = a[k-2], a[k-1]
    ans = 0
    for i in range(n+1):
        x = (n - (second * i)) / first
        ans += i >= x >= 0 and x.is_integer()
    return ans

print('\n'.join(map(str, (solve() for _ in range(int(input()))))))",return 0,"ans = 0
    else:
        ans = a[k-2]"
"import sys

read = sys.stdin.readline
write = sys.stdout.write

fnb = [0, 1]

for j in range(2, 28):
    fnb.append(fnb[j - 2] + fnb[j - 1])

fna = [1] + fnb


def fi(num):
    return [fna[num], fnb[num]]


def solve():
    n, f = map(int, read().split())
    ans = 0

    if f > 28:
        return ""0""

    a, b = fi(f - 1)
    n1, n2 = 0, 0

    for i in range(n):
        if (n - i * a) % b == 0:
            {{completion}}

    if n1 > n2 or n1 < 0 or n2 < 0:
        return ""0""

    while n1 + b <= n2 - a:
        n1 += b
        n2 -= a
        ans += 1

    return ans


for _ in range(int(read())):
    write(str(solve()) + ""\n"")
","ans += 1
            n1 = i
            n2 = (n - i * a) // b
            break","ans += 1
            n1 += a
            n2 += b
            a, b = fi(n - i * a)"
"import sys
from sys import stdin, stdout, stderr
from math import *
 
my_buffer = []
 
def flush_out():
    stdout.writelines(my_buffer)
 
def input():
    return stdin.readline().strip()
 
def array_input(dtype):
    return list(map(dtype, input().split()))
 
def print(s):
    global my_buffer
    my_buffer.append(str(s) + '\n')
 
def forced_print(s):
    stdout.writelines(s + '\n')
    stdout.flush()
 
def main():
    
    def solve(node, adj, sub):
        sack = s2 = 1
        c1 = c2 = 0
        mx = 0
        for x in adj[node]:
            mx = max(mx, sub[x])
 
        if mx >= (sub[node] - 1) // 2:
            return mx * (sub[node] - 1 - mx)
        
        for x in adj[node]:
            if sub[x] == 1: c1 += 1
            elif sub[x] == 2: {{completion}}
            else:
                s2 = sack
                sack <<= sub[x]
                sack |= s2
        
        ans = 0
        sack = bin(sack)[2:][::-1]
        num = sub[node] // 2
        for i in range(min(len(sack), num + 1)):
            if sack[i] == '1':
                j = i
                w = min(c2, (num - j) // 2)
                j += w * 2
                w = min(c1, num - j)
                j += w
                ans = max(ans, j * (sub[node] - 1 - j))
        return ans
    
    n = int(input())
    p = array_input(int)
    adj = [list() for i in range(n + 1)]
    for i in range(n - 1): adj[p[i]].append(i + 2)
    sub = [0 for i in range(n + 1)]
 
    vis = [False for i in range(n + 1)]
    stk = [1]
    while len(stk):
        if vis[stk[-1]]:
            for x in adj[stk[-1]]:
                sub[stk[-1]] += sub[x]
            sub[stk[-1]] += 1
            stk.pop()
        else:
            yo = stk[-1]
            vis[yo] = True
            for x in adj[yo]:
                stk.append(x)
 
    ans = 0
    for i in range(1, n + 1): ans += solve(i, adj, sub)
    print(ans)
 
main()
flush_out()",c2 += 1,"c2 += 1
            else:
                s2 = sack
                sack <<= sub[x]
                sack |= s2
        
        ans = 0
        sack = bin(sack)[2:][::-1]
        num = sub[node] // 2
        for i in range(min(len(sack), num + 1)):
            if sack[i] == '1':
                j = i
                w = min(c2, (num - j) // 2)
                j += w * 2
                w = min(c1, num - j)
                j += w
                ans = max(ans, j * (sub[node] - 1 - j))
        return ans
    
    n = int(input())
"
"import sys
from sys import stdin, stdout, stderr
from math import *

my_buffer = []

def flush_out():
    stdout.writelines(my_buffer)

def input():
    return stdin.readline().strip()

def array_input(dtype):
    return list(map(dtype, input().split()))

def print(s):
    global my_buffer
    my_buffer.append(str(s) + '\n')

def forced_print(s):
    stdout.writelines(s + '\n')
    stdout.flush()

def main():
    # Write here

    def solve(node, adj, sub):
        sack = s2 = 1
        c1 = c2 = 0
        mx = 0
        for x in adj[node]:
            mx = max(mx, sub[x])

        if mx >= (sub[node] - 1) // 2:
            return mx * (sub[node] - 1 - mx)
        
        for x in adj[node]:
            if sub[x] == 1: c1 += 1
            elif sub[x] == 2: {{completion}}
            else:
                s2 = sack
                sack <<= sub[x]
                sack |= s2
        
        ans = 0
        sack = bin(sack)[2:][::-1]
        num = sub[node] // 2
        for i in range(min(len(sack), num + 1)):
            if sack[i] == '1':
                j = i
                w = min(c2, (num - j) // 2)
                j += w * 2
                w = min(c1, num - j)
                j += w
                ans = max(ans, j * (sub[node] - 1 - j))
        return ans
    
    n = int(input())
    p = array_input(int)
    adj = [list() for i in range(n + 1)]
    for i in range(n - 1): adj[p[i]].append(i + 2)
    sub = [0 for i in range(n + 1)]

    vis = [False for i in range(n + 1)]
    stk = [1]
    while len(stk):
        if vis[stk[-1]]:
            for x in adj[stk[-1]]:
                sub[stk[-1]] += sub[x]
            sub[stk[-1]] += 1
            stk.pop()
        else:
            yo = stk[-1]
            vis[yo] = True
            for x in adj[yo]:
                stk.append(x)

    ans = 0
    for i in range(1, n + 1): ans += solve(i, adj, sub)
    print(ans)

# __main__
main()
flush_out()",c2 += 1,"c2 += 1
            else:
                s2 = sack
                sack <<= sub[x]
                sack |= s2
        
        ans = 0
        sack = bin(sack)[2:][::-1]
        num = sub[node] // 2
        for i in range(min(len(sack), num + 1)):
            if sack[i] == '1':
                j = i
                w = min(c2, (num - j) // 2)
                j += w * 2
                w = min(c1, num - j)
                j += w
                ans = max(ans, j * (sub[node] - 1 - j))
        return ans
    
    n = int(input())
"
"from math import sqrt
for _ in range(int(input())):
 {{completion}}","n,c=map(int,input().split())
 ps=list(map(int,input().split()))
 sp=sum(ps); sp2=sum(p*p for p in ps)
 w = (int(sqrt(sp**2 - n*(sp2 - c))) - sp) // (2*n)
 print(w)","n,c = map(int, input().split())
 w = 1
 while c > w:
  w += 1
 print(w)
<|/ q tags=python,algorithm |>
<| c |>
What have you tried so far? Where are you stuck?
<|/ c |>
<| c |>
I tried to solve this problem by myself but i couldn't get any solution
<|/ c |>
<| c |>
Please show us your attempt.
<|/ c |>
<| c |>
I added my code in the question
<|/ c |>
<| c |>
Please read [ask] and "
"'''
Author       : InHng
LastEditTime : 2023-08-29 22:37:11
:(
'''
import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n, c = map(int, input().split())
    a, b = 0, 4 * n
    for x in map(int, input().split()):
        {{completion}}
    a = 4 * n
    d = b * b + a * c
    print((int(d ** 0.5) - b) // a + 1)
","c -= x * x
        b += x * 2","a, b = b, a + x
    c = b * b + a * c"
"import sys

t=int(sys.stdin.readline().rstrip())

for _ in range(t):
    n,c=map(int,sys.stdin.readline().rstrip().split())

    lst = list(map(int,sys.stdin.readline().rstrip().split()))

    sums = 0
    sumsq = 0

    for i in range(n):
        {{completion}}

    ans = (-sums+(sums**2-n*(sumsq-c))**0.5)/(2*n)
    print(int(ans))
    
","sums+=lst[i]
        sumsq+=lst[i]**2","sums += lst[i]
        sumsq += lst[i]*lst[i]"
"for _ in range(int(input())):
	nandu, mug, kaja, Hang = map(int, input().split())
	c = 0
	data = list(map(int, input().split()))
	for y in data:
		if y % kaja == Hang % kaja:
			if 0 < abs(Hang - y) // kaja < mug:
				{{completion}}
	print(c)",c += 1,"c += 1
			else:
				break
		else:
			break"
"def solve():
    n, m, k, H = map(int, input().split())
    v = list(map(int, input().split()))

    ct = 0
    for i in range(n):
        d = abs(H - v[i])
        if 0 < d <= (m - 1) * k and d % k == 0 and v[i] != H:
            {{completion}}

    print(ct)

def main():
    TC = int(input())
    for _ in range(TC):
        solve()

if __name__ == ""__main__"":
    main()
",ct += 1,ct += 1
"def solve(n,m,k,H,h):
    count=0
    for height in h:
        if H==height:
            continue
        elif H>height:
            if (H-height)%k==0:
                if (H-height)//k<m:
                    {{completion}}
        else:
            if (height-H)%k==0:
                if (height-H)//k<m:
                    count+=1
    return count
t = int(input())
for i in range(t):
    n,m,k,H =map(int,input().split())
    h = list(map(int,input().split()))
    print(solve(n,m,k,H,h))

",count+=1,count+=1
"from sys import stdin, stdout
from math import sqrt
from collections import Counter
from functools import lru_cache
input = lambda: stdin.readline()[:-1]


# i + j = x, i*j = y -> x - j = i, (x-j)*j = y
# i = x - j
# j^2 - j*x + y = 0, d = x^2 - 4*y
# j = (x +- sqrt(d)/2)
for _ in range(int(input())):
    n = int(input())
    a = Counter(map(lambda x: 2*x, map(int, input().split())))
    q = int(input())
    ans = [0]*q
    for k in range(q):
        x, y = map(int, input().split())
        t = x*x - 4*y
        # (x - sqrt(t)/2), (x + sqrt(t)/2) -> answers
        # 2*n = x - sqrt(t)
        if t < 0:
            continue
        tt = round(sqrt(t))
        if tt * tt != t:
            continue
        if t == 0:
            t = a.get(x, 0)
            ans[k] += t*(t - 1)//2
        else:
            {{completion}}
    print(*ans)","i = x - tt
            j = x + tt
            ans[k] += a.get(i, 0)*a.get(j, 0)","ans[k] += 2*t
    ans = sorted(ans)"
"import math
import sys
input=sys.stdin.readline

t = int(input())
while t>0:
    n = int(input())
    a = list(map(int, input().split()))
    d = {}
    DELTA = 10**(-6)
    for ai in a:
        if (ai + 3 not in d):
            d[ai + 3] = 0
        d[ai + 3] += 1
    ans = []
    q = int(input())
    for i in range(q):
        x,y = map(int, input().split())
        adder = (x*x - 4*y)
        if (adder < 0):
            ans.append(0)
        else:
            adder = math.isqrt(adder)
            a1 = int((x + adder)//2)
            a2 = int((x - adder)//2)
            if (abs(a1 + a2 - x) <= DELTA and abs(a1 * a2 - y) <= DELTA):
                if (abs(a1-a2) <= DELTA):
                    ans.append((d.get(a1 + 3, 0) * (d.get(a1 + 3, 0) - 1))//2)
                else:
                    {{completion}}
            else:
                ans.append(0)
    print(*ans)
            
        
    t-=1","ans.append(d.get(a1 + 3, 0) * d.get(a2 + 3, 0))","ans.append((d.get(a2 + 3, 0) * (d.get(a2 + 3, 0) - 1))//2)"
"import sys
input = lambda: sys.stdin.readline().rstrip()
ii = lambda: int(input())
mint = lambda: map(int, input().split())
lint = lambda: list(mint())

m = 10**9+7

from math import isqrt

def solve():
    n = ii()
    cnt = {}
    for x in mint():
        x ^= m
        if x not in cnt:
            cnt[x] = 0
        cnt[x] += 1

    nq = ii()
    ans = [0] * nq
    for i in range(nq):
        x, y = mint()
        res = 0
        delta = x * x - 4 * y
        if delta > 0:
            sd = isqrt(delta)
            if sd * sd != delta or (x + sd) % 2 != 0:
                {{completion}}
            a, b = (x + sd) // 2, (x - sd) // 2
            res = cnt.get(a^m, 0) * cnt.get(b^m, 0)
        elif delta == 0:
            a = x // 2
            res = cnt.get(a^m, 0) * (cnt.get(a^m, 0) - 1) // 2
        ans[i] = res
    return ans


T = ii()

for _ in range(T):
    ans = solve()
    print(*ans)",continue,sd = -sd - 1
"N = int(input()) ; Dic = [[] for _ in range(N+1)] ; I = list(map(int,input().split()))

for i in range(N-1) : Dic[I[i]].append(i+2)

Ans = 0 ; D = [1] ; V = [0] * (1+N) ; A = [1] * (1+N)

while D :
    n = D[-1]

    if V[n] == 0 :
        for num in Dic[n] : D.append(num)
        V[n] = 1 ; continue

    D.pop() ; cnt = 0 ; B = []

    for num in Dic[n] : cnt += A[num] ; B.append(A[num])

    dp = [0] * (1+cnt) ; dp[0] = 1 ; B.sort()

    for num in B :
        for j in range(cnt, -1, -1) :
            if dp[j] == 0 or j+num > cnt : {{completion}}
            dp[j+num] = 1

    check = 0
    for i in range(cnt+1) :
        if dp[i] == 1 : check = max(i*(cnt-i), check)

    Ans += check ; A[n] += cnt

print(Ans)",continue,"break
            if B[j+num] > dp[j+num] :
                dp[j+num] = B[j+num]"
"import sys

# sys.setrecursionlimit(10000)


def input_general():
    return sys.stdin.readline().rstrip('\r\n')


def input_num():
    return int(sys.stdin.readline().rstrip(""\r\n""))


def input_multi(x=int):
    return map(x, sys.stdin.readline().rstrip(""\r\n"").split())


def input_list(x=int):
    return list(input_multi(x))


def main():
    n = input_num()
    parent = input_list()
    edge_dict = [[] for _ in range(n + 1)]

    for i, p in enumerate(parent, 2):
        edge_dict[p].append(i)

    parent = [0] * 2 + parent

    answer = 0
    sub = [0] + [1] * n

    for u in range(n, 0, -1):
        p = parent[u]
        sub[p] += sub[u]

        if edge_dict[u]:
            cand = [sub[v] for v in edge_dict[u]]
            tot = sub[u] - 1

            dp = [1] + [0] * (tot // 2)
            half = len(dp)

            for d in cand:
                for i in range(half - 1 - d, -1, -1):
                    {{completion}}

            near = max(i for i, mask in enumerate(dp) if mask)
            answer += near * (tot - near)

    print(answer)


if __name__ == ""__main__"":
    main()
",dp[i + d] |= dp[i],"dp[i] = max(dp[i], dp[i + d])

            dp[0] = 0"
"from collections import defaultdict
n = int(input())
arr = [int(i) for i in input().split()]
if n == 2:
    print(0)
else:
    t = [1]*(n+1)
    p = list(range(n+1))
    dic = defaultdict(list)
    for i,v in enumerate(arr):
        dic[v].append(i+2)
        p[v] = 0
    dic2 = dic.copy()
    for i in dic.keys():
        dic2[i] = dic[i][::]
    qq = sorted(set(p))[1:]
    while qq and dic!={}:
        mm = qq.pop()
        t[arr[mm-2]] += t[mm]
        #print(dic,mm)
        dic[arr[mm-2]].remove(mm)
        if dic[arr[mm-2]] == []:
            qq.append(arr[mm-2])
            del dic[arr[mm-2]]
    ans = 0
    #print(dic2)
    for x in dic2.keys():
        if len(dic2[x]) == 1:
            continue
        pp = [t[i] for i in dic2[x]]
        
        ss = set()
        tot = sum(pp)
        hf = tot//2
        res = 0
        for i in pp:
            if i >= hf:
                res = i*(tot-i)
                break
            tt = set()
            tt.add(i)
            for st in ss:
                if st + i == hf:
                    res = hf*(tot-hf)
                    break
                elif st + i< hf:
                    {{completion}}
            if res > 0:
                break
            ss |= tt
        if res == 0:
            res = max(ss)*(tot-max(ss))
        ans += res
    #print(t)
    print(ans)
    
                ",tt.add(st+i),tt.add(st + i)
"T=int(input())
from sys import stdin, setrecursionlimit
input = stdin.readline
readline = stdin.readline

for _ in range(T):
  N,K=map(int,input().split())
  A=list(map(int, input().split()))
  if A[0]==A[-1]:
    a=A[0]
    if A.count(a)>=K:
      print('Yes')
    else:
      print('No')
  else:
    a,b=A[0],A[-1]
    ca,cb=0,0
    for aa in A:
      if ca<K:
        if a==aa:
          ca+=1
      else:
        if b==aa:
          {{completion}}
    if cb<K:
      print('No')
    else:
      print('Yes')",cb+=1,"cb+=1
        else:
          break
    if ca<K:
      print('No')
    else:
      print('Yes')
      
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
"
"import sys

R = sys.stdin.readline
inf = int(1e18)
mod = int(1e9) + 7


def get_int() -> int:
    return int(R())


def get_str() -> str:
    return R().strip()


def get_int_list() -> list:
    return list(map(int, R().split(' ')))


def init_matrix(n_, m_, value_=0) -> list:
    return [[value_] * m_ for _ in range(n_)]


def solve():
    n, k = get_int_list()
    a = get_int_list()

    cnt_0 = cnt_n = 0
    for i in range(n):
        if a[i] == a[0] and cnt_0 < k:
            {{completion}}
        if a[i] == a[-1] and cnt_0 == k and cnt_n < k:
            cnt_n += 1

    if a[0] == a[-1] and cnt_0 == k or cnt_0 == cnt_n == k:
        print('YES')
    else:
        print('NO')


for _ in range(get_int()):
    solve()
",cnt_0 += 1,cnt_0 += 1
"t=int(input())
l=[]
for i in range(t):
    x=input().split()
    y=input().split()
    n=int(x[0])
    k=int(x[1])
    if n==1:
        l.append('YES')
    else:
        a=y[0]
        b=y[-1]
        if a==b:
            cnt=0
            for i in y:
                if i==a:
                    cnt+=1
                if cnt==k:
                    l.append('YES')
                    break
            if cnt<k:
                l.append('NO')
        else:
            j=0
            cnt=0
            while j<n:
                if y[j]==a:
                    cnt+=1
                if cnt==k:
                    break
                j+=1
            j+=1
            if cnt==k:
                cnt=0
                while j<n:
                    if y[j]==b:
                        {{completion}}
                    if cnt==k:
                        break
                    j+=1
                if cnt==k:
                    l.append('YES')
                else:
                    l.append('NO')
            else:
                l.append('NO')
for i in l:
    print(i)
            
                
            
            

        
        
            
    
",cnt+=1,cnt+=1
"import sys
 
input = sys.stdin.readline
N = 1 << 20
n = 0
q = int(input())
s = [0] * (q + 1)
b = [0] * q
stack = []
pos = [q] * N
c = [0] * (q + 1)
for _ in range(q):
    a = input().strip().split()
    if a[0] == ""?"":
        print(s[n],flush=True)
    elif a[0] == ""-"":
        k = int(a[1])
        stack.append([-1,k])
        n -= k
    elif a[0] == ""+"":
        x = int(a[1])
        stack.append([x,pos[x],b[n],pos[b[n]],s[n + 1]])
        if pos[b[n]] == n:
            c[pos[b[n]]] -= 1
            pos[b[n]] = q
            c[pos[b[n]]] += 1
        if pos[x] > n:
            c[pos[x]] -= 1
            pos[x] = n
            c[pos[x]] += 1
        s[n + 1] = s[n] + c[n]
        b[n] = x
        n += 1
    else:
        T = stack.pop()
        if T[0] == -1:
            n += T[1]
        else:
            n -= 1
            x,px,z,pz,sn = T
            b[n] = z
            s[n + 1] = sn
            if px != pos[x]:
                {{completion}}
 
            if pos[z] != pz:
                c[pos[z]] -= 1
                pos[z] = pz
                c[pos[z]] += 1","c[pos[x]] -= 1
                pos[x] = px
                c[pos[x]] += 1","c[px] -= 1
                pos[px] = x
                c[px] += 1
            if pos[z] > pz:
                c[pos[z]] -= 1
                pos[z] = pz
                c[pos[z]] += 1"
"import sys

input = sys.stdin.readline
N = 1 << 20
n = 0
q = int(input())
s = [0] * (q + 1)
b = [0] * q
stack = []
pos = [q] * N
c = [0] * (q + 1)
for _ in range(q):
    a = input().strip().split()
    if a[0] == ""?"":
        print(s[n],flush=True)
    elif a[0] == ""-"":
        k = int(a[1])
        stack.append([-1,k])
        n -= k
    elif a[0] == ""+"":
        x = int(a[1])
        stack.append([x,pos[x],b[n],pos[b[n]],s[n + 1]])
        if pos[b[n]] == n:
            c[pos[b[n]]] -= 1
            pos[b[n]] = q
            c[pos[b[n]]] += 1
        if pos[x] > n:
            c[pos[x]] -= 1
            pos[x] = n
            c[pos[x]] += 1
        s[n + 1] = s[n] + c[n]
        b[n] = x
        n += 1
    else:
        T = stack.pop()
        if T[0] == -1:
            n += T[1]
        else:
            n -= 1
            x,px,z,pz,sn = T
            b[n] = z
            s[n + 1] = sn
            if px != pos[x]:
                {{completion}}

            if pos[z] != pz:
                c[pos[z]] -= 1
                pos[z] = pz
                c[pos[z]] += 1","c[pos[x]] -= 1
                pos[x] = px
                c[pos[x]] += 1","c[px] -= 1
                pos[px] = x
                c[px] += 1
            if pos[z] > pz:
                c[pos[z]] -= 1
                pos[z] = pz
                c[pos[z]] += 1"
"import sys
input = lambda :sys.stdin.readline()[:-1]
ni = lambda :int(input())
na = lambda :list(map(int,input().split()))
yes = lambda :print(""yes"");Yes = lambda :print(""Yes"");YES = lambda : print(""YES"")
no = lambda :print(""no"");No = lambda :print(""No"");NO = lambda : print(""NO"")
#######################################################################

def solve(l,r):#l:0, r:1
    if l + r >= n+1:return 10**9
    res = 10**9
    x = 10**9
    l, r = r, l
    for i in range(l, n-r+1):
        x = min(x, l - (s[i]-s[i-l]))
        res = min(res, x + s[i+r]-s[i])
    x = 10**9
    l,r = r, l
    for i in range(l, n-r+1):
        x = min(x, s[i]-s[i-l])
        res = min(res, x + r - (s[i+r]-s[i]))
    return res

for _ in range(ni()):
    n, k = na()
    t = [int(i) for i in input()]
    s = [0]
    for i in range(n):
        s.append(s[-1] + t[i])
    
    j = n
    ans = []
    for i in range(n+1):
        while j >= 0:
            x = solve(i, j)
            #print(i, j, x)
            if x > k:
                j -= 1
            else:
                {{completion}}
    f = []
    #print(ans)
    for a in range(1, n+1):
        res = 0
        for i, j in ans:
            res = max(res, i * a + j)
        f.append(res)
    print(*f)","ans.append((i, j))
                break","ans.append((i, j))
                j -= 1
                break
    "
"from queue import deque
t=int(input())
while t>0:
    a=list(map(int,input().split()))
    n=a[0]
    m=a[1]
    S=input()
    f=[]
    g=[]
    ans=[]
    for i in range(m+1):
        f.append(0)
        g.append(0)
    for i in range(n+1):
        ans.append(-1)
    for i in range(n):
        o=0
        s=0
        j=i
        while j>=0:
            s=s+1
            o=o+(S[j]!='0')
            if o<=m:
                {{completion}}
            j=j-1
        o=0
        s=0
        j=i
        while j>=0:
            s=s+1
            o=o+(S[j]!='1')
            if o<=m:
                g[o]=max(g[o],s)
            j=j-1
        for ii in range(1,m+1):
            f[ii]=max(f[ii],f[ii-1])
            g[ii]=max(g[ii],g[ii-1])
        j=i
        o=0
        s=0
        while j<n:
            if o<=m:
                ans[f[m-o]]=max(ans[f[m-o]],s)
            j=j+1
            if j<n:
                o=o+(S[j]!='1')
            s=s+1
        j=i
        o=0
        s=0
        while j<n:
            if o<=m:
                ans[s]=max(ans[s],g[m-o])
            j=j+1
            if j<n:
                o=o+(S[j]!='0')
            s=s+1
    for i in range(1,n+1):
        s=0
        for j in range(n+1):
            if ans[j]>=0:
                s=max(s,j*i+ans[j])
        print(s,end=' ')
    print()
    t=t-1

","f[o]=max(f[o],s)","g[o]=max(g[o],s)"
"def search_on_pref(j,zam,dl,x,sr,k):
    while j>=0:
        dl+=1
        if s[j]!=sr: 
            zam+=1
        if zam<=k: 
            x[zam]=max(x[zam], dl)
        j-=1
    return x
    
def main(n,k,s):
    ans=[-1]*(n+1)
    a=[0]*(k+1)
    b=[0]*(k+1)
    for i in range(n):
        a=search_on_pref(i,0,0,a,""0"",k)
        b=search_on_pref(i,0,0,b,""1"",k)
        for ind in range(1,k+1):
            a[ind]=max(a[ind], a[ind-1])
            b[ind]=max(b[ind], b[ind-1])
        l=i; zam=0; dl=0
        while l<n:
            if zam<=k: 
                ans[a[k-zam]]=max(dl, ans[a[k-zam]])
            l+=1
            if l<n:
                if s[l]==""0"": {{completion}}
            dl+=1
        l=i; zam=0; dl=0
        while l<n:
            if zam<=k:
                ans[dl]=max(ans[dl], b[k-zam])
            l+=1
            if l<n:
                if s[l]==""1"": zam+=1
            dl+=1
    for A in range(1,n+1):
        ANSWER=0
        for j in range(0, n+1):
            if ans[j]>=0:
                ANSWER=max(ANSWER,A*j+ans[j])
        print(ANSWER,end="" "")
    print()
    
t=int(input())
for i in range(t):
    a,b=map(int,input().split())
    s=input()
    main(a,b,s)
#searching 0...n zero - getting answer for ""1""",zam+=1,zam+=1
"import math, sys
input = sys.stdin.readline

t = int(input())

for _ in range(t):
    n = int(input())
    a = [*map(int, input().split())]

    b = sorted(a)

    for x, y in zip(a, b):
        if x % 2 != y % 2:
            {{completion}}
    else:
        print(""YES"")




","print(""NO"")
            break","b.insert(x, x)
            break

    if b == sorted(a):
        print(""YES"")"
"import sys
def input(): return sys.stdin.readline().strip()

numbs=int(input())
 
for i in range(numbs):
    n = int(input())
    c, x =- 1, [int(i) for i in input().split()]
    c = x.copy()
    c.sort()
    yn = ""YES""
    for i in range(n):
        if c [i] %2 != x[i] % 2:
            {{completion}}
    print(yn)
","yn = ""NO""
            break","yn = ""NO"""
"from sys import stdin
def input(): return stdin.readline()[:-1]

def solve():
    N = int(input())
    A = list(map(int, input().split()))

    B = sorted(A)

    for i, j in zip(A,B):
        if i%2 != j%2:
            {{completion}}
    print(""YES"")


for _ in range(int(input())):
    solve()","print(""NO"")
            return","B[i], B[j] = B[j], B[i]

    if sorted(A) == B:
        print(""YES"")
    else:
        print(""NO"")

for _ in range(int(input())):
    solve()
<|/ file source=github |>"
"for case in range(int(input())):
    length, k = map(int, input().split())
    nums = list(map(int, input().split()))
    nums.sort()

    curr = 0

    l = 0

    for i in range(1, length):
        if nums[i] - nums[i-1] > k:
            {{completion}}
    curr = max(curr, length - l)

    print(length - curr)
","curr = max(curr, i - l)
            l = i","l += 1
        else:
            curr += l
            l = 0"
"
import sys
input = sys.stdin.readline
MOD = 10**9 + 7

def read_array(factory):
    return [factory(num) for num in input().strip().split()]
def print_array(arr):
    print("" "".join(map(str, arr)))

def solve(n, k, a):
    a.sort()
    cnt = 0
    max_cnt = 0
    for i in range(1, len(a)):
        if a[i] - a[i-1] > k:
            cnt = 0
        else:
            {{completion}}
        max_cnt = max(cnt, max_cnt)

    return n - max_cnt - 1

if __name__ == ""__main__"":
    # Read in input:
    t = int(input())

    # Call solution:
    for _ in range(t):
        n, k = read_array(int)
        a = read_array(int)
        ans = solve(n, k, a)
        print(ans)

",cnt += 1,cnt += 1
"n = int(input())
for i in range(n):
    a, b = map(int, input().split())
    lists = [int(j) for j in input().split()]
    lists.sort(reverse=True)
    p, count = 0, 0
    for j in range(len(lists) - 1):
        if lists[j] - lists[j + 1] <= b:
            count += 1
        else:
            {{completion}}
    p = max(p, count)

    if p == a:
        print(0)
    else:
        print(a-p-1)","p = max(p, count)
            count = 0","count = 0
        if count > p:
            p = count"
"import sys, os
input = sys.stdin.buffer.readline

def g(u, v):
    x, y = (u + c0[v]) >> 1, (u + c0[v]) & 1 
    return parent[x] & z if not y else parent[x] >> 20

q = int(input())
u, m = 0, 0
st = [0]
st0 = []
l = pow(10, 6) + 5
parent = [0] * (10 * l)
c0 = [0] * (q + 1)
a = [0] * (q + 1)
pow2 = [1]
for _ in range(19):
    pow2.append(2 * pow2[-1])
z = sum(pow2)
c = [l] * l
ans0 = [0]
ans = 0
j = 0
for _ in range(q):
    t = list(input().rstrip().decode().split())
    if t[0] == ""+"":
        x = int(t[1])
        m += 1
        parent[j >> 1] ^= u if not j & 1 else u << 20
        j += 1
        a[m] = x
        st.append(m)
        for i in range(20):
            if not i < c0[u + 1] - c0[u]:
                break
            p = g(i, u)
            parent[j >> 1] ^= p if not j & 1 else p << 20
            j += 1
            u = p
        c0[m + 1] = j
        if c[x] == l:
            st0.append(c[x])
            c[x] = m
            ans += 1
        else:
            u = m
            for i in range(19, -1, -1):
                if i < c0[u + 1] - c0[u] and g(i, u) >= c[x]:
                    {{completion}}
            if u ^ c[x]:
                st0.append(c[x])
                c[x] = m
                ans += 1
            else:
                st0.append(0)
        ans0.append(ans)
        u = m
    elif t[0] == ""-"":
        k = int(t[1])
        for i in range(20):
            if k & pow2[i]:
                k ^= pow2[i]
                u = g(i, u)
            if not k:
                break
        ans = ans0[u]
        st.append(u)
    elif t[0] == ""!"":
        v = st.pop()
        u = st[-1]
        if u < v:
            cx = st0.pop()
            if cx:
                c[a[v]] = cx
        ans = ans0[u]
    else:
        ans = ans0[u]
        os.write(1, b""%d\n"" % ans)","u = g(i, u)","c[x] = g(i, u)
                    ans += 1
                    break
            st0.append(0)
    elif t[0] == ""-"":
        k = int(t[1])
        for i in range(20):
            if k & pow2[i]:
                k ^= pow2[i]
                u = g(i, u)
            if not k:
                break
        ans = ans0[u]
        st.append(u)
    elif t[0] == ""!"":
        v = st.pop()
        u = st[-1]
        if u < v:
            cx = st0.pop()
            if cx:
                c[a[v]] = cx
        ans = ans0[u]
    else:
        ans = ans0[u]
        os."
"for s in[*open(0)][2::2]:{{completion}}
","print('YNEOS'[sum(map(int,s.split()))%2::2])","
    s=s.split()
    s=sorted(s)
    sum1=sum(s[:2])
    sum2=sum(s[2:])
    if sum1%2==sum2%2==1:
        print(""YES"")
    else:
        print(""NO"")
<|/ a dscore=0 |>"
"for _ in range(int(input())):
    n=int(input())
    lst=list(map(int,input().split()))
    c=0
    for i in lst:
        if i%2!=0:
            {{completion}}
    print('YES' if c%2==0 else ""NO"")",c+=1,"c-=i
        else:
            c+=i"
"for _ in range(int(input())):
    {{completion}}","input()
    print(""NO"" if sum(map(int, input().split())) & 1 else ""YES"")","array = list(map(int, input().split()))
    sum1 = sum(array[:len(array) // 2])
    sum2 = sum(array[len(array) // 2:])
    if sum1 % 2 == 0 and sum2 % 2 == 0:
        print(""YES"")
    else:
        print(""NO"")
<|/ file filename=coloring.py |>"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    ls = list(map(int,input().split()))
    tmp_ls = [i for i in ls]
    tmp_ls.sort()
    s = sum(tmp_ls)
    ans = {}
    a = s-n*(tmp_ls[0]-1)
    ans[tmp_ls[0]] = a
    for i in range(1,n):
        {{completion}}
    ls_ans = [ans[x] for x in ls]
    print("" "".join(map(str, ls_ans)))
","a+=(-n+2*i)*(tmp_ls[i]-tmp_ls[i-1])
        ans[tmp_ls[i]] = a","tmp_ls[i] = tmp_ls[i-1]+1
        ans[tmp_ls[i]] = tmp_ls[i]
    tmp_ls.sort()
    ls = [tmp_ls[i] for i in ls]"
"import sys
input=sys.stdin.readline

t=int(input())
for _ in range(t):
    n=int(input())
    x=list(map(int,input().split()))
    a=sorted(x)
    pref=[0]
    val=dict()
    for i in range(n):
        pref.append(pref[-1]+a[i])
    for i in range(n):
        less=a[i]*(i+1)-(pref[i+1]-(i+1))
        if(i<=n-2):
            more=(pref[n]-pref[i+1])-(a[i]-1)*(n-i-1)
        else:
            {{completion}}
        val[a[i]]=less+more
    ans=[val[x[i]] for i in range(n)]
    print(*ans)
        
",more=0,"more=a[i]*(n-i)
        ans=0
        for j in range(n):
            if(j==i):
                continue
            ans+=pref[j]*val[j]
        val[a[i]]=less+more
    ans=[val[x[i]] for i in range(n)]
    print(*ans)
<|/ file ext=.py |>"
"from sys import stdin
def input(): return stdin.readline()[:-1]

def solve():



    N = int(input())
    

    
    arr = list(map(int, input().split()))

    if N == 1:
        {{completion}}
    b = sorted(arr)
    
    d = {}
    for i in range(N):
        d[b[i]] = i

    ANS = [0] * N

    segments = [0] * (N-1)
    for i in range(N-1):
        segments[i] = b[i+1] - b[i]
    
    filter = [0] * (N-1)
    filter[0] = 2-N
    for i in range(1, N-1):
        filter[i] = filter[i-1] + 2
    initial = 0
    initial += N
    for i in range(N-1):
        initial += segments[i] * (N-1-i)
    ANS[0] = initial

    for i in range(1, N):
        ANS[i] = ANS[i-1] + (filter[i-1] * segments[i-1])
    
    # print(*ANS)
    a = []
    for i in arr:
        a.append(ANS[d[i]])
    print(*a)
    

for _ in range(int(input())):
    solve()","print(1)
        return","arr = [arr[0]]
    "
"import sys 
input = sys.stdin.buffer.readline 

def find_root(root_dict, x):
    L = []
    while x != root_dict[x]:
        {{completion}}
    for y in L:
        root_dict[y] = x
    return x 
    
p = 998244353

def process(n, S, G):
    root_dict = [i for i in range(n+1)]
    root_size = [1 for i in range(n+1)]
    G = sorted(G, key=lambda a: a[2], reverse=True)
    answer = 1
    while len(G) > 0:
        u, v, w = G.pop()
        u1 = find_root(root_dict, u)
        v1 = find_root(root_dict, v)
        sizes = S-w+1
        g1 = root_size[u1]
        g2 = root_size[v1]
        entry = pow(sizes, g1*g2-1, p)
        answer = (answer*entry) % p 
        root_dict[u1] = v1 
        root_size[v1]+=g1 
    print(answer)
        
        

t = int(input())
for i in range(t):
    n, S = [int(x) for x in input().split()]
    G = []
    for j in range(n-1): 
        u, v, w = [int(x) for x in input().split()]
        G.append([u, v, w])
    process(n, S, G)","L.append(x)
        x = root_dict[x]","x += 1
        L.append(x)"
"# https://codeforces.com/contest/1857

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!

MOD = 998244353


class DisjointSetUnion:
    def __init__(self, n):
        self.n = n
        self.parent = list(range(n))
        self.rank = [1] * n
        self.size = [1] * n

    def find_set(self, x):
        """"""Finds the representative of the set that x belongs to.""""""
        xx = x
        while x != self.parent[x]:
            x = self.parent[x]
        while xx != x:
            self.parent[xx], xx = x, self.parent[xx]
        return x

    def same_set(self, x, y):
        """"""Returns true if x and y belong to the same set, and false otherwise.""""""
        return self.find_set(x) == self.find_set(y)

    def unite_sets(self, x, y):
        """"""Unites two sets; returns True if the sets were not united before and False otherwise.""""""
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] < self.rank[y]:
            self.parent[x] = y
            self.size[y] += self.size[x]
        elif self.rank[x] > self.rank[y]:
            {{completion}}
        else:
            self.parent[y] = x
            self.rank[x] = self.rank[x] + 1
            self.size[x] += self.size[y]
        return True

    def set_size(self, x):
        """"""Returns the size of the set that x belongs to.""""""
        return self.size[self.find_set(x)]


def solve_case():
    n, s = map(int, input().split())
    edges = sorted([tuple(map(int, input().split())) for _ in range(n - 1)], key=lambda x: x[2])
    dsu = DisjointSetUnion(n + 1)
    ans = 1
    for u, v, w in edges:
        ans = ans * pow(s - w + 1, dsu.set_size(u) * dsu.set_size(v) - 1, MOD) % MOD
        dsu.unite_sets(u, v)
    print(ans)


for _ in range(int(input())):
    solve_case()
","self.parent[y] = x
            self.size[x] += self.size[y]","y, x = self.find_set(y), self.find_set(x)"
"import sys
input = sys.stdin.readline
INF = 998244353

def find(n) :
    d = []
    while U[n] !=  n : d.append(n) ; n = U[n]
    for num in d : U[num] = n

    return n

for _ in range(int(input())) :
    n, S = map(int,input().split()) ; I = [tuple(map(int,input().split())) for _ in range(n-1)]

    I.sort(key = lambda x : -x[2]) ; U = [x for x in range(1+n)] ; D = [1] * (n+1)

    Ans = 1
    while I :
        a, b, c = I.pop() ; p, q = find(a), find(b)

        r = D[p]*D[q]-1 ; s = S-c+1

        R = []
        while r > 1 : R.append(r%2) ; r //= 2

        while R :
            s = (s*s)%INF
            if R.pop() == 1 : {{completion}}

        if D[p]*D[q]-1 != 0 : Ans = (Ans*s)%INF
        if p < q : U[q] = p ; D[p] += D[q]
        else : U[p] = q ; D[q] += D[p]

    print(Ans)",s = (s*(S-c+1))%INF,"break
            s += INF"
"q = ' ' + input()
n = len(q) - 1
F = [0] * 101
G = [0] * 101
cnt, cur = 0, 0
F[0], G[0] = 1, 1
for i in range(1, n + 1) :
	if q[i] == '0' :
		cnt += 1
		for j in range(cnt, 0, -1) :
			F[j] |= F[j - 1] << i
	else :
		cur += cnt
		for j in range(i - cnt, 0, -1) :
			{{completion}}
tag = (n * (n - 1) - cnt * (cnt - 1) - (n - cnt) * (n - cnt - 1)) // 4
for x in range(n + 1) :
	if (F[x] << cur) & (G[x] << tag) :
		print(x)
		break
",G[j] |= G[j - 1] << i,"G[j] |= G[j - 1] << cur
		cnt -= 1"
"q = ' ' + input()
n = len(q) - 1#input
F = [0] * 101
G = [0] * 101
cnt, cur = 0, 0
F[0], G[0] = 1, 1
for i in range(1, n + 1) :
	if q[i] == '0' :
		cnt += 1
		for j in range(cnt, 0, -1) :
			F[j] |= F[j - 1] << i
	else :
		cur += cnt
		for j in range(i - cnt, 0, -1) :
			{{completion}}
tag = (n * (n - 1) - cnt * (cnt - 1) - (n - cnt) * (n - cnt - 1)) // 4
for x in range(n + 1) :
	if (F[x] << cur) & (G[x] << tag) :
		print(x)#printing output
		break",G[j] |= G[j - 1] << i,"G[j] |= G[j - 1] << cur
		cnt = 1"
"s = ' ' + input()
n = len(s) - 1
F = [0] * 101
G = [0] * 101
cnt, cur = 0, 0
F[0], G[0] = 1, 1
for i in range(1, n + 1) :
	if s[i] == '0' :
		cnt += 1
		for j in range(cnt, 0, -1) :
			F[j] |= F[j - 1] << i
	else :
		cur += cnt
		for j in range(i - cnt, 0, -1) :
			{{completion}}
tag = (n * (n - 1) - cnt * (cnt - 1) - (n - cnt) * (n - cnt - 1)) // 4
for x in range(n + 1) :
	if (F[x] << cur) & (G[x] << tag) :
		print(x)
		break
# TEST 19",G[j] |= G[j - 1] << i,"G[j] |= G[j - 1] << cur
		cnt -= 1
F[n], G[n] = 1, 1"
"I,V,R=input,10**18,range
for _ in""z""*int(I()):
    n,k=map(int,I().split())
    a=list(map(int,I().split()))
    b=list(map(int,I().split()))
    d=[[0 for i in R(k+1)]for j in R(n+1)]
    f=[[V]*3007,[-V]*3007,[V]*3007,[-V]*3007]
    for i in R(n+1):
        for j in R(min(i+1,k+1)):
            x,y=i-1,i-j
            if i:
                {{completion}}
            z=d[i][j]
            if i<n:
                f[0][y]=min(f[0][y],a[i]+b[i]-z)
                f[1][y]=max(f[1][y],a[i]+b[i]+z)
                f[2][y]=min(f[2][y],b[i]-a[i]-z)
                f[3][y]=max(f[3][y],b[i]-a[i]+z)
    print(d[n][k])","d[i][j]=max(d[x][j],a[x]+b[x]-f[0][y],-a[x]-b[x]+f[1][y],a[x]-b[x]-f[2][y],b[x]-a[x]+f[3][y])","z=d[x][y]
                if j<k:
                    f[0][x]=min(f[0][x],a[i]+b[i]-z)
                    f[1][x]=max(f[1][x],a[i]+b[i]+z)
                    f[2][x]=min(f[2][x],b[i]-a[i]-z)
                    f[3][x]=max(f[3][x],b[i]-a[i]+z)
            if j<k:
                z=d[x][y]
                if i<n:
                    f[0][y]=min(f[0][y],a[i]+b[i]-z)
                    f[1][y]=max(f[1][y],a[i]+b[i]"
"from sys import stdin, stdout

t = int(stdin.readline())

for _ in range(t):
    n, k = [int(x) for x in stdin.readline().split()]
    a = [int(x) for x in stdin.readline().split()]
    b = [int(x) for x in stdin.readline().split()]

    dp = [0]*(k+1)
    for i in range(n,k-1,-1):
        dp2 = [0]
        diag11 = a[i-1]+b[i-1]
        diag12 = a[i-1]-b[i-1]
        diag21 = -a[i-1]+b[i-1]
        diag22 = -a[i-1]-b[i-1]

        for j in range(1,k+1):
            dp2.append(max(diag11-b[i-j]-a[i-j], diag12-b[i-j]+a[i-j], diag21+b[i-j]-a[i-j], diag22+b[i-j]+a[i-j], dp[j]))
            if i-j > 0:
                {{completion}}

        dp = dp2

    stdout.write(str(dp[-1])+""\n"")
","diag11 = max(diag11, dp2[-1]+a[i-j-1]+b[i-j-1])
                diag12 = max(diag12, dp2[-1]+a[i-j-1]-b[i-j-1])
                diag21 = max(diag21, dp2[-1]-a[i-j-1]+b[i-j-1])
                diag22 = max(diag22, dp2[-1]-a[i-j-1]-b[i-j-1])","dp2.append(max(dp[j-1], dp[j-2]))"
"import collections
import sys
import heapq

input = sys.stdin.readline


def inp():
    return (int(input()))
def inlt():
    return (list(map(int, input().split())))
def insr():
    s = input()
    return (list(s[:len(s) - 1]))
def invr():
    return (map(int, input().split()))


def solution():
    n, k = inlt()
    a = inlt()
    b = inlt()
    dp = [[0] * (k+1) for i in range(n+1)]
    # -a + b
    dp1 = [-10**18] * (n+1)
    # a + b
    dp2 = [-10**18] * (n + 1)
    # -a - b
    dp3 = [-10**18] * (n + 1)
    # a - b
    dp4 = [-10**18] * (n + 1)
    for i in range(n+1):
        for j in range(min(i, k)+1):
            if i != 0:
                {{completion}}
            diag_val = i - j
            if i != 0:
                dp[i][j] = max(dp[i][j], - a[i - 1] + b[i - 1] + dp1[diag_val])
                dp[i][j] = max(dp[i][j], + a[i - 1] + b[i - 1] + dp3[diag_val])
                dp[i][j] = max(dp[i][j], - a[i - 1] - b[i - 1] + dp2[diag_val])
                dp[i][j] = max(dp[i][j], + a[i - 1] - b[i - 1] + dp4[diag_val])
            if i != n:
                dp1[diag_val] = max(dp1[diag_val], dp[i][j] - a[i] + b[i])
                dp2[diag_val] = max(dp2[diag_val], dp[i][j] + a[i] + b[i])
                dp3[diag_val] = max(dp3[diag_val], dp[i][j] - a[i] - b[i])
                dp4[diag_val] = max(dp4[diag_val], dp[i][j] + a[i] - b[i])

    print(dp[-1][-1])

    return 0


if __name__ == '__main__':
    t = inp()
    for i in range(t):
        solution()
",dp[i][j] = dp[i-1][j],"dp[i][j] = max(dp[i][j], - a[i - 1] + b[i - 1])
                dp[i][j] = max(dp[i][j], + a[i - 1] + b[i - 1])
                dp[i][j] = max(dp[i][j], - a[i - 1] - b[i - 1])
                dp[i][j] = max(dp[i][j], + a[i - 1] - b[i - 1])
            if i != n:
                dp1[i - j + 1] = max(dp1[i - j + 1], dp[i][j] - a[i] + b[i])
                dp2[i - j + 1] = max(dp2[i - j + 1], dp[i][j] + a[i] + b[i])
                dp3[i - j + 1]"
"T = int(input())
while T:
    T -= 1
    n = int(input())
    mn = -1
    for i in range(n):
        x,y = map(int, input().split())
        if x < 11 and y > mn:
            {{completion}}
    print( ans )","ans = i + 1
            mn = y","ans = x
            mn = y"
"x=int(input())
for i in range(x):
   z=int(input())
   c=0
   s=0
   for i in range(1,z+1):
        a,b=map(int, input().split())     
        if a<=10 and b>c:
            {{completion}}
   print(s)","c=b
            s=i","s=s+1
            c=b
   if s==z:
       print(1)
   else:"
"t = int(input())

for _ in range(t):
    n = int(input())
    r = []
    
    for i in range(n):
        a, b = map(int, input().split())
        if a <= 10:
            {{completion}}
    
    r.sort(key=lambda x: x[1], reverse=True)
    print(r[0][0])
","r.append((i + 1, b))","r.append((a, b))
        else:
            r.append((10, b))"
"import sys
input = sys.stdin.readline
INF = 10 ** 9
K = 26 * 26
 
A = [ord(char) - ord(""a"") for char in input().rstrip()]
n = len(A)
G = [[] for _ in range(K)]
 
for i in range(1, n):    
    v = A[i - 1] * 26 + A[i]
    G[v].append(i)
 
 
m = int(input())
queries = [tuple(map(int, input().split())) for _ in range(m)]
res = [abs(f - t) for f, t in queries]
 
for v in range(K):
    if not G[v]:
        continue
    
    vis = [False] * K
    vis[v] = 0
    dist = [INF] * n
    q = list(G[v])
    for j in G[v]:
        dist[j] = 0
 
    for idx in range(n - 1):
        i = q[idx]
        if i < n - 1 and dist[i + 1] == INF:
            dist[i + 1] = dist[i] + 1
            q.append(i + 1)
        
        if i > 1 and dist[i - 1] == INF:
            dist[i - 1] = dist[i] + 1
            q.append(i - 1)
 
        v = A[i - 1] * 26 + A[i]
        if not vis[v]:
            vis[v] = True
            for j in G[v]:
                if dist[j] == INF:
                    {{completion}}
 
    for i, (f, t) in enumerate(queries):
        res[i] = min(res[i], dist[f] + dist[t] + 1)
 
print(""\n"".join(map(str, res)))","dist[j] = dist[i] + 1
                    q.append(j)","dist[j] = dist[i] + 1
                    q.append(j)
 "
"import collections
import sys
import heapq

input = sys.stdin.readline


def inp():
    return (int(input()))
def inlt():
    return (list(map(int, input().split())))
def insr():
    s = input()
    return (list(s[:len(s) - 1]))
def invr():
    return (map(int, input().split()))


def solution():
    s = input().strip()
    n = len(s)
    li = []
    cnt = [[] for _ in range(676)]
    for i in range(n-1):
        cur_val = (ord(s[i]) - ord('a')) * 26 + (ord(s[i+1]) - ord('a'))
        cnt[cur_val].append(i)
        li.append(cur_val)
    # Read the queries
    queries = []
    m = inp()
    ans = [0] * m
    for i in range(m):
        s, t = inlt()
        s -= 1
        t -= 1
        queries.append((s, t))
        ans[i] = abs(t - s)

    # Run BFS on each of the 26*26 and update the best res
    dis = [n] * n
    visited = [False] * n
    flag = [False] * 676
    for i in range(676):
        # Re-init the dis and visited
        for j in range(n):
            dis[j] = n
            visited[j] = False
        for j in range(676):
            flag[j] = False

        # Multi-Source BFS
        q = collections.deque()
        flag[i] = True
        for j in cnt[i]:
            visited[j] = True
            q.append((j, 0))
        while q:
            x, d = q.popleft()
            dis[x] = d
            if x > 0 and visited[x - 1] is False:
                visited[x - 1] = True
                q.append((x - 1, d + 1))
            if x < n-2 and visited[x + 1] is False:
                visited[x + 1] = True
                q.append((x + 1, d + 1))
            if flag[li[x]] is False:
                flag[li[x]] = True
                for y in cnt[li[x]]:
                    if visited[y] is False:
                        {{completion}}

        for j, (s, t) in enumerate(queries):
            ans[j] = min(ans[j], dis[s] + dis[t] + 1)

    for i in ans:
        print(i)


if __name__ == '__main__':
    t = 1
    for i in range(t):
        solution()
","visited[y] = True
                        q.append((y, d + 1))","visited[y] = True
                        q.append((y, d + 1))

        dis = [dis[j] for j in range(n)]
        visited = [visited[j] for j in range(n)]
        flag = [flag[j] for j in range(676)]"
"import sys

input = sys.stdin.readline

s = input().strip()
n = len(s)
dis = [n]*n
visit = [False] * n
li = []
cnt = [[] for _ in range(676)]
for i in range(n - 1):
    tmp = (ord(s[i]) - ord('a')) * 26 + ord(s[i + 1]) - ord('a')
    cnt[tmp].append(i)
    li.append(tmp)
queries = []
m = int(input())
ans = [0] * m
for i in range(m):
    s,t = map(int,input().split())
    s -= 1
    t -= 1
    queries.append((s,t))
    ans[i] = abs(s - t)


for i in range(676):
    for j in range(n):
        visit[j] = False
        dis[j] = n
    # 不要多次进入同一个传送门
    flag = [False] * 676
    from collections import deque
    q = deque([])
    flag[i] = True
    for j in cnt[i]:
        visit[j] = True
        q.append(j)
    d = 0
    while q:
        for _ in range(len(q)):
            x = q.popleft()
            dis[x] = d
            if x > 0 and not visit[x - 1]:
                visit[x - 1] = True
                q.append(x - 1)
            if x < n - 2 and not visit[x + 1]:
                visit[x + 1] = True
                q.append(x + 1)
            if not flag[li[x]]:
                flag[li[x]] = True
                for y in cnt[li[x]]:
                    if not visit[y]:
                        {{completion}}
        d += 1
    for j,(s,t) in enumerate(queries):
        ans[j] = min(ans[j],dis[s] + dis[t] + 1)

for i in ans:
    print(i)","visit[y] = True
                        q.append(y)","visit[y] = True
                        q.append(y)"
"import sys
def input()   : return sys.stdin.readline().strip()
def getints() : return map(int,sys.stdin.readline().strip().split())

for _ in range(int(input())):
    n,steps = getints()
    l = list(getints())
    
    ans = max(l)
    for j in range(n-1):
        w = 1
        k = steps
        a = list(l)
        sol = a[j]
        for i in range(j,n-1):
            t1 = a[i+1]-a[i]+1
            if t1 >= 0:
                if k >= w*t1:
                    k -= w*t1
                    sol += t1
                    w += 1
                else:
                    sol += k//w
                    break
            else:
                if k >= -1*t1:
                    k += t1
                    w += 1
                    a[i+1] -= t1
                else: {{completion}}
        ans = max(sol,ans)
    print(ans)",break,"
                    sol += k//w
                    break"
"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    max_a = max(a)
    x, y = max_a, max_a+k
    b = [0]*n
    for i in range(n):
        b[i] = b[i-1]+a[i]

    def valid(z):
        # breakpoint()
        t = z-max_a
        for i in range(n-t):
            cnt = 0
            c_flag = False
            if a[i+t] != max_a:
                if i+t == n-1:
                    c_flag = True
                for j in range(i+t+1, n):
                    if a[j] >= max_a-(j-i-t):
                        break
                    else:
                        if j == n-1:
                            c_flag = True
                            break
                        else:
                            {{completion}}
            if c_flag:
                continue
            if cnt+(max_a+z)*(t+1)//2 - (b[i+t]-(b[i-1] if i > 0 else 0)) <= k:
                return True
        return False

    while x < y:
        z = (x+y+1)//2
        if valid(z):
            x = z
        else:
            y = z-1
    print(x)

t = int(input())
for _ in range(t):
    solve()
",cnt += max_a-(j-i-t)-a[j],"cnt += 1
            if c_flag:
                continue
            if cnt+(max_a+z)*(t+1)//2 - (b[i+t]-(b[i-1] if i > 0 else 0)) <= k:
                return True
        return False

    while x < y:
        z = (x+y+1)//2
        if valid(z):
            x = z
        else:
            y = z-1
    print(x)

t = int(input())
for _ in range(t):
    solve()
'''
<|/ a tags=python,algorithm |>"
"import sys

R = lambda:map(int, sys.stdin.readline().rstrip().split())

def solve():
    n, k = R()
    lst = list(R())
    mult = set(lst)
    ans = 0
    arr = lst.copy()
    for i in range(n - 2, -1 , -1):
        if arr[i + 1] >= arr[i]:
            arr[i] = arr[i + 1] + 1
    i = 1
    while i < n and arr[i - 1] == arr[i] + 1:
        i += 1
    i -= 1
    num = arr[0] + 1
    nmax = arr[0] + 1
    nmin = arr[i] - 1
    while nmax - nmin > 1:
        mid = (nmax + nmin) // 2
        indmax = num - mid
        summin = 10**9
        for j in range(indmax):
            temp = 0
            count = mid
            for e in range(j, i):
                dif = count - lst[e]
                if dif <= 0:
                    {{completion}}
                count -= 1
                temp += dif
            summin = min(summin, temp)
        if summin > k:
            nmax = mid
        else:
            nmin = mid
    print(nmin)
        

t ,= R()
for _ in range(t):
    solve()

",break,"dif = 1
                temp += dif
                count -= 1
            summin = min(summin, temp)
        if summin > k:
            nmax = mid
        else:
            nmin = mid
    print(nmin)

t ,= R()
for _ in range(t):
    solve()

'''
Sample Input:
2
3 5
1 2 3 4 5

Sample Output:
2
'''
<|/ file filename=MaxSumSubarray.py |>"
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()

M = 998244353

for _ in range(int(input())):
    n, k = map(int, input().split())
    dp = [[0]*(k+1) for _ in range(n+1)]
    dp[0] = [1]*(k+1)

    for req in range(n+1):
        for last in range(1, k+1):
            for i in range(1, k+2-last):
                if last*i > req: {{completion}}
                dp[req][last] += dp[req - last*i][i]
                dp[req][last] %= M

    print(sum(dp[n]) % M)",break,break
"M = 998244353
 
t = int(input())
 
for _ in range(t):
    n, k = map(int, input().split())
    
    dp = [[1] * (k + 1)] + [[0 for _ in range(k + 1)] for _ in range(n)]
    
    for i in range(1, n + 1):
        for j in range(0, k + 1):
            for l in range(0, k - j):
                if i - (l + 1) * (j + 1) < 0:
                    {{completion}}
                dp[i][j] = (dp[i][j] + dp[i - (l + 1) * (j + 1)][l]) % M
 
    ans = 0
    for j in range(0, k + l):
        ans = (ans + dp[n][j]) % M
    print(ans)",break,"dp[i][j] = dp[i - (l + 1) * (j + 1)][j]
                elif i - (l + 1) * (j + 1) >= n:
                    dp[i][j] = dp[i - (l + 1) * (j + 1)][j] + dp[i - (l + 1) * (j + 1)][j - 1]
                else:"
"# https://codeforces.com/contest/1920

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!

MOD = 998244353


def ff(i, j, k):
    return i * k + j


def solve_case():
    n, k = map(int, input().split())  # 1 <= k <= n <= 2_500

    dp = [0] * (k * (n + 1))

    for j in range(k):
        dp[ff(0, j, k)] = 1

    for i in range(n + 1):
        for j in range(k):
            if dp[ff(i, j, k)]:
                for t in range(k):
                    if j + t + 1 > k:
                        {{completion}}
                    add = (j + 1) * (t + 1)
                    if i + add > n:
                        break
                    dp[ff(i + add, t, k)] += dp[ff(i, j, k)]
                    if dp[ff(i + add, t, k)] >= MOD:
                        dp[ff(i + add, t, k)] -= MOD

    ans = sum(dp[ff(n, j, k)] for j in range(k))
    ans %= MOD
    print(ans)


for _ in range(int(input())):
    solve_case()
",break,"dp[ff(i, j, k)] = 0
                        break"
"for n in[*map(int,open(0))][1:]:
 i=1
 while n%i<1:{{completion}}
 print(i-1)",i+=1,"
  i=i*10"
"for k in[*map(int,open(0))][1:]:
 i=1
 while k%i<1:{{completion}}
 print(i-1)",i+=1,"
  i=i*10"
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    i = n-1
    while(i>0):
        if a[i]<a[i-1]:
            {{completion}}
        i-=1
    if i==0:
        print(0)
    else:
        a = a[:i+1]
        print(max(a))",break,"temp = a[i]
            a[i] = a[i-1]
            a[i-1] = temp"
"def main():
    t = int(input())
    results = []

    for _ in range(t):
        n = int(input())
        arr = list(map(int, input().split()))
        max_element = 0

        for i in range(n - 1):
            if arr[i] > arr[i + 1] and arr[i] > max_element:
                {{completion}}

        results.append(max_element)

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()
",max_element = arr[i],"arr[i] = 0
                max_element = arr[i]
            elif arr[i] < arr[i + 1] and arr[i] > max_element:
                arr[i] = 0
                max_element = arr[i]"
"#https://codeforces.com/problemset/problem/1856/A

t = int(input())
answer_list = []
while t > 0:
    n = int(input())
    a = [int(x) for x in input().split()]
    a_sorted = sorted(a)
    answer = 0
    for x in range(n-1, -1, -1):
        if(a[x] != a_sorted[x]):
            {{completion}}
    answer_list.append(answer)
    t-=1
for answer in answer_list:
    print(answer)","answer = a_sorted[x]
            break","answer += 1
            break"
"for s in[*open(0)][2::2]:{{completion}}
","print('NYOE S'[1<len(a:=s.split())<=sum(map(int,a))-a.count('1')::2])","
    s=s.split()
    s=int(s[0])
    a=int(s[1:])
    sum=0
    for j in range(1,n+1):
        if a[j]==a[j-1]:
            sum+=a[j]
    if sum==n:
        print(""YES"")
    else:
        print(""NO"")
<|/ file ext=.py |>"
"for s in[*open(0)][2::2]:
    {{completion}}","print('NYOE S'[1<len(a:=s.split())<=sum(map(int,a))-a.count('1')::2])","s=int(s)
    if s==sum(s):
        print(""YES"")
    else:
        print(""NO"")
<|/ file source=github |>"
for san in[*open(0)][2::2]:{{completion}},"print('NYOE S'[1<len(a:=san.split())<=sum(map(int,a))-a.count('1')::2])","
    san=san.split()
    san=san[0]
    san=san.split("","")
    san=san[0]
    san=san.split(""\n"")
    san=san[0]
    san=san.split(""\n"")
    san=san[0]
    san=san.split(""\n"")
    san=san[0]
    san=san.split(""\n"")
    san=san[0]
    san=san.split(""\n"")
    san=san[0]
    san=san.split(""\n"")
    san=san[0]
    san=san.split(""\n"")
    san=san[0]
    san="
"import sys
input = sys.stdin.readline
MOD = 998244353

n, k = map(int, input().split())
dp = [0] * k
dp[0] = 1
ans = 0

for i in range(n):
    ndp = [0] * k
    sm = 0
    for j in range(k - 1, -1, -1):
        sm = (sm + dp[j]) % MOD
        if j > 0:
            {{completion}}
        ndp[(j + 1) % k] += (k - j) * dp[j]
        ndp[(j + 1) % k] %= MOD

    dp = ndp
    ans += dp[0] * pow(k, n - 1 - i, MOD) % MOD
    ans %= MOD

print(ans)",ndp[j] += sm,"ndp[j] += dp[j - 1]
        ndp[j] += sm
        ndp[j] %= MOD
        dp[j] = 0
        if j > 0:
            dp[j - 1] = (dp[j - 1] + dp[j]) % MOD
    dp = ndp
    ans += dp[0] * pow(k, n - 1 - i, MOD) % MOD
    ans %= MOD

print(ans)
<|/ a tags=algorithm,dynamic-programming |>
<| a dscore=0 |>
<code>
import sys
input = sys.stdin.readline
MOD = 998244353

n, k = map(int, input().split())
dp = [0] * k
dp[0]"
"n, k = map(int, input().split())
mod = 998244353

factorial = [1]
for i in range(1, k+1):
    factorial.append(factorial[-1] * i % mod)

pw = [pow(k,-j,mod) for j in range(k+1)]
dp = []
for i in range(n-k+1):
    dp.append(factorial[k] * pow(k, n-k, mod) % mod)
    for j in range(1, min(i+1, k)):
        dp[i] -= (dp[i-j] * pw[j] * factorial[j]) % mod
        if dp[i] < 0: {{completion}}

print(sum(dp) % mod)",dp[i] += mod,dp[i] = 0
"import sys
input = sys.stdin.buffer.readline

m = 998244353

n, k = map(int, input().split())

ans = 0

dp = [0] * (k + 1)
dp[0] = 1
for i in range(n+1):
    ndp = [0] * (k + 1)
    p = 0
    for j in range(k, -1, -1):
        if dp[j]:
            if j != k:
                ndp[j+1] = (ndp[j+1] + (k-j)*dp[j]) % m
            if j:
                if j == k:
                    # Ensure subs don't intersect
                    ndp[1] = (ndp[1] + k*dp[j]) % m

                    ans = (ans + dp[j] * pow(k, n-i, m)) % m
                else:
                    {{completion}}
    dp = ndp

print(ans)
","p = (p + dp[j]) % m
                    ndp[j] = (ndp[j] + p) % m","ndp[j+1] = (ndp[j+1] + dp[j]) % m
            else:
                ndp[1] = (ndp[1] + dp[j]) % m
        else:
            ndp[j+1] = dp[j]
        dp = ndp

print(ans)
'''
<|/ a dscore=0 |>"
"y = int(input())
 
for _ in range(y):
    {{completion}}","p, q, k = (int(v) for v in input().split())
    l= min(p,q+k+1)
    print(l*2-1)","b, c, h = map(int, input().split())
    layers = [b]
    for i in range(c):
        layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
    layers.extend(layers)
"
"from sys import stdin



n = int(stdin.readline())

for ligne in stdin:

    ligne = ligne.split("" "")
    b=int(ligne[0])

    c=int(ligne[1])
    h=int(ligne[2])
    if b>c+h:
            print(2*(c+h)+1)
    elif b<=c+h:
            {{completion}}
 		  	     	    		    	 	 	",print(2*b-1),"
            print(2*(b+h)+1)
    else:
            print(2*(c+h)+1)
    
<|/ file ext=.py |>"
"def main():
    for _ in range(int(input())):
        {{completion}}

if __name__ == ""__main__"":
    main()
","b, c, h = map(int, input().split())
        print(min(b - 1, c + h) * 2 + 1)","b, c, h = map(int, input().split())
        print(max(b, c))"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    a = [int(i) for i in input().split()]
    b = [int(i) for i in input().split()]
    mx = -2*10**9-1
    ans = []
    for i in range(n):
        d = a[i] - b[i]
        if d > mx:
            ans = [i+1]
            mx = d
        elif d == mx:
            {{completion}}
    print(len(ans))
    print(*ans)
",ans.append(i+1),ans.append(i+1)
"from sys import stdin
input = stdin.readline


def solve():
    input()
    edges = []
    stream = zip(
        map(int, input().split()),
        map(int, input().split()),
    )
    best = float(""-inf"")
    result = []
    for pos, (a, b) in enumerate(stream):
        cost = a - b
        if cost > best:
            {{completion}}
        if cost == best:
            result.append(pos + 1)

    result.sort()
    print(len(result))
    return "" "".join(str(x) for x in result)


for _ in range(int(input())):
    print(solve())
","best = cost
            result = []","best = cost
            edges = [(a, b)]
        elif cost == best:
            edges.append((a, b))

    for a, b in edges:
        cost = a - b"
"from sys import stdin
input=lambda :stdin.readline()[:-1]

def solve():
  n=int(input())
  a=list(map(int,input().split()))
  b=list(map(int,input().split()))
  c=[a[i]-b[i] for i in range(n)]
  mx=max(c)
  ans=[]
  for i in range(n):
    if c[i]==mx:
      {{completion}}
  print(len(ans))
  print(*ans)


for _ in range(int(input())):
  solve()",ans.append(i+1),"ans.append(i)
  ans.sort()"
"import sys
input = sys.stdin.readline

def solve():
    n, m, d = map(int, input().split())
    a = list(map(int, input().split()))
    a.insert(0, -d + 1)
    a.append(n + 1)
    cooki = 0
    for i in range(m + 1):
        cooki += (a[i + 1] - a[i] - 1) // d
    cooki += m

    ans = cooki
    res = 0
    for i in range(1, m + 1):
        curr = cooki - (a[i] - a[i - 1] - 1) // d - (a[i + 1] - a[i] - 1) // d
        curr += (a[i + 1] - a[i - 1] - 1) // d - 1
        if curr < ans:
            {{completion}}
        if curr == ans:
            res += 1
    print(ans, res)
    return

def main():
    t = int(input())
    for _ in range(t):
        solve()


main()
",res = 0 ; ans = curr,ans = curr
"import sys
def input()   : return sys.stdin.readline().strip()
def getints() : return map(int,sys.stdin.readline().strip().split())

import bisect
left  = lambda l,a : bisect.bisect_left(l,a)
right = lambda l,a : bisect.bisect_right(l,a)

for _ in range(int(input())):
    n,m,d = getints()
    l = list(getints())
    
    ans = 1
    dst = 1
    i = 0
    base = 1
    c = 0
    while True:
        if base:
            if l[i] == 1: i += 1
            base = 0    
        elif i < m:
            if i+1 < m:
                if l[i] < dst+d:
                    if l[i+1] <= dst+d: c+= 1
                    elif 1+(l[i+1]-l[i])//d + int(bool((l[i+1]-l[i])%d)) > (l[i+1]-dst)//d+int(bool((l[i+1]-dst)%d)): c += 1
            elif i == m-1:
                if l[i] < dst+d:
                    if dst+d > n: c+= 1 
                    elif 1+(n-l[i])//d > (n-dst)//d: {{completion}}
                    
            ans += 1
            if dst + d < l[i]:
                dst += d
            elif dst + d == l[i]:
                i += 1
                dst += d
            else:
                dst = l[i]
                i += 1
        else:
            ans += (n-dst)//d
            break
    print(ans-1 if c else ans, c if c else m)
  			   	 	  	 			  			 	  			",c += 1,c += 1
"import sys
input=sys.stdin.buffer.readline
def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input()
def rm():
    return map(int,input().split())

def main():
    n,m,d=rm()
    a=rl()
    if a[0]!=1: a=[1]+a
    a.append(n+1)
    cnt=len(a)-1
    for i in range(1,len(a)):
        cnt+=(a[i]-a[i-1]-1)//d
    res=0
    if len(a)==2: return [cnt,m]
    for i in range(1,len(a)-1):
        if (a[i]-a[i-1]-1)//d+(a[i+1]-a[i]-1)//d+1>(a[i+1]-a[i-1]-1)//d:
            {{completion}}
    if res!=0: return [cnt-1,res]
    else: return [cnt,m]
t=ri()
for i in range(t):
    print(*main())",res+=1,"res+=1
    if res==0: return [cnt,m]
    cnt+=(a[-1]-a[-2]-1)//d"
for s in[*open(0)][2::2]:{{completion}},"print(sum(x==str(i)for
i,x in enumerate(s.split(),1))+1>>1)","
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s=sorted(s)
    s="
"for _ in range(int(input())):
    {{completion}}

","n = int(input())
    c = list(map(int, input().split()))
    res = sum(1 for i in range(1, n + 1) if i == c[i - 1])
    print((res + 1) // 2)","n, *p = map(int, input().split())
    ans = 0
    for _ in range(n):
        ans += p[0]
        p[0], p[1] = p[1], p[0]
    print(ans)"
"t=int(input())
for i in range(t):
    n=int(input())
    p=list(map(int,input().split()))
    say=0
    for i in range(n):
        if p[i]==i+1:
            {{completion}}
    print((say+1)//2)",say+=1,say+=1
"import sys;input=sys.stdin.readline
R=lambda:list(map(int,input().split()))
for _ in  range(int(input())):
    n=int(input())
    a=R()
    m1=m2=10**18
    res=0
    for i in a:
        if i<m1: m1=i
        elif i<m2: {{completion}}
    print(res)
",m2=i; res+=1,"m2=i
    for i in a:
        if i>m1: m1=i
        elif i>m2: m2=i
    if m1>m2: m1,m2=m2,m1
    if m1>m2:
        res=m1-m2
    else:
        res=m2-m1"
"import sys
for _ in range(int(sys.stdin.readline())):
    n=int(sys.stdin.readline())
    a=list(map(int,sys.stdin.readline().split()))

    A,B,res=n+1,a[0],0
    for x in a:
        if x>B and x<A:
            {{completion}}
        B=min(B,x)
    print(res)","res+=1
            A=x","res+=1
        A=max(A,x)"
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    P = [int(x) - 1 for x in input().split()]

    mn = n
    y = n
    state = [0] * n
    state[0] = 1
    for i, p in enumerate(P):
        if p < mn:
            {{completion}}

        if y < p:
            state[i] = 1
            continue

        y = min(y, p)
    
    return n - sum(state)

T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","mn = p
            state[i] = 1
            continue","mn = (p + y) % n
            y = y - p"
"for s in[*open(0)][1:]:{{completion}}
","m,k,a,b=map(int,s.split());x=min(m%k,a);m-=x;print(max(m//k-(a-x)//k-b,0)+m%k)","
    s=s.split()
    a,b,c,d=int(s[0]),int(s[1]),int(s[2]),int(s[3])
    if a<b and a<c and a<d:
        ans=min(a+c,a+b+d)
    elif a<b and a<c and b>d:
        ans=min(a+c,a+b+d)
    elif a<b and b>c and a<d:
        ans=min(a+c,a+b+d)
    elif a<b and b>c and b>d:
        ans=min(a+c,a+b+d)
    elif a<b and b>c and c>d:
        "
for s in[*open(0)][1:]:{{completion}},"m,k,a,b=map(int,s.split());x=min(m%k,a);m-=x;print(max(m//k-(a-x)//k-b,0)+m%k)","
    s=s.split()
    a,b,c,d=int(s[0]),int(s[1]),int(s[2]),int(s[3])
    if a<b and a<c and a<d:
        print b
    elif b<a and b<c and b<d:
        print c
    elif c<a and c<b and c<d:
        print d
    else:
        print 0
<|/ file filename=Monocarp.py |>"
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')



for _ in range(int(input())):
    w, f = map(int, input().split())
    n = int(input())
    a = list(map(int, input().split()))
    sm = ans = sum(a)
    dp = 1

    for x in a:
        dp |= dp << x

    for i, x in enumerate(bin(dp)[::-1]):
        if x == '1':
            {{completion}}
            
    print(ans)","ans = min(ans, max((i + w - 1) // w, (sm - i + f - 1) // f))","sm = sm - a[i] if sm > 0 else sm + a[i]
            ans = min(ans, sm)
            sm = 0"
"import sys
input = sys.stdin.readline

t=int(input())
for tests in range(t):
    w,f=map(int,input().split())
    n=int(input())
    A=list(map(int,input().split()))

    SUM=sum(A)

    if w<f:
        w,f=f,w

    OK=(sum(A)+w-1)//w
    NG=0

    LIST=0

    for a in A:
        LIST|=(LIST<<a)|(1<<a)


    while OK>NG+1:
        #print(OK,NG)
        mid=(OK+NG)//2

        a=w*mid
        b=f*mid

        #print(OK,NG,mid,a,b)

        if SUM>a+b:
            NG=mid
            continue

        k=LIST & ((1<<(a+1))-1)
        if k==0:
            NG=mid
            continue

        #print(LIST,k,k.bit_length())
        if SUM-(k.bit_length() - 1)<=b:
            OK=mid
        else:
            {{completion}}

    print(OK)

        

        
        
    
",NG=mid,"NG=mid
            continue"
"from sys import stdin
input=lambda :stdin.readline()[:-1]

from heapq import heappop, heappush

def solve():
  w,f=map(int,input().split())
  n=int(input())
  a=list(map(int,input().split()))
  a.sort()
  sm=sum(a)
  dp=1
  for i in a:
    dp|=dp<<i
  res=bin(dp)[2:]
  ans=1<<60
  for i in range(sm+1):
    if res[i]=='1':
      {{completion}}
  print(ans)
  

for _ in range(int(input())):
  solve()","j=sm-i
      ans=min(ans,max((i+w-1)//w,(j+f-1)//f))","ans=min(ans,dp-i)
      break"
"import os, gc
import sys
input = sys.stdin.buffer.readline
 
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    pos = [0] * n
    for i in range(n-2, -1, -1):
        pos[i] = (a[i] >= a[i+1]) + pos[i+1]
    ans = pos[0]
    nev = 1
    for i in range(n):
        if i and a[i] >= a[i-1]:
            nev += 1
        if i == n-1:
            ans = min(ans, nev)
        else:
            {{completion}}
    print(ans)","ans = min(ans, nev + pos[i+1])","ans = min(ans, pos[i+1] - nev)"
"import sys

R = sys.stdin.readline
inf = int(1e18)
mod = int(1e9) + 7


def get_int() -> int:
    return int(R())


def get_str() -> str:
    return R().strip()


def get_int_list() -> list:
    return list(map(int, R().strip().split(' ')))


def init_matrix(n_, m_, value_=0) -> list:
    return [[value_] * m_ for _ in range(n_)]


def solve():
    n = get_int()
    a = get_int_list()

    pos = 0
    for i in range(1, n):
        if a[i] <= a[i - 1]:
            {{completion}}

    ans = pos
    neg = 1
    for i in range(n):
        if i + 1 < n:
            pos -= a[i] >= a[i + 1]

        if i > 0:
            neg += a[i] >= a[i - 1]

        ans = min(ans, neg + pos)

    print(ans)


for _ in range(get_int()):
    solve()
",pos += 1,pos += 1
"from sys import stdin, stdout

t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    a = [int(x) for x in stdin.readline().split()]

    prefix = [0]
    for i in range(1,n):
        if a[i-1] <= a[i]:
            prefix.append(prefix[-1]+1)
        else:
            prefix.append(prefix[-1])

    suffix = [0]*n
    for i in range(n-2,-1,-1):
        if a[i+1] <= a[i]:
            suffix[i] = suffix[i+1]+1
        else:
            suffix[i] = suffix[i+1]

    answer = n
    left = 0
    for i in range(n):
        if i == n-1 or a[i+1] <= a[i]:
            temp = suffix[i]
            if left > 0:
                {{completion}}
            answer = min(answer, temp)

            left = i+1

    stdout.write(str(answer)+""\n"")
",temp += 1 + prefix[left-1],"temp = min(temp, prefix[left])
            temp = temp*2"
"for _ in range(int(input())):
    s=''
    for i in range(8):
        {{completion}}
    print(s.replace('.',''))",s+=input(),s=s+input()[i]
"t=int(input())
for k in range(0,t):
    x=[]
    for j in range(0,8):
        s=input()
        for i in s:
            if i!=""."":
                {{completion}}
    s_=''
    for i in x:
        s_+=i
    print(s_)
",x.append(i),"x.append(i)
            else:
                break"
"for _ in range(int(input())):
    {{completion}}
","print(''.join([s for s in [input().replace('.', '') for _ in range(8)] if s]))","grid = []
    for _ in range(8):
        grid.append(input())
    word = ''
    for row in grid:
        for col in row:
            if col == '.':
                word += '.'
            else:
                word += chr(ord('a') + (ord(col) - ord('a') + 1)%26)
    print(word)
<|/ file dstars=0 |>"
"for line in [*open(0)][1:]:
    {{completion}}
","x, y, z = map(int, line.split())
    print('SFeicrosntd'[x > y - z % 2::2])","a,b,c = map(int, line.split())
    anna = katie = 0
    for turn in range(1,a+1):
        anna = katie = 0
        if turn%a==0: anna = 1
        if turn%b==0: katie = 1
        if turn%c==0: katie = 1
        if anna==1 and katie==1: print(""First"")
        elif anna==1 and katie==0: print(""Second"")
        else: print(""Third"")
    
<|/ file source=github |>"
for g in[*open(0)][1:]:{{completion}},"a,b,c=map(int,g.split());print(""SFeicrosntd""[a+c%2>b::2])","
    a,b,c = map(int, g.split())
    if a<b+c and a<c:
        print ""First""
    elif b<a+c and b<c:
        print ""Second""
    else:
        print ""Third""
<|/ file filename=AnnaAndKatie.py "
for sss in[*open(0)][1:]:{{completion}},"d,f,c=map(int,sss.split());print('SFeicrosntd'[d>f-c%2::2])","
    sss=sss.split()
    a,b,c=int(sss[0]),int(sss[1]),int(sss[2])
    anna=b+c
    katie=a
    anna=anna-anna%9
    katie=katie-katie%9
    if anna==katie:
        print(""First"")
    elif anna>katie:
        print(""Second"")
    else:
        print(""Third"")
<|/ file dstars=1 |>"
"import sys
input = sys.stdin.readline

# from math import gcd, isqrt
# import bisect #-->For bisect.bisect_left=lower_bound and bisect_right=upper_bound)

t = 1
t = int(input())
for _ in range(t):
    n = int(input())
    m1 = []
    mi = 9999999999
    for i in range(n):
        {{completion}}
    m1.sort()
    ans = mi + sum(m1) - m1[0]
    print(ans)","m = int(input())
        l = sorted(list(map(int, input().split())))
        m1.append(l[1])
        mi = min(mi, l[0])","mi = mi + int(input())
        m1.append(mi)
    m1.sort()
    ans = mi + sum(m1) - m1[0]
    print(ans)
<|/ q dscore=0 |>
<| c |>
Please add your code. Also, please format your question properly. https://stackoverflow.com/help/how-to-ask
<|/ c |>
<| c |>
Please add your code to the question. Don't post it as a comment. Also, please format your question properly. https://stackoverflow.com/help/how-to-ask
<|/ c |>
<| c |>
Please add your code to the question. Don't post it as a comment. Also, please format your "
"import sys 
input = sys.stdin.buffer.readline 

def process(A):
    n = len(A)
    if n==1:
        answer = min(A[0])
    else:
        L0 = []
        L1 = []
        for row in A:
            {{completion}}
        answer = sum(L1)-min(L1)+min(L0)
    
    sys.stdout.write(f'{answer}\n')
    
t = int(input())
for i in range(t):
    n = int(input())
    A = []
    for j in range(n):
        m = int(input())
        row = [int(x) for x in input().split()]
        A.append(row)
    process(A)
    ","row.sort()
            L0.append(row[0])
            L1.append(row[1])","min1 = min(row)
            L1.append(min1)
            L0.append(min1-min(row))
        "
"import sys
#from bisect import bisect_right as br
#from collections import Counter
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    temp = int(1e9)
    temp2 = int(1e9)
    ans = 0
    for z in range(n):
        {{completion}}
    print(ans-temp+temp2)","m = int(input())
        b = list(map(int,input().split()))
        b.sort()
        diff = b[1]-b[0]
        ans += b[1]
        temp = min(b[1], temp)
        temp2 = min(b[0], temp2)","m, *a = map(int, input().split())
        ans = min(ans, min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min("
"for _ in range(int(input())):
    n = int(input())
    l = list(map(int, input().split()))
    ml = [0] * n
    mr = [0] * n
    al = [0] * n
    ar = [0] * n
    res = ['0'] * n
    
    P = [0]
    for k in l:
        P.append(P[-1] ^ k)
    
    for i in range(n):
        for j in range(n - 1, i - 1, -1):
            x = P[i] ^ P[j + 1]
            if x == 0:
                if al[i] or ar[j] or i == 0 and j == n - 1:
                    al[i], ar[j] = 1, 1
                    if i == j:
                        res[i] = '1'
            else:
                if al[i] or ar[j] or x & ml[i] or x & mr[j] or i == 0 and j == n - 1:
                    v = 1 << x.bit_length() - 1
                    ml[i] |= v
                    mr[j] |= v
                    if i == j:
                        {{completion}}
    
    print(''.join(res))",res[i] = '1',"res[i] = '1'
                    break
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys

input = sys.stdin.readline

def highbit(val):
    return 1 << val.bit_length() - 1 if val else -1

def xor(a, b): return a ^ b

t = int(input())
for _ in range(t):
    n = int(input())
    nums = list(map(int, input().split()))
    
    mask_start = [0] * n
    mask_end = [0] * n
    
    pref_xor = [0] * (n + 1)
    for i in range(n):
        pref_xor[i+1] = pref_xor[i] ^ nums[i]
    mask_start[0] = mask_end[n-1] = highbit(pref_xor[-1])
    
    ans = [0] * n
    for segment_length in range(n - 1, -1, -1):
        for start in range(n - segment_length):
            end = start + segment_length
            xor_sum = pref_xor[start] ^ pref_xor[end + 1]
            
            if mask_start[start] == -1 or mask_end[end] == -1 or mask_start[start] & xor_sum or mask_end[end] & xor_sum:
                if segment_length:                    
                    val = highbit(xor_sum)
                    mask_start[start] |= val
                    mask_end[end] |= val
                else:
                    {{completion}}

    print(*ans, sep='')",ans[start] = 1,"ans[start] = 1
            else:
                ans[start] = 0"
"def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    pref = [0]
    for a in arr:
        pref.append(pref[-1]^a)
    bmp = [0]*n
    bms = [0]*n
    zp = [0]*n
    zs = [0]*n
    if pref[n]:
        bmp[n-1] = bms[0] = 1<<(pref[n].bit_length()-1)
    else:
        zp[n-1] = zs[0] = 1
    ans = [""0""]*n
    for i in range(n):
        for j in range(n-1, i, -1):
            x = pref[i] ^ pref[j+1]
            if x&bmp[j] or x&bms[i] or zp[j] or zs[i]:
                if x:
                    y = 1<<(x.bit_length()-1)
                    bmp[j] |= y
                    bms[i] |= y
                else:
                    {{completion}}
        if arr[i]&bmp[i] or arr[i]&bms[i] or zp[i] or zs[i]:
            ans[i] = ""1""
    print("""".join(ans))


import sys
input = lambda: sys.stdin.readline().rstrip()
t = int(input())
for i in range(t):
    solve()
","zp[j] = 1
                    zs[i] = 1","y = zs[j+1]
                    zp[j] |= y
                    zs[i] |= y
                break"
"from io import BytesIO, IOBase
import random
import sys
import os

import bisect
from collections import Counter, defaultdict, deque
from copy import deepcopy
from functools import cmp_to_key, lru_cache, reduce
from heapq import heapify, heappop, heappush, heappushpop, nlargest, nsmallest
from itertools import accumulate, combinations, permutations
from operator import add, iand, ior, itemgetter, mul, xor
from string import ascii_lowercase, ascii_uppercase
from typing import *
BUFSIZE = 4096

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                {{completion}}
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin = IOWrapper(sys.stdin)
sys.stdout = IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def I():
    return input()

def II():
    return int(input())

def MII():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

inf = float('inf')

# from types import GeneratorType

# def bootstrap(f, stack=[]):
#     def wrappedfunc(*args, **kwargs):
#         if stack:
#             return f(*args, **kwargs)
#         else:
#             to = f(*args, **kwargs)
#             while True:
#                 if type(to) is GeneratorType:
#                     stack.append(to)
#                     to = next(to)
#                 else:
#                     stack.pop()
#                     if not stack:
#                         break
#                     to = stack[-1].send(to)
#             return to
#     return wrappedfunc

# RANDOM = random.getrandbits(32)

# class Wrapper(int):
#     def __init__(self, x):
#         int.__init__(x)

#     def __hash__(self):
#         return super(Wrapper, self).__hash__() ^ RANDOM

mod = 10 ** 9 + 7

n = II()
nums = LGMI()
indeg = [0] * n

for v in nums:
    indeg[v] += 1

tmp = indeg[:]
stack = [i for i in range(n) if indeg[i] == 0]
ans = 1
while stack:
    u = stack.pop()
    ans *= indeg[u] + 1
    ans %= mod
    
    tmp[nums[u]] -= 1
    if tmp[nums[u]] == 0:
        stack.append(nums[u])

for i in range(n):
    if tmp[i]:
        v1 = 1
        v2 = 0
        while tmp[i]:
            tmp[i] = 0
            v1 *= indeg[i] + 1
            v1 %= mod
            v2 += indeg[i]
            i = nums[i]
        ans *= v1 - v2
        ans %= mod
print(ans)",break,"buffer = self.buffer.getvalue()
                self.buffer.truncate(0), self.buffer.seek(0)
                return buffer"
"import sys
input = sys.stdin.buffer.readline
from collections import deque

for _ in range(int(input())):
    n, m, k = map(int,input().split())
    h = list(map(int,input().split()))
    graph = [[] for _ in range(n)]
    for _ in range(m):
        a, b = [int(x) - 1 for x in input().split()]
        graph[a].append(b)

    dp = [0] * n
    for v in range(n):
        for u in graph[v]:
            dp[u] = max(dp[u], dp[v] + (h[v] > h[u]))
    
    mx = max(dp[i] * k + h[i] for i in range(n))
    
    order = sorted(range(n), key=lambda i:h[i])
    ans = mx - h[order[0]]

    for i in range(n - 1):
        if dp[order[i]] == 0:
            dp[order[i]] = 1
            mx = max(mx, k + h[order[i]])
            Q = deque([order[i]])
            while Q:
                v = Q.popleft()
                for u in graph[v]:
                    if dp[u] < dp[v] + (h[v] > h[u]):
                        {{completion}}
        ans = min(ans, mx - h[order[i + 1]])

    print(ans)","dp[u] = dp[v] + (h[v] > h[u])
                        Q.append(u)
                        mx = max(mx, dp[u] * k + h[u])","dp[u] = dp[v] + (h[v] > h[u])
                        Q.append(u)"
"from sys import stdin, stdout
from collections import defaultdict, deque

t = int(stdin.readline())

for _ in range(t):
    n, m, k = [int(x) for x in stdin.readline().split()]
    h = [int(x) for x in stdin.readline().split()]

    children = {i:[] for i in range(n)}
    roots = [True]*n
    for bar in range(m):
        u, v = [int(x)-1 for x in stdin.readline().split()]
        children[u].append(v)
        roots[v] = False

    start = set()
    start_to_roots = defaultdict(list)
    for i in range(n):
        if roots[i]:
            start.add(h[i])
            start_to_roots[h[i]].append(i)
    start = list(start)
    start.sort()

    real_start = start[0]
    real_end = -1
    timestamp = [real_start]*n
    for i in range(n):
        if timestamp[i] % k <= h[i]:
            timestamp[i] = (timestamp[i]//k)*k + h[i]
        else:
            timestamp[i] = (timestamp[i]//k + 1)*k + h[i]
        real_end = max(real_end, timestamp[i])

        for child in children[i]:
            timestamp[child] = max(timestamp[child], timestamp[i])

    if len(start) == 1:
        stdout.write(str(real_end-real_start)+""\n"")

    else:
        answer = real_end-real_start

        for j in range(1,len(start)):
            real_start = start[j]

            queue = deque()
            for root in start_to_roots[start[j-1]]:
                timestamp[root] += k
                real_end = max(real_end, timestamp[root])
                queue.append(root)

            while len(queue) > 0:
                u = queue.popleft()
                for child in children[u]:
                    if timestamp[child] < timestamp[u]:
                        {{completion}}

            answer = min(answer, real_end - real_start)

        stdout.write(str(answer)+""\n"")
","timestamp[child] += k
                        real_end = max(real_end, timestamp[child])
                        queue.append(child)","timestamp[child] = timestamp[u] + k
                        queue.append(child)"
"import sys
import random

input = sys.stdin.readline
rd = random.randint(10 ** 9, 2 * 10 ** 9)

t = int(input())
for _ in range(t):
    n, m, k = map(int, input().split())
    h = list(map(int, input().split()))
    cnt = [0] * n
    g = [[] for _ in range(n)]
    for _ in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        g[x].append(y)
        cnt[y] += 1
    total_time = h[:]
    from collections import deque
    start = []
    for i in range(n):
        if cnt[i] == 0:
            start.append((i, total_time[i]))
    q = deque(start)
    while q:
        T, time = q.popleft()
        for x in g[T]:
            if h[T] > h[x]:
                total_time[x] = max(total_time[x], time + h[x] + k - h[T])
            else:
                total_time[x] = max(total_time[x], time - h[T] + h[x])
            cnt[x] -= 1
            if cnt[x] == 0:
                q.append((x, total_time[x]))
    # 暴力推移每一个事件 而不是只把整体的最后时间推移
    mx = max(total_time)
    start.sort(key=lambda x: x[1])
    ans = mx - start[0][1]
    for i in range(len(start) - 1):
        mi = start[i + 1][1]
        q = deque([(start[i][0],start[i][1] + k)])
        while q:
            T, time = q.popleft()
            mx = max(mx, time)
            for x in g[T]:
                if h[T] > h[x]:
                    new = time + h[x] + k - h[T]
                else:
                    {{completion}}
                if new > total_time[x]:
                    total_time[x] = new
                    q.append((x, total_time[x]))
        ans = min(ans, mx - mi)
    print(ans)",new = time - h[T] + h[x],new = time - h[T] + h[x]
"t = int(input())

def doit():
    S = input()
    n = 0
    u = 0
    s = 1
    for c in S:
        if c == ""+"":
            n += 1
        elif c == ""-"":
            n -= 1
            s = min(s,n)
            if n < u:
                {{completion}}
        elif c == ""1"":
            if u > 0:
                return ""NO""
            s = n
        elif c == ""0"":
            if s==n or n<=1:
                return ""NO""
            if u==0:
                u = n
    return ""YES""
        
for _ in range(t):
    print(doit())",u = 0,"u = 0
        elif c == ""+"":
            if u > 0:
                return ""NO""
            s = n
        elif c == ""-"":
            if s==n or n<=1:
                return ""NO""
            if u==0:
                u = n
    return ""YES""
        
for _ in range(t):
    print(doit())
    
<|/ file filename=Monocarp.py ext=.py |>"
"# /**
#  *     author: brownfox2k6
#  *    created: 31/08/2023 22:12:59 Hanoi, Vietnam
# **/

def solve():
  st = []
  for c in input():
    if c == '+':
      if st and st[-1] == -1:
        st.append(-1)
      else:
        st.append(0)
    elif c == '-':
      if st.pop() == 1 and st:
        st[-1] = 1
    elif c == '1':
      if len(st) >= 2:
        if st[-1] == -1:
          {{completion}}
        st[-1] = 1
    else:
      if len(st) < 2 or st[-1] == 1:
        return ""NO""
      st[-1] = -1
  return ""YES""

print('\n'.join(solve() for _ in range(int(input()))))","return ""NO""","st[-1] = 1
        else:
          st[-1] = -1
      else:"
"from sys import stdin


def input():
    return stdin.readline()[:-1]


for _ in range(int(input())):
    s = input()
    mn = 0
    mx = 0
    c = 0
    for i in s:
        if i == ""+"":
            if mx == c:
                mx += 1
            c += 1
        elif i == ""-"":
            c -= 1
            mn = mn if mn < c else c
            mx = mx if mx < c else c
        elif i == ""1"":
            if c > mx:
                {{completion}}
            mx = mn = c
        else:
            if c < 2 or c <= mn:
                print(""NO"")
                break
            mx = c - 1 if c - 1 < mx else mx
    else:
        print(""YES"")","print(""NO"")
                break","mx = 0
                mn = 0
            elif c < mn:
                mn = c
            else:
                mx = mn if mn < c else c
        elif i == ""0"":"
"for n in[*map(int,open(0))][1:]:{{completion}}
",k=int((2*n+1)**.5);print((n*(4*n*n-6*n-10)-k*(2*k*k+3*k-8))//12+n*k),"
    cost = 0
    for p in permutations(range(1,n+1)):
        cost += p[n-1]*p[0]
    if cost > 500:
        print(cost)
        break
    else:
        print(cost)
        
""""""
<|/ file ext=.py |>"
"for i in[*map(int,open(0))][1:]:
    {{completion}}
","j=int((2*i+1)**.5);
    print((i*(4*i*i-6*i-10)-j*(2*j*j+3*j-8))//12+i*j)","arr=list(map(int,i.split()))
    arr=sorted(arr)
    cost=0
    for j in range(1,len(arr)):
        cost+=arr[j]*j
    if cost>500:
        print(cost)
        break
    else:
        print(cost)
        
<|/ file source=github |>"
"input_data = [*map(int, open(0))][1:]

for n in input_data:
    {{completion}}
","k = int((2 * n + 1) ** 0.5)
    result = (n * (4 * n * n - 6 * n - 10) - k * (2 * k * k + 3 * k - 8)) // 12 + n * k
    print(result)","cost = 0
    for i in range(1, n+1):
        cost += i*i
    cost = cost - (max((i*i for i in range(1, n+1))))
    print(cost)
<|/ file source=github |>"
"import sys
input = sys.stdin.readline

mod=998244353

def calc(A,b):
    #print(A,b)
    if b<0:
        return len(A)*len(A)
    ANS=0

    B=[]
    C=[]

    for i in range(len(A)):
        if A[i] & (1<<b) != 0:
            B.append(A[i]^(1<<b))
        else:
            {{completion}}

    ANS+=3*len(B)*len(C)
    if B!=[]:
        ANS+=len(B)*len(B)+calc(B,b-1)
    if C!=[]:
        ANS+=calc(C,b-1)

    return ANS%mod
    


        

t=int(input())
for tests in range(t):
    n=int(input())
    A=list(map(int,input().split()))


    print(calc(A,31)*pow(n*n,mod-2,mod)%mod)
    
",C.append(A[i]),C.append(A[i]^(1<<b))
"import heapq
from sys import stdin
input=lambda:stdin.readline().strip()
T=int(input())
while T:
    n,m,d=map(int,input().split())
    A=list(map(int,input().split()))
    ret=0
    heap=[]
    SUM=0
    for i in A:
        if i>0:
            if len(heap)<m:
                heapq.heappush(heap,i)
                SUM+=i
            elif i>heap[0]:
                {{completion}}
        SUM-=d
        # print(SUM,heap)
        ret=max(ret,SUM)
    print(ret)
    T-=1","SUM-=heapq.heappop(heap)
                heapq.heappush(heap,i)
                SUM+=i","heapq.heappush(heap,i)
                SUM+=i
            else:
                heapq.heappop(heap)
                heapq.heappush(heap,i)
                SUM+=i
        else:
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap)
            heapq.heappop(heap"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()

import heapq
for _ in range(t):
	n, m, d = I()
	a = I()

	h = []
	best = 0
	total = 0
	for i in range(n):
		if a[i] > 0:
			if len(h) == m:
				remove = heapq.heappushpop(h, a[i])
				total += a[i] - remove
				best = max(best, total - d * (i + 1))
			else:
				{{completion}}
	print(best)","heapq.heappush(h, a[i])
				total += a[i]
				best = max(best, total - d * (i + 1))","heapq.heappush(h, a[i])
				total += a[i]
				best = max(best, total - d * (i + 1))
		else:
			if len(h) == m:
				remove = heapq.heappop(h)
				total -= remove
				best = max(best, total - d * (i + 1))
			else:
				heapq.heappop(h)
				total -= a[i]
				best = max(best, total - d * (i + 1))"
"from heapq import *
 
 
def solution():
    n, m, d = map(int, input().split())
    a = [int(i) for i in input().split()]
    movies = []
    entertainment = 0
    ans = 0
    for i in range(n):
        if len(movies) == m:
            if a[i] > movies[0]:
                {{completion}}
        elif a[i] > 0:
            heappush(movies, a[i])
            entertainment += a[i]
        ans = max(entertainment - d * (i + 1), ans)
    print(ans)
 
 
t = int(input())
for _  in range(t):
    solution()
","entertainment = entertainment - movies[0] + a[i]
                heapreplace(movies, a[i])","heappush(movies, a[i])
                entertainment += a[i]
            else:
                movies.pop()"
"import sys
import random

input = sys.stdin.readline
rd = random.randint(10 ** 9, 2 * 10 ** 9)


class SegmentTree():
    def __init__(self, init, unitX, f):
        self.f = f  # (X, X) -> X
        self.unitX = unitX
        self.f = f
        if type(init) == int:
            self.n = init
            self.n = 1 << (self.n - 1).bit_length()
            self.X = [unitX] * (self.n * 2)
        else:
            self.n = len(init)
            self.n = 1 << (self.n - 1).bit_length()
            # len(init)が2の累乗ではない時UnitXで埋める
            self.X = [unitX] * self.n + init + [unitX] * (self.n - len(init))
            # 配列のindex1まで埋める
            for i in range(self.n - 1, 0, -1):
                {{completion}}

    def update(self, i, x):
        """"""0-indexedのi番目の値をxで置換""""""
        # 最下段に移動
        i += self.n
        self.X[i] = self.f(self.X[i], x)
        # 上向に更新
        i >>= 1
        while i:
            self.X[i] = self.f(self.X[i * 2], self.X[i * 2 | 1])
            i >>= 1

    def getvalue(self, i):
        """"""元の配列のindexの値を見る""""""
        return self.X[i + self.n]

    def getrange(self, l, r):
        """"""区間[l, r)でのfを行った値""""""
        l += self.n
        r += self.n
        al = self.unitX
        ar = self.unitX
        while l < r:
            # 左端が右子ノードであれば
            if l & 1:
                al = self.f(al, self.X[l])
                l += 1
            # 右端が右子ノードであれば
            if r & 1:
                r -= 1
                ar = self.f(self.X[r], ar)
            l >>= 1
            r >>= 1
        return self.f(al, ar)


class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def update(self, index, val):
        # val 是增量, 如果是修改值记得计算增量
        # val = val - query_lr(index,index)
        while index <= self.n:
            self.tree[index] += val
            index += index & (-index)

    def query(self, r):
        res = 0
        while r > 0:
            res += self.tree[r]
            r -= r & (-r)
        return res

    # 计算[l,r]区间和，注意数组查询要+1 0-indexed -> 1-indexed+1
    def query_lr(self, left, right):
        return self.query(right) - self.query(left - 1)


n, q = map(int, input().split())
a = list(map(int, input().split()))
max_tree = SegmentTree(n, 0, max)
sum_tree = BIT(n)
li = [[] for _ in range(n + 1)]
pos = [[] for _ in range(n + 1)]
for i in range(n):
    pos[a[i]].append(i)
for i in range(q):
    x, y = map(int, input().split())
    li[y].append((x, i))

ans = [0] * q
cnt = [0] * (n + 1)
for r in range(1, n + 1):
    cnt[r] = cnt[r - 1] + len(pos[r])
    count = 0
    for i in range(1, len(pos[r])):
        mx = max_tree.getrange(pos[r][i - 1] + 1, pos[r][i])
        sum_tree.update(mx + 1, 1)
        sum_tree.update(r + 1, -1)
    for x in pos[r]:
        max_tree.update(x, r)
    for l, index in li[r]:
        ans[index] = cnt[r] - cnt[l - 1] - sum_tree.query_lr(0, l)
print(*ans, sep='\n')
","self.X[i] = self.f(self.X[i * 2], self.X[i * 2 | 1])","j = i >> 1
                self.X[i] = self.f(self.X[j], self.X[i])"
"def II():
    return(int(input()))
def LMI():
    return(list(map(int,input().split())))
def I():
    return(input())
def MII():
    return(map(int,input().split()))
import sys
input=sys.stdin.readline
# import io,os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# from collections import Counter
# int(math.log(len(L)))
# import math
# from collections import defaultdict
# mod=10**9+7
# from collections import deque
import  math

class segment_tree_max():
    def __init__(self,X):
        L=[-math.inf]+X
        n=int(math.ceil(math.log(len(L))/math.log(2)))
        self.seg=[0]*(2**(n)-1)+L+[0]*(2**n-len(L))
        for i in range(2**n-2,-1,-1):
            self.seg[i]=max(self.seg[2*i+1],self.seg[2*i+2])
    def update(self,m,n):
        x=m+len(self.seg)//2
        self.seg[x]=n
        x=(x-1)//2
        while x>-1:
            self.seg[x]=max(self.seg[2*x+1],self.seg[2*x+2])
            x=(x-1)//2

    def ma(self,l,r):
        a=len(self.seg)//2+l
        b=len(self.seg)//2+r
        s=-math.inf
        while a<=b:
            if a%2==0:
                s=max(self.seg[a],s)
                a+=1
            if b%2==1:
                s=max(s,self.seg[b])
                b-=1
            b-=1
            a//=2
            b//=2
        return s

class FENWICK_TREE():
    def __init__(self,L):
        pre=[0]
        pre.extend(L)
        n=len(pre)
        for i in range(1,n):
            pre[i]+=pre[i-1]
        self.tree=[0]*n
        for i in range(1,n):
            self.tree[i]=pre[i]-pre[i-(i&-i)]
    def addn(self,m,n):
        ind=m
        while ind<=len(self.tree):
            self.tree[ind]+=n
            ind+=ind&-ind
    def su(self,l,r):
        ans1=0
        l-=1
        while r>0:
            ans1+=self.tree[r]
            r-=r&-r
        ans2=0
        while l>0:
            ans2+=self.tree[l]
            l-=l&-l
        return ans1-ans2
def t():
    n,q=MII()
    L=LMI()
    Q=[[] for _ in range(n+1)]
    for i in range(q):
        l,r=MII()
        Q[r].append((l,i))
    final=[0]*q
    X=segment_tree_max([0]*n)
    Y=FENWICK_TREE([0]*n)
    pos=[[] for _ in range(n+1)]
    for i in range(n):
        pos[L[i]].append(i)
    cou=[len(pos[i]) for i in range(n+1)]
    for i in range(1,n+1):
        for j in range(1,len(pos[i])):
            if pos[i][j-1]+1==pos[i][j]:
                Y.addn(i,1)
            else:
                cc=X.ma(pos[i][j-1]+1,pos[i][j]-1)
                Y.addn(i,1)
                if cc!=0:
                    {{completion}}
        cou[i]+=cou[i-1]
        for l,ind in Q[i]:
            final[ind]=cou[i]-cou[l-1]-Y.su(l,i)
        for j in pos[i]:
            X.update(j,i)
    print(*final)












if __name__==""__main__"":

    # for _ in range(II()):
        # t()
    t()","Y.addn(cc,-1)","Y.addn(i,cc)
                    cou[i]-=cc
                    cou[j-1]+=cc
                    cou[j]+=cc
                    cou[j-1]-=cc
                    cou[j-1]+=cc
                    cou[j-1]-=cc
                    cou[j-1]+=cc
                    cou[j-1]-=cc
                    cou[j-1]+=cc
                    cou[j-1]-=cc
                    cou[j-1]+=cc
                    cou[j-1]-=cc
                    cou[j-1]+=cc
                    cou[j-1]-=cc
                    cou"
"import sys
input = sys.stdin.readline

def bucketsort(order, seq):
    buckets = [0] * (max(seq) + 1)
    for x in seq:
        buckets[x] += 1
    for i in range(len(buckets) - 1):
        buckets[i + 1] += buckets[i]

    new_order = [-1] * len(seq)
    for i in reversed(order):
        x = seq[i]
        idx = buckets[x] = buckets[x] - 1
        new_order[idx] = i

    return new_order


def ordersort(order, seq, reverse=False):
    bit = max(seq).bit_length() >> 1
    mask = (1 << bit) - 1
    order = bucketsort(order, [x & mask for x in seq])
    order = bucketsort(order, [x >> bit for x in seq])
    if reverse:
        order.reverse()
    return order


class FenwickTree:
    def __init__(self, x):
        """"""transform list into BIT""""""
        self.bit = x
        for i in range(len(x)):
            j = i | (i + 1)
            if j < len(x):
                {{completion}}

    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < len(self.bit):
            self.bit[idx] += x
            idx |= idx + 1

    def query(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def findkth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(len(self.bit).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(self.bit) and k >= self.bit[right_idx]:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1

class SegmentTree:
    def __init__(self, data, default=0, func=max):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1
        while _size < self._len:
            _size *= 2
        self._size = _size

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        """"""func of data[start, stop)""""""
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

n, q = map(int, input().split())
a = list(map(int, input().split()))

z = n + 1

out = [-1] * q
#left = []
right = []
qadj = [[] for _ in range(z)]

for i in range(q):
    li, ri = map(int, input().split())
    qadj[li].append(i)
    #left.append(li)
    right.append(ri)

rem = [[] for _ in range(z + 1)]
data = [0] * (z + 1)

mseg = SegmentTree([0] * n)
last = [-1] * z

ind = ordersort(range(n), a)

for i in ind:
    v = a[i]
    data[v] += 1

    if last[v] != -1:
        rr = mseg.query(last[v] + 1, i)
        rem[rr].append(v)
    
    mseg[i] = v
    last[v] = i

from operator import add
seg = FenwickTree(data)

for i in range(z):
    for ind in qadj[i]:
        out[ind] = seg.query(right[ind] + 1) - seg.query(i)

    for r in rem[i]:
        seg.update(r, -1)

print('\n'.join(map(str, out)))

",x[j] += x[i],"self[j] = x[i]

    def __getitem__(self, idx):
        """"""calc sum(bit[:idx])""""""
        x = 0
        while idx < len(self.bit):
            x += self.bit[idx]
            idx |= idx + 1
        return x

    def __setitem__(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < len(self.bit):
            self.bit[idx] += x
            idx |= idx + 1"
"input_lines = [*open(0)][2::2]

for line in input_lines:
    {{completion}}
","values = [*map(int, line.split())]
    result = max(0, min((y - x + 2) >> 1 for x, y in zip(values, values[1:])))
    print(result)","n, *a = map(int, line.split())
    
    sorted_array = sorted(a)
    
    sorted_array.append(0)
    
    sorted_array = [*map(int, sorted_array)]
    
    sorted_array.sort()
    
    sorted_array = [*map(int, sorted_array)]
    
    sorted_array = [*map(int, sorted_array)]
    
    sorted_array = [*map(int, sorted_array)]
    
    sorted_array = [*map(int, sorted_array)]
    
    sorted_array = [*map(int, sorted_array)]
    
    sorted_array = [*map(int, sorted_array)]
    
    sorted_array = ["
"for _ in range(int(input())):
    n=int(input())
    a=list(map(int,input().split()))
    m=10**9
    for i in range(n-1):
        if a[i]>a[i+1]:
            {{completion}}
        m=min(m,a[i+1]-a[i])
    print(m//2+1)
","m=-1
            break","i+=1
        elif a[i]<a[i+1]:
            i+=1
        else:
            i+=1"
"import sys

T = int(sys.stdin.readline())

for _ in range(T):
    n = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))
    
    diff = float('inf')
    sorted = True
    for i in range(n):
        if i > 0:
            {{completion}}
    
    if not sorted:
        print(0)
        continue
    
    print(diff//2 + 1)
","diff = min(nums[i] - nums[i - 1], diff)
            sorted &= nums[i] >= nums[i - 1]","diff += nums[i] - nums[i - 1]
        if diff < 0:
            sorted = False
            break"
"import sys
def input(): return sys.stdin.readline().strip()


t = int(input())
for _ in range(t):
    n = int(input())
    a = [int(i) for i in input().split()]
    for i in range(n):
        calc = a[i]
        if (calc > n or a[calc-1] < (i + 1)):
            {{completion}}
    else:
        print(""YES"")
","print(""NO"")
            break","calc = calc
        else:
            calc = calc-1
        a[i] = calc
    if a[0] == a[n-1]:
        print(""YES"")"
"import sys

input = sys.stdin.readline
print = sys.stdout.write

def con():
    l = int(input().rstrip())
    b = list(map(int, input().rstrip().split()))
    if b[0] != l:
        return ""NO""
    for i in range(1, l):
        if b[i] > l:
            return ""NO""
        for j in range(b[i], b[i-1]):
            if b[j] != i:
                {{completion}}
    return ""YES""

print(""\n"".join([con() for n in range(int(input().rstrip()))]))","return ""NO""","l = j
                break
        if l == b[i-1]:
            return ""NO""
    return ""YES""

def con2():
    l = int(input().rstrip())
    b = list(map(int, input().rstrip().split()))
    if b[0] != l:
        return ""NO""
    for i in range(1, l):
        if b[i] > l:
            return ""NO""
        for j in range(b[i], b[i-1]):
            if b[j] != i:
                l = j
                break
        if l == b[i-1]:
            return ""NO""
    return ""YES""

def con3():
    l = int(input().rstrip())
    b = list(map(int, input().rstrip().split()))
    if b[0] != l:
        return """
"from sys import stdin, stdout
from collections import deque


def solve():
    n = int(stdin.buffer.readline().decode())
    nums = list(map(int, stdin.buffer.readline().decode().split()))

    for i in range(n):
        while n and nums[n - 1] <= i:
            {{completion}}
        if nums[i] != n:
            return 'No'
    return 'Yes'


def main():
    answers = list()
    for _ in range(int(stdin.buffer.readline().decode())):
        answers.append(solve())

    stdout.write('\n'.join(map(str, answers)))


if __name__ == '__main__':
    main()












",n -= 1,"n -= 1
        if nums[i] != n:
            return 'No'
    return 'Yes'


def main():
    answers = list()
    for _ in range(int(stdin.buffer.readline().decode())):
        answers.append(solve())

    stdout.write('\n'.join(map(str, answers)))


if __name__ == '__main__':
    main()







































































































































































































































































































"
"import sys

input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    exist = [0] * (n+1)
    for x in a:
        exist[x] = 1
    for x in range(n+1):
        if not exist[x]:
            {{completion}}

    ans = []
    for i in range(n):
        ans.append(a[(-(k-1)+i) % (n+1)])

    print(*ans)
",a = [x] + a,"exist[x] = -1

    exist = [0] + exist"
"import math
import sys

fastin = sys.stdin.readline
fastout = sys.stdout.write


def solve():
    n, k = map(int, fastin().split())
    arr = list(map(int, fastin().split()))
    seen = set(arr)
    for i in range(n + 1):
        if i not in seen:
            {{completion}}

    ret = [str(arr[(i - k) % (n + 1)]) for i in range(n)]
    fastout("" "".join(ret) + ""\n"")


t = int(fastin())
for _ in range(t):
    solve()
","arr.append(i)
            break","seen.add(i)
            arr[i] = 0
    arr.sort()"
"import sys
def input(): return sys.stdin.readline().strip()


for test in range(int(input())):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    brr = [0]*(n+1)
    no = -1
    for i in arr:
        brr[i] = 1
    for i in range(n+1):
        if brr[i] == 0:
            {{completion}}
    crr = [no] + arr[::-1]
    k -= 1
    k%=n+1
    ans = [0]*n
    for i in range(n):
        ans[i] = crr[(k-i)%(n+1)]
    print(*ans)
",no = i,"no += 1
            brr[i] = 1
    no = no%n"
"for s in[*open(0)][1:]:
 n=i=j=len(a:=[0,*map(int,s[:-1])]);c=0
 while i:{{completion}}
 print(''.join(map(str,a[:j])).lstrip('0')+'0'*(n-j))","i-=1;a[i]+=c;j=(j,i)[c:=a[i]>4]","
  c+=i%10
  i=i//10
  j=j-1
  k=(j-i)//2
  a[k]=a[k]-(i+j)*10
  a[k]=a[k]//10
  i=c
 print(max(a))
<|/ q tags=python,algorithm |>
<| c |>
What have you tried so far? Please post your code.
<|/ c |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
I added the code I tried
<|/ c |>"
"for _ in range(int(input())):
	s = input();n = len(s);p = 0;lst = -1
	for i in range(n - 1, -1, -1):
		if int(s[i]) + p >= 5:p = 1;lst = i
		else:{{completion}}
	if lst > -1:
		if lst == 0:print('1' + ('0' * n))
		else:print(s[: lst - 1] + str(int(s[lst - 1]) + 1) + ('0' * (n - lst)))
	else:print(s)",p = 0,"p = p * 10 + int(s[i])
	if lst > -1:
		if lst == 0:print('1' + ('0' * n))
		else:print(s[: lst - 1] + str(int(s[lst - 1]) + 1) + ('0' * (n - lst)))
	else:print(s)
<|/ a tags=python-3.x,python |>"
"def f(s):
    n = len(s)
    pre4 = -1
    for i in range(n):
        if int(s[i])>=5:
            if i==0:
                return '1'+('0'*n)
            else:
                curr = i-1
                while(curr >=0 and s[curr]=='4'):
                    curr -= 1
 
                if curr==-1:
                    return '1'+('0'*n)
                else:
                    {{completion}}
    return s
 
                
tc = int(input())
while tc > 0:
    s = input()
    print(f(s))
    tc = tc-1","digit = int(s[curr])
                    return s[:curr]+str(digit+1)+('0'*(n-1-curr))","pre4 = curr
 
    return s[pre4]+'1'+('0'*n)
 
def g(s):
    n = len(s)
    pre4 = -1
    for i in range(n):
        if int(s[i])>=5:
            if i==0:
                return '1'+('0'*n)
            else:
                curr = i-1
                while(curr >=0 and s[curr]=='4'):
                    curr -= 1
 
                if curr==-1:
                    return '1'+('0'*n)
                else:
                    pre4 = curr
 
    return s[pre4]+'2'+('0'*n)
 
def h(s):
    n = len(s)
"
"# O(n*m*k)

import sys
input = sys.stdin.buffer.readline

n, m, k = map(int, input().split())

a = [[0]*n for _ in range(m)]
for i in range(n):
    row = list(map(int, input().split()))
    for j in range(m):
        a[j][i] = row[j]

for i in range(m):
    a[i].sort(reverse=True)

dp = [[-1e18]*n for _ in range(k)]
for i in range(k):
    dp[i][0] = a[0+i][0]

for i in range(m-k):
    dp2 = [[-1e18] * n for _ in range(k)]
    mx = -1e18  # Prefix max to remove O(k) factor
    for j in range(k):
        for z in range(n):
            mx = max(mx, dp[j][z])
            if j and z != n-1:
                {{completion}}
        dp2[j][0] = max(dp2[j][0], mx + a[i+1+j][0])

    dp = dp2

ans = 0
for j in range(k):
    for z in range(n):
        ans = max(ans, dp[j][z])

print(ans)
","dp2[j-1][z+1] = max(dp2[j-1][z+1], dp[j][z] + a[i+1+j-1][z+1])","dp2[j][z] = dp[j][z] + a[i+1+j][z]
            else:
                dp2[j][z] = dp[j][z] + a[z]"
"import sys
input = sys.stdin.readline 

from math import isqrt

t = 1 
t = int(input())
for i in range(t):
    {{completion}}","n = int(input())
    val = (1 + isqrt(1 + 8*n)) // 2
    ans = val + max(0, n - ((val)*(val-1)//2))
    print(ans)","n =  int(input())
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"#import sys
#input = sys.stdin.readline
#print = sys.stdout.write
 
tm = int(input())
ans = ['']*tm
for t in range(tm):
    n = int(input())
    if n <= 1:
        {{completion}}
    res = int((2*n + 0.25)**0.5 + 0.500001)
    if n - res*(res - 1)//2 < 0:
        res -= 1
    res += n - res*(res - 1)//2
    ans[t] = str(res)
print('\n'.join(ans))","ans[t] = '2'
        continue","ans[t] = '1'
        continue
    ans[t] = '0'
    ans[t+1] = '1'
    ans[t+2] = '2'
    ans[t+3] = '3'
    ans[t+4] = '4'
    ans[t+5] = '5'
    ans[t+6] = '6'
    ans[t+7] = '7'
    ans[t+8] = '8'
    ans[t+9] = '9'
    ans[t+10] = '10'
    ans[t+11] = '11'
    ans[t+12] = '12'
    ans[t+13] = '13'"
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    l = 1
    r = 10**10+2
    while l < r:
        mid = (l+r+1)//2
        if mid *(mid-1)//2 <= n:
            l = mid
        else:
            {{completion}}
    # print(l) 
    print(l +n- l * (l-1)//2)


for _ in range(int(input())):
    solve()",r = mid -1,"r =mid
        "
"# https://codeforces.com/contest/1864

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n = int(input())
    m = [input() for _ in range(n)]

    ans = 0

    diag_inc = [0] * (2 * n)
    diag_dec = [0] * (3 * n)
    changed = [0] * n

    for r in range(n):

        changed[0] = 0
        for i in range(r + 1):
            changed[0] ^= diag_inc[i]
        for c in range(1, n):
            changed[c] = changed[c - 1] ^ diag_inc[r + c] ^ diag_dec[r - c + n]

        for c in range(n):
            if changed[c] != int(m[r][c] == ""1""):
                {{completion}}

    print(ans)


for _ in range(int(input())):
    solve_case()
","ans += 1
                diag_inc[r + c] ^= 1
                diag_dec[r - c - 1 + n] ^= 1","ans += 1
                changed[c] = int(m[r][c] == ""1"")
                diag_inc[r + c] ^= changed[c]
                diag_dec[r - c + n] ^= changed[c]"
"def solve():

    n = int(input())
    mat = [input().strip() for _ in range(n)]

    left = [0] * n
    right = [0] * n
    mid = [0] * n
    ans = 0
    for j in range(n):
        if mat[0][j] == '1':
            mid[j] = 1
            ans += 1

    for i in range(1, n):
        nleft = [0] * n
        nright = [0] * n
        nmid = [0] * n
        for j in range(n):
            
            nmid[j] = mid[j]
            if j:
                nleft[j] ^= left[j - 1] ^ mid[j - 1]
            if j < n - 1:
                nright[j] ^= right[j + 1] ^ mid[j + 1]

            if (nmid[j] + nleft[j] + nright[j]) & 1:
                if not mat[i][j] == '1':
                    nmid[j] ^= 1
                    ans += 1
            else:
                if mat[i][j] == '1':
                    {{completion}}
        left = nleft
        right = nright
        mid = nmid


    out.append(ans)


out = []
        
def main():
    
    T = int(input())

    for _ in range(T):
        x = solve()

    print('\n'.join(map(str, out)))
    

from sys import stdin, stdout
input = stdin.readline

main()





 
","nmid[j] ^= 1
                    ans += 1","nmid[j] ^= 0
                    ans += 1

        mid = nmid"
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    left, right = [0] * (n + 1), [0] * (n + 1)
    ans = 0
    for i in range(n):
        s = input()
        vals = [0] * (n + 1)
        last = left[0]
        for j in range(1, n):
            left[j - 1] = left[j]
        left[0] ^= last
        left[n - 1] = 0
        for j in range(n - 2, -1, -1):
            right[j + 1] = right[j]
        for j in range(n):
            vals[j] ^= left[j] ^ right[j] ^ (vals[j - 1] if j else 0)
        for j in range(n):
            if int(s[j]) ^ (vals[j] & 1):
                {{completion}}
    print(ans)
","ans += 1
                left[j] ^= 1
                right[j + 1] ^= 1",ans += 1
"# Optimize the obvious O(NM) dp (0 means player moving will lose).
# We don't need to store the answer to all O(NM) states.
# As we iterate from bottom to top row, we just have to store the columns where an answer of 0 exists.
#   Motivated by the fact that our dp is just dp[i][j] = 1 if can transition to dp[i2][j2] = 0 else 0
# We obviously have at least O(K) updates (at special tile, answer is 0).
# However, we only have at most 1 extra update per row:
# first column j where no answer of 0 exists and no special tiles to right
#   By definition, all j2 > j have answer 1
#   Since answer = 0 for j, answer = 1 for j2 < j

import sys
input = sys.stdin.buffer.readline

n, m, k = map(int, input().split())
special = [[] for _ in range(n)]
for _ in range(k):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    special[x].append(y)

j = m-1
has0 = [0] * m

for i in range(n-1, 0, -1):
    while j >= 0 and has0[j]:
        j -= 1

    mxjt = -1
    for jt in special[i]:
        has0[jt] = 1
        mxjt = max(jt, mxjt)
    if j >= 0 and j > mxjt:
        has0[j] = 1

if special[0] or has0[0]:
    print(""Chaneka"")
else:
    while j >= 0 and has0[j]:
        {{completion}}

    print(""Chaneka"" if j else ""Bhinneka"")
",j -= 1,j += 1
"MOD = 998244353
N, K = map(int, input().split())
ans, roll1, roll2 = 1, 1, 1
for l in range(1, N+1):
    if K+1-l == 0: {{completion}}
    curr = (MOD + pow(l+1, K+1-l, MOD) - pow(l, K+1-l, MOD)) % MOD
    roll1 = (roll1 * l) % MOD
    roll2 = (roll2 * (N+1-l)) % MOD
    ans = (ans + curr*roll1*roll2) % MOD

print(ans)
",break,"break
    roll1 = (roll1 * l) % MOD
    roll2 = (roll2 * (N+1-l)) % MOD
    ans = (ans + roll1*roll2) % MOD

for l in range(1, N+1):
    if K+1-l == 0: break"
"mod = 998244353
fact = [1]*200001
for i in range(1,200001):
    {{completion}}
invfact = [pow(f,-1,mod) for f in fact]

n,k = map(int,input().split())
ans = 1
for x in range(1,min(n+1,k+1)):
    add = pow(x+1,k-x+1,mod) - pow(x,k-x+1,mod)
    add = (add*fact[x])%mod
    add = (add*fact[n])%mod
    add = (add*invfact[n-x])%mod
    ans = (ans+add)%mod
print(ans)
",fact[i]= (fact[i-1]*i)%mod,fact[i] = fact[i-1]*i
"MOD = 998244353
N, K = map(int, input().split())
ans, roll1, roll2 = 1, 1, 1
for l in range(1, N+1):
    if K+1-l == 0: {{completion}}
    curr = (MOD + pow(l+1, K+1-l, MOD) - pow(l, K+1-l, MOD)) % MOD
    roll1 = (roll1 * l) % MOD
    roll2 = (roll2 * (N+1-l)) % MOD
    ans = (ans + curr*roll1*roll2) % MOD

print(ans)",break,break
"import sys
input=sys.stdin.readline
n=int(input())
x={}
for i,j in zip(*[map(int,input().split()) for _ in range(2)]):
    x[i]=j
m=int(input())
z=0
for i,j in zip(*[map(int,input().split()) for _ in range(2)]):
    if x.get(i,0)<j:
        z=-1
        break
    elif x.get(i,0)!=j:
        {{completion}}
print(pow(2,n-m+z,998244353) if z!=-1 else 0)",z+=1,"z-=1
        break"
"def solve():
    # n=map(int,input().split())
    n=int(input())
    a=list(map(int,input().split()))
    b=list(map(int,input().split()))
    m=int(input())
    c=list(map(int,input().split()))
    d=list(map(int,input().split()))

    if m>n:return 0

    i=0
    j=0
    while i<n and j<m:
        if a[i]>c[j]:
            return 0
        if a[i]==c[j]:
            b[i]=b[i]-d[j]
            if b[i]<0:{{completion}} 
            j+=1
        i+=1

    x=0
    for i in b:
        if i>0:x+=1
    return int((2**x)%998244353)






















ans=solve()
print(ans)",return 0,"
                b[i]=0
            i+=1
            j+=1
        else:
            b[i]=b[i]-c[j]
            if b[i]<0:
                b[i]=0
            i+=1
            j+=1
    while i<n:
        if a[i]>c[j]:
            return 0
        if a[i]==c[j]:
            b[i]=b[i]-d[j]
            if b[i]<0:
                b[i]=0
            i+=1
            j+=1
        else:
            b[i]=b[i]-c[j]
            if b[i]<0:
                b[i]=0
            i+=1
            j+=1
    while j<m:
        if a[i]>c[j]:
            return 0
        if a[i]=="
"n_fact_X = int(input())
base_X = [int(N) for N in input().split()]
exp_X = [int(N) for N in input().split()]
n_fact_Y = int(input())
base_Y = [int(N) for N in input().split()]
exp_Y = [int(N) for N in input().split()]


def problem(nx, bx, ex, ny, by, ey):
    mod = 998244353
    i = 0  # for y
    j = 0  # for x
    n = 0
    while i < ny or j < nx:
        if i == ny or by[i] > bx[j]:
            n += 1
            j += 1
        elif by[i] == bx[j]:
            if ey[i] < ex[j]:
                n += 1
            elif ey[i] > ex[j]:
                {{completion}}
            j += 1
            i += 1
        else:
            return 0

    sol = 1
    while n > 0:
        sol = (sol * 2) % mod
        n -= 1
    return sol


print(problem(n_fact_X, base_X, exp_X, n_fact_Y, base_Y, exp_Y))",return 0,"n += 1
            j += 1
        elif by[i] < bx[j]:
            n += 1"
"from math import lcm
N, M = [int(i) for i in input().split()]
M = min(M, N)
def arith(lo, hi):
    return (hi*(hi+1)//2) - (lo*(lo-1))//2 

best = 1
best_balls = 0
for i in range(2, M+1):
    L = lcm(i, N)
    total = 0

    cur = i
    lo = 1
    for j in range(L//N):
        x = max(1 + (lo-cur)//(i-1), 0)
        if cur + x*i <= N:
            {{completion}}
        end = (N-cur+i-1)//i
        cur = 1+(cur+end*i-1)%N
        lo += end

    if total > best_balls:
        best = i
        best_balls = total

print(best)


","end = (N-cur)//i
            start = x
            total += (arith(start, end))*i + cur*(end-start+1)","total += x*i
            cur += x*i"
"from math import gcd

N, M = map(int, input().split())
ans, bestK = 0, 1
for K in range(2, min(N,M)+1):
    if N%K == 0:
        x = N//K
        cur = K*x*(x+1) // 2
        if cur > ans:
            {{completion}}
        continue
    elif gcd(N,K) > 1: continue
    
    cur = 0
    id, c = 1, K
    while id < N:
        ct = (N-c) // K
        sw = (1 + (id-c) // (K-1)) if id>=c else 0
        if sw <= ct:
            cur += c*(ct-sw+1) + K * (ct*(ct+1)//2 - sw*(sw-1)//2)
        id += ct+1
        c = (c + (ct+1)*K - 1) % N
        c += 1
    if cur > ans:
        ans, bestK = cur, K

print(bestK)
","ans, bestK = cur, K","ans, bestK = cur, K
    elif M%K == 0:
        x = M//K
        cur = K*x*(x+1) // 2
        if cur > ans:
            ans, bestK = cur, K
    elif K > N and K > M:"
"tt=int(input())
for ii in range(tt):
    p=int(input())
    vis=[0]*(p+2)
    p=list(map(int,input().split()))
    ans=0
    for i in p:
        vis[i]=1
        if vis[i+1]==1:{{completion}}
    print(ans)
",ans+=1,"
            vis[i+1]=0
            vis[i]=1
            ans=ans+2
        else:
            vis[i+1]=1
            vis[i]=0
            ans=ans+1
    ans=ans-p"
"# LUOGU_RID: 139637104

def solve():
    n = int(input().strip())
    a = list(map(int, input().strip().split()))
    st = [False] * (n + 10)

    res = 0
    for i in a:
        if i != 1 and st[i-1] == False:
            {{completion}}
        st[i] = True

    print(res)

for i in range(int(input().strip())):
    solve()
",res += 1,"st[i] = True
            st[i-1] = True
            res += 1
        elif i == 1 and st[i-1] == True:
            st[i] = True
            st[i-1] = False
            res += 1
        else:"
"for _ in range(int(input())):
    t = int(input())
    l = list(map(int,input().split()))
    count = 0
    d = [0]*(t+1)
    for i in range(t):
        d[l[i]-1] = 1
        if d[l[i]] == 1:
            {{completion}}
    print(count)",count += 1,"count += 1
    print(count)
<|/ file source=github ext=.py |>"
"mod=998244353
n=int(input())
s=list(map(int, input().split()))
inv=pow(100,mod-2,mod)
p=[0]*100
invp=[0]*100
for i in range(100):
    p[i]=i*inv%mod
    invp[i]=pow(1-p[i],mod-2,mod)
a=[0]*100
ans=[0]*n
for i in range(n):
    if i>=1:
        for j in range(100):
            {{completion}}
    ans[i]=1+p[s[i]]*(1+a[s[i]])*invp[s[i]]%mod
print(sum(ans)%mod)",a[j]=(a[j]+ans[i-1])*p[j]%mod,"ans[i]+=p[j]*invp[j]*a[j]
        a[i]=s[i]
    else:
        a[i]=s[i]
for i in range(n):"
"def quick_pow(a,b):
    res=1
    while b:
        if b&1:
            {{completion}}
        a=a*a%mod
        b>>=1
    return res

mod=998244353
tmp=quick_pow(100,mod-2)
ans=0
n=int(input())
p=[0]+list(map(int,input().split()))
inv=[0 for _ in range(100)]
S=[0 for _ in range(100)]
f=[0 for _ in range(n+1)]
for i in range(100):
    inv[i]=i*tmp%mod
for i in range(1,n+1):
    f[i]=(S[p[i]]+1)*quick_pow((1-inv[p[i]]+mod)%mod,mod-2)%mod
    ans=(ans+f[i])%mod
    for j in range(100):
        S[j]=(inv[j]*S[j]%mod+inv[j]*inv[j]%mod*f[i]%mod)%mod
print(ans)
        
",res=res*a%mod,"res=res*a
        a=a*a%mod
        b>>=1
    return res

mod=998244353
tmp=quick_pow(100,mod-2)
ans=0
n=int(input())
p=[0]+list(map(int,input().split()))
inv=[0 for _ in range(100)]
S=[0 for _ in range(100)]
f=[0 for _ in range(n+1)]
for i in range(100):
    inv[i]=i*tmp%mod
for i in range(1,n+1):
    f[i]=(S[p[i]]+1)*quick_pow((1-inv[p[i]]+mod)%mod,mod-2)%mod
    ans=("
"MOD = 998244353
denom = pow(100, MOD-2, MOD)

N = int(input())
P = [0] + list(map(int, input().split()))
p = [(pct*denom)%MOD for pct in range(100)]
E = [0] * (N+1)
E[1] = pow(MOD+1-p[P[1]], MOD-2, MOD)
DP = [(p[pct]*p[pct]*E[1])%MOD for pct in range(100)]
for k in range(2, N+1):
    E[k] = (pow(MOD+1-p[P[k]], MOD-2, MOD) * (1+DP[P[k]])) % MOD
    for pct in range(100):
        {{completion}}

print(sum(E)%MOD)
",DP[pct] = ((DP[pct] + E[k]*p[pct])*p[pct]) % MOD,DP[pct] = (DP[pct]*p[pct]*E[k]) % MOD
"import sys
input = sys.stdin.readline
o = lambda: map(int, input().split())
 
for _ in range(int(input())):
    h,c = o()
    grid = []
    for _ in range(h):
        grid.append(list(input().strip()))
    ans = []
    e = {0:""W"",1:""B""}
    flag = True
    t = 0
    for i in range(h):
        for j in range(c):
            if grid[i][j] == ""U"":
                grid[i][j] = e[t]
                grid[i+1][j] = e[(t+1)%2]
                t = (t+1) % 2
        if t:
            flag = False
            break
    if flag:
        for j in range(c):
            for i in range(h):
                if grid[i][j] == ""L"":
                    {{completion}}
            if t:
                flag = False
                break
        if flag:
            for row in grid:
                print("""".join(row))
        else:
            print(-1)
    else:
        print(-1)","grid[i][j] = e[t]
                    grid[i][j+1] = e[(t + 1) % 2]
                    t = (t + 1) % 2","grid[i][j] = e[t]
                    grid[i][j-1] = e[(t-1)%2]
                    t = (t-1) % 2
            if t:
                flag = False
                break
        if flag:
            for j in range(c):
                for i in range(h):
                    if grid[i][j] == ""R"":
                        grid[i][j] = e[t]
                        grid[i][j+1] = e[(t+1)%2]
                        t = (t+1) % 2
            if t:
                flag = False
                break
        if flag:
            for j in range(c):
                for i in range(h):
                    if grid[i][j] == ""D"":
                        grid[i][j] = e[t]
                        grid[i-1][j] = e[(t-1)%2]
                        t"
"import sys
input = sys.stdin.readline

t=int(input())
for tests in range(t):
    n,m=map(int,input().split())
    MAP=[input().strip() for i in range(n)]

    ANS=[["".""]*m for i in range(n)]

    flag=1

    for i in range(n-1):
        count=0
        for j in range(m):
            if MAP[i][j]==""U"":
                if count==0:
                    ANS[i][j]=""W""
                    ANS[i+1][j]=""B""
                else:
                    {{completion}}

                count^=1

        if count!=0:
            flag=0

    for i in range(m-1):
        count=0
        for j in range(n):
            if MAP[j][i]==""L"":
                if count==0:
                    ANS[j][i]=""W""
                    ANS[j][i+1]=""B""
                else:
                    ANS[j][i]=""B""
                    ANS[j][i+1]=""W""

                count^=1

        if count!=0:
            flag=0

    if flag==1:
        for i in range(n):
            print("""".join(ANS[i]))
    else:
        print(-1)
            
","ANS[i][j]=""B""
                    ANS[i+1][j]=""W""","ANS[i][j]=""B""
                    ANS[i+1][j]=""W"""
"import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    n, m = readInts()
    arr = [readStr() for _ in range(n)]
    ans = [["".""] * m for _ in range(n)]

    for i in range(n):
        curr = 0
        for j in range(m):
            if arr[i][j] == ""U"":
                {{completion}}
        if curr:
            return -1

    for j in range(m):
        curr = 0
        for i in range(n):
            if arr[i][j] == ""L"":
                ans[i][j] = ""W"" if not curr else ""B""
                ans[i][j+1] = ""W"" if curr else ""B""
                curr ^= 1
        if curr:
            return -1
    return ""\n"".join(["""".join(each) for each in ans])


for _ in range(int(input())):
    print(solve())
","ans[i][j] = ""W"" if not curr else ""B""
                ans[i+1][j] = ""W"" if curr else ""B""
                curr ^= 1","ans[i][j] = ""B"" if not curr else ""W""
                ans[i][j+1] = ""B"" if curr else ""W""
                curr ^= 1"
"from functools import lru_cache

P = 998244353
mx = 130

sm_pow = [[0] * (mx + 1) for _ in range(10**5 + 5)]
for i in range(1, len(sm_pow)):
    cur = 1
    for j in range(mx + 1):
        sm_pow[i][j] = (sm_pow[i-1][j] + cur) % P
        cur = (cur * i) % P

@lru_cache(maxsize=None)
def count_values(yy):
    if yy == 0:
        a = [0] * mx
        return a[:], a[:]
    if yy == 1:
        a = [1] + [0] * (mx - 1)
        return a[:], a[:]

    h = yy.bit_length() - 1
    l = yy - (2**h - 1)

    R1, P1 = count_values(2**(h-1) - 1 + min(l, 2**(h-1)))
    R2, P2 = count_values(2**(h-1) - 1 + max(l - 2**(h-1), 0))

    R1, R2 = [1] + R1[:-1], [1] + R2[:-1]
    R0 = [a + b for a, b in zip(R1, R2)]
    R0[0] -= 1

    P0 = [a + b for a, b in zip(P1, P2)]
    for i in range(2 * h + 2):
        for j in range(min(2 * h + 2, len(P0) - i)):
            {{completion}}
    return [v % P for v in R0], [v % P for v in P0]

for _ in range(int(input())):
    yy, uu = map(int, input().split())
    result = 0
    for i, v in enumerate(count_values(yy)[1]):
        i += 1
        result += v * pow(uu, yy - i, P) * (uu * pow(uu, i, P) - sm_pow[uu-1][i])
    print(result % P)
",P0[i + j] += R1[i] * R2[j],"P0[j] %= P
    P0 = [v % P for v in P0]"
"from sys import *
import math
from functools import cache
input = stdin.readline
inputlist = lambda: map(int, stdin.readline().split())
MOD = 998244353

@cache
def paths(n):
    if n == 1: return [1], [1]
    if n == 2: return [2, 1], [1, 1]
    
    maxpow = 1
    while maxpow-1 < n: maxpow *= 2
    temp = (maxpow//4)-1
    left = min((maxpow//2)-1, n-1-temp)
    right = n-1-left

    leftpaths, lefttop = paths(left)
    rightpaths, righttop = paths(right)
    depth = len(lefttop) + 1

    newpaths = [0] * (2 * depth - 1)
    newtop = [0] * depth
    for i in range(len(lefttop)):
        newtop[i + 1] += lefttop[i]
        newpaths[i + 1] += lefttop[i]
    for i in range(len(righttop)):
        newtop[i + 1] += righttop[i]
        newpaths[i + 1] += righttop[i]
    newpaths[0] += 1
    newtop[0] += 1
 
    for i in range(len(leftpaths)): newpaths[i] += leftpaths[i]
    for i in range(len(rightpaths)): newpaths[i] += rightpaths[i]
 
    for i in range(len(lefttop)):
        for j in range(len(righttop)):
            {{completion}}
    
    return newpaths, [v % MOD for v in newtop]

for _ in range(int(input())):
    n, m = inputlist()
    p, _ = paths(n)
    maxlength = len(p)
    
    p_small = [1] * m
    im = pow(m, MOD - 2, MOD)
    ans = 0
    for length in range(maxlength):
        for i in range(m):
            p_small[i] *= (i * im) % MOD
            p_small[i] %= MOD
        exp = m - sum(p_small)
        ans += exp * p[length]
        ans %= MOD
    ans *= pow(m, n, MOD)
    ans %= MOD
    
    print(ans)","newpaths[i + j + 2] += lefttop[i] * righttop[j]
            newpaths[i + j + 2] %= MOD","temp = newpaths[i + j + 1]
            newpaths[i + j + 1] = newpaths[i + j] + temp
            newpaths[i + j] %= MOD
 
    for i in range(len(newpaths)):
        if newpaths[i] < 0: newpaths[i] = 0
        if newpaths[i] > MOD: newpaths[i] = MOD"
"import sys
input = sys.stdin.readline

from functools import cache

MOD = 998244353

@cache
def paths(n):
    if n == 1:
        return [1], [1]
    if n == 2:
        return [2, 1], [1, 1]

    p2 = 1
    while p2 - 1 < n:
        p2 *= 2

    r_sz = (p2 // 4) - 1
    l_sz = min((p2 // 2) - 1, n - 1 - r_sz)
    r_sz = n - 1 - l_sz

    #print(p2, l_sz, r_sz)

    p_l, d_l = paths(l_sz)
    p_r, d_r = paths(r_sz)

    assert len(d_l) >= len(d_r)

    m_d = len(d_l) + 1

    d = [0] * m_d
    p = [0] * (2 * m_d - 1)
    for i in range(len(d_l)):
        d[i + 1] += d_l[i]
        p[i + 1] += d_l[i]
    for i in range(len(d_r)):
        d[i + 1] += d_r[i]
        p[i + 1] += d_r[i]
    p[0] += 1
    d[0] += 1

    for i in range(len(p_l)):
        p[i] += p_l[i]
    for i in range(len(p_r)):
        p[i] += p_r[i]

    for i in range(len(d_l)):
        for j in range(len(d_r)):
            {{completion}}
    
    #print(n, p, d)
    return p, [v % MOD for v in d]

outl = []

t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    
    p, _ = paths(n)
    z = len(p)

    out = 0

    p_small = [1] * m
    im = pow(m, MOD - 2, MOD)

    for length in range(z):
        for i in range(m):
            p_small[i] *= (i * im) % MOD
            p_small[i] %= MOD

        exp = m - sum(p_small)
        out += exp * p[length]
        out %= MOD

    out *= pow(m, n, MOD)
    out %= MOD
    
    outl.append(out)

print('\n'.join(map(str, outl)))

	 		 		   	 				   	 	   		","p[i + j + 2] += d_l[i] * d_r[j]
            p[i + j + 2] %= MOD","p_sum = p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            p_sum += p[i + j + 1]
            "
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
powers = {}
for i in range(32):
	for j in range(32):
		powers[(1 << i) - (1 << j)] = (i, j)
special_r = {}
for i in range(32):
	special_r[-(1 << i)] = i
special_g = {}
for i in range(32):
	special_g[1 << i] = i

for _ in range(t):
	n, = I()
	a = I()
	if sum(a) % n:
		print(""No"")
		continue

	mean = sum(a) // n
	gives = [0] * 34
	receives = [0] * 34
	g = [0] * 34
	r = [0] * 34

	for i in range(n):
		diff = mean - a[i]
		if diff != 0:
			if diff in powers:
				x, y = powers[diff]
				gives[x] += 1
				receives[y] += 1
				if diff in special_g:
					g[special_g[diff]] += 1
				elif diff in special_r:
					r[special_r[diff]] += 1
			else:
				print(""No"")
				break
	else:
		for i in range(32):
			if (gives[i] - receives[i]) % 2:
				print(""No"")
				break
			if gives[i] > receives[i]:
				move = (gives[i] - receives[i]) // 2
				if r[i] < move:
					print(""No"")
					break
				gives[i] -= move
				receives[i] += move
				receives[i + 1] -= move
			elif receives[i] > gives[i]:
				move = (receives[i] - gives[i]) // 2
				if g[i] < move:
					{{completion}}
				receives[i] -= move
				gives[i] += move
				gives[i + 1] -= move
		else:
			print(""Yes"")","print(""No"")
					break","print(""No"")
					break
				gives[i] += move"
"# for I/O for local system
import sys
from os import path
if(path.exists('Input.txt')):
    sys.stdin = open('Input.txt','r')
    sys.stdout = open('Output.txt','w')
 
# For fast I/O
input = sys.stdin.buffer.readline
# input = sys.stdin.readline
print = sys.stdout.write
 
# Import libraries here whenever required
from math import *
from random import randint
 
# Use this because normal dict can sometimes give TLE
class mydict:
    def __init__(self, func=lambda: 0):
        self.random = randint(0, 1 << 32)
        self.default = func
        self.dict = {}
    def __getitem__(self, key):
        mykey = self.random ^ key
        if mykey not in self.dict:
            self.dict[mykey] = self.default()
        return self.dict[mykey]
    def get(self, key, default):
        mykey = self.random ^ key
        if mykey not in self.dict:
            return default
        return self.dict[mykey]
    def __setitem__(self, key, item):
        mykey = self.random ^ key
        self.dict[mykey] = item
    def getkeys(self):
        return [self.random ^ i for i in self.dict]
    def __str__(self):
        return f'{[(self.random ^ i, self.dict[i]) for i in self.dict]}'
 
# Solver function
def solve():
    s = sum(a)
    if(s % n):
        print(""NO\n"")
        return
    x = s // n
    d = [0] * 40
    aa = [0] * 40
    bb = [0] * 40
    for i in range(n):
        val = a[i]
        if(val == x):
            continue
        y = abs(x - val)
        if((y & (y - 1)) == 0):
            y = int(log2(y))
            other = y + 1
            # print(y)
            if(val > x):
                d[other] -= 1
                d[y] += 1
                aa[y] += 1
            else:
                {{completion}}
            continue
        add = 0
        give = -1
        while (1 << add) < 3 * 10 ** 9:
            val1 = (1 << add)
            diff = val - x
            val2 = val1 - diff
            if(val2 > 0 and (val2 & (val2 - 1)) == 0):
                give = val2
                break
            add += 1
        if(give == -1):
            print(""NO\n"")
            return
        cnt = 0
        xx = 1
        while xx != give:
            xx *= 2
            cnt += 1
        give = cnt
        add, give = give, add
        d[add] += 1
        d[give] -= 1
    # print(d)
    # print(aa)
    # print(bb)
    for i in range(40):
        if(i + 1 < 40):
            while(d[i] > 0 and aa[i] > 0):
                d[i] -= 2
                aa[i] -= 1
                d[i + 1] += 1
            while(d[i] < 0 and bb[i] > 0):
                d[i] += 2
                bb[i] -= 1
                d[i + 1] -= 1
        if(d[i] != 0):
            print(""NO\n"")
            return
    print(""YES\n"")
 
# Main 
for _ in range(int(input())):
    n = int(input())
    a = [int(x) for x in input().split()]
    solve()","d[y] -= 1
                d[other] += 1
                bb[y] += 1","d[other] += 1
                d[y] -= 1
                bb[y] -= 1
            continue
        add = 0
        give = -1
        while (1 << add) < 3 * 10 ** 9:
            val1 = (1 << add)
            diff = val - x
            val2 = val1 - diff
            if(val2 > 0 and (val2 & (val2 - 1)) == 0):
                give = val2
                break
            add += 1
        if(give == -1):
            print(""NO\n"")
            return
        cnt = 0
        xx = 1
        while xx != give:
            xx *= 2
            cnt += 1
        give = cnt
        add, give = give, add
"
"import sys
input = sys.stdin.readline
def fg():
    return int(input())
def fgh():
    return [int(xx) for xx in input().split()]
def sd():
    print('Yes')
def df():
    print('No')
def good(x):
    f = 0
    while x:
        if x % 2:
            f += 1
        x //= 2
    return f <= 2
step = [1]
for i in range(40):
    step.append(step[-1] * 2)
for ___ in range(fg()):
    n = fg()
    a = fgh()
    S = sum(a)
    if S % n:
        df()
        continue
    d = S // n
    q = [0] * 40
    w = [0] * 40
    x = [0] * 40
    t = [0] * 40
    for i in range(n):
        g = a[i] - d
        c = 0
        while g and g % 2 == 0:
            c += 1
            g //= 2
        if g < 0:
            if g == -1:
                t[c] += 1
            elif -(g - 1) not in step:
                df()
                break
            else:
                w[step.index(-(g - 1)) + c] += 1
                q[c] += 1
        else:
            if g == 1:
                x[c] += 1
            elif g == 0:
                q[c] += 1
                w[c] += 1
            else:
                if g + 1 not in step:
                    df()
                    break
                else:
                    {{completion}}
    else:
        for i in range(35):
            y = x[i]
            z = t[i]
            o = q[i]
            k = w[i]
            p = o + y - k - z
            if p % 2:
                df()
                break
            if p < 0:
                if -p // 2 > z:
                    df()
                    break
                else:
                    w[i + 1] += -p // 2
            else:
                if p // 2 > y:
                    df()
                    break
                else:
                    q[i + 1] += p // 2
        else:
            sd()

","q[step.index(g + 1) + c] += 1
                    w[c] += 1","w[step.index(g + 1) + c] += 1
                    q[c] += 1
    if good(sum(q)):
        sd()"
"n=int(input())
aa=[abs(int(i)) for i in input().split()]
if 0 in aa:
    print(0)
else:
    {{completion}}
",print(abs(min(aa))),"ans=0
    for i in range(n):
        if aa[i]==0:
            ans+=1
            aa[i]=1
        else:
            aa[i]=aa[i]-1
    print(ans)
<|/ a tags=python,algorithm |>"
"inf = 10 ** 18

for _ in range(int(input())):
    n = int(input())
    a = [int(x) for x in input().split()]

    p = [-1] * (n + 2)
    f = [inf] * (n + 2)

    f[0] = -1

    for j in range(n):
        o = [0] * (n + 2)
        q = [-1] * (n + 2)
        cnt = 0

        for i in range(j, -1, -1):
            o[a[i]] = 1;
            while o[cnt]:
                cnt += 1
            q[i] = cnt
            if cnt <= q[i + 1] or cnt <= p[i]:
                continue

            delta = []

            for k in range(n + 2):
                if f[k] < i and f[k ^ cnt] == inf:
                    {{completion}}

        p = q

    for i in range(n + 1, -1, -1):
        if f[i] < inf :
            print(i)
            break
",f[k ^ cnt] = j,"delta.append(k)
            delta.sort()

            delta.reverse()

            delta.insert(0, j)

            for k in range(n + 2):
                if f[k] < i and f[k ^ cnt] == inf:
                    delta.append(k)

            delta.sort()

            delta.reverse()

            delta.insert(0, j)

            for k in range(n + 2):
                if f[k] < i and f[k ^ cnt] == inf:
                    delta.append(k)

            delta.sort()

            delta.reverse()

            delta.insert(0, j)

            for k in range(n + 2):
                if f[k] < i and f[k ^ cnt] == inf:
                    delta.append(k)

            delta.sort()"
"inf = float('inf')

def f(j):
    if last_mex[j]:
        for v in range(n + 1):
            if mex_pos[v] < last_pos[j]:
                mex_pos[v ^ last_mex[j]] = min(mex_pos[v ^ last_mex[j]], j)

t = int(input())
for _ in range(t):
    n = int(input())
    nums = list(map(int, input().split()))
    
    last_mex = [0] * n
    last_pos = list(range(n))
    mex_pos = [inf] * (n + 1)
    mex_pos[0] = -1
    
    for i in range(n):
        vis = [0] * (n + 1)
        mex = 0
        for j in range(i, n):
            vis[nums[j]] = 1
            flag = False
            while vis[mex]: mex += 1; flag = True
            
            if flag:
                if last_mex[j] != mex:
                    {{completion}}
                last_pos[j] = i
        f(i)
    
    print(max(i for i in range(n + 1) if mex_pos[i] < inf))","f(j)
                    last_mex[j] = mex","last_mex[j] = mex
                    last_pos[j] = i
                mex += 1
                
        mex_pos[i] = mex
    
    mex_pos[0] = -1
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys 
input = sys.stdin.buffer.readline 
""""""
if you want the mex-product to have 
""""""
def process(A):
    if 0 not in A:
      sys.stdout.write('0\n')
      return
    n = len(A)
    """"""
    largest R so 2**R-1 <= n 
    
    """"""
    R = 0 
    while 2**R-1 <= n:
        R+=1
    d = [None for i in range(2**R-1)]
    mexes = [None for i in range(n+2)]
    for i in range(1, n+1):
        my_mex = [0 for i in range(n+2)]
        I = 0
        for j in range(i, 0, -1):
            aj = A[j-1]
            my_mex[aj] = 1
            I0 = I 
            while my_mex[I]==1:
                I+=1 
            if I0 != I:
                if d[I] is None:
                    d[I] = i
                if mexes[I] is None or mexes[I] < j: 
                  mexes[I] = j
                  for k in range(2**R-1):
                      if d[k] is not None and d[k] <= j-1 and d[I^k] is None:
                          {{completion}}
    print(max([i for i in range(2**R-1) if d[i] is not None]))
        
t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    process(A)",d[I^k] = i,"my_mex[I^k] = 1
                          mexes[I^k] = j
    
    
    """"""
    
    """"""
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys

input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))

    ans = 1

    same = sum(a)
    if same % n != 0:
        print('NO')
        continue
    else:
        same //= n

    need = [0] * 31

    for x in a:
        d = same - x
        if d != 0:
            ad = abs(d)

            small = ad & -ad
            big = 1 << ad.bit_length()

            if big - small == ad:
                add = 1 if d > 0 else -1
                need[big.bit_length()-1] += add
                need[small.bit_length()-1] -= add
            else:
                {{completion}}

    if not all(x == 0 for x in need):
        ans = 0

    print(""YES"" if ans else ""NO"")
",ans = 0,"need[big.bit_length()-1] += 1 if d > 0 else -1
                need[small.bit_length()-1] -= 1 if d > 0 else -1

    need = sorted(need)"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
powers = {}
for i in range(32):
	for j in range(32):
		powers[(1 << i) - (1 << j)] = (i, j)

for _ in range(t):
	n, = I()
	a = I()
	if sum(a) % n:
		print(""No"")
		continue

	mean = sum(a) // n
	gives = [0] * 32
	receives = [0] * 32

	for i in range(n):
		diff = a[i] - mean
		if diff != 0:
			if diff in powers:
				x, y = powers[diff]
				gives[x] += 1
				receives[y] += 1

			else:
				{{completion}}
	else:
		if gives == receives:
			print(""Yes"")
		else:
			print(""No"")
","print(""No"")
				break","print(""No"")
				continue

	for i in range(32):
		if gives[i] == receives[i]:
			print(""Yes"")
		else:
			print(""No"")
			break

	mean = sum(a) // n
	gives = [0] * 32
	receives = [0] * 32

	for i in range(n):
		diff = a[i] - mean
		if diff != 0:
			if diff in powers:
				x, y = powers[diff]
				gives[x] += 1
				receives[y] += 1

			else:
				print(""No"")
				continue

	for i in range(32):
		if gives[i] == receives[i]:
			print(""Yes"")
		else:
			print(""No"")
			break

	"
"#author: sushmanth

from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


which = dict()
for i in range(35):
    for j in range(35):
        which[(1 << i) - (1 << j)] = [i , j]

def answer():


    s = sum(a)
    if(s % n):return 'No'

    final = s // n
    count = [0 for i in range(35)]
    for i in range(n):
        if(a[i] > final):
            v = a[i] - final
            if(v not in which):return 'No'
            count[which[v][0]] += 1
            count[which[v][1]] -= 1
        else:
            v = final - a[i]
            if(v not in which):{{completion}}
            count[which[v][0]] -= 1
            count[which[v][1]] += 1


    for x in range(35):
        if(count[x]):return 'No'

    return 'Yes'


for T in range(int(input())):

    n = int(input())
    a = inp()

    print(answer())




    

",return 'No',return 'No'
"import sys
input=sys.stdin.readline
for i in range(int(input())):
    n,k=map(int,input().split())
    a=[*map(int,input().split())]
    f,c=1,-1
    if k==1:
        if a!=list(range(1,n+1)):f=0
    else:
        for i in range(n):
            s,p,t,l=a[i],i,[],0
            while s>0:
                {{completion}}
            if s==c and (l<k or t[-k]!=p):f=0;break
            c-=1
    if f:print('YES')
    else:print('NO')","t.append(p)
                l+=1
                a[p]=c
                s,p=a[s-1],s-1","t.append(s)
                s,p=s-1,p%k"
"import sys
input=sys.stdin.buffer.readline
def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input()
def rm():
    return map(int,input().split())

def main():
    n,k=rm()
    b=rl()
    for i in range(n): b[i]-=1
    if k==1:
        for i in range(n):
            if b[i]!=i: {{completion}}
        return 'YES'
    v=set()
    for i in range(n):
        nxt=i
        cnt=0
        d={}
        while nxt not in v:
            d[nxt]=cnt
            v.add(nxt)
            cnt+=1
            nxt=b[nxt] 
        if nxt not in d.keys(): continue
        if cnt-d[nxt]!=k: return 'NO'
    return 'YES'

t=ri()
for i in range(t):
    print(main())",return 'NO',return 'NO'
"import sys;input=sys.stdin.readline;R=lambda:list(map(int,input().split()))
for _ in range(int(input())):
    n,k=R()
    b=[0]+R()
    if k==1:
        if b!=[i for i in range(n+1)]: print('No')
        else: {{completion}}
        continue
    vs=[0]*(n+1)
    val=[0]*(n+1)
    turn=[0]*(n+1)
    for i in b[1:]:
        t=i
        if vs[t]: continue
        cnt=0
        while not vs[t]:
            turn[t]=i
            vs[t]=1
            val[t]=cnt
            cnt+=1
            t=b[t]
        if turn[t]==turn[i] and cnt-val[t]!=k: print('No'); break
    else: print('Yes')
            
            
        

    
'''
2
10 2
5 1 2 5 4 8 3 10 4 8
10 6
6 7 7 8 1 3 9 1 8 2
'''
",print('Yes'),print('Yes')
"for _ in range(int(input())):
    a = input()
    b = input()
    ans = 0
    for i in range(len(a)):
        if a[i] == b[i] == ""0"" and a[i+1] == b[i+1] == ""1"":
            {{completion}}
    if ans:
        print(""YES"")
    else:
        print(""NO"")","ans += 1
            break","ans = 1
            break"
"t=int(input())
for _ in range(t):
	a=input()
	b=input()
	flag=False

	for i in range (len(a)):
		if (a[i]=='0' and b[i]=='0') and (a[i+1]=='1' and b[i+1]=='1'):
			{{completion}}

	if flag:
		print(""YES"")
	else:
		print(""NO"")",flag=True,"flag=True
			break"
"n=int(input())
while n>0:
    n-=1
    a = list(map(int,input()))
    b = list(map(int,input()))
    for i in range(1, len(a)):
        if a[i - 1] == b[i - 1] == 0 and a[i] == b[i] == 1:
            {{completion}}
    else:
        print('NO')","print('YES')
            break","a[i - 1] = 1
            b[i - 1] = 1
            break
    if a[0] == b[0] and a[1] == b[1]:
        print('YES')"
"I=input
for _ in[0]*int(I()):
 n,a,q=map(int,I().split());k=l=m=0
 for x in I():
  if'+'<x:k+=1
  else:{{completion}}
 print(('YES','MAYBE','NO')[(m<n-a)+(l<n-a)])
",m+=1;l+=k<1;k-=k>0,"k=0
  if'-'<x:l+=1
  else:l=0
  if'+'<x:m+=1
  else:m=0
 print(('YES','MAYBE','NO')[(m<n-a)+(l<n-a)])
<|/ a dscore=0 |>"
"t = int(input())
for i in range(t):
    n, a, q = [int(i) for i in input().split()]
    s = input()
    k = a
    p = a
    flag = True
    for sign in s:
        if k == n:
            print(""YES"")
            flag = False
            break
        if sign == '+':
            k += 1
            p += 1
        else:
            {{completion}}
        if k == n:
            print(""YES"")
            flag = False
            break
    if flag:
        if p < n:
            print(""NO"")
        else:
            print(""MAYBE"")

",k -= 1,"p -= 1
            k += 1"
"t = int(input())
for _ in range(0, t):
    n, a, q = map(int, input().split())
    ar = input()
    z = len(ar)
    result = ""MAYBE""
    c=0

    if n == a:
        result = ""YES""
    elif a + ar.count(""+"") < n:
        result = ""NO""
    else:
        for i in ar:
            if i == ""+"":
                c += 1
            else:
                {{completion}}
            if c + a == n:
                result = ""YES""
                break
    print(result)",c -= 1,c -= 1
for a in[*open(0)][1:]:{{completion}},"print('YNEOS'[sum(sorted(map(int,a[::2]))[1:])<10::2])","
    if sum(a) == 10:
        print(""YES"")
    else:
        print(""NO"")
<|/ q |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Welcome to Stack Overflow! It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far, example input (if there is any), the expected output, and the output you actually get (console output, tracebacks, etc.). The "
"for _ in range (int(input())):
    a,b,c = map(int,input().split())
    if a+b >= 10 or b+c  >= 10 or c+a >= 10: print(""YES"")
    else: {{completion}}","print(""NO"")","print(""NO"")
<|/ file ext=.py |>"
"a = int(input())
for i in range(a):
    b = list(map(int,input().split()))
    b.sort()
    if b[2]+b[1]>=10:
        print('YES')
    else:
        {{completion}}",print('NO'),
"from sys import stdin, setrecursionlimit
#from math import ceil
#from collections import deque
#from heapq import *
#from functools import lru_cache
input = stdin.readline
#setrecursionlimit(1000000)

for _ in range(int(input())):
    n, k = map(int, input().split())
    s = input().strip()
    if k%2==0:
        print("""".join(sorted(s)))
    else:
        even = sorted(s[::2])
        odd = sorted(s[1::2])
        s = []
        for i in range(len(odd)):
            {{completion}}
        if len(even) > len(odd):
            s.append(even[-1])
        print("""".join(s))","s.append(even[i])
            s.append(odd[i])",s.append(odd[i])
"import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    n, k = readInts()
    s = readStr()
    ans = [-1] * n
    u, v = 0, 1
    idx = sorted([i for i in range(n)], key=lambda x: s[x])
    for i in idx:
        if u > v:
            u, v = v, u
        if i % 2 == u % 2 or k % 2 == 0:
            ans[u] = s[i]
            u += 2
        else:
            {{completion}}
    return """".join(ans)


for _ in range(int(input())):
    print(solve())
","ans[v] = s[i]
            v += 2","ans[v] = s[i // 2]
            v += 2"
"def main():
    t = int(input())
    r = [str(solution(i,t)) for i in range(t)]

    print('\n'.join(r))


def solution(ti,tn):
    n,k = map(int, input().split())
    ss = input().strip()

    if k % 2 == 1:
        es = []
        os = []

        for i in range(n):
            if i % 2 == 1:
                os.append(ss[i])
            else:
                {{completion}}

        es.sort()
        os.sort()

        rs = []

        for i in range(len(os)+2):
            if i < len(es): rs.append(es[i])
            if i < len(os): rs.append(os[i])

        return ''.join(rs)
    
    else:
        return ''.join(sorted(ss))

main()
",es.append(ss[i]),es.append(ss[i])
"# D. Prefix Purchase
import sys
input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n = int(input())
    c = list(map(int,input().split()))
    k = int(input())
    for i in range(n - 2, -1, -1):
        c[i] = min(c[i], c[i + 1])
    a = [0] * n
    a[0] = k // c[0]
    k %= c[0]
    for i in range(1, n):
        add = c[i] - c[i - 1]
        if add == 0:
            a[i] = a[i - 1]
        else:
            {{completion}}
    print(*a)","a[i] = min(a[i - 1], k // add)
            k -= add * a[i]","add = min(a[i - 1], add)
            a[i] = add
    if k > 0:
        a[n-1] = k
    else:
        a[n-1] = 0"
"import sys
from sys import stdin

tt = int(stdin.readline())

ANS = []

for loop in range(tt):

    n = int(stdin.readline())
    c = list(map(int,stdin.readline().split()))
    k = int(stdin.readline())

    for i in range(n-1,0,-1):
        if c[i-1] > c[i]:
            c[i-1] = c[i]

    ans = []

    for i in range(n):

        if i == 0:
            cost = c[i]
            ans.append( k // cost )
            k %= cost

        else:

            cost = c[i] - c[i-1]

            if cost != 0:
                max_buy = min(ans[-1],k // cost)
            else:
                {{completion}}

            ans.append(max_buy)
            k -= cost * max_buy

    ANS.append("" "".join(map(str,ans)))


print (*ANS,sep=""\n"")
",max_buy = ans[-1],"cost = ans[-1]
                max_buy = k"
"import sys

input = lambda: sys.stdin.readline().rstrip()


def solution(n, k, a):
    pref, res = [(a[-1], n - 1)], [k // min(a)]
    for i in range(1, n):
        pref.append(pref[-1])
        if a[-i - 1] < pref[-1][0]:
            pref[-1] = (a[-i - 1], n - i - 1)
    pref.reverse()
    t, r = divmod(k, pref[0][0])
    for i in range(1, n):
        if pref[i][0] == pref[i - 1][0]:
            res.append(res[-1])
        else:
            {{completion}}
    return "" "".join(map(str, res))


for _ in range(int(input())):
    n = int(input())
    a = [int(i) for i in input().split()]
    k = int(input())
    print(solution(n, k, a))","m = min(r // (pref[i][0] - pref[i - 1][0]), res[i - 1])
            res.append(m)
            r -= m * (pref[i][0] - pref[i - 1][0])","res[-1] = (res[-1][0], r + i)"
"import sys
input = sys.stdin.readline

# import time
# from collections import defaultdict
# t = int(time.time())
# m = defaultdict(int)
# m[key ^ t] += 1


def check_case():
    n = int(input().strip())
    s = input().strip()
    misses = 0
    for i in range(n // 2):
        if s[i] != s[n - 1 - i]:
            {{completion}}
    result = [""0""] * (n + 1)
    for i in range(misses, n + 1 - misses, 2 - n % 2):
        result[i] = ""1""
    print("""".join(result))



ncases = int(input())
for case in range(ncases):
    check_case()

",misses += 1,"misses += 1
    if misses == n:
        print(""1"")
        return
    l = [""0""] * (n + 1)
    for i in range(n // 2):
        l[i] = ""1""
    l[n // 2] = ""0""
    l = """".join(l)
    l = l[::-1]
    if s == l:
        print(""1"")
        return
    print(""0"")


def check_case2():
    n = int(input().strip())
    s = input().strip()
    misses = 0
    for i in range(n // 2):
        if s[i] != s[n - 1 - i]:
            misses += 1
    if misses == n:
        print(""1"")
        return
    l = [""0""] * (n + 1)
    for i in range(n // 2):
"
"from math import ceil
from sys import stdin, stdout
for t in range(int(stdin.buffer.readline().decode())):
    n = int(stdin.buffer.readline().decode())
    s = stdin.buffer.readline().decode()
    coin = 0
    diff = 0
    a = 0
    ans = ['1']*(n+1)
    for i in range(0, ceil(n//2)):
        if s[i] == s[n-1-i]:
            coin += 1
        else:
            diff += 1
    if n % 2:
        a = 1
    for j in range(0, n + 1):
        num = j - diff
        if num > 2 * coin + a or j < diff:
            ans[j] = '0'
        else:
            if num % 2 == a or num % 2 == 0:
                ans[j] = '1'
            else:
                {{completion}}
    stdout.write(''.join(map(str, ans)))
    stdout.write('\n')",ans[j] = '0',ans[j] = '0'
"from sys import stdin
input = stdin.readline

for _ in range(int(input())):
    n=int(input())
    s=input()
    one=s.count('1')
    c=0
    for i in range(n//2):
        if s[i]!=s[n-i-1]:
            {{completion}}
    ans=['0']*(n+1)
    for i in range(n+1):
        if i>=c and (n-i)>=c and(n%2 or (i-c)%2==0):
            ans[i]='1'
    print(''.join(ans))
        
    
    
            
   
   

    
        
        
  
    ",c+=1,"c += 1
    if c==one:
        print('0')
    else:
        print('1')
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        "
"import sys
input = sys.stdin.readline
for _ in range(int(input())):
  n,m = [int(x) for x in input().split()]
  a = [int(x) for x in input().split()]
  b = [int(x) for x in input().split()]

  full_b = 0
  for v in b: {{completion}}

  a0 = 0
  a1 = 0
  for v in a:
    a0 ^= v
    a1 ^= v | full_b
  print(min(a0, a1), max(a0, a1))",full_b |= v,full_b ^= v
"#!/usr/local/bin/python3

import sys
input = sys.stdin.readline

def ri(): return int(input())
def rl(v_type=int): return list(map(v_type, input().split()))
def rs(): return input().rstrip()
def out(x, sep=' '): return sep.join(map(str, x))


def solve_case():
    n, m = rl()
    A = rl()
    B = rl()
    all_or = 0
    for b in B:
        {{completion}}
    x = y = 0
    for a in A:
        x ^= a
        y ^= (a | all_or)
    return out([min(x, y), max(x, y)])


if __name__ == '__main__':
    T = int(input())
    ret = [solve_case() for ti in range(1, T + 1)]
    print(out(ret, '\n'))
",all_or |= b,"bit = 1 << b
        all_or |= bit
    all_or |= 1 << n
    all_or |= 1 << m
    "
"import sys, os
input = sys.stdin.buffer.readline
for _ in range(int(input())):
    lena, lenb = map(int, input().split())
    a = tuple(map(int, input().split()))
    b = tuple(map(int, input().split()))
    default = 0
    for i in a:
        default ^= i
    currentmin, currentmax = default, default
    if lena % 2:
        for i in range(lenb):
            local = default | b[i]
            currentmin = min(local, currentmin)
            currentmax |= b[i]
    else:
        for i in range(lenb):
            {{completion}}
    print(currentmin, currentmax)
","local = default & (~b[i])
            currentmin &= ~b[i]
            currentmax = max(local, currentmax)","local ^= b[i]
            currentmin = min(local, currentmin)
            currentmax ^= b[i]"
"import sys

input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n, m = map(int, input().split())

    adj = [[] for _ in range(n+1)]

    for i in range(m):
        a, b = map(int, input().split())
        adj[a].append(b)

    dp = [None, [1]]
    for i in range(2, n):
        dp.append([0]*i)
        dp[i][i-1] = 1 / i
        for j in range(i-1):
            if i-1-(j+1) >= 1:
                {{completion}}
            if j:
                dp[i][j] += dp[i-2][j-1] * (j / i)

    ans = [0] * (n+1)
    ans[n] = 1
    for i in range(n-1, 0, -1):
        c = sorted(ans[j] for j in adj[i])

        for j in range(len(c)):
            ans[i] += dp[len(c)][j] * c[j]

    print(ans[1])
",dp[i][j] += dp[i-2][j] * (i-1-(j+1)) / i,"dp[i][j] += dp[i-1-(j+1)][j+1] * (j / i)
            elif j+1 < i:
                dp[i][j] += dp[i-1-(j+1)][j+1] * (j / i)
            else:
                dp[i][j] += dp[i-1-(j+1)][j+1] * (j / i)"
"import sys

# sys.setrecursionlimit(10000)


def input_general():
    return sys.stdin.readline().rstrip('\r\n')


def input_num():
    return int(sys.stdin.readline().rstrip(""\r\n""))


def input_multi(x=int):
    return map(x, sys.stdin.readline().rstrip(""\r\n"").split())


def input_list(x=int):
    return list(input_multi(x))


coeff = [[], [1.], [0.5, 0.], [1/3, 1/3, 1/3]]


def main():
    n, m = input_multi()
    edge_dict = [[] for _ in range(n + 1)]

    for _ in range(m):
        u, v = input_multi()
        edge_dict[u].append(v)

    prob = [0.] * n + [1.]
    for u in range(n - 1, 0, -1):
        nbd = [prob[v] for v in edge_dict[u]]

        if not nbd:
            prob[u] = 0
            continue

        nbd.sort(reverse=True)
        d = len(nbd)

        if len(coeff) <= d:
            for nd in range(len(coeff), d + 1):
            # for nd in range(len(coeff), 20):
                if nd % 2 == 1:
                    coeff.append([1 / nd] * nd)

                else:
                    it = coeff[-2]
                    new = [1 / nd]
                    for i, (p1, p2) in enumerate(zip([0] + it, it + [0])):
                        {{completion}}

                    coeff.append(new)

        prob[u] = sum(p1 * p2 for p1, p2 in zip(nbd, coeff[d]))

    print(prob[1])

    # print(coeff)


if __name__ == ""__main__"":
    cases = input_num()

    for _ in range(cases):
        main()
",new.append((p1 * i + p2 * (nd - 2 - i)) / nd),new.append(p1 * p2)
"import sys
input=sys.stdin.readline
import math
t=int(input())
for _ in range(t):
    [n,m]=[int(x) for x in input().split()]
    neighbors=[[] for i in range(n+1)]
    for j in range(m):
        [a,b]=[int(x) for x in input().split()]
        neighbors[a].append(b)
    probabilities=[0 for i in range(n+1)]
    probabilities[n]=1

    coeffs=[[],[1],[.5,0]]
    for i in range(3,n):
        new_coeffs=[1/i]
        for j in range(1,i):
            new_coeffs.append((j-1)/i*coeffs[i-2][j-2]+(i-j-1)/i*coeffs[i-2][min(j-1,i-3)])
        coeffs.append(new_coeffs)
    for j in range(n-1,0,-1):
        vals=[probabilities[neighbors[j][i]] for i in range(len(neighbors[j]))]
        if len(vals)!=0:
            vals.sort()
            vals.reverse()
            val=0
            for i in range(len(vals)):
                {{completion}}
            probabilities[j]=val
    print(probabilities[1])",val+=vals[i]*coeffs[len(vals)][i],val+=vals[i]*coeffs[j][neighbors[j].index(neighbors[j][i])]
"n, m = [int(x) for x in input().split()]
dyn = [[0]*(m+1) for i in range(n+1)]

for k in range(2, n+1):
    for l in range(k, m+1-n+k):
        {{completion}}

print(n + 2*dyn[n][m])","amin = l//k
        amax = max(amin, min((m-k+1)//(n-k+1), l-k+1))
        dyn[k][l] = min([dyn[k-1][l-a]+(l-a)/a for a in range(amin, amax+1)])","rand = random.randint(0,l)
        dyn[k][l] = dyn[k][l-1] + rand
        dyn[k][m] = dyn[k][m-1] - rand
        dyn[k][l] = dyn[k][l-1] + rand
        dyn[k][m] = dyn[k][m-1] - rand"
"n, m = [int(x) for x in input().split()]
dp = [[0]*(m+1) for i in range(n+1)]
 
for k in range(2, n+1):
    for l in range(k, m+1-n+k):
        {{completion}}
 
print(n + 2*dp[n][m])","mini = l//k
        maxi = max(mini, min((m-k+1)//(n-k+1), l-k+1))
        dp[k][l] = min([dp[k-1][l-a]+(l-a)/a for a in range(mini, maxi+1)])","l = l - k
        dp[k][l] = dp[k-1][l] + dp[k][l-1]
 
for k in range(n+1):
    for l in range(m+1):
        if dp[k][l] == dp[k][m]:
            print(k+1, l+1)"
"n, m = [int(x) for x in input().split()]
dyn = [[0]*(m+1) for i in range(n+1)]

for k in range(2, n+1):
    for l in range(k, m+1-n+k):
        {{completion}}

print(n + 2*dyn[n][m])
","amin = l//k
        amax = max(amin, min((m-k+1)//(n-k+1), l-k+1))
        dyn[k][l] = min([dyn[k-1][l-a]+(l-a)/a for a in range(amin, amax+1)])","rand = random.randint(0,l)
        dyn[k][l] = rand"
"
import sys
print2 = print
input = sys.stdin.readline
print = sys.stdout.write



t = int(input())


for _ in range(t):
    n, k = map(int, input().split())

    a = list(map(int, input().split()))
    seen = set(a)

    l = 0
    r = n - 1
    for i in range(1, k+1):
        if i not in seen:
            {{completion}}
        while a[l] < i:
            l+=1

        while a[r] < i:
            r-=1

        w = r - l + 1
        print(f""{w+w} "")
    print(""\n"")

","print(""0 "")
            continue","seen.add(i)
            continue"
"import sys
input=sys.stdin.buffer.readline
def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input()
def rm():
    return map(int,input().split())
 
def main():
    n,k=rm()
    a=rl()
    for i in range(n): a[i]-=1
    lf=[-1]*k
    rt=[-1]*k
    for i in range(n):
        if lf[a[i]]==-1: {{completion}}
    for i in range(n-1,-1,-1):
        if rt[a[i]]==-1: rt[a[i]]=i
    ans=[0]*k
    cl=n+1;cr=-1
    for i in range(k-1,-1,-1):
        if lf[i]==-1: continue
        cl=min(cl,lf[i])
        cr=max(cr,rt[i])
        ans[i]=2*(cr-cl+1)
    return ans
 
t=ri()
for i in range(t):
    print(*main())",lf[a[i]]=i,"lf[a[i]]=i
    for i in range(n):
        if rt[a[i]]==-1: rt[a[i]]=i
    ans=[0]*k
    cl=n+1;cr=-1
    for i in range(k-1,-1,-1):
        if lf[i]==-1: continue
        cl=min(cl,lf[i])
        cr=max(cr,rt[i])
        ans[i]=2*(cr-cl+1)
    return ans
 
t=ri()
for i in range(t):
    print(*main())
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 "
"ans = []
for _ in range(int(input())):
    n, k = list(map(int, input().split()))
    a = list(map(int, input().split()))

    left, right = 1, n
    ns = []
    ns_clear = [0 for _ in range(k)]
    for i in range(1, k+1):
        while a[left-1] < i and left < right:
            {{completion}} 
        while a[right-1] < i and right > left:
            right -= 1 
        ns.append(2*(right-left+1))

    for elem in a:
        ns_clear[elem-1] = ns[elem-1]

    ans.append(ns_clear)

for ns in ans:
    print(' '.join(map(str, ns)))",left += 1,"left += 1
        ns.append(2*(left-right+1))

    for elem in a:
        ns_clear[elem-1] = ns[elem-1]

    ans.append(ns_clear)

for ns in ans:
    print(' '.join(map(str, ns)))
<|/ a dscore=0 |>
<| c |>
Thanks for your answer! I tried to run your code but got this error message: ```Traceback (most recent call last):
  File ""/Users/yonghong/PycharmProjects/untitled1/main.py"", line 13, in <module>
    left, right = 1, n
NameError: name 'n' is not defined```
<|/ c |>
<| c "
"I=input
for _ in[0]*int(I()):
 i=0
 for s in zip(*(I()for _ in[0]*int(I().split()[0]))):{{completion}}
 print('YNEOS'[i<4::2])",i+=i<4and'vika'[i]in s,"
  print('YES'[i<4::2])
  i+=1
 i=0"
"for _ in range(int(input())):
    n, lenght = map(int, input().split())
    arr = []
    word = ""vika""
    bi = 0
    for i in range(n):
        arr.append(list(input()))
    
    for j in range(lenght):
        for i in range(n):
            if arr[i][j] == word[bi]:
                {{completion}}
        if bi == 4:
            print(""YES"")
            break
    else:
        print(""NO"")","bi += 1
                break","bi = bi + 1
                break
        if bi == 4:
            print(""YES"")
            break
    else:
        print(""NO"")
<|/ q tags=python-3.x,python |>
<| c |>
Please don't post images of code. Post the code as text in the question.
<|/ c |>
<| c |>
Please read [ask] and [mcve]. Your code is not minimal, complete or verifiable. For example, what does `arr` contain? What does `word` contain? What does `bi` contain? What does `i` contain? What does `j` contain? What does `i` do? "
"def solve(n, m,x):
    a=""vika""
    k=0
    for j in range(m):
        for i in range(n):
            if x[i][j]==a[k]:
                k+=1
                if k==4:
                    {{completion}}
                break
    return ""NO""

t = int(input())
for i in range(t):
    n, m = [int(_) for _ in input().split()]
    x=[]
    l=[]
    for j in range(n):
        a=input()
        x.append(a)
    print(solve(n, m,x))

","return (""YES"")",k=0
"from sys import *
from collections import deque 
input = stdin.readline
inputlist = lambda: map(int, stdin.readline().split())
MOD = 998244353

def solve():
    n = int(input())
    array = list(inputlist())

    valuedict = {}
    for value in array:
        if value in valuedict: valuedict[value] += 1
        else: valuedict[value] = 1
    
    for count in valuedict.values():
        if count % 2: return pow(2, len(valuedict)-1, MOD)

    visited = {array[0]}
    currentset = set([array[0]])
    current = deque([array[0]])
    arrays = []
    temparray = [array[0]]
    for value in array[1:]:
        if len(current) == 0:
            arrays.append(temparray)
            temparray = []
        if value in visited:
            if value in currentset:
                if value != current[0]:
                    return pow(2, len(valuedict)-1, MOD)
                else:
                    current.popleft()
                    currentset.discard(value)
            else:
                current.append(value)
                currentset.add(value)
                temparray.append(value)
        else:
            current.append(value)
            currentset.add(value)
            visited.add(value)
            temparray.append(value)
    if len(current) == 0: arrays.append(temparray)

    visited = [0] * 200001
    numtoindex = [[] for _ in range(200001)]
    for index, array in enumerate(arrays):
        for value in array:
            numtoindex[value].append(index)
            visited[value] = 1 
    count = 0
    current = set()
    for i in range(1, 200001):
        if visited[i]:
            count += 1
            current = set([i])
            while current:
                newcurrent = set()
                for i in current:
                    visited[i] = 0
                newnums = set()
                for i in current:
                    for indices in numtoindex[i]:
                        newnums.add(indices)
                for indices in newnums:
                    for num in arrays[indices]:
                        if visited[num]: {{completion}}
                current = newcurrent

    return (pow(2, len(valuedict)-1, MOD) - pow(2, count-1, MOD)) % MOD

print(solve())",newcurrent.add(num),"continue
                        if num in newcurrent: continue
                        newcurrent.add(num)"
"
import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

M = 2 * 10**5 + 100

mod = 998244353

def brute(N,A):
    first = [-1] * M
    last = [-1] * M

    k = 0
    val = []
    for i,a in enumerate(A):
        if first[a] == -1:
            k += 1
            first[a] = i
            val.append(a)
        last[a] = i
    
    ans = 0
    for S in range(1<<k):
        next_color = [""""] * M
        for i in range(k):
            if S>>i & 1:
                next_color[val[i]] = ""r""
            else:
                next_color[val[i]] = ""b""
        
        tmp_r = []
        tmp_b = []
        for a in A:
            if next_color[a] == ""r"":
                tmp_r.append(a)
                next_color[a] = ""b""
            else:
                tmp_b.append(a)
                next_color[a] = ""r""
        
        if tmp_r < tmp_b:
            ans += 1
    
    return ans





def solve(N,A):

    A = [a-1 for a in A]

    first = [-1] * M
    last = [-1] * M
    k = 0
    for i,a in enumerate(A):
        if first[a] == -1:
            k += 1
            first[a] = i
        last[a] = i

    same = 1
    tmp_red = []
    tmp_blue = []
    next_color = ["""" for i in range(M)]
    tmp_last = -1

    group = [[x] for x in range(M)]
    x_to_g = [x for x in range(M)]
    maxi_last = [last[x] for x in range(M)]

    for i in range(N):
        a = A[i]
        if next_color[a] == """":
            tmp_red.append(a)
            next_color[a] = ""b""
        elif next_color[a] == ""r"":
            tmp_red.append(a)
            next_color[a] = ""b""
        else:
            if tmp_red[len(tmp_blue)]!=a:
                same = 0
                break
            tmp_blue.append(a)
            next_color[a] = ""r""
        
        if len(tmp_red) == len(tmp_blue):
            root = x_to_g[tmp_red[0]]
            for x in tmp_red[1:]:
                rx = x_to_g[x]
                
                if rx == root:
                    continue

                if len(group[root]) < len(group[rx]):
                    for val in group[root]:
                        group[rx].append(val)
                        maxi_last[rx] = max(maxi_last[rx],last[val])
                        x_to_g[val] = rx
                    group[root] = []
                    root = rx
                else:
                    for val in group[rx]:
                        {{completion}}
                    group[rx] = []
            
            check = 0
            for x in tmp_red:
                if i < maxi_last[x_to_g[x]]:
                    check = 1
                next_color[x] = """"
            if check == 0:
                same = 2 * same
                same %= mod
                    
            
            
            
            tmp_red,tmp_blue = [],[]
        
        #print(same,tmp_red,tmp_blue)

    if tmp_red!=tmp_blue:
        same = 0

    res = pow(2,k,mod) - same
    res *= pow(2,mod-2,mod)
    res %= mod

    return res


while False:
    N = 12
    A = []
    for i in range(N//2):
        a = random.randint(1,N//2)
        A.append(a)
        A.append(a)
    random.shuffle(A)

    if solve(N,A) != brute(N,A):
        print(N)
        print(A)
        print(solve(N,A),brute(N,A))
        exit()
    assert solve(N,A) == brute(N,A)
    print(""AC"",solve(N,A))

N = int(input())
A = li()
print(solve(N,A))","group[root].append(val)
                        maxi_last[root] = max(maxi_last[root],last[val])
                        x_to_g[val] = root","group[root].append(val)
                        maxi_last[root] = max(maxi_last[root],last[val])
                        x_to_g[val] = root
                    group[rx] = []
                    root = root
            
            tmp_red,tmp_blue = [],[]
            
        else:
            tmp_last = -1
            tmp_red,tmp_blue = [],[]
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
"
"#n=int(input())
#n,m=map(int,input().split())
#l=list(map(int,input().split()))
import sys
input = sys.stdin.buffer.readline

t=int(input())
for __ in range(t):
    n, k, a, b = map(int, input().split())
    cities=[]
    a-=1
    b-=1
    for i in range(n):
        {{completion}}
    mindista=4*(10**9)
    mindistb=4*(10**9)
    ax=cities[a][0]
    ay=cities[a][1]
    bx=cities[b][0]
    by=cities[b][1]
    for i in range(k):
        cx=cities[i][0]
        cy=cities[i][1]
        mindista = min(mindista,abs(ax-cx)+abs(ay-cy))
        mindistb = min(mindistb, abs(bx - cx) + abs(by - cy))
    ans=min(mindistb+mindista,abs(ax-bx)+abs(ay-by))
    print(ans)","x,y=map(int, input().split())
        cities.append((x,y))","cities.append(map(int,input().split()))
    cities=sorted(cities,key=lambda x:(x[0],x[1]))
    cities=cities[::-1]
    cities=cities[:k]
    cities=cities[::-1]
    cities=cities[:k]
    cities=cities[::-1]
    cities=cities[:k]
    cities=cities[::-1]
    cities=cities[::-1]
    cities=cities[::-1]
    cities=cities[::-1]
    cities=cities[::-1]
    citie"
"from sys import stdin
def input(): return stdin.readline()[:-1]
for _ in range(int(input())):
	n,k,a,b=map(int,input().split())
	lt=[]
	for i in range(n):
		{{completion}}
	l=min(lt[a-1],lt[b-1])
	r=max(lt[a-1],lt[b-1])
	ans=abs(l[0]-r[0])+abs(l[1]-r[1])
	ans1=float(""inf"")
	for i in range(k):
		ans1=min(ans1,abs(l[0]-lt[i][0])+abs(l[1]-lt[i][1]))
	ans2=float(""inf"")
	for i in range(k):
		ans2=min(ans2,abs(r[0]-lt[i][0])+abs(r[1]-lt[i][1]))
	print(min(ans1+ans2,ans))","x,y=map(int,input().split())
		lt.append([x,y])","lt.append([input(),input()])
	lt.sort()
	lt=lt[::-1]"
"import sys
def st(): return str(input())
def inp(): return int(sys.stdin.readline())
def strip(): return list(sys.stdin.readline().strip())
def li(): return list(map(int, sys.stdin.readline().split()))
	
for pratyush in range(inp()):
    n,k,a,b=li()
    l,la,lb=[],[],[]
    for j in range(n):
        l.append(li())
    ax=l[a-1][0]
    ay=l[a-1][1]
    bx=l[b-1][0]
    by=l[b-1][1]
    for j in range(k):
        la.append(abs(l[j][0]-ax)+abs(l[j][1]-ay))
        lb.append(abs(l[j][0]-bx)+abs(l[j][1]-by))
    if k==0: print(abs(ax-bx)+abs(ay-by))
    else: {{completion}}","print(min(min(la)+min(lb), abs(ax-bx)+abs(ay-by)))","print(min(la)+min(lb))
<|/ file dstars=0 source=github filename=Piggy_Travel.py "
"for s in[*open(0)][2::2]:
 n=len(a:=s.split());r=[0]*n
 for _,i in sorted(zip(map(int,a),range(n))):{{completion}}
 print(*r)
",r[i]=n;n-=1,"
  r[i]=i"
"def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = sorted(zip(map(int, input().split()), range(n)))
        b = [0] * n
        for i in range(n):
            {{completion}}
        print(' '.join(map(str, b)))

if __name__ == '__main__':
    main()
",b[a[i][1]] = n - i,"j = i
            while j > 0 and a[j-1][0] == a[j][0]:
                b[i] = b[i] + 1
                j -= 1
            b[i] = b[i] + 1
        for i in range(n):
            b[i] = b[i] // 2
        print(' '.join(map(str, b)))

if __name__ == '__main__':
    main()
""""""
<|/ file source=github |>"
"t = int(input())

while t:
    n = int(input())
    a = []
    for i, item in enumerate(input().split()):
        {{completion}}
    a.sort()
    b = [0] * n
    for i in range(n):
        b[ a[i][1] ] = n
        n -= 1
    print("" "".join(map(str, b)))

    t -= 1
","a.append((int(item), i))","a.append([item, i])
    a.sort()
    b = [0] * n
    for i in range(n):
        b[ a[i][1] ] = n
        n -= 1
    print("" "".join(map(str, b)))

    t -= 1
<|/ q tags=python,algorithm |>
<| c |>
What have you tried so far? Please post your code.
<|/ c |>
<| c |>
Please post the code you've written so far.
<|/ c |>
<| c |>
I added the code I wrote
<|/ c |>
<| c |>
I added the code I wrote
<|/ c |>
<|"
"import sys
input=sys.stdin.readline
#sys.stdin=open('input.txt','r')
for _ in range(int(input())):
    n=int(input())
    ar=list(map(int,input().split()))
    st=input()
    arxor=[0]
    zz=0
    oo=0
    for i in range(n):
        arxor.append(arxor[-1]^ar[i])
        if(st[i]=='1'):
            oo^=ar[i]
        else:
            zz^=ar[i]
    
    ans=[]
    q=int(input())
    for i in range(q):
        li=list(map(int,input().split()))
        if(li[0]==1):
            l=li[1]
            r=li[2]
            temp=arxor[r]^arxor[l-1]
            zz^=temp
            oo^=temp
        else:
            if(li[1]==1):
                ans.append(oo)
            else:
                {{completion}}
    print(*ans)
    ",ans.append(zz),ans.append(zz)
"import sys
import math
 
def main():
    input = sys.stdin.readline
    cases = int(input().strip())
 
    output_list = []
 
    for _ in range(cases):
        length = int(input().strip())
        nums = [int(num) for num in input().split()]
        binnums = [int(i) for i in input().strip()]
        query_results = []
 
        xor0, xor1 = 0, 0
        pref = [0]
        for i, num in enumerate(nums):
            if binnums[i] == 0:
                xor0 ^= num
            else:
                {{completion}}
            pref.append(pref[-1]^num)
 
        for _ in range(int(input().strip())):
            query = [int(x) for x in input().split()]
            if query[0] == 1:
                l = query[1] - 1
                r = query[2]
                xor0 ^= pref[l]^pref[r]
                xor1 ^= pref[l]^pref[r]
            else:
                query_results.append(str(xor1 if query[1] == 1 else xor0))
        
        output_list.append(' '.join(query_results))
 
    print(""\n"".join(output_list))
 
if __name__ == ""__main__"":
    main()
",xor1 ^= num,"pref.append(num^pref[-1])
 
        for i, num in enumerate(nums):
            if binnums[i] == 1:
                xor1 ^= num
            else:"
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    A = list(map(int, input().split()))
    s = [int(x) for x in input().rstrip()]

    P = [0] * (n + 1)
    Q = [0] * (n + 1)
    for i, (a, b) in enumerate(zip(A, s)):
        P[i + 1] = P[i] ^ a
        Q[i + 1] = Q[i] ^ (a * b)

    curr = 0
    q = int(input())
    res = []
    for _ in range(q):
        op, *query = map(int, input().split())
        if op == 1:
            l, r = query
            l -= 1
            r -= 1
            curr ^= P[r + 1] ^ P[l]
        
        else:
            g = query[0]
            ans = Q[-1] ^ curr
            if g == 0:
                {{completion}}
            res.append(ans)

    return "" "".join(map(str, res))


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))",ans ^= P[-1],"ans ^= 0
            else:
                ans ^= P[g] ^ curr"
"import sys, os
input = sys.stdin.buffer.readline
def dfs(edges, visited, queue):
    while queue:
        parent, lastindex = queue.pop()
        visited.add(lastindex)
        for city in edges[lastindex]:
            if city not in visited:
                queue += [(lastindex, city)]
            elif city != parent and parent != None:
                return city
def bfs(edges, start, end):
    if start == end: return 0
    visited = {start}
    queue = [(start,0)]
    while queue:
        new = queue.pop()
        for city in edges[new[0]]:
            if city not in visited:
                if city == end: {{completion}}
                visited.add(city)
                queue = [(city, new[1] + 1)] + queue
for _ in range(int(input())):
    numbuildings, marcel, val = map(int, input().split())
    edges = [[] for _ in range(numbuildings+1)]
    for _ in range(numbuildings):
        left, right = map(int, input().split())
        edges[left] += [right]
        edges[right] += [left]
    visited = set()
    queue = [(None, val)]
    entry = dfs(edges, visited, queue)
    valdistance = bfs(edges, val, entry)
    marceldistance = bfs(edges, marcel, entry)
    if valdistance < marceldistance: sys.stdout.write(""YES"" + ""\n"")
    else: sys.stdout.write(""NO"" + ""\n"")",return new[1] + 1,"break
                visited.add(city)
                queue.append((city, new[1]+1))
    return -1
for _ in range(int(input())):
    numbuildings, marcel, val = map(int, input().split())
    edges = [[] for _ in range(numbuildings+1)]
    for _ in range(numbuildings):
        left, right = map(int, input().split())
        edges[left] += [right]
        edges[right] += [left]
    visited = set()
    queue = [(None, val)]
    entry = dfs(edges, visited, queue)
    valdistance = bfs(edges, val, entry)
    marceldistance = bfs(edges, marcel, "
"import collections
from sys import *
input = stdin.readline

# !!! Check if input have a t !!!

# T = 0
T = 1

def solve():
	n, a, b = ria()
	a -= 1
	b -= 1
	nei = collections.defaultdict(list)
	for _ in range(n):
		x, y = ria()
		x -= 1
		y -= 1
		nei[x].append(y)
		nei[y].append(x)
	
	loop = -1
	vis = [0] * n
	s = [[b, -1]]
	while s:
		x, pre = s.pop()
		vis[x] = 1
		for y in nei[x]:
			if y == pre:
				continue
			if vis[y]:
				loop = y
				s = []
				break
			s.append([y, x])
	if loop == -1:
		print(""NO"")
		return

	def dis(s, e):
		if s == e:
			return 0
		q = collections.deque()
		q.append([s, -1, 0])
		vis = [0] * n
		while q:
			x, pre, dis = q.popleft()
			vis[x] = 1
			if x == e:
				return dis
			for y in nei[x]:
				if y == pre:
					{{completion}}
				if vis[y]:
					continue
				q.append([y, x, dis+1])
		return -1
	da = dis(a, loop)
	db = dis(b, loop)
	print(""YES"" if db < da else ""NO"")
	return


def ria():
	return list(map(int, input().strip().split()))
def rsa():
	return input().strip().split()
def ri():
	return int(input().strip())
def rs():
	return input().strip()

def tcase():
	for _ in range(ri()):
		solve()

def main():
	tcase() if T else solve()

if __name__ == ""__main__"":
    main()
",continue,continue
"from collections import defaultdict, deque, Counter
import heapq
import random

from math import inf, sqrt

from sys import stdin, stdout


# input
input = stdin.readline
_ri = lambda: int(input())
_rmi = lambda: map(int, input().split())
_rli = lambda: list(map(int, input().split()))
_rs = lambda: input()[:-1]
_rcs = lambda: list(input()[:-1])
_rls = lambda: list(input()[:-1].split())


def solve(n, a, b, g):
    if a == b:
        return ""NO""
    vis = n*[False]
    dsts = n * [inf]
    stack = [(b, -1, 0)]
    while stack:
        node, p, dst = stack.pop()
        if vis[node]:
            target = node
            break
        dsts[node] = dst
        vis[node] = True
        for adj in g[node]:
            if adj == p:
                continue
            stack.append((adj,node,dst+1))
    vis = n*[False]
    dst = 0
    q = [a]
    while q:
        nxt_q = []
        for node in q:
            if node == target:
                return ""NO""
            for adj in g[node]:
                if vis[adj]:
                    {{completion}}
                vis[adj] = True
                nxt_q.append(adj)
        dst += 1
        if dst > dsts[target]:
            return ""YES""
        q = nxt_q
    return -1

t = int(input())
for _ in range(t):
    n, a, b = _rmi()
    a -= 1
    b -= 1
    g = [[] for _ in range(n)]
    for _ in range(n):
        u, v = _rmi()
        g[u-1].append(v-1)
        g[v-1].append(u-1)
    print(solve(n, a, b, g))
",continue,"nxt_q.append(adj)
                    vis[adj] = False
                    break
            else:"
"from collections import Counter

t = int(input())
ans = []
for i in range(t):
    n = int(input())
    info = list(map(int,input().split()))
    a = Counter(info)
    if a[0] == 0:
        ans.append(0)
    else:
        now_min = a[0]
        is_min = [0]
        l = 0
        while True:
            l += 1
            if a[l]<now_min:
                {{completion}}
            if not a[l]:
                break

        dp = [0]
        for k in range(1,len(is_min)):
            dp.append(min([is_min[k] * a[is_min[j]] + dp[j] for j in range(k)]))
        ans.append(dp[-1] - l)

for w in ans:
    print(w)
","is_min.append(l)
                now_min = a[l]","now_min = a[l]
                is_min = [l]
            elif a[l]==now_min:
                is_min.append(l)"
"# -*- coding: utf-8 -*-
""""""
Created on Fri Dec  8 21:06:44 2023

@author: Lenovo
""""""

for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    check,flag=[0]*(n+1),[True]*(n+1)
    for i in l:
        if i<=n:
            check[i]+=1
    if not check[0]:
        print(0)
        continue
    minn=float(""inf"")
    for i in range(n+1):
        if not check[i]:
            break
        elif check[i]<minn:
            minn=check[i]
        else:
            flag[i]=False
    dp=[float(""inf"")]*i+[0]
    for j in range(i,-1,-1):
        if not flag[j]:
            continue
        for k in range(j,i+1):
            if not flag[k]:
                {{completion}}
            dp[j]=min(dp[j],dp[k]+k*(check[j]-1)+j)
    print(dp[0])",continue,"dp[j]=min(dp[j],dp[k]+k*(check[j]-1)+j)
    print(dp[0])
<|/ a |>"
"# LUOGU_RID: 138678462
from functools import lru_cache
for _ in range(int(input())):
    @lru_cache
    def r(m):
        if m==0:return 0
        x=1<<30
        for i in d:
            if i[1]>=m:{{completion}}
            x=min(x,m*i[0]-m+i[1]+r(i[1]))
        return x
    input();a=list(map(int,input().split()));b={i:0 for i in set(a)};c={}
    for i in a:b[i]+=1
    for i in range(6000):
        if i not in b:break
        if b[i]not in c:c[b[i]]=i
    d=sorted(c.items(),key=lambda x:x[1]);print(r(i))",break,break
"n = int(input())
a = [0]+[*map(int,input().split())]
mod = 998244353
for i in range(1,n+1):
    for j in range(i,n+1,i):
        {{completion}}
ans = 0
cnt = 1
for x in sorted(a[1:]):
    ans = (ans+x*cnt) % mod
    cnt = (cnt*2) % mod
print(ans)","a[i] = max(a[i],a[j])",a.append(a[j]+a[i-1])
"mod=998244353
n=int(input())
L=list(map(int,input().split("" "")))
count=[0]*(n+1)
for j in range (1,n+1):
    for k in range (j-1,n,j):
        {{completion}}
count.sort()
idx=1
ans=0
for j in range (1,len(count)):
    ans=(ans+(count[j]*idx)%mod)%mod
    idx=(idx*2)%mod
print(ans)


    
        
    
    ","count[j]=max(count[j],L[k])",count=count+[(L[j-1]+L[k])%mod]
"n = int(input())
a = [0]+list(map(int, input().split()))
mod = 998244353
b = [0]*(n+1)
for i in range(1,1+n):
    {{completion}}

b = sorted(b[1:])
ans = 0
dt = [1]
for i in range(n-1):
    dt.append(dt[-1]*2%mod)

for i in range(n):
    ans += (b[-1-i]*dt[-1-i])%mod
    ans %= mod
print(ans)
",b[i] = max(a[i::i]),"b.append(b[i-1])
    b[i] = b[i]*2%mod"
"import sys

input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    q = int(input())

    qu = [[] for _ in range(n)]
    for i in range(q):
        l, k = map(int, input().split())
        l -= 1
        qu[l].append((i, k))

    ans = [-1] * q

    segs = []
    for l in range(n-1, -1, -1):
        nsegs = [(l, a[l])]
        for l2, x in segs:
            if x&a[l] != nsegs[-1][1]:
                nsegs.append((l2, x&a[l]))
        segs = nsegs

        for i, k in qu[l]:
            j = -1
            while j+1 < len(segs) and segs[j+1][1] >= k:
                j += 1
            if j == -1:
                continue
            if j == len(segs)-1:
                ans[i] = n
            else:
                {{completion}}

    print(*ans)
",ans[i] = segs[j+1][0],ans[i] = segs[j+1][0]
"import sys
input = sys.stdin.readline
def fg():
    return int(input())
def fgh():
    return [int(xx) for xx in input().split()]
def tt():
    sys.stdout.flush()
def sd():
    print('YES')
def df():
    print('NO')
step = [1]
for i in range(63):
    step.append(step[-1] * 2)
for _____ in range(fg()):
    n = fg()
    a = fgh()
    q = fg()
    
    B = [[0] * n for i in range(19)]
    for i in range(n):
        B[0][i] = a[i]
    for i in range(1, 19):
        for j in range(n - step[i] + 1):
            B[i][j] = B[i - 1][j] & B[i - 1][j + step[i - 1]]
    for __ in range(q):
        l, k = fgh()
        ans = 0
        V = step[31] - 1
        for j in range(18, -1, -1):
            if l + ans + step[j] <= n + 1 and V & B[j][l - 1 + ans] >= k:
                {{completion}}
        if ans:
            print(l + ans - 1, end = ' ')
        else:
            print(-1, end = ' ')
    print()
","V &= B[j][l - 1 + ans]
                ans += step[j]","ans = j
                break"
"#!/usr/bin/python3

import bisect
import collections
import heapq
import io
import math
import os
import random
import re
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
# Mod = 1000000007
Mod = 998244353

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def euk(x, y):
    if y:
        p, q, g = euk(y, x % y)
        return (q, p - (x // y) * q, g)
    return (1, 0, x)

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

T = 1
T = int(_input())
for _ in range(T):
  n = int(_input())
  a = [list(map(int, _input().split()))]
  while (1 << (len(a) - 1)) < n:
    a.append([0] * n)
    j = len(a) - 2
    for i in range(n):
      x = i + (1 << j)
      a[-1][i] = (a[-2][i] & a[-2][x]) if x < n else a[-2][i]
  # print(*a, sep='\n')
  sol = []
  for _ in range(int(_input())):
    l, k = map(int, _input().split())
    l -= 1
    w = len(a)
    mask = (1 << 31) - 1
    t = mask
    while l < n and w > 0:
      if (t & a[w - 1][l]) >= k:
        {{completion}}
      w -= 1
    sol.append(min(l, n) if t < mask else -1)
  print(*sol)
","t &= a[w - 1][l]
        l += 1 << (w - 1)","t -= a[w - 1][l]
        l += 1
      w -= 1
    sol.append(min(l, n) if t < mask else -1)
  print(*sol)
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  "
"import sys
input = sys.stdin.readline

def solve():
    n, k = map(int, input().split())
    arr = [*map(int, input().split())]
    h = [*map(int, input().split())]
    res = 0
    s = 0
    l = 0
    for r in range(n):
        if h[r-1] % h[r]:
            {{completion}}
        s += arr[r]
        while s > k and l <= r:
            s -= arr[l]
            l += 1
        res = max(r-l+1, res)

    print(res)

for _ in range(int(input())):
    solve()","l = r
            s = 0","s += arr[r]
            while s > k and l <= r:
                s -= arr[l]
                l += 1
            res = max(r-l+1, res)
        else:
            s = 0
            l += 1
            
    print(res)

for _ in range(int(input())):
    solve()
<|/ a dscore=0 |>"
"import sys

def read(T=int):
	return [T(i) for i in sys.stdin.readline().split()]

def solve():
	[n,k],a,b=[read() for i in range(3)]
	j,c,ans=0,0,0
	for i in range(n):
		while c<k and j<n:
			if (j>i and b[j-1]%b[j]) or (c+a[j]>k):
				{{completion}}
			c+=a[j]
			j+=1

		ans=max(ans,j-i)
		c-=a[i]

	print(ans)

def main():
	for i in range(read(int)[0]):
		solve()

main()",break,"break
			j+=1
		if j>=n:
			break
		if c+a[j]>k:
			break
		if j>i:"
"rvar = lambda: map(int, input().split())
rarr = lambda: list(map(int, input().split()))
rstr = lambda: input().strip().decode()
rint = lambda: int(input())
 
'''Speed up input'''
import sys
input = sys.stdin.readline
 
for _ in range(rint()):
    n, k = rvar()
    a = rarr()
    h = rarr()
    cur = 0
    start = 0
    res = 0
    flag = False
    for end in range(n):
        cur += a[end]
        if end > 0 and h[end - 1] % h[end] != 0:
            {{completion}}
 
 
 
        while cur > k:
            cur -= a[start]
            start += 1
        res = max(res, end - start + 1)
 
    print(res)","start = end
            cur = a[end]","flag = True
            break"
for s in[*open(0)][1:]:{{completion}},"n,k,x=map(int,s.split());print((-1,(k*k-k)//2+(x-(x==k))*(n-k))[x+2>k<=n])","
    s=s.split()
    a,b,c=int(s[0]),int(s[1]),int(s[2])
    
    if a<b and a<c and b<c:
        print(a+b+c)
    else:
        print(-1)
<|/ file ext=.py source=github |>"
"for _ in range(int(input())):
    n, k, x = map(int, input().split())
    if k > n or k > x + 1:
        print(-1)
    else:
        {{completion}}
",print(k*(k-1)//2+(n-k)*(x-1 if k == x else x)),"arr = [int(i) for i in input().split()]
        mex = -1
        for i in range(n):
            if arr[i] > mex:
                mex = arr[i]
        print(mex)
    
<|/ file dstars=0 ext=.py |>"
"for s in[*open(0)][1:]:
    {{completion}}","n,k,x=map(int,s.split());
    print((-1,(k*k-k)//2+(x-(x==k))*(n-k))[x+2>k<=n])","s=s.split()
    a,b,c=int(s[0]),int(s[1]),int(s[2])
    if a<b and b<c:
        a,b,c=b,c,a
    if a<c:
        a,c=c,a
    if b<c:
        b,c=c,b
    if a==b==c:
        a,b,c=c,a,b
    if a==b or b==c:
        a,b,c=c,b,a
    if a==b or b==c:
        a,b,c=c,a,b
    if a==b or b==c:
        a,b,c=c,b,a
    if a==b or "
"import math

ans = []
for _ in range(int(input())):
    {{completion}}

print('\n'.join(map(str, ans)))","n, x, y = list(map(int, input().split()))
    s = 0
    lcm = x * y // math.gcd(x, y)
    n_pos, n_neg = n // x, n // y
    n_intersect = n // lcm
    n_pos -= n_intersect
    n_neg -= n_intersect
    s += n_pos*(2*n - n_pos + 1) // 2
    s -= n_neg*(1 + n_neg) // 2
    ans.append(s)","n, x, y = map(int, input().split())
    score = (n * (n + 1)) // 2 - math.fsum(map(int, list(str(n))))
    ans.append(score)"
"import sys
input = sys.stdin.readline
 
from math import gcd, isqrt
# from collections import deque
# import bisect #-->For bisect.bisect_left=lower_bound and bisect_right=upper_bound
 
t = 1
t = int(input())
for _ in range(t):
    {{completion}}","n, x, y = map(int, input().split())
    z = n // (x * y // gcd(x,y))
    a = n // x - z
    b = n // y - z
    ans = (n * (n+1) // 2) - ((n-a) * (n-a+1) // 2) - (b * (b+1) // 2)
    print(ans)","n, x, y = map(int, input().split())
    
    score = 0
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import sys
import math
sys.setrecursionlimit(100000)  # CF function call stack depth: ~2900


def my_input():
    {{completion}}


def solve():
    n, x, y = map(int, my_input().split())
    cx = n // x
    cy = n // y
    c = n // (x * y // math.gcd(x, y))
    cx -= c
    cy -= c
    return cx * (n - cx) + cx * (cx + 1) // 2 - cy * (cy + 1) // 2


def main():
    print('\n'.join([str(solve()) for _ in range(int(my_input()))]))


main()
",return sys.stdin.readline().strip(),"my_str = input()
    return my_str.split()"
"import sys
input = sys.stdin.readline

def solve():
    n, m = map(int, input().split())
    res = 0    
    for _ in range(30):
        {{completion}}
    if n != 0:
        print(-1)
        return
    print(res)

for _ in range(int(input())):
    solve()","n %= m
        res += n
        n *= 2","pieces = input()
        pieces = pieces.split()
        pieces = list(map(int, pieces))
        pieces.sort()
        pieces = list(map(int, pieces))
        pieces = [0] + pieces + [pieces[-1]]
        pieces = list(map(int, pieces))
        pieces = [0] + pieces + [pieces[-1]]
        pieces = list(map(int, pieces))
        pieces = [0] + pieces + [pieces[-1]]
        pieces = list(map(int, pieces))
        pieces = [0] + pieces + [pieces[-1]]
        pieces = list(map(int, pieces))
        pieces = [0] + pieces + [pieces[-1]]
        pieces = list("
"def gcd(x, y):
    while y != 0:
        (x, y) = (y, x % y)
    return x

import sys

for _ in range(int(sys.stdin.readline())):
    m, n = map(int, sys.stdin.readline().split())

    c = 0

    x = gcd(m, n)

    m = m // x
    n = n // x

    f = True
    k = 0

    while f:
        k += 1
        m %= n


        c += m
        m = m << 1
    
        f = not (n*(m//n) == m)
        if k > 30:
            {{completion}}
    
    if n*(m//n) == m:
        print(c*x)
        continue
    
    print('-1')

        
",f = False,"n = n//2
            m = m//2
            k = 0
    
    if n*(m//n) == m:
        print(c*x)
        continue
    
    print('-1')

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        "
"from sys import stdin, stdout
from math import gcd,log2
t = int(stdin.readline())
def max_p(n):
    while n%2==0:
        n = n//2
    return n
for _ in range(t):
    n,m=map(int,stdin.readline().split())
    result = 0
    if n%m==0:
        pass

    elif n%max_p(m):
        result = -1
    else:
        n = n%m
        while n%m!=0 :
            {{completion}}



    stdout.write(str(result)+'\n')","result +=n
            n = (n*2)%m","n = n//m
            m += 1
        result += 1"
"import sys
input = sys.stdin.readline
T = int(input())

for _ in range(T):
    n, m, k = map(int, input().split())
    if k > 3:
        print(0)
    elif k == 1:
        print(1)
    elif k == 2:
        if n >= m:
            print(m)
        else:
            {{completion}}
    else: #k == 3:
        temp = m - n - m//n + 1
        if temp <= 0:
            print(0)
        else:
            print(temp)","temp = n + m // n - 1
            print(temp)","temp = m - n + 1
            if temp <= 0:
                print(0)
            else:
                print(temp)
    elif k == 3:
        if n >= m:
            print(m)
        else:
            temp = m - n - m//n + 1
            if temp <= 0:
                print(0)
            else:
                print(temp)
    else:
        print(0)
<|/ file ext=.py source=github |>"
"tests = int(input())
output = []

for x in range(tests):
    n, m, k = map(int, input().split())
    if k > 3:  #we can only get maximum of 3 distinct values (bigger than n -> smaller than n -> zero)
        {{completion}}
    if k == 3:
        #value in n+1 needs to be bigger than n
        output.append(max(0, (m-n+1) - (m//n)))
    if k == 2:
        #value in n+1 needs to be multiplier of n -> c*n or smaller than n
        output.append((m//n) + min(m, n-1))
    if k == 1:
        output.append(1) #all zeros

for o in output:
    print(o)",output.append(0),"output.append((m//n) + min(m, n-1))
        continue
    if k == 4:
        #value in n+1 needs to be smaller than n
        output.append(min(m, n-1))"
"import sys

input=sys.stdin.readline

t = 1; t = int(input())

def solve() -> None:
    n,m,k=map(int,input().split())
    if k==1:print(1)
    elif k==2:{{completion}}
    elif k==3:print(0 if m<=n else m-n-int((m-n)/n))
    else:print(0)
    
for _ in [0] * t : solve()",print(m if m<=n else n+int((m-n)/n)),print(0 if m<=n else m-n-int((m-n)/n))
"for _ in range(int(input())):
    {{completion}}","s = input()
    print(s.count(""A"") - min(map(len, s.split(""B""))))","s=input()
    s=s.replace('AB','BC')
    s=s.replace('BA','CB')
    s=s.replace('ABA','CBA')
    s=s.replace('BA','C')
    s=s.replace('AB','C')
    s=s.replace('A','B')
    s=s.replace('B','C')
    print(len(s))
<|/ file source=github "
"def solve(s):
    tota = s.count('A')
    
    s = s.split('B')
    if '' in s: {{completion}}
    
    return tota-len(min(s, key = len))
            
for _ in range(int(input())):
    print(solve(input()))",return tota,"s.remove('')
    
    s = list(s)
    
    s.sort()
    
    s = list(s)
    
    s.sort()"
"def res():
    {{completion}}


for _ in range(int(input())):
    print(res())
","a = input()
    s = list(a.split(""B""))
    return len(a) - a.count(""B"") - len(min(s))","ans = 0
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys
input = sys.stdin.readline

maxn = 1001

primes = []
sieve = [True] * maxn
for i in range(2, maxn):
    if sieve[i]:
        primes.append(i)
        for j in range(i*i, maxn, i):
            sieve[j] = False


def solve():
    orig_n,q = map(int, input().split())
    n = orig_n
    orig_prime_cnt = {}
    for p in primes:
        while n%p == 0:
            orig_prime_cnt[p] = orig_prime_cnt.get(p,0) + 1
            n //= p
    
    if n != 1:
        orig_prime_cnt[n] = 1
    
    n = orig_n
    prime_cnt = orig_prime_cnt.copy()

    for _ in range(q):
        query = input().split()
        if query[0] == '1':
            x = int(query[1])
            n *= x
            for p in primes:
                while x%p == 0:
                    {{completion}}

            if x != 1:
                prime_cnt[x] = prime_cnt.get(x,0) + 1

            dn = 1
            for i in prime_cnt.values():
                dn *= i+1

            if n%dn == 0:
                print('YES')
            else:
                print('NO')
            
        else:
            n = orig_n
            prime_cnt = orig_prime_cnt.copy()

    print()



tc = int(input())
for case in range(tc):
    solve()
    ","prime_cnt[p] = prime_cnt.get(p,0) + 1
                    x //= p","prime_cnt[p] = prime_cnt.get(p,0) + 1
                    x //= p"
"from sys import stdout
from sys import stdin

def get():
    return stdin.readline().strip()
def getf():
    return [int(i) for i in get().split()]
def put(a, end = ""\n""):
    stdout.write(str(a) + end)
def putf(a, sep = "" "", end = ""\n""):
    stdout.write(sep.join([str(i) for i in a]) + end)

#from collections import defaultdict, deque
#from random import randint, shuffle
#from functools import cmp_to_key, reduce
#from math import factorial, acos, asin, atan2, gcd, log, e
#from bisect import bisect_right as br, bisect_left as bl, insort
#from array import array
#from heapq import heappush, heappop
#from decimal import Decimal

def fact(n):
    d = dict()

    i = 2
    while(i * i <= n):
        if(n % i == 0):
            a = 0
            while(n % i == 0):
                a += 1
                n //= i
            d[i] = a
        i += 1

    if(n > 1):
        d[n] = 1

    return d

def copy(d):
    d_new = dict()

    for key in d:
        d_new[key] = d[key]

    return d_new

def prod1(d):
    res = 1
    for key in d:
        res *= (d[key] + 1)
    return res

def divisible(a, b):
    for key in b:
        if(a.get(key, 0) < b[key]):
            return False
    return True

def solve():
    n, q = getf()
    d = fact(n)

    n_cur = n
    d_cur = copy(d)
    
    for i in range(q):
        w = getf()

        if(w[0] == 1):
            dx = fact(w[1])
            for divisor in dx:
                d_cur[divisor] = d_cur.get(divisor, 0) + dx[divisor]
            if(divisible(d_cur, fact(prod1(d_cur)))):
                put(""YES"")
            else:
                {{completion}}
        else:
            n_cur = n
            d_cur = copy(d)
    put("""")

def main():

    t = int(get())

    for _ in range(t):
        solve()
    
main()
","put(""NO"")","put(""NO"")
            break
        elif(w[0] == 2):
            n = w[1]
            d = copy(d)
            d_cur = copy(d)
        elif(w[0] == 3):
            n = w[1]
            d = copy(d)
            d_cur = copy(d)
            d_cur[w[1]] = d_cur.get(w[1], 0) + 1
        elif(w[0] == 4):
            n = w[1]
            d = copy(d)
            d_cur = copy(d)
            d_cur[w[1]] = d_cur.get(w[1], 0) - 1
        elif(w[0] == 5):
            n = w[1]
            d = copy(d)
            d_cur = copy(d)
            d_cur"
"# -*- coding:utf-8 -*-
# author      : utoppia
# description : solutions for codeforces
# updated at  : 2023-09-26 22:36:06
# -----------------------------------------------------
# File Name   : $%file%$
# Language    : Python
# ----------------------------------------------------


def read_int():
    return int(input())


def read_list():
    return list(map(int, input().split()))


def main():
    t = int(input())
    while t > 0:
        solve()
        t -= 1


def solve():
    n, q = read_list()
    p = []
    vis = [0 for _ in range(1001)]
    for i in range(2, 1001):
        if vis[i] == 0:
            p.append(i)
            for j in range(i * i, 1001, i):
                vis[j] = 1

    # print(p[:10])
    cnt = [0 for _ in p]
    m = n
    for i, x in enumerate(p):
        while m % x == 0:
            cnt[i] += 1
            m //= x
    if m > 2:
        p.append(m)
        cnt.append(1)

    d = 1
    for x in cnt:
        d *= x + 1

    m = n
    pp = [x for x in p]
    cntt = [x for x in cnt]
    dd = d
    for _ in range(q):
        s = input()
        if s[0] == ""1"":
            _, x = list(map(int, s.split()))
            m *= x
            for i, q in enumerate(pp):
                tmp = 0
                while x % q == 0:
                    {{completion}}
                if tmp > 0:
                    dd = dd // (cntt[i] + 1) * (cntt[i] + tmp + 1)
                    cntt[i] += tmp
            if x > 2:
                pp.append(x)
                cntt.append(1)
                dd *= 2
            # print(m, dd)
            if m % dd == 0:
                print(""YES"")
            else:
                print(""NO"")
        else:
            m = n
            pp = [x for x in p]
            cntt = [x for x in cnt]
            dd = d


if __name__ == ""__main__"":
    main()
","x //= q
                    tmp += 1","tmp += 1
                    x //= q"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    x = 1000
    for i in range(n):
        {{completion}}
    print(x)","a, b = map(int, input().split())
        x = min(x, a+(b-1)//2)","d, s = map(int, input().split())
        x += d
        x -= s"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()

for _ in range(t):
	n, = I()

	dist = 1000000000

	for i in range(n):
		{{completion}}
	print(dist)","d, s = I()
		dist = min(dist, d + (s - 1) // 2)","d, s = I()
		dist += d
		if dist >= s:
			dist -= s
			break

	print(dist)
<|/ file ext=.py source=github |>"
"import sys
input = sys.stdin.readline
for _ in range(int(input())):
    n = int(input())
    ans = 1e9
    for i in range(n):
        {{completion}}
    print(ans)","a, b = map(int, input().split())
        ans = min(ans, a + (b - 1) // 2)","d, s = map(int, input().split())
        if d > ans:
            ans = d
        if s > ans:
            ans = s"
for s in[*open(0)][1:]:{{completion}},"a,b,c=map(int,s.split());print(0--abs(a-b)//2//c)","
    a,b,c=map(float,s.split())
    if c>b:
        a,b,c=b,c,a
    if c>a:
        a,b,c=c,a,b
    if c>b:
        a,b,c=b,c,a
    if c>a:
        a,b,c=c,a,b
    if c>b:
        a,b,c=b,c,a
    if c>a:
        a,b,c=c,a,b
    if c>b:
        a,b,c=b,c,a
    if c>a:
        a,b,c=c,a,b
    if c>b:
        a,b,c=b,c,a
    if "
"for _ in range(int(input())):
    {{completion}}","a, b, c = map(int, input().split())
    print((abs(a - b) + 2 * c - 1) // (2 * c))","a,b,c = map(int, input().split())
    
    
    
<|/ file ext=.py filename="
"t=int(input())
while t:
  a,b,c=map(int,input().split())
  p=max(a,b)
  q=min(a,b)
  d=(p-q)/2
  if d%c==0:
     print(int(d//c))
  else:
     {{completion}}
  t-=1",print(int(d//c+1)),"print(0)
  t-1
<|/ q tags=python,python-3.x |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Welcome to Stack Overflow! Please take the [tour], read [what's on-topic here](/help/on-topic), [ask], 
and the [question checklist](//meta.stackoverflow.com/q/260648/843953), 
"
"import sys

R = lambda:map(int, sys.stdin.readline().rstrip().split())

def solve():
    n, k = R()
    line = sys.stdin.readline().rstrip()
    arr_l = list(R())
    arr_r = list(R())
    q ,= R()
    lst_q = list(R())
    ans = [line[i] for i in range(n)]
    arr = [0] * n
    for el in lst_q:
        arr[el - 1] += 1
    for i in range(k):
        l = arr_l[i] - 1
        r = arr_r[i] - 1
        summ = 0
        temp = 0
        for j in range(l, (r + l) // 2 + 1):
            summ += arr[j] + arr[r - temp]
            if summ % 2 != 0:
                {{completion}}
            temp += 1
    print(''.join(ans))
    

t ,= R()
for _ in range(t):
    solve()
","ans[j], ans[r - temp] = ans[r - temp], ans[j]","summ -= 1
            summ %= 10
            ans[temp] = chr(summ)"
"'''
Author       : InHng
LastEditTime : 2023-09-27 23:18:56
'''
import sys
input = sys.stdin.readline
# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

for _ in range(int(input())):
    n, k = map(int, input().split())
    s = list(input().strip())
    l = list(map(int, input().split()))
    r = list(map(int, input().split()))
    for i in range(k):
        l[i], r[i] = l[i] - 1, r[i] - 1
    f = [0 for __ in range(n)]
    input()
    x = list(map(int, input().split()))
    for xi in x:
        f[xi - 1] ^= 1
    
    for i in range(k):
        mid, j = 0, l[i]
        while j <= l[i] + r[i] - j:
            mid ^= f[j] ^ f[l[i] + r[i] - j]
            if mid:
                {{completion}}
            j += 1
    
    s = ''.join(s)
    print(s)
","s[j], s[l[i] + r[i] - j] = s[l[i] + r[i] - j], s[j]","s[j] = s[j - 1]
            else:
                s[j] = s[j + 1]
            f[j] ^= 1"
"import collections
import bisect
from sys import *
input = stdin.readline

# !!! Check if input have a t !!!

# T = 0
T = 1

def solve():
	n, k = ria()
	s = rs()
	la = ria()
	ra = ria()
	q = ri()
	xs = ria()
	cnt = [0] * (n + 1)
	for x in xs:
		cnt[x-1] += 1
	ans = """"
	for i in range(k):
		base = la[i]-1
		l, r = la[i]-1, ra[i]-1
		ts = list(s[l:r+1])
		odd = 0
		while l < r:
			odd += cnt[l] + cnt[r]
			if odd & 1:
				{{completion}}
			l += 1
			r -= 1
		ans += """".join(ts)
	
	print(ans)
	return


def ria():
	return list(map(int, input().strip().split()))
def rsa():
	return input().strip().split()
def ri():
	return int(input().strip())
def rs():
	return input().strip()

def tcase():
	for _ in range(ri()):
		solve()

def main():
	tcase() if T else solve()

if __name__ == ""__main__"":
    main()
","ts[l - base], ts[r - base] = ts[r - base], ts[l - base]","ts[l], ts[r] = ts[r], ts[l]
				l += 1
				r -= 1
			odd >>= 1
		ans += """".join(ts)
	
	for i in range(q):
		base = xs[i]-1
		l, r = xs[i]-1, ra[i]-1
		ts = list(s[l:r+1])
		odd = 0
		while l < r:
			odd += cnt[l] + cnt[r]
			if odd & 1:
				ts[l], ts[r] = ts[r], ts[l]
				l += 1
				r -= 1
			odd >>= 1
		"
for l in[*open(0)][2::2]:{{completion}},"print(-sum(map(int,l.split())))","
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()
    l.split()"
"for _ in range(int(input())):
    {{completion}}","n = input()
    print(-sum(map(int, input().split())))","teams = int(input())
    efficiencies = []
    for _ in range(teams):
        efficiencies.append(int(input()))
    efficiencies.sort()
    efficiencies = efficiencies[::-1]
    efficiencies = efficiencies[1:]
    efficiencies = efficiencies[::-1]
    efficiencies = efficiencies[1:]
    efficiencies = efficiencies[::-1]
    efficiencies = efficiencies[1:]
    efficiencies = efficiencies[::-1]
    efficiencies = efficiencies[1:]
    efficiencies = efficiencies[::-1]
    efficiencies = efficiencies[1:]
    efficiencies = efficiencies[::-1]
    efficiencies = effici"
"t=int(input())
for i in range(t):
  {{completion}}","n=int(input())
  a=list(map(int,input().split()))
  print(-sum(a))","n=int(input())
  a=list(map(int, input().split()))
  b=list(map(int, input().split()))
  c=a[:]
  c.sort()
  c.reverse()
  c=c[:n-1]
  c.sort()
  c=c[:n-1]
  c=c+b
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  c=c+a
  "
"import sys
n = int(input())
p = list(map(int,input().split()))
if p == [1]*(n-1):
    print('1 '*(n+1))
    sys.stdout.flush()
    sys.exit()
deg = [0]*n
for i in p:
    deg[i-1] += 1
dist = [0]*n
for i in range(1,n):
    dist[i] = 1+dist[p[i-1]-1]
root = [0]*n
for i in range(1,n):
    if p[i-1] == 1:
        root[i] = i
    else:
        root[i] = root[p[i-1]-1]
ans = 2
color = [-1]*n
for i in range(1,n):
    if deg[i] == 1 and color[root[i]] == 1-dist[i]%2:
        ans = 3
    elif deg[i] == 1:
        color[root[i]] = dist[i]%2
for i in range(n):
    color[i] = max(0,color[i])
print(ans)
for i in range(1,n):
    print((dist[i]+color[root[i]])%ans+1)
sys.stdout.flush()
while input() == '0':
    l = list(map(int,input().split()))
    if ans == 2 and l[0] == 1:
        print(1)
    elif ans == 2:
        print(2)
    else:
        for i in range(3):
            if l[i] == 1 and l[(i-1)%3] == 0:
                {{completion}}
    sys.stdout.flush()",print(i+1),"ans = 3
                break
            elif l[i] == 1:
                ans = 2
                break
print(ans)
for i in range(1,n):
    print((dist[i]+color[root[i]])%ans+1)"
"import sys
import os, gc

n = int(input())
p = list(map(int,input().split()))

if p == [1]*(n-1):
    print('1 '*(n+1))
    sys.stdout.flush()
    sys.exit()
    
deg = [0]*n

for i in p:
    deg[i-1] += 1
dist = [0]*n

for i in range(1,n):
    dist[i] = 1+dist[p[i-1]-1]
root = [0]*n

for i in range(1,n):
    if p[i-1] == 1:
        root[i] = i
    else:
        root[i] = root[p[i-1]-1]
        
ans = 2
color = [-1]*n

for i in range(1,n):
    if deg[i] == 1 and color[root[i]] == 1-dist[i]%2:
        ans = 3
    elif deg[i] == 1:
        color[root[i]] = dist[i]%2
        
for i in range(n):
    color[i] = max(0,color[i])
    
print(ans)

for i in range(1,n):
    print((dist[i]+color[root[i]])%ans+1)
    
sys.stdout.flush()

while input() == '0':
    
    l = list(map(int,input().split()))
    
    if ans == 2 and l[0] == 1:
        print(1)
        
    elif ans == 2:
        print(2)
        
    else:
        for i in range(3):
            if l[i] == 1 and l[(i-1)%3] == 0:
                {{completion}}
                
    sys.stdout.flush()
",print(i+1),"ans = 3
                break
            elif l[i] == 1:
                ans = 2
                break
        
        if ans == 3:
            print(3)
            
        else:
            print(4)"
"def solve():
    a,b,n = map(int,input().split())
    l=list(map(int,input().split()))
    for i in l:
        if i >=a:
            b+=a-1
        else:
            {{completion}}
    print(b)
for _ in range(int(input())):
    solve()",b+=i,"c-=1
    if c==0:
        print(b)
    else:
        print(b)
    for _ in range(int(input())):
        solve()
'''
def solve():
    a,b,n = map(int,input().split())
    l=list(map(int,input().split()))
    for i in l:
        if i >=a:
            b+=a-1
        else:
            c-=1
    if c==0:
        print(b)
    else:
        print(b)
    for _ in range(int(input())):
        solve()
'''
def solve():
    a,b,n = map(int,input().split())
    l=list(map(int,input().split()))
    for i in l:
        if "
"test_cases = int(input())

for x in range(test_cases):
    {{completion}}","inp = input().split("" "")
    a = int(inp[0])
    b = int(inp[1])
    xka = [int(i) for i in input().split("" "")]
    print(b + sum([i if i<a else a-1 for i in xka]))","a,b,n = map(int, input().split())
    tools = [int(i) for i in input().split()]
    bomb = max(a,b)
    bomb = min(a,b)
    bomb = max(a,b)
    bomb = min(a,b)
    bomb = max(a,b)
    bomb = min(a,b)
    bomb = max(a,b)
    bomb = min(a,b)
    bomb = max(a,b)
    bomb = min(a,b)
    bomb = max(a,b)
    bomb = min(a,b)
    bomb = max(a,b)
    bomb = "
"
def solution (ceil, current, tools):
   if ceil == 1:
      {{completion}}
   ceil -= 1
   tools = [ceil if tool > ceil else tool for tool in tools]
   return sum(tools) + current

for x in range(int(input())):
   ceil, current, n = [int(val) for val in input().split()]
   tools = [int(val) for val in input().split()]
   print(solution(ceil, current, tools))
",return 1,"tools = [ceil if tool > ceil else tool for tool in tools]
      return sum(tools) + current
   while tools:
      tool = tools.pop(0)
      if tool > ceil:
         tool = ceil
      ceil -= 1
      tools = [ceil if tool > ceil else tool for tool in tools]
      return sum(tools) + current

def solution (ceil, current, tools):
   if ceil == 1:
      tools = [ceil if tool > ceil else tool for tool in tools]
      return sum(tools) + current
   while tools:
      tool = tools.pop(0)
      if tool > ceil:
         tool = ceil"
"MOD = 998244353

n = int(input())
a = list(map(int, input().split()))

ans = 0
for b in range(31):
    preans = 0
    sm = [1, 0]
    smL = [0, 0]
    x = 0
    for i in range(n):
        {{completion}}

    ans += preans*(2**b)
    ans %= MOD
print(ans)","x = x ^ (a[i] >> b & 1)
        smR = sm[x ^ 1] * (i + 1)
        preans += smR - smL[x ^ 1]
        preans %= MOD
        sm[x] += 1
        smL[x] += i + 1","sm[x] = a[i] ^ sm[x]
        smL[x] = sm[x] & 1
        preans += smL[x]*smL[x+1]*smL[x+2]*smL[x+3]
        x += 1"
"import sys, os
input = sys.stdin.buffer.readline
length = int(input())
array = list(map(int, input().split()))
maxbit = max(array).bit_length()
binaryarray = [2**i for i in range(maxbit)]
answer = 0
for i in range(maxbit):
    sum0, sum1, num0, num1, total, currentprefix = -1, 0, 1, 0, 0, 0
    for j in range(len(array)):
        currentprefix ^= binaryarray[i] & array[j]
        if currentprefix:
            num1 += 1
            sum1 += j
            total += num0*j - sum0
        else:
            {{completion}}
    answer += total * binaryarray[i]
    answer %= 998244353
sys.stdout.write(str(answer) + ""\n"")
","num0 += 1
            sum0 += j
            total += num1*j - sum1","sum0 += j
            num0 += 1
            total += num1*j - sum1"
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')
ii = lambda: int(input())
mii = lambda: map(int, input().split())
lii = lambda: list(mii())

MOD = 998244353

T = 1

def solve():
    n = ii()
    arr = lii()
    ans = 0
    for i in range(30):
        res = 0
        xors = 0
        cnt = [1, 0]
        s = [0, 0]
        for j, x in enumerate(arr, 1):
            {{completion}}
        ans += (res << i) % MOD
    return ans % MOD


for _ in range(T):
    print(solve())","d = x >> i & 1
            xors ^= d
            res += j * cnt[xors ^ 1] - s[xors ^ 1]
            res %= MOD
            cnt[xors] += 1
            s[xors] += j","cnt[0] += x & 1
            cnt[1] += x >> 1
            s[0] += x & 2
            s[1] += x >> 2
            res = (res << 1) + (x & 3) * xors
            xors = (cnt[0] * cnt[1]) % MOD
        ans += (res << i) % MOD
    return ans % MOD

for _ in range(T):
    print(solve())
<|/ file source=github ext=.py |>"
"for _ in range(int(input())):
    {{completion}}
","a = input().split()[-1]
    s = input().split()
    print(""YES"" if a in s else ""NO"")","n, k = map(int, input().split())
    a = [int(i) for i in input().split()]
    a.sort()
    count = 0
    for i in range(n):
        if a[i] == k:
            count += 1
    if count > a[n-1]:
        print(""NO"")
    else:
        print(""YES"")
<|/ file source=github |>"
"def main():
    ans = []
    t = int(input())
    for _ in range(t):
        n, k = input().split()
        arr = input().split()
        if k in arr:
            ans.append(""YES"")
        else:
            {{completion}}
    for i in ans:
        print(i)

if __name__ == ""__main__"":
    main()","ans.append(""NO"")","ans.append(""NO"")"
"def solve():
	{{completion}}
for _ in range(int(input())):solve()","n, k = map(int, input().split())
	a = list(map(int, input().split()))
	print('NYOE S'[k in a::2])","n = int(input())
	a = [int(i) for i in input().split()]
	k = int(input())
	count = 0
	for i in range(n):
		if a[i] > k:
			count += 1
		else:
			count += 0
	if count > n:
		print(""YES"")
	else:
		print(""NO"")

if __name__ == '__main__':"
"import queue
from sys import stdin
def input(): return stdin.readline().rstrip()


for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    g = [[] for _ in range(n)]
    for i in range(n - 1):
        x, y = map(int, input().split())
        x -= 1; y -= 1
        g[x].append(y)
        g[y].append(x)

    ans = [0] * n
    cnt = [1] * n
    parent = [-1] * n
    s = []
    q = []
    q.append((0, -1))
    while q:
        node, pr = q.pop()
        for vecin in g[node]:
            if vecin == pr:
                {{completion}}
            parent[vecin] = node
            s.append(vecin)
            q.append((vecin, node))
    
    for x in s[::-1]:
        ans[0] += (a[x] ^ a[parent[x]]) * cnt[x]
        cnt[parent[x]] += cnt[x]
    
    for x in s:
        ans[x] = ans[parent[x]] + (a[x] ^ a[parent[x]]) * (n - cnt[x] * 2)
    
    print(*ans)
",continue,"cnt[vecin] -= 1
                if cnt[vecin] == 0:
                    del cnt[vecin]
                    del s[vecin]
                    del parent[vecin]
            else:
                cnt[vecin] += 1"
"import sys
input = sys.stdin.readline

for _ in range(int(input())) :
    N = int(input()) ; Dic = [[] for _ in range(1+N)]
    A = [0]+list(map(int,input().split()))

    for _ in range(N-1) :
        a, b = map(int,input().split())
        Dic[a].append(b) ; Dic[b].append(a)

    P = [0] * (1+N) ; Ans = 0 ; D = [1] ; V = [0] * (1+N)

    while D :
        n = D[-1]

        if V[n] == 0 :
            for num in Dic[n] :
                if V[num] == 0 : {{completion}}
            V[n] = 1 ; continue
        
        D.pop() ; cnt = 1
        for num in Dic[n] :
            if P[num] != 0 : cnt += P[num] ; Ans += (A[n]^A[num])*P[num]
        
        P[n] = cnt

    dp = [0] * (1+N) ; dp[1] = Ans ; D = [1] ; V = [0] * (1+N) ; V[1] = 1

    while D :
        n = D.pop()

        for num in Dic[n] :
            if V[num] == 0 :
                dp[num] = dp[n]-(A[num]^A[n])*(P[num]-(P[n]-P[num]))
                V[num] = 1 ; D.append(num) ; P[num] += P[n]-P[num]

    print(*dp[1:])",D.append(num),D.append(num) ; P[num] += P[n]-P[num]
"import sys

R = sys.stdin.readline
inf = int(1e18)
mod = int(1e9) + 7


def get_int() -> int:
    return int(R())


def get_str() -> str:
    return R().strip()


def get_int_list() -> list:
    return list(map(int, R().strip().split(' ')))


def init_matrix(n_, m_, value_=0) -> list:
    return [[value_] * m_ for _ in range(n_)]


from collections import deque


def solve():
    n = get_int()
    a = get_int_list()

    g = init_matrix(n + 1, 0)
    for i in range(n - 1):
        u, v = get_int_list()
        u -= 1
        v -= 1
        g[v].append(u)
        g[u].append(v)

    q = deque()
    stack = []
    prev = [0] * n
    cnt = [1] * n
    cost = [0] * n

    q.append((0, -1))
    while len(q):
        v, pv = q.pop()

        stack.append(v)

        for u in g[v]:
            if u != pv:
                {{completion}}

    for v in stack[1:][::-1]:
        cost[prev[v]] += (a[prev[v]] ^ a[v]) * cnt[v] + cost[v]
        cnt[prev[v]] += cnt[v]

    for v in stack[1:]:
        cost[v] += (n - 2 * cnt[v]) * (a[prev[v]] ^ a[v]) + cost[prev[v]] - cost[v]

    print(*cost)


for _ in range(get_int()):
    solve()
","prev[u] = v
                q.append((u, v))","q.append((u, v))

        prev[v] = pv
        cnt[v] += 1"
"import math
for i in[*open(0)][2::2]:{{completion}}","a=sorted(map(int,i[::2]));a[0]+=1;print(math.prod(a))","
    a,b=map(int,input().split())
    ans=a*b
    ans=ans+1
    print(ans)
<|/"
"import math
for s in[*open(0)][2::2]:{{completion}}","a=sorted(map(int,s[::2]));a[0]+=1;print(math.prod(a))","
    s=int(s)
    ans=0
    for i in range(1,s+1):
        ans=ans*i
    print(ans)
<|/ q tags=python-3.x,python |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have tried so far.
"
"for _ in range(int(input())):
	n, p = map(int, input().split())
	arr1 = list(map(int, input().split())) #number of messages
	arr2 = list(map(int, input().split())) #cost per message
	arr = list(zip(arr2, arr1))
	arr.sort()
	cost = p
	n -= 1
	for i in range(n):
		if arr[i][0] < p:
			cost += arr[i][0] * arr[i][1]
			n -= arr[i][1]
			if n < 0:
				{{completion}}
		else:
			cost += n * p
			break
	print(cost)","cost -= arr[i][0] * (-n)
				break",break
"import math 
def isprime(n):
	j=2
	while j*j<=n:
		if n%j==0:
			return False
		j+=1 
	return True 
I=lambda: map(int,input().split())
l=lambda: list(map(int,input().split()))
li=lambda: [(int(v),j) for j,v in enumerate (input().split())]
def solve(a,b):
	return a*(b//2)
	
	
for i in range(int(input())):
	n,k=I()
	a=l()
	b=li()
	s=k
	n-=1
	b.sort(key=lambda tup: tup[0])
	for j in b:
		if j[0]>=k:
			break
		elif a[j[1]]>=n:
			{{completion}}
		else:
			s+=j[0]*a[j[1]]
			n-=a[j[1]]
	s+=n*k		
	print(s)","s+=j[0]*n
			n=0
			break",break
"import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    n, p = readInts()
    a, b = readList(), readList()

    idx = sorted([i for i in range(n)], key=lambda x: b[x])
    while idx and b[idx[-1]] >= p:
        idx.pop()

    cost, curr = p, n - 1
    for i in idx:
        if not curr:
            {{completion}}
        cnt = min(curr, a[i])
        cost += cnt * b[i]
        curr -= cnt
    return cost + curr * p

for _ in range(int(input())):
    print(solve())",break,"curr += a[i]
            continue"
"import sys
input=sys.stdin.readline
for i in range(int(input())):
    n,x=map(int,input().split())
    a=list(sorted(map(int,input().split())))
    h,p=a[0],a[0]
    for i in range(n):
        if (s:=a[i])!=p:
            h+=(y:=min(s-p,x//i))
            x-=y*i;p=s
            if y==0:{{completion}}
    print(h+x//n)",break,"
                break"
"import sys

t = int(sys.stdin.readline())

for i in range(t):
    l1 = sys.stdin.readline().split()
    n = int(l1[0])
    x = int(l1[1])

    l2 = sys.stdin.readline().split()
    a = []
    for i in l2:
        a.append(int(i))
    
    a.sort()
    
    i = 0
    done = False
    while i<len(a)-1:
        h = a[i]
        diff = a[i+1]-a[i]
        if x > diff*(i+1):
            x-=diff*(i+1)
            i+=1
        else:
            {{completion}}

    if not done:
        k = x//(i+1)
        h = a[i]+k
        print(h)

    ","k=x//(i+1)
            h+=k
            print(h)
            done = True
            break","done = True
            break"
"from sys import stdin, stdout
for t in range(int(stdin.readline())):
    n, x = map(int, stdin.readline().strip().split())
    a = list(map(int, stdin.readline().strip().split()))
    a.sort()
    h = a[0]
    s = 1
    for i in range(1, n):
        if a[i] > a[i-1]:
            if x > s * (a[i] - a[i - 1]):
                x -= s * (a[i] - a[i - 1])
                s += 1
                h += a[i] - a[i-1]
            elif x == s * (a[i] - a[i - 1]):
                {{completion}}
            else:
                h += x//s
                x = 0
                break
        else:
            s += 1
    if x > 0:
        h += x//n
    stdout.write(f'{h}')
    stdout.write('\n')","x = 0
                h += a[i] - a[i-1]
                break","x -= s * (a[i] - a[i - 1])
                s += 1"
"import sys
input = sys.stdin.readline


for _ in range(int(input())):
    n = int(input())
    w = list(map(int, input().split()))
    d = dict()
    c, ew = 0, 0
    for i in w:
        if i not in d:
            c += 1
            d[i] = c
        else:
            {{completion}}
        ew += c
    print(ew)
","ew -= d[i]
            d[i] = c",c += d[i - 1]
"from sys import stdin
from collections import defaultdict
input = stdin.readline

def solve():
    input()
    arr = [*map(int, input().split())]
    dp = defaultdict(int)
    dp[arr[0]]=1
    dp[0]=0
    for i, x in enumerate(arr[1:], 1):
        if x != arr[i-1]:
            {{completion}}
    print(sum(dp.values()))

for _ in range(int(input())):
    solve()",dp[x] = dp[arr[i-1]]+(x not in dp),"lp=i
            break
    for x in arr[lp:]:
        dp[x]+=1
    sum = 0
    for x in dp.values():
        sum += x"
"import sys
def input()   : return sys.stdin.readline().strip()
def getints() : return map(int,sys.stdin.readline().strip().split())

for _ in range(int(input())):
    n = int(input())
    l = [*getints()]
    
    t = set()
    d = [0]*n
    for i in range(n-1,-1,-1):
        t.add(l[i])
        d[i] = len(t)
    
    ans = 0
    s = set()
    for i in range(n):
        if l[i] not in s:
            {{completion}}
    print(ans)
    ","ans += d[i]
            s.add(l[i])","s.add(l[i])
            ans += 1
    "
"import sys
input = sys.stdin.buffer.readline

for _ in range(int(input())):
    {{completion}}","n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    ans = min(n * min(a) + sum(b), n * min(b) + sum(a))
    print(ans)","n, *a = map(int, input().split())
    n, *b = map(int, input().split())
    cost = 0
    for i in range(n):
        for j in range(n):
            if i == j or a[i] == 0 or b[j] == 0 or a[i] == b[j]:
                cost += a[i] + b[j]
    print(cost)
<|/ file source=github |>"
"import sys


def II(): {{completion}}
def LI(): return [int(num) for num in sys.stdin.readline().split()]
def SI(): return sys.stdin.readline().rstrip()


def solve():
    n = II()
    a = LI()
    b = LI()
    sum_a = sum(a) + n * min(b)
    sum_b = sum(b) + n * min(a)
    print(min(sum_a, sum_b))


for _ in range(II()):
    solve()
",return int(sys.stdin.readline()),return int(sys.stdin.readline())
"import sys
input=sys.stdin.readline
import math


for j in range(int(input())):
    {{completion}}
        


        

















        
        


    
    


    








","n=int(input())
    a=[int(i) for i in input().split("" "")]
    b=[int(i) for i in input().split("" "")]
    e=min(a)
    h=min(b)
    # ans=float('inf')
    ans=min(sum(a)+(h*n),sum(b)+(e*n))
    print(ans)","
    n=int(input())
    a=list(map(int,input().split()))
    b=list(map(int,input().split()))
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = set(map(int, input().split()))
    g = [[] for _ in range(n)]
    for i in range(n - 1):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)
    from collections import deque
    def bfs(start):
        q = deque([(start, -1)])
        ans = -1
        dd = -1
        step = -1
        while q:
            step += 1
            for _ in range(len(q)):
                u, fa = q.popleft()
                if u + 1 in a:
                    ans = u
                    dd = step
                for v in g[u]:
                    if v != fa:
                        {{completion}}
        return ans,dd
    x, _ = bfs(0)
    y, d = bfs(x)
    print((d + 1)//2)","q.append((v, u))","q.append( (v, fa) )"
"import sys
input=sys.stdin.buffer.readline
# import threading
# threading.stack_size(10**8)
# sys.setrecursionlimit(10**6)
# threading.Thread(target=main).start()
def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input()
def rm():
    return map(int,input().split())

def main():
    n,k=rm()
    a=rl()
    g=[[] for i in range(n)]
    for i in range(k): a[i]-=1
    rt=a[0]
    a=set(a)
    for i in range(n-1):
        u,v=rm();u-=1;v-=1
        g[u].append(v);g[v].append(u)
    if len(a)==1: return 0
    ind=rt
    curdst=0
    sta=[(rt,-1,0)]
    while sta:
        u,p,dst=sta.pop()
        if u in a and dst>curdst:
            ind=u;curdst=dst
        for v in g[u]:
            if v==p: {{completion}}
            sta.append((v,u,dst+1))
    curdst=0
    sta=[(ind,-1,0)]
    while sta:
        u,p,dst=sta.pop()
        if u in a and dst>curdst:
            ind=u;curdst=dst
        for v in g[u]:
            if v==p: continue
            sta.append((v,u,dst+1))
    return (curdst+1)//2

t=ri()
for i in range(t):
    print(main())",continue,continue
"import sys
input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n, k = map(int,input().split())
    marked = [0] * n
    for v in map(int,input().split()):
        marked[v - 1] = 1
    tree = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        tree[u].append(v)
        tree[v].append(u)
    if k == 1:
        print(0)
        continue
    Q = [(-1, marked.index(1), 0)]
    U, D = None, -1
    while Q:
        p, v, d = Q.pop()
        if marked[v] and d > D:
            D, U, = d, v
        for u in tree[v]:
            if u != p:
                {{completion}}
    Q = [(-1, U, 0)]
    while Q:
        p, v, d = Q.pop()
        if marked[v]:
            D = max(D, d)
        for u in tree[v]:
            if u != p:
                Q.append((v, u, d + 1))
    print((D + 1) // 2)","Q.append((v, u, d + 1))","Q.append((v, u, d + 1))
    print((D + 1) // 2)
<|/ a |>"
"i = input
f = set.union

for _ in range(int(i())):
    a = [f({*i().split()[1:]}) for _ in range(int(i()))]
    final = f(*a)
    max_ = 0
    for u in final:
        tmp = set()
        for s in a:
            if u not in s: {{completion}}
        max_ = max(max_, len(tmp))
    print(max_)",tmp |= s,"tmp.add(s)
        tmp = list(tmp)"
"import sys
input = sys.stdin.readline
print = sys.stdout.write

def count_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

N = int(input())
for _ in range(N):
    n = int(input())
    mx = 0
    v = [0] * n

    for i in range(n):
        k, *bits = map(int, input().split())
        for x in bits:
            v[i] |= 1 << x

    p = 0
    for x in range(51):
        r = 0
        for i in v:
            if (i >> x) & 1 == 0:
                {{completion}}
        r = count_bits(r)
        if x:
            if p ^ r and mx < r:
                mx = r
        else:
            p = r

    print(str(mx) + '\n')
",r |= i,"r |= 1
        p ^= r"
"for _ in range(int(input())):
    n = int(input())
    
    S = []
    for _ in range(n):
        {{completion}}
    
    Union = set().union(*S)
    max_number = 0

    for i in Union:
        max_number = max(max_number, len(set().union(*[s for s in S if i not in s])))

    print(max_number)","S.append(set(map(int, input().split()[1:])))",S.append([int(i) for i in input().split()])
"import sys
input = sys.stdin.readline
n=int(input())
for _ in range(n):
    n,m=map(int,input().split())
    x=input().strip(""\n"")
    s=input().strip(""\n"")
    cont=0
    while s not in x:
        cont+=1
        x=x+x
        if len(x)>m*n and s not in x:
            {{completion}}
    print(cont)","cont=-1
            break","cont+=1
            x=x+x
            s=s+s
            if len(s)>m*n:
                cont+=1
                s=s+s
                x=x+x
                s=s+s
                if len(s)>m*n:
                    cont+=1
                    s=s+s
                    x=x+x
                    s=s+s
                    if cont==n:
                        print(cont)
                        break
                else:
                    cont+=1
                    s=s+s
                    x=x+x
                    s=s+s
                    if len(s)>m*n:
                        cont+=1
                        s=s+s
                        x=x+x
                        s=s+s
                        if len(s)>"
"from sys import stdin
 
def main():
    t = int(stdin.readline().strip())
    for _ in range(t):
        list(map(int, stdin.readline().strip().split()))
        x = stdin.readline().strip()
        s = stdin.readline().strip()
        operations = 0
        if s in x:
            print(operations)
        else:
            for _ in range(6):
                x += x
                operations += 1
                if(s in x):
                    {{completion}}
            if s in x:
                print(operations)
            else:
                print(-1)
 
main()",break,"print((operations-1))
                    break"
"ans=[]
t=int(input())
def main():
    n, m = [*map(int, input().split("" ""))]
    x = input()
    s = input()
    i = 0
    if s in x:
        ans.append(i)
        return
    for _ in range(6):
        x += x
        i += 1
        if s in x:
            {{completion}}
    ans.append(-1)
for _ in range(t):
    main()
print('\n'.join([*map(str,ans)]))
","ans.append(i)
            return","ans.append(i)
            return
    ans.append(-1)
for _ in range(t):
    main()
print('\n'.join([*map(str,ans)]))
<|/ file dstars=1 ext=.py |>"
for s in[*open(0)][1:]:{{completion}},"n,k,x=map(int,s.split());print('NYOE S'[k*k+k<=2*x<=(2*n-k+1)*k::2])","
    s=s.split()
    a,b,c=int(s[0]),int(s[1]),int(s[2])
    if a<b and b<c:
        if a+b+c==x:
            print(""YES"")
        else:
            print(""NO"")
<|/ file source=github filename=Vasilije.py |>"
"import math
for _ in range(int(input())):
    n = int(input())
    l = list(map(int,input().split()))
    x = 1
    for i in l:
        x *= i
    if round(2**(math.log(x,2)/n))**n == x:
        print('YES')
    else:
        {{completion}}",print('NO'),
"from math import log, exp, gcd

def test(n, xs):
    root = exp(sum(log(x) for x in xs) / n)
    if abs(root - round(root)) > 0.00001:
        {{completion}}
    return all(x == 1 or gcd(x, round(root)) != 1 for x in xs)

def task():
    n = int(input())
    xs = [int(x) for x in input().split()]
    print('YES' if test(n, xs) else 'NO')

# main:
for _ in range(int(input())):
    task()",return False,"root = round(root)
    return all(x == 1 or gcd(x, round(root)) != 1 for x in xs)

def task():
    n = int(input())
    xs = [int(x) for x in input().split()]
    print('YES' if test(n, xs) else 'NO')

for _ in range(int(input())):
    task()
<|/ file filename=p10.py |>"
"from math import exp, log
 
Tnt = int(input())
 
for _ in range(Tnt):
    
  n = int(input())
  s = [int(x) for x in input().split()]
  prod = 1
  for i in s:
    prod *= i
  valid = round(exp(log(prod)/n)) ** n == prod
  if valid:
    print(""YES"")
  else:
    {{completion}}","print(""NO"")","prod = 1
    for i in s:
      prod *= i
    valid = round(exp(log(prod)/n)) ** n == prod
    if valid:
      print(""NO"")
    else:
      print(""NO"")
<|/ file source=github |>"
"from sys import stdin,stdout
# from os import _exit
# from bisect import bisect_left,bisect
# from heapq import heapify,heappop,heappush
# from sys import setrecursionlimit
# from collections import defaultdict,Counter
# from itertools import permutations
from math import gcd,ceil,sqrt,factorial,log2
# setrecursionlimit(int(1e5))
input,print = stdin.readline,stdout.write

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    ans,y = 0,0
    for i in range(1,n):
        c = ceil(log2(a[i-1]/a[i])+y)
        if c>0:
            ans+=c
            y = c
        else:
            {{completion}}

    print(str(ans)+""\n"")
",y = 0,"ans+=y
            y = 1"
"import sys

for _ in range(int(sys.stdin.readline())):
    n = int(sys.stdin.readline())
    a = list(map(int, sys.stdin.readline().split()))
    rez = op = 0
    for i in range(1, len(a)):
        {{completion}}
    print(rez)
","op = (
            max(op - (a[i] // a[i - 1]).bit_length() + 1, 0)
            if a[i] >= a[i - 1]
            else op + ((a[i - 1] - 1) // a[i]).bit_length()
        )
        rez += op","op = op + 1
        if a[i] > a[i-1]:
            a[i] = a[i] * 2
        else:
            rez = rez + 1
    if rez < op:
        rez = op"
"import sys

input = sys.stdin.readline


def solve(n, arr):  # we cannot keep multiplying as the number is too large
    # so we store num_zero, the amount of 0s beyond 32 bit integer.
    ans = 0
    largest = int(""0b"" + ""1"" * 32, 2)  # 32 bit.
    num_zeros = [0] * n

    for i in range(1, n):
        shifts = 0
        while arr[i] < arr[i - 1]:
            shifts += 1
            arr[i] *= 2
        if arr[i] > largest:
            arr[i] //= 2
            num_zeros[i] = num_zeros[i - 1] + 1
            shifts -= 1
        else:
            {{completion}}
        ans += shifts + num_zeros[i]

    print(ans)


def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        arr = list(map(int, input().split()))
        solve(n, arr)


main()
",num_zeros[i] = num_zeros[i - 1],"arr[i] //= 2
            shifts += 1
        arr[i] = arr[i] % largest"
"import sys
input = sys.stdin.readline

t=int(input())
for tests in range(t):
    n=int(input())
    A=list(map(int,input().split()))

    LIST=[0]*(n+1)
    for a in A:
        LIST[a]+=1

    ANS=0

    SCORE=[0]*(n+1)

    for i in range(1,n+1):
        count=0
        for j in range(i,n+1,i):
            count+=LIST[j]

        SCORE[i]=count*(count-1)//2

    #print(SCORE)

    USE=[0]*(n+1)

    for i in range(n,0,-1):
        if SCORE[i]==0:
            continue
        for j in range(i+i,n+1,i):
            SCORE[i]-=SCORE[j]

        if LIST[i]>0:
            for j in range(i,n+1,i):
                {{completion}}

    #print(SCORE,n*(n-1)//2)

    #print(n*(n-1)//2-sum(SCORE))

    ANS=0
    for i in range(n+1):
        if USE[i]==0:
            ANS+=SCORE[i]

    print(ANS)
        

    
",USE[j]=1,USE[j]=1
"from sys import *
input = stdin.readline
inputlist = lambda: map(int, stdin.readline().split())
 
def solve():
    n = int(input())
    array = list(inputlist())
    dict = [0] * (n+1)
 
    for num in array:
        dict[num] += 1
 
    myset = [0] * (n+1)
    for num in range(1, n+1):
        if dict[num] != 0:
            for i in range(num, n+1, num):
                {{completion}}
 
    bad = [0] * (n+1)
    for num in reversed(range(1, n+1)):
        if myset[num] == 1:
            temp = 0
            for i in range(num, n+1, num):
                temp += dict[i]
            temp = (temp)*(temp-1)//2
            for i in range(2*num, n+1, num):
                temp -= bad[i]
            bad[num] = temp
 
    return (n)*(n-1)//2 - sum(bad)
 
for i in range(int(input())):
    print(solve())",myset[i] = 1,"myset[i] += dict[num]
 
    for num in range(1, n+1):
        if dict[num] != 0:
            for i in range(num, n+1, num):
                myset[i] -= dict[num]
 "
"import collections
import math
import sys
import heapq

input = sys.stdin.readline


def inp():
    return (int(input()))
def inlt():
    return (list(map(int, input().split())))
def insr():
    s = input()
    return (list(s[:len(s) - 1]))
def invr():
    return (map(int, input().split()))


def solution():
    n = inp()
    a = inlt()
    cnt = [0] * (n + 1)
    for x in a:
        cnt[x] += 1
    dp = [0] * (n + 1)
    for x in range(n, 0, -1):
        c = 0
        for i in range(x, n + 1, x):
            c += cnt[i]
        dp[x] = c * (c-1) // 2
        for i in range(2*x, n + 1, x):
            dp[x] -= dp[i]
    for x in range(n+1):
        if cnt[x]:
            for i in range(x, n+1, x):
                {{completion}}
    print(sum(dp))
    return


if __name__ == '__main__':
    t = inp()
    for i in range(t):
        solution()
",dp[i] = 0,"dp[x] -= dp[i]
    sum = 0
    for x in range(n+1):
        if dp[x]:
            sum += dp[x]
    print(sum)
    return


def solution():
    n = inp()
    a = insr()
    cnt = collections.Counter(a)
    dp = [0] * (n + 1)
    for x in range(n, 0, -1):
        c = 0
        for i in range(x, n + 1, x):
            c += cnt[i]
        dp[x] = c * (c-1) // 2
        for i in range(2*x, n + 1, x):
            dp[x] -= dp[i]
    for x in range(n+1):
        if cnt[x]:
            for i in range(x, n+1, x):
                dp[x] -= dp[i]
    "
"import heapq as hp
from collections import defaultdict
import sys
input=sys.stdin.readline
a=defaultdict(int);b=defaultdict(int)
c=[];d=[];ans=[]
for _ in range(int(input())):
    i,j,k=input().split()
    j=-int(j);k=int(k)
    if i == '+':
        a[j]+=1;b[k]+=1
        hp.heappush(c,j);hp.heappush(d,k)
    else:
        {{completion}}
    while c and a[c[0]]<1:hp.heappop(c)
    while d and b[d[0]]<1:hp.heappop(d)
    #print(a,b)
    ans.append('YES' if (c and d[0]<-c[0]) else 'NO')
print('\n'.join(ans))",a[j]-=1;b[k]-=1,"i=-int(i);j=int(j);k=int(k)
        if i == '-':
            a[j]-=1;b[k]-=1
            hp.heappop(c);hp.heappop(d);
        else:
            print('NO')
            break
    #print(a,b)"
"ls, rs = {}, {}
max_l = min_r = -1
ans = ''
for i in range(int(input())):
    t, l, r = map(str, input().split())
    l, r = int(l), int(r)
    if t == '+':
        if l in ls:
            ls[l] += 1
        else:
            ls[l] = 1
        if r in rs:
            rs[r] += 1
        else:
            rs[r] = 1
        if max_l == -1:
            max_l = l
        else:
            max_l = max(max_l, l)
        if min_r == -1:
            min_r = r
        else:
            min_r = min(min_r, r)
    else:
        ls[l] -= 1
        rs[r] -= 1
        if rs[r] == 0:
            del rs[r]
            if r == min_r:
                if rs:
                    min_r = min(rs.keys())
                else:
                    {{completion}}
        if ls[l] == 0:
            del ls[l]
            if l == max_l and ls:
                max_l = max(ls.keys())
    ans += ['NO', 'YES'][max_l > min_r] + '\n'
print(ans.rstrip('\n'))",max_l = min_r = -1,"min_r = max_l
        if ls[l] == 0:
            del ls[l]
            if l == max_l and ls:
                max_l = max(ls.keys())
    ans += ['NO', 'YES'][max_l > min_r] + '\n'
print(ans.rstrip('\n'))
<|/ file dstars=0 source=github |>"
"from sys import stdin,stdout
# from os import _exit
from bisect import bisect_left,bisect
# from heapq import heapify,heappop,heappush
# from sys import setrecursionlimit
from collections import defaultdict,Counter
# from itertools import permutations
# from math import gcd,ceil,sqrt,factorial
# setrecursionlimit(int(1e5))
input,print = stdin.readline,stdout.write

q = int(input())
lef = defaultdict(int)
rig = defaultdict(int)
cur = -1
ruc = int(1e9)+5

for _ in range(q):
    t,l,r = list(map(str,input().split()))
    l,r = int(l),int(r)
    pos = True
    if t=='+':
        cur = max(cur,l)
        ruc = min(ruc,r)
        lef[l]+=1
        rig[r]+=1
    else:
        lef[l]-=1
        rig[r]-=1
        if lef[l]==0:
            lef.pop(l)
            if l>=cur:
                {{completion}}
        if rig[r]==0:
            rig.pop(r)
            if r<=ruc:
                ruc = min(rig.keys(),default = int(1e9)+5)
    
    ans = ""YES"" if cur>ruc else ""NO""
    print(str(ans)+""\n"")
","cur = max(lef.keys(),default = 0)","cur = max(lef.keys(),default = int(1e9)+5)"
"import sys
input = sys.stdin.readline


for _ in range(int(input())):
    n, m = map(int, input().split())
    a = sorted(map(int, input().split()))
    b = sorted(map(int, input().split()))
    x, i, j, c = 0, 0, 0, 0
    while j < n and i < n-1:
        if b[j] > a[i]:
            i += 1
        else:
            {{completion}}
        j += 1
    if x == 0:
        x = b[-1]
        c += 1
    a = min(x-1, m)
    b = m-a
    print((c-1)*a + c*b)","x = b[j]
            c += 1","j += 1
    if x == 0:
        x = b[-1]
        c += 1
    a = min(x-1, m)
    b = m-a
    print((c-1)*a + c*b)
<|/ a tags=python,algorithm |>"
"import sys

def Solve(n, m, a, b):
    i, j = 0, 0
    ans = 0
    pos = -1
    # binary search
    while i < n-1 and j < n:
        if a[i] >= b[j]:
            pos = j
            j += 1
        else:
            {{completion}}
    ans = n-1-i
    if pos == -1:
        pos = j
    sys.stdout.write(str(min(b[pos]-1, m)*ans + max((m-b[pos]+1), 0)*(ans+1))+'\n')

if __name__ == '__main__':
    t = int(sys.stdin.readline())
    for _ in range(t):
        n, m = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        b = list(map(int, sys.stdin.readline().split()))
        a.sort()
        b.sort()
        Solve(n, m, a, b)","i += 1
            j += 1","i += 1
    if pos == -1:
        pos = j
    ans = n-1-i
    if pos == -1:
        pos = j
    sys.stdout.write(str(min(b[pos]-1, m)*ans + max((m-b[pos]+1), 0)*(ans+1))+'\n')

def Solve(n, m, a, b):
    i, j = 0, 0
    ans = 0
    pos = -1
    while i < n-1 and j < n:
        if a[i] >= b[j]:
            pos = j
            j += 1
        else:
            i += 1
    if pos == -1:
        pos = j
    ans = n-1-i
    if pos == -1:
"
"from sys import stdin, stdout

t = int(stdin.readline())

for _ in range(t):
    n, m = [int(x) for x in stdin.readline().split()]
    a = [int(x) for x in stdin.readline().split()]
    b = [int(x) for x in stdin.readline().split()]
    a.sort()
    b.sort()

    answer = 0
    p1 = 0
    p2 = 0
    bstar = -1
    while p2 < n:
        if p1 == n-1:
            answer += 1
            bstar = b[p2]
            break
        elif a[p1] >= b[p2]:
            {{completion}}
        else:
            p1 += 1
            p2 += 1

    real_answer = answer*m - min(m,(bstar-1))

    stdout.write(str(real_answer)+'\n')
","bstar = b[p2]
            answer += 1
            p2 += 1","answer += 1
            bstar = b[p2]
            p1 += 1
            p2 += 1
        elif a[p1] < b[p2]:
            answer += 1
            bstar = b[p2]
            p1 += 1
            p2 += 1"
"import sys

input = sys.stdin.readline


def best(times):  # from cses
    arr = []
    for s, e in times:
        arr.append(s * 2)
        arr.append(e * 2 + 1)
    arr.sort()  # tuple sort is slow in python, so we should just assign the last bit and sort.
    ans = 0
    curr = 0
    for i in arr:
        if i % 2 == 0:  # arrive, so we add.
            curr += 1
        else:
            {{completion}}
        ans = max(ans, curr)
    return ans


def solve(n, m, arr):
    a = [x for x in arr if x[0] != 1]
    b = [x for x in arr if x[1] != m]
    print(max(best(a), best(b)))


def main():
    t = int(input())
    for _ in range(t):
        n, m = list(map(int, input().split()))
        arr = [list(map(int, input().split())) for _ in range(n)]
        solve(n, m, arr)


main()
",curr -= 1,curr -= 1
"# https://codeforces.com/contest/1884

import sys
import random

input = lambda: sys.stdin.readline().rstrip()  # faster!
RAND64 = random.getrandbits(64)  # anti-hacking!
# RAND64 = 0


def solve_case():
    n, m = map(int, input().split())  # 1 <= n <= 10**5, 1 <= m <= 10**9
    l, r, x = [-1] * n, [-1] * n, {1, m + 1}
    for i in range(n):
        li, ri = map(int, input().split())
        l[i] = li
        r[i] = ri
        x |= {li, ri + 1}

    # coordiate compression
    x = sorted(x)
    idx_map = {xi ^ RAND64: i for i, xi in enumerate(x)}
    mm = len(idx_map)

    # print(l)
    # print(r)
    # print(x)
    # print(idx_map)

    # [l, r)
    l = [idx_map[li ^ RAND64] for li in l]
    r = [idx_map[(ri + 1) ^ RAND64] for ri in r]

    # print(l)
    # print(r)

    cnt1 = [0] * mm
    for i in range(n):
        if l[i] > 0:
            {{completion}}
    for i in range(1, mm):
        cnt1[i] += cnt1[i - 1]

    cnt2 = [0] * mm
    for i in range(n):
        if r[i] < mm - 1:
            cnt2[l[i]] += 1
            cnt2[r[i]] -= 1
    for i in range(1, mm):
        cnt2[i] += cnt2[i - 1]

    ans = max(max(cnt1), max(cnt2))
    print(ans)


for _ in range(int(input())):
    solve_case()
","cnt1[l[i]] += 1
            cnt1[r[i]] -= 1","cnt1[l[i]] += 1
            cnt1[r[i]] -= 1"
"import sys
def main():
    input = sys.stdin.readline
    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        a, b = [[0], [0]], [[0], [0]]
        for _ in range(n):
            l, r = map(int, input().split())
            if l > 1:
                {{completion}}
            if r < m:
                b[0].append(l)
                b[1].append(r)
        a[0].sort()
        a[1].sort()
        ans_a = ans_b = 0
        cnt = 0
        while a[0][-1] or a[1][-1]:
            k = max(a[0][-1], a[1][-1])
            while a[1][-1] == k:
                cnt += 1
                a[1].pop()
            ans_a = max(ans_a, cnt)
            while a[0][-1] == k:
                cnt -= 1
                a[0].pop()
        b[0].sort()
        b[1].sort()
        cnt = 0
        while b[0][-1] or b[1][-1]:
            k = max(b[0][-1], b[1][-1])
            while b[1][-1] == k:
                cnt += 1
                b[1].pop()
            ans_b = max(ans_b, cnt)
            while b[0][-1] == k:
                cnt -= 1
                b[0].pop()
        print(max(ans_a, ans_b))
main()","a[0].append(l)
                a[1].append(r)","a[0].append(l)
                a[1].append(r)
            if r > m:
                b[0].append(l)
                b[1].append(r)
        a[0].sort()
        a[1].sort()
        ans_a = ans_b = 0
        cnt = 0
        while a[0][-1] or a[1][-1]:
            k = max(a[0][-1], a[1][-1])
            while a[1][-1] == k:
                cnt += 1
                a[1].pop()
            ans_a = max(ans_a, cnt)
            while a[0][-1] == k:
                cnt -= 1
                a[0].pop()
        b[0].sort()
        b[1].sort()
        cnt = 0
        while b[0][-1] or b[1][-1]:
"
"import sys
input = sys.stdin.readline


for _ in range(int(input())):
    n = int(input())
    w = list(map(int, input().split()))
    d = [0]*(n+1)
    for i in range(n-1, -1, -1):
        a = w[i] + i + 1
        if a > n:
            d[i] = d[i+1] + 1
        else:
            {{completion}}
    print(d[0])
","d[i] = min(d[i+1]+1, d[a])","j = i
            while j > 0 and w[j-1] > a:
                j -= 1
            d[i] = min(j+1, d[i+1])"
"import sys
input=sys.stdin.buffer.readline
def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input()
def rm():
    return map(int,input().split())

def main():
    n=ri()
    a=rl()
    dp=[n]*(n+1);dp[-1]=0
    for i in range(n-1,-1,-1):
        if i+a[i]+1<n+1: {{completion}}
        dp[i]=min(dp[i],1+dp[i+1])
    return dp[0]

t=ri()
for i in range(t):
    print(main())",dp[i]=dp[i+a[i]+1],"dp[i]=min(dp[i],dp[i+a[i]+1])
    for i in range(n-1,-1,-1):"
"import sys;input=sys.stdin.readline
T, = map(int, input().split())
for _ in range(T):
    N, = map(int, input().split())
    X = list(map(int, input().split()))
    dp = [0]*(N+1)
    for i in range(N-1,-1,-1):
        dp[i] = dp[i+1]+1
        if i+X[i]+1 > N:
            {{completion}}
        dp[i] = min(dp[i], dp[i+X[i]+1])
    print(dp[0])

",continue,"continue 
        if i+X[i]+1 == N:
            dp[i] = dp[i]+1
            continue
        if i+X[i]+1 > N:
            dp[i] = dp[i]+1
            continue"
"N = 1550
n = int(input())
vec = [[] for _ in range(3)]
contador1 = [0] * (4 * N + 10)
contador2 = [0] * (4 * N + 10)
pila = []

for _ in range(n):
    tipo, segundos = map(int, input().split())
    if tipo >= 3:
        tipo = 0
    vec[tipo].append(segundos)

vec[0].sort(reverse=True)

encontrarRespuesta = False
total = n

for pos in range(1, 2 * n + 6):
    contador1 = [0] * (4 * N + 10)
    contador2 = [0] * (4 * N + 10)

    while vec[0] and vec[0][-1] <= pos:
        segundos = vec[0].pop()
        vec[1].append(segundos)
        vec[2].append(segundos)

    total = sum(len(vec[tipo]) for tipo in range(3))

    for segundos in vec[1]:
        contador1[pos + segundos - 1] += 1

    for segundos in vec[2]:
        if segundos < pos:
            contador2[segundos] += 1
        else:
            contador2[segundos - 1] += 1

    valido = True
    suma1 = 0

    for i in range(pos):
        suma1 += contador2[i]

        if suma1 > i:
            valido = False
            break

    if not valido:
        continue

    tipo2 = 0
    suma2 = 0
    pila = [0] * n
    top = 0
    cur = len(vec[0]) - 1

    for i in range(1, 4 * N + 11):
        suma2 += contador1[pos + i - 1] + contador2[pos + i - 1]
        tipo2 += contador2[pos + i - 1]

        while cur >= 0 and vec[0][cur] == pos + i:
            pila[top] = vec[0][cur]
            top += 1
            cur -= 1

        while suma2 + top > i and 1 + suma1 < pos:
            if suma1 + suma2 + top <= i + pos - 1 and tipo2 > 0:
                tipo2 -= 1
                suma2 -= 1
                suma1 += 1
            else:
                if top <= 0 or pila[top - 1] <= i:
                    {{completion}}
                suma1 += 1
                contador1[pos + pila[top - 1] - 1] += 1
                top -= 1
                total += 1

        if suma2 + top > i:
            valido = False
            break

        if suma2 + suma1 + top == total:
            encontrarRespuesta = True
            break

    if not valido:
        continue

    if encontrarRespuesta:
        print(2 + total)
        break

if not encontrarRespuesta:
    print(-1)
",break,"valido = False
                    break
                else:
                    pila[top - 1] -= 1"
"MAX_N = 1550
numero_camaras = int(input())
grupos_camaras = [[] for _ in range(3)]
contadores1 = [0] * (4 * MAX_N + 10)
contadores2 = [0] * (4 * MAX_N + 10)
pila_segundos = []

for _ in range(numero_camaras):
    tipo, tiempo = map(int, input().split())
    if tipo >= 3:
        tipo = 0
    grupos_camaras[tipo].append(tiempo)

grupos_camaras[0].sort(reverse=True)

respuesta_encontrada = False
total_camaras = numero_camaras

for posicion in range(1, 2 * numero_camaras + 6):
    contadores1 = [0] * (4 * MAX_N + 10)
    contadores2 = [0] * (4 * MAX_N + 10)

    while grupos_camaras[0] and grupos_camaras[0][-1] <= posicion:
        tiempo = grupos_camaras[0].pop()
        grupos_camaras[1].append(tiempo)
        grupos_camaras[2].append(tiempo)

    total_camaras = sum(len(grupos_camaras[tipo]) for tipo in range(3))

    for tiempo in grupos_camaras[1]:
        contadores1[posicion + tiempo - 1] += 1

    for tiempo in grupos_camaras[2]:
        if tiempo < posicion:
            contadores2[tiempo] += 1
        else:
            contadores2[tiempo - 1] += 1

    es_valido = True
    suma_1 = 0

    for i in range(posicion):
        suma_1 += contadores2[i]
        if suma_1 > i:
            es_valido = False
            break

    if not es_valido:
        continue

    tipo_2 = 0
    suma_2 = 0
    pila_segundos = [0] * numero_camaras
    tope = 0
    actual = len(grupos_camaras[0]) - 1

    for i in range(1, 4 * MAX_N + 11):
        suma_2 += contadores1[posicion + i - 1] + contadores2[posicion + i - 1]
        tipo_2 += contadores2[posicion + i - 1]

        while actual >= 0 and grupos_camaras[0][actual] == posicion + i:
            pila_segundos[tope] = grupos_camaras[0][actual]
            tope += 1
            actual -= 1

        while suma_2 + tope > i and 1 + suma_1 < posicion:
            if suma_1 + suma_2 + tope <= i + posicion - 1 and tipo_2 > 0:
                tipo_2 -= 1
                suma_2 -= 1
                suma_1 += 1
            else:
                if tope <= 0 or pila_segundos[tope - 1] <= i:
                    {{completion}}
                suma_1 += 1
                contadores1[posicion + pila_segundos[tope - 1] - 1] += 1
                tope -= 1
                total_camaras += 1

        if suma_2 + tope > i:
            es_valido = False
            break

        if suma_2 + suma_1 + tope == total_camaras:
            respuesta_encontrada = True
            break

    if not es_valido:
        continue

    if respuesta_encontrada:
        print(2 + total_camaras)
        break

if not respuesta_encontrada:
    print(-1)

		     	  		 	 	  		 	 	 						",break,"tipo_2 += 1
                    suma_2 += 1
                    suma_1 += 1
                else:
                    tipo_2 += 1
                    suma_2 += 1"
"N = 1550
n = int(input())
vec = [[] for _ in range(3)]
contador1 = [0] * (4 * N + 10)
contador2 = [0] * (4 * N + 10)
pila = []

for _ in range(n):
    tipo, segundos = map(int, input().split())
    if tipo >= 3:
        tipo = 0
    vec[tipo].append(segundos)

vec[0].sort(reverse=True)

encontrarRespuesta = False
total = n

for pos in range(1, 2 * n + 6):
    contador1 = [0] * (4 * N + 10)
    contador2 = [0] * (4 * N + 10)

    while vec[0] and vec[0][-1] <= pos:
        segundos = vec[0].pop()
        vec[1].append(segundos)
        vec[2].append(segundos)

    total = sum(len(vec[tipo]) for tipo in range(3))

    for segundos in vec[1]:
        contador1[pos + segundos - 1] += 1

    for segundos in vec[2]:
        if segundos < pos:
            contador2[segundos] += 1
        else:
            contador2[segundos - 1] += 1

    valido = True
    suma1 = 0

    for i in range(pos):
        suma1 += contador2[i]

        if suma1 > i:
            valido = False
            break

    if not valido:
        continue

    tipo2 = 0
    suma2 = 0
    pila = [0] * n
    top = 0
    cur = len(vec[0]) - 1

    for i in range(1, 4 * N + 11):
        suma2 += contador1[pos + i - 1] + contador2[pos + i - 1]
        tipo2 += contador2[pos + i - 1]

        while cur >= 0 and vec[0][cur] == pos + i:
            pila[top] = vec[0][cur]
            top += 1
            cur -= 1

        while suma2 + top > i and 1 + suma1 < pos:
            if suma1 + suma2 + top <= i + pos - 1 and tipo2 > 0:
                tipo2 -= 1
                suma2 -= 1
                suma1 += 1
            else:
                if top <= 0 or pila[top - 1] <= i:
                    {{completion}}
                suma1 += 1
                contador1[pos + pila[top - 1] - 1] += 1
                top -= 1
                total += 1

        if suma2 + top > i:
            valido = False
            break

        if suma2 + suma1 + top == total:
            encontrarRespuesta = True
            break

    if not valido:
        continue

    if encontrarRespuesta:
        print(2 + total)
        break

if not encontrarRespuesta:
    print(-1)

 		    	 			 	  			    	 	 		",break,"valido = False
                    break
                else:
                    tipo2 -= 1"
"import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n = int(input())
    m = [input().rstrip() for i in range(n)]
    answer = 0
    for i in range(n//2):
        for j in range(i, n - i - 1):
            arr = [m[j][i], m[i][n - j - 1], m[n-i-1][j], m[n-1-j][n - 1 - i]]
            arr.sort()
            for l in arr:
                {{completion}}
    print(answer)",answer += ord(arr[3]) - ord(l),"answer += 1
                if l == ""z"":
                    answer -= 1"
"def solve(n, A):
    ans = 0
    for i in range(n // 2):
        for j in range(n // 2):
            M = [ord(A[i][j]), ord(A[n - 1 - j][i]), ord(A[n - 1 - i][n - 1 - j]), ord(A[j][n - 1 - i])]
            c = max(M)
            for e in M:
                {{completion}}
    return ans

def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        A = [input() for _ in range(n)]
        print(solve(n, A))

if __name__ == ""__main__"":
    main()

",ans += c-e,ans += e - c
"#sys.stdin.readline().strip()
#sys.stdout.write(str()+""\n"")
#sys.stdout.write(""Yes\n"")

import math
import sys


S = []

for lol in range(int(sys.stdin.readline().strip())):
	n=int(sys.stdin.readline().strip())
	A=[]
	for _ in range(n):
		A.append(sys.stdin.readline().strip())
    
	ope = 0
    
	for i in range(n//2):
		for j in range(n//2):
			{{completion}}
	S.append(str(ope))
    
sys.stdout.write(""\n"".join(S))



    
    
","a, b, c, d = ord(A[i][j]), ord(A[j][-i-1]), ord(A[-i-1][-j-1]), ord(A[-1-j][i])
			ope += 4*max([a,b,c,d])-(a+b+c+d)","ope = ope + math.floor((A[i][j]-A[n//2-i][n//2-j])/math.sqrt(2))
    "
"import sys

input = sys.stdin.readline
mod = 998244353
for _ in range(int(input())):
    n = list(input())
    ans = 1
    total = 0
    temp = 1
    now = '2'
    for i in range(len(n)):
        if n[i] != now:
            ans *= temp
            temp = 1
            now = n[i]
        else:
            {{completion}}
        ans %= 998244353
    ans *= temp
    print(total, ans)
","temp += 1
            total += 1
            ans *= total","temp = temp * 2
            now -= 1
        total += ans
        if now == 0:
            ans *= temp
            temp = 1
            now = '2'
    ans *= temp
    ans %= mod
    temp = 1
    now = '3'
    for i in range(len(n)):
        if n[i] != now:
            ans *= temp
            temp = 1
            now = n[i]
        else:
            temp = temp * 2
            now -= 1
        total += ans
        if now == 0:
            ans *= temp
            temp = 1
            now = '3'"
"T=int(input())
mod=998244353
import sys

while T>0:
    T-=1

    s=sys.stdin.readline().rstrip()
    flag=-1
    ans1=0
    bt=0
    ans2=1
    for i in range(len(s)):
        if flag!=int(s[i]):
            flag=int(s[i])
            ans1+=bt
            ans2*=(bt+1)
            ans2%=mod
            bt=0
        else:
            {{completion}}
    ans1+=bt
    ans2*=(bt+1)
    ans2%=mod
    ans3=1
    for i in range(1,ans1+1):
        ans3*=i
        ans3%=mod
    ans=ans3*ans2
    ans%=mod
    sys.stdout.write(str(ans1)+' '+str(ans)+'\n')



",bt+=1,"bt+=1
    ans2%=mod"
"import sys
import math
input = sys.stdin.readline

t = int(input())
for __ in range(t):
    s = input()
    ans = 1
    count = 1
    segs = 1
    look = s[0]
    for i in range(1, len(s)):
        if s[i] == look:
            count += 1
        else:
            {{completion}}
    if count > 1:
        segs += 1
        ans *= count
        ans %= 998244353
    for i in range(1, len(s) - segs + 1):
        ans *= i
        ans %= 998244353
    print(str(len(s) - segs) + "" "" + str(ans % 998244353))","segs += 1
            ans *= count
            ans %= 998244353
            count = 1
            look = s[i]","count += 1
            look = s[i]"
"from sys import stdin, stdout
n, m = map(int, stdin.readline().split())
s = bytearray(stdin.readline().encode())
A = 1
for i, c in enumerate(s):
    if i and c == ord('?'):
        {{completion}}
stdout.write('0\n' if s[0] == ord('?') else f'{A}\n')
for line in stdin:
    i, c = line.split()
    i = int(i) - 1
    if i and s[i] == ord('?'):
        A = A * pow(i, -1, 998244353) % 998244353
    s[i] = ord(c)
    if i and s[i] == ord('?'):
        A = A * i % 998244353
    stdout.write('0\n' if s[0] == ord('?') else f'{A}\n')",A = A * i % 998244353,"A = A * pow(i, -1, 998244353) % 998244353
    s[i] = ord(c)
    if i and c == ord('?'):
        A = A * i % 998244353"
"import sys
input = sys.stdin.readline

N = 998244353
def inv(k):
    if k == 1:
        return 1
    else:
        pow = N - 2
        ans = 1
        while pow != 0:
            if pow % 2 == 1:
                {{completion}}
            k **= 2
            k %= N
            pow //= 2
        return ans

n, m = [int(i) for i in input().split()]
n -= 1
s = input()[:-1]
p = [i if s[i] == '?' else 1 for i in range(n)]
ans = 1
for i in range(1, n):
    ans *= p[i]
    ans %= N
print(ans*p[0])
for _ in range(m):
    i, c = input().split()
    i = int(i) - 1
    if i != 0:
        ans *= inv(p[i])
        p[i] = i if c == '?' else 1
        ans *= p[i]
        ans %= N
    else:
        p[i] = i if c == '?' else 1
    print(ans*p[0])
","ans *= k
                ans %= N","ans *= k
                ans %= N
            pow //= 2
            ans *= k
            ans %= N"
"n = int(input())
score = [[0] * 10 for _ in range(10)]
for i in range(10):
  for j in range(10):
    score[i][j] = min(i, j, 9 - i, 9 - j) + 1
def func(i, nums):
  res = 0
  for j in range(10):
    if nums[j] == 'X':
      {{completion}}
  return res
for _ in range(n):
  res = 0
  for i in range(10):
    nums = input()
    res += func(i, nums)
  print(res)
	 	  	  	  	  	  	 			 	      	",res += score[i][j],"res += score[i][j]
    else:
      res += score[i][j] * (j - i)"
"N = int(input())
for i in range(N):
    A = []
    for _ in range(10):
        A.append(input())
    score = 0
    for x in range(5):
        for y in range(x, 9 - x):
            if A[x][y] == ""X"":
                {{completion}}
            if A[y][9-x] == ""X"":
                score += (x + 1)
            if A[9-y][x] == ""X"":
                score += (x + 1)
            if A[9-x][9-y] == ""X"":
                score += (x + 1)
    print(score)
        
",score += (x + 1),"score += (x + 1)
            if A[y][x] == ""X"":
                score += (x + 1)"
"def solve():
    matrix = [list(input()) for _ in range(10)]
    points = 0
    i, j = 0, 9
    while i < j:
        movei = movej = i
        while movej < j:
            {{completion}}
        while movei < j:
            points += (matrix[movei][movej] == ""X"") * (i + 1)
            movei += 1
        while movej > i:
            points += (matrix[movei][movej] == ""X"") * (i + 1)
            movej -= 1
        while movei > i:
            points += (matrix[movei][movej] == ""X"") * (i + 1)
            movei -= 1
        i += 1
        j -= 1
    print(points)


def main():
    t = 1
    t = int(input())
    for _ in range(t):
        solve()


if __name__ == ""__main__"":
    # Talk is cheap. Show me the code. — Linus Torvalds
    main()
","points += (matrix[movei][movej] == ""X"") * (i + 1)
            movej += 1","points += (matrix[movei][movej] == ""X"") * (i + 1)
            movej += 1"
"import sys
input = sys.stdin.readline
mod = 998244353

for _ in range(int(input())):
    N, M = map(int, input().split())
    A0 = list(map(int, input().split()))
    B = list(map(int, input().split()))

    assert M == 1
    A = [1] + A0
    A.sort()
    B.sort()
    j = 0
    for i in range(N):
        if B[i] > A[j]:
            {{completion}}
    print(N - j)
",j += 1,"j += 1
        else:
            A[j], A[i] = A[i], A[j]
            B[j], B[i] = B[i], B[j]
            j += 1
    A.sort()
    B.sort()
    
    k = j
    
    for i in range(N):
        if B[i] > A[k]:
            k += 1
        else:
            A[k], A[i] = A[i], A[k]
            B[k], B[i] = B[i], B[k]
            k += 1
    
    A.sort()
    B.sort()
    
    ans = 0
    
    for i in range(1, k + 1):
        ans += (i - 1) * N
        ans += N - i
"
"import sys

R = lambda:map(int, sys.stdin.readline().rstrip().split())

def solve():
    n, m = R()
    lstA = list(R()) + [1]
    lstB = list(R())
    lstA.sort()
    lstB.sort()
    #print(lstA)
    #print(lstB)
    i = 0
    j = n - 1
    k = 0
    ans = 0
    while i <= j:
        #print(i, j, k)
        if lstA[k] >= lstB[i]:
            i += 1
            j -= 1
            ans += 1
        else:
            {{completion}}
    while k <= j:
        #print(i, j, k)
        if lstA[k] >= lstB[i]:
            i += 1
            j -= 1
            ans += 1
        else:
            k += 1
            i += 1
    print(ans)

t ,= R()
for _ in range(t):
    solve()
","k += 1
            i += 1","k += 1
            i += 1
    j = 0
    k = n - 1
    ans = 0"
"# ﷽
import sys
input = lambda: sys.stdin.readline().strip()
def inlst():return [int(i) for i in input().split()]
oo=float('inf')

def solve():
    n,m=inlst()
    a=[1]+sorted(inlst())
    b=sorted(inlst())
    i=0
    for j in range(n):
        if a[i]<b[j]:{{completion}}
    

     
    print(n-i)

    

def main():
    for i in range(int(input())):
        solve()


if __name__ == ""__main__"":
    main()
",i+=1,"
            i+=1
            a.insert(i,a.pop(a[j]))
            b.insert(i,b.pop(b[j]))
        else:
            i+=1
            a.insert(i,a.pop(a[j]))
            b.insert(i,b.pop(b[j]))
            
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys
import math

# region fastio
input = lambda: sys.stdin.readline().rstrip()
sint = lambda: int(input())
mint = lambda: map(int, input().split())
ints = lambda: list(map(int, input().split()))
# endregion fastio

# MOD = 998_244_353
# MOD = 10 ** 9 + 7
# DIR4 = ((-1, 0), (0, 1), (1, 0), (0, -1)) #URDL
# DIR8 = ((-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1))

def solve() -> None:
    n, t = mint()
    g = [[] for _ in range(n)]
    for i in range(t):
        m = sint()
        for _ in range(m):
            u, v = mint()
            u -= 1
            v -= 1
            g[u].append((v, i))
            g[v].append((u, i))

    k = sint()
    times = ints()

    dis = [math.inf] * n
    dis[0] = 0
    point = [set() for _ in range(t)]
    for y, i in g[0]:
        point[i].add(y)
    
    for i, t in enumerate(times, 1):
        t -= 1
        if not point[t]: continue
        p = point[t].copy()
        point[t].clear()
        for x in p:
            if dis[x] < i: {{completion}}
            dis[x] = i
            for y, j in g[x]:
                point[j].add(y)
    
    print(-1 if dis[-1] == math.inf else dis[-1])

solve()",continue,continue
"import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log, log2, pi, ceil
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from heapq import *
from collections import deque, Counter as ctr


inp = lambda: int(stdin.readline().strip())
strng = lambda: stdin.readline().strip()
jn = lambda x, l: x.join(map(str, l))
strl = lambda: list(stdin.readline().strip())
mul = lambda: map(int, stdin.readline().strip().split())
mulf = lambda: map(float, stdin.readline().strip().split())
seq = lambda: list(map(int, stdin.readline().strip().split()))

ceildiv = lambda x, d: -(x // -d)

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))

mod = 998244353


def main():
    [n, t] = seq()
    adj = [[] for _ in range(n)]
    for i in range(t):
        for _ in range(inp()):
            [a, b] = seq()
            a -= 1
            b -= 1
            adj[a].append((b, i))
            adj[b].append((a, i))
    k = inp()

    dis = [-1] * n
    dis[0] = 0
    ed = [[] for _ in range(t)]
    for nei, ti in adj[0]:
        ed[ti].append(nei)

    for r, time in enumerate(mul()):
        time -= 1
        neis = ed[time]
        ed[time] = []
        for ne in neis:
            if dis[ne] > -1:
                {{completion}}
            dis[ne] = r + 1
            for nei, ti in adj[ne]:
                ed[ti].append(nei)
        
        
    return dis[-1]


MULT = False
rg = inp() if MULT else 1

for i in range(rg):
    ret = main()
    if ret is not None:
        if isinstance(ret, tuple) or isinstance(ret, list):
            print(*ret)
        else:
            print(ret)",continue,"dis[ne] = r + 1
                for nei, ti in adj[ne]:
                    ed[ti].append(nei)
            else:
                dis[ne] = -1
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"from sys import stdin
input = lambda: stdin.readline().rstrip('\r\n')
from math import inf

n, t = map(int, input().split())
g = [[] for _ in range(n+1)]

for i in range(t):
    for _ in range(int(input())):
        u, v = map(int, input().split())
        g[u] += [(v, i)]
        g[v] += [(u, i)]

k = int(input())
a = list(map(lambda x: int(x)-1, input().split()))
f = [[] for _ in range(t)]
for i in range(k, 0, -1):
    f[a[i-1]].append(i)

time = [inf]*(n+1)
time[1] = 0
pq = [[] for _ in range(k+1)]
pq[0] = [1]

for t in range(k+1):
    for u in pq[t]:
        for v, tl in g[u]:
            while f[tl] and f[tl][-1] <= t: {{completion}}
            if f[tl] and time[v] > f[tl][-1]:
                time[v] = f[tl][-1]
                pq[time[v]] += [v]

print(time[-1] if time[-1] < inf else -1)",f[tl].pop(),tl -= 1
"for i in range(int(input())):
    n, k = map(int, input().split())
    s = input()
    count = 0
    i = 0
    while i < n:
        if s[i] == 'B':
            i += k
            count += 1
        else:
            {{completion}}
    print(count)",i += 1,i += 1
"def solve(s, n, k):
    cnt, i = 0, 0
    while i < n:
        if s[i] == ""B"":
            cnt += 1
            i += k
        else:
            {{completion}}
    return cnt

def main():
    ans = []
    t = int(input())
    for _ in range(t):
        n, k = input().split()
        n, k = int(n), int(k)
        s = input().strip()
        ans.append(solve(s, n, k))
    for i in ans:
        print(i)

if __name__ == ""__main__"":
    main()",i += 1,"cnt -= 1
            i += k"
"for _ in range(int(input())):
	n,k=[int(i) for i in input().split()]
	s=input()
	a=0
	x=n-1
	while x>=0:
		if s[x]=='B':
			a+=1
			x-=k
		else:
			{{completion}}
	print(a)",x-=1,x+=1
"import sys
input = sys.stdin.readline
mod = 998244353


# max
def STfunc(a, b):
    if a > b:
        return a
    else:
        return b

# クエリは0-indexedで[l, r)
class SparseTable():
    def __init__(self, A, Nmax=-1):
        # A: 処理したい数列
        # Nmax: （Aの長さ + appendを呼ぶ回数）以上の値
        if Nmax == -1:
            self.N = len(A)
        else:
            self.N = Nmax
        self.N_cur = len(A)
        self.K = self.N.bit_length() - 1
        self.table = [0] * (self.N * (self.K + 1))
        for i, a in enumerate(A):
            self.table[i] = a
        for k in range(1, self.K + 1):
            for i in range(self.N_cur):
                j = i - (1 << (k-1))
                if j >= 0:
                    self.table[i + k * self.N] = STfunc(self.table[i + (k - 1) * self.N], self.table[j + (k - 1) * self.N])

    def query(self, l, r):
        # [l, r)の最小値を求める
        assert r <= self.N_cur
        k = (r-l).bit_length() - 1
        return STfunc(self.table[r - 1 + k * self.N], self.table[l + (1 << k) - 1 + k * self.N])

    def append(self, val):
        i = self.N_cur
        self.table[i] = val
        for k in range(1, self.K + 1):
            j = i - (1 << (k-1))
            if j >= 0:
                self.table[i + k * self.N] = STfunc(self.table[i + (k - 1) * self.N], self.table[j + (k - 1) * self.N])
        self.N_cur += 1


for _ in range(int(input())):
    N, M, K = map(int, input().split())
    LR = []
    for _ in range(M):
        l, r = map(int, input().split())
        LR.append((l, r))

    ev = [[] for _ in range(N + 2)]
    for j, (l, r) in enumerate(LR):
        ev[l].append((j, 1))
        ev[r + 1].append((j, -1))

    ST_list = [SparseTable([0], Nmax=N + 1) for _ in range(K + 1)]

    dp = [[-10 ** 9] * (N+1) for _ in range(K + 1)]
    dp[0][0] = 0
    ans = 0
    seg_set = set()
    for i in range(1, N + 1):
        for j, flg in ev[i]:
            if flg == 1:
                seg_set.add(j)
            else:
                seg_set.discard(j)
        if len(seg_set) <= K:
            l_set = {0, i}
            l_cnt = {0: 1, i: 1}
            for j in seg_set:
                l = LR[j][0]
                l_set.add(l)
                if l not in l_cnt:
                    l_cnt[l] = 0
                l_cnt[l] += 1
            l_list = sorted(list(l_set))

            x = len(seg_set)
            seg_dict = {x: (0, l_list[1])}
            for jj in range(1, len(l_list) - 1):
                l = l_list[jj]
                x -= l_cnt[l]
                seg_dict[x] = (l, l_list[jj + 1])
            for k_add in range(K + 1):
                if k_add not in seg_dict:
                    continue
                ll, rr = seg_dict[k_add]
                for k in range(K + 1):
                    k_new = k + k_add
                    if k_new > K:
                        {{completion}}
                    dp[k_new][i] = max(dp[k_new][i], ST_list[k].query(ll, rr) + 1)
        for k in range(K + 1):
            ST_list[k].append(dp[k][i])

    ans = 0
    for k in range(K + 1):
        for i in range(N + 1):
            ans = max(ans, dp[k][i])
    print(ans)
",break,"k_new = K
                    if k_new < 1:
                        k_new = 1"
"
for s in[*open(0)][1:]:{{completion}}","a,b,c=sorted(map(int,s.split()));print('YNEOS'[b/a+c/a>5or
b%a+c%a>0::2])","
    s=s.split()
    a,b,c=int(s[0]),int(s[1]),int(s[2])
    if a==b==c:
        print(""YES"")
    else:
        print(""NO"")
<|/ file ext=.py |>"
for s in[*open(0)][1:]:{{completion}},"a,b,c=sorted(map(int,s.split()));print('YNEOS'[b/a+c/a>5or
b%a+c%a>0::2])","
    s=s.split()
    a,b,c=int(s[0]),int(s[1]),int(s[2])
    if a==b==c:
        print(""YES"")
    else:
        print(""NO"")

<|/ file source=github ext=.py |>"
"import sys
def main():
    input = sys.stdin.readline
    modulo = 10**9+7
    t = int(input())
    a = [0, 0]
    b = [0, 0]
    tmp = 4
    for i in range(2, 61):
        j = -1
        cpy = tmp
        while cpy:
            {{completion}}
        a.append(j)
        tmp <<= 1
        b.append(tmp2 if (tmp2 := i**(j+1)) < tmp else 0)
    c = [0]
    for i in range(1, 61):
        tmp = (1 << i)*a[i]
        if b[i]:
            tmp += (1 << (i+1))-b[i]
        c.append((c[-1]+tmp) % modulo)
    def get(x):
        cpy = x
        i = -1
        while cpy:
            cpy >>= 1
            i += 1
        ret = c[i]-((1 << (i+1))-x)*a[i]
        if b[i]:
            ret -= (1 << (i+1))-max(x, b[i])
        return ret
    for _ in range(t):
        l, r = map(int, input().split())
        print((get(r+1)-get(l)) % modulo)
main()","cpy //= i
            j += 1","j = j+1
            cpy >>= 1
        tmp2 = tmp"
"import sys
from collections import Counter
def Q(): return map(int, sys.stdin.readline().split())

def f(s, t):
    ans = 0
    while s>=t:
        s //= t
        ans += 1
    return ans

MOD = 10**9+7
res = Counter()
for i in range(2, 60):
    a = f(1<<i, i)
    res[1<<i] = a  # g 为 a+1 的起始点
    t = i**(a+1)
    if t < 1 << i+1:
        # t 在 i 的区间内 [1<<i, 1<<i+1)
        res[t] = a+1

res = sorted(res.items())
path = [res[0]]
for i in range(1, len(res)):
    x,y = res[i]
    if y != path[-1][1]:
        path.append(res[i])
path.append((10**18+1, 10))  # 尾部加个哨兵
    
for _ in range(int(sys.stdin.readline())):
    l, r = Q()
    ans = 0
    n = len(path)
    for i in range(n-1):
        x,y = path[i]
        t1, t2 = path[i+1]
        if t1 <= l: {{completion}}
        ans += (min(t1, r+1) - max(l, x)) * y
        ans %= MOD
        if t1 > r:
            break
    print(ans)",continue,"continue
        if t2 <= r: continue
        t1 = t1 & t"
"import sys
from heapq import heappush, heappop
from bisect import bisect_right
input = sys.stdin.readline
MOD = 10 ** 9 + 7
mx = 10 ** 18 + 1

def g(x):
    f = (x).bit_length() - 1
    z = 1
    while f ** (z + 1) <= x:
        {{completion}}
    return z


# for i in [X[j], X[j + 1]), g(i) = G[j]
X = [0, 4, 8, 9]
G = [0, 2, 1, 2]

h = []
for k in range(4, 60):
    heappush(h, 1 << k)
    for z in range(2, 11):
        heappush(h, k ** z)

while h:
    x = heappop(h)
    z = g(x)
    if z != G[-1]:
        X.append(x)
        G.append(z)

X.append(mx)
G.append(10)

m = len(X)
P = [0] * m
for i in range(1, m):
    P[i] = (P[i - 1] + (X[i] - X[i - 1]) * G[i - 1]) % MOD


q = int(input())
res = []

for _ in range(q):
    l, r = map(int, input().split())

    ans = 0
    j = bisect_right(X, r)
    ans += P[j] - G[j - 1] * (X[j] - r - 1)

    i = bisect_right(X, l)
    ans -= P[i] - G[i - 1] * (X[i] - l)

    ans %= MOD
    res.append(ans)

print(""\n"".join(map(str, res)))",z += 1,"z += 1
    return z


def f(x):
    f = (x).bit_length() - 1
    z = 1
    while f ** (z + 1) <= x:
        z += 1"
"from math import sqrt
from sys import stdin, stdout
inp = lambda : list(map(int,stdin.readline().split()))
t = inp()[0]
while t>0:
    t -= 1
    P = inp()
    A = inp()
    B = inp()
    distOA = sqrt((A[0])**2 + (A[1])**2)
    distOB = sqrt((B[0])**2 + (B[1])**2)
    distPA = sqrt((P[0]-A[0])**2 + (P[1]-A[1])**2)
    distPB = sqrt((P[0]-B[0])**2 + (P[1]-B[1])**2)
    distAB = sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2)
    c = max(min(distPA, distPB), min(distOA, distOB))

    if (min(distPA, distPB) == distPA and min(distOA, distOB) == distOA):
        pass
    elif(min(distPA, distPB) == distPB and min(distOA, distOB) == distOB):
        pass
    else:
        if(distAB > 2*c):
            {{completion}}
    stdout.write(""%0.10f""%c+'\n')

",c =distAB/2,"stdout.write(""%0.10f""%c+'\n')
        else:
            stdout.write(""%0.10f""%c+'\n')
    stdout.flush()"
"import os, sys, math, io
from collections import deque
""""""
from io import BytesIO, IOBase
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)""""""
input = lambda: sys.stdin.readline()[:-1]
mass = lambda: list(map(int, input().strip().split()))


def toFixed(numObj, digits=0):
    return f""{numObj:.{digits}f}""


def solve():
    n, m, k = mass()
    a = [[] for _ in range(n + 1)]
    for i in range(1, m + 1):
        l, r = mass()
        a[l - 1].append(i)
        a[r].append(-i)
    c = [0 for _ in range(m)]
    r = {}
    s = set()
    al = 0
    for i in range(len(a) - 1):
        for j in range(len(a[i])):
            if a[i][j] > 0:
                s.add(a[i][j])
            else:
                {{completion}}
        if len(s) == 0:
            al += 1
        elif len(s) == 1:
            c[list(s)[0] - 1] += 1
        elif len(s) == 2:
            t = list(s)
            t.sort()
            t[0] -= 1
            t[1] -= 1
            r[tuple(t)] = r.get(tuple(t), 0) + 1
    res = 0
    for i in r.keys():
        res = max(res, r[i] + c[i[0]] + c[i[1]])
    c.sort(reverse=True)
    res = max(res, c[0] + c[1])
    print(res + al)


for _ in range(int(input())):
    solve()
",s.remove(-a[i][j]),"a[i][j] = -1
    for i in range(len(a) - 1):
        for j in range(len(a[i])):
            if a[i][j] < 0:
                a[i][j] = 0
    for i in range(len(a)):
        if a[i][-1] < 0:
            a[i][-1] = 0
    for i in range(len(a)):
        if a[i][-1] > 0:
            a[i][-1] = 0
    for i in range(len(a)):
        if a[i][-1] < 0:
            a[i][-1] = 0
    for i in range(len(a)):
        if a[i][-1] > 0:
            a[i][-1] = 0
    for i in range(len(a)):
        if a[i][-1] < 0:
            a[i][-1] = 0
    for i in range(len(a)):
        if a[i][-1] > 0:
            a[i][-1] = 0
    for i in range(len(a)):
        if a[i][-1] < 0:
            a"
"# https://codeforces.com/contest/1890

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


def solve_case():
    n, m, k = map(int, input().split())
    lr = [tuple(map(int, input().split())) for _ in range(m)]

    # amount of rain in each city
    rain = [0] * (n + 2)
    for l, r in lr:
        rain[l] += 1
        rain[r + 1] -= 1
    for i in range(n + 1):
        rain[i + 1] += rain[i]

    # number of rain-free cities
    n_rain_free = sum(1 for i in range(1, n + 1) if rain[i] == 0)

    # cumulative number of cities covered by exactly 1 / 2 rain segments
    rain1_cum = [1 if rain[i] == 1 else 0 for i in range(n + 1)]
    rain2_cum = [1 if rain[i] == 2 else 0 for i in range(n + 1)]
    for i in range(n):
        rain1_cum[i + 1] += rain1_cum[i]
        rain2_cum[i + 1] += rain2_cum[i]

    # for each rain segment, count the cities only covered by this segment, and pick the two largest counts
    best1, best2 = 0, 0
    for i in range(m):
        x = rain1_cum[lr[i][1]] - rain1_cum[lr[i][0] - 1]
        if x > best1:
            best1, best2 = x, best1
        elif x > best2:
            best2 = x
    ans = n_rain_free + best1 + best2

    # rain start/finish events
    events = [[] for _ in range(n + 2)]
    for idx, (l, r) in enumerate(lr, 1):
        events[l] += [idx]
        events[r + 1] += [-idx]

    active_rain = set()
    for i in range(1, n + 1):
        for idx in events[i]:
            if idx > 0:
                active_rain.add(idx - 1)
            else:
                {{completion}}
        if len(active_rain) == 2:
            idx1, idx2, = active_rain
            lmin = min(lr[idx1][0], lr[idx2][0])
            lmax = max(lr[idx1][0], lr[idx2][0])
            rmin = min(lr[idx1][1], lr[idx2][1])
            rmax = max(lr[idx1][1], lr[idx2][1])
            ans = max(ans, n_rain_free + rain2_cum[rmin] - rain2_cum[lmax - 1] + rain1_cum[rmax] - rain1_cum[lmin - 1])

    print(ans)


for _ in range(int(input())):
    solve_case()
",active_rain.remove(-idx - 1),"active_rain.add(idx)

    if len(active_rain) > 0:"
"def II():
    return(int(input()))
def LMI():
    return(list(map(int,input().split())))
def I():
    return(input())
def MII():
    return(map(int,input().split()))
import sys
input=sys.stdin.readline
# import io,os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# from collections import Counter
# int(math.log(len(L)))
# import math
# from collections import defaultdict
# mod=10**9+7
# from collections import deque
# import  math
import bisect
from collections import Counter


for _ in range(II()):
    n,m,k=MII()
    X=[0]*(n+1)
    I=[]
    for _ in range(m):
        l,r=MII()
        I.append((l,r))
        X[l-1]+=1
        X[r]-=1
    two=[]
    base=0
    if X[0]==0:
        base+=1
    elif X[0]<=2:
        two.append(0)
    for i in range(1,n):
        X[i]+=X[i-1]
        if X[i]==0:
            base+=1
        elif X[i]<=2:
            {{completion}}
    X=[[] for _ in range(len(two))]
    cnt=0
    for i in range(m):
        l,r=I[i]
        x=bisect.bisect_left(two,r)
        y=bisect.bisect_left(two,l-1)
        # print(x,y)
        for j in range(y,x):
            X[j].append(cnt)
        cnt+=1
    ans=0
    counts=[0]*(m)
    ctwo=Counter()
    for i in range(len(two)):
        if len(X[i])==1:
            counts[X[i][0]]+=1
        else:
            ctwo[(X[i][0],X[i][1])]+=1
    for x,y in ctwo.keys():
        ans=max(ans,ctwo[(x,y)]+counts[x]+counts[y])
    counts.sort(reverse=True)
    ans=max(ans,counts[0]+counts[1])
    print(ans+base)




    # return



# if __name__==""__main__"":

#     for _ in range(II()):
#         t()
    # t()",two.append(i),"two.append(0)
        else:
            two[bisect.bisect_left(two,X[i]-1)]+=1
    two=two[::-1]"
"from math import gcd

for _ in range(int(input())): 
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    s = p = f = l = 0 
    arr = []
    
    for i in range(n-1):
        if gcd(a[i], a[i+1]) == 1: 
            s += 1
            if p == 2 and a[i+1] != 1 and k: s, k, p = s-2, k-1, 0
            elif a[i] == 1: 
                if p == 1: arr[-1] += 1
                else: 
                    {{completion}}
            else: p = 2
        else: p = 0
    
    if a[-2:] == [1, 1]: 
        if arr.pop()+1 == n and k < n: s += 1
    if arr != [] and a[0] == 1: arr.pop(0) 
    
    arr.sort()
    
    for i in arr:
        if k < i: break 
        s -= (i + 1)
        k -= i
            
    print(max(0, s-k))
    ","p = 1
                    arr.append(1)","arr.append(a[i])
                    arr.append(a[i+1])
                    p += 1
                    l += 1
            else: p = 2
        else: p = 0
    
    if a[-2:] == [1, 1]: 
        if arr.pop()+1 == n and k < n: s += 1
    if arr != [] and a[0] == 1: arr.pop(0) 
    
    arr.sort()
    
    for i in arr:
        if k < i: break 
        s -= (i + 1)
        k -= i
            
    print(max(0, s-k))
    
<|/ file ext=.py |>"
"from math import gcd
 
for _ in range(int(input())): 
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    s = p = f = l = 0 
    arr = []
    
    for i in range(n-1):
        if gcd(a[i], a[i+1]) == 1: 
            s += 1
            if p == 2 and a[i+1] != 1 and k: s, k, p = s-2, k-1, 0
            elif a[i] == 1: 
                if p == 1: arr[-1] += 1
                else: 
                    {{completion}}
            else: p = 2
        else: p = 0
    
    if a[-2:] == [1, 1]: 
        if arr.pop()+1 == n and k < n: s += 1
    if arr != [] and a[0] == 1: arr.pop(0) 
    
    arr.sort()
    
    for i in arr:
        if k < i: break 
        s -= (i + 1)
        k -= i
            
    print(max(0, s-k))","p = 1
                    arr.append(1)","arr.append(a[i])
                    arr.append(a[i+1])
                    p = 2
            elif a[i+1] == 1: 
                if p == 1: arr[-1] += 1
                else: 
                    arr.append(a[i])
                    arr.append(a[i+1])
                    p = 2
            else: p = 0
        else: p = 0
    
    if a[-2:] == [1, 1]: 
        if arr.pop()+1 == n and k < n: s += 1
    if arr != [] and a[0] == 1: arr.pop(0) 
    
    arr.sort()
    
    for i in arr:
        if k < i: break 
        s -= (i + 1)
        k -= i
            
    print(max(0, s-k))
"
"import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    n, k = readInts()
    arr = readList()
    freq = [0] * k
    for v in arr:
        freq[v % k] += 1
    if freq[0]:
        return 0
    elif k == 4:
        if freq[2] >= 2:
            return 0
        elif freq[2] == freq[3] == 0:
            return 2
        else:
            return 1
    else:
        for i in range(k-1, 0, -1):
            if freq[i]:
                {{completion}}
    return

for _ in range(int(input())):
    print(solve())",return k-i,"freq[i] -= 1
                freq[(i+1) % k] += 1
                if freq[(i+1) % k] == 1:
                    return 1
                break
        return 0

if __name__ == '__main__':
    solve()"
"import sys ; input = sys.stdin.buffer.readline

for _ in range(int(input())):

    n,k = map(int,input().split())
    li = list(map(int,input().split()))
    r = [0 for _ in range(k)]

    for i in range(n): x = (-li[i])%k ; r[x] += 1

    if k != 4:
        i = 0
        while r[i] == 0: i += 1
        print(i)
    else:
        i = 0
        while r[i] == 0:
            i += 1
        if r[2] >= 2: i = min(i,0)
        elif r[2] == 1 and r[3] >= 1: {{completion}}
        elif r[2] == 0 and r[3] >= 2: i = min(i,2) 
        print(i)","i = min(i,1)","i = min(i,1)"
"# OM SHRI GANESHAY NAMAH    
# HARE KRISHNA

import sys
from os import path
# from math import log2, floor, ceil, sqrt, pow, gcd
# from random import random, randint, shuffle, choice
from collections import Counter, defaultdict, deque
# from itertools import permutations, combinations
# from functools import reduce
# from heapq import heapify, heappop, heappush, heapreplace
# from bisect import bisect_left, bisect_right

def get_str(): return sys.stdin.readline().strip()
def get_int(): return int(get_str())
def get_arr(): return list(map(int, get_str().split()))

if path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

sys.setrecursionlimit(10**6)
MOD, MOD2, INF = 10**9 + 7, 998244353, 10**18

def solve():
    n, k = get_arr()
    a = [i % k for i in get_arr()]
    if 0 in a:
    	print(0)
    	return
    mx = max(a)
    ans = k - mx
    if k == 4:
    	cnt2 = a.count(2)
    	if cnt2 >= 2:
    		ans = 0
    	elif cnt2 == 1:
    		{{completion}}
    	else:
    		ans = min(ans, 2)
    print(ans)

tc = 1
tc = get_int()

for _ in range(tc):
    # print(f'Case #{i+1}:', end=' ')
    solve()",ans = 1,ans = 2
"for s in [*open(0)][2::2]:
 n=len(a:=sorted(list(map(int, s.split()))));j=n-1;b=sum(a);c=b//2
 while c>0:{{completion}}
 print((b+1)//2+n-j-1)


",c-=a[j];j-=1,"
  j-=1
  c+=b//2"
"import sys
input = sys.stdin.readline
rounds = int(input())

for ii in range(rounds):
  out=0
  ans='Yes'
  length,ope=map(int,input().split())
  arr=list(map(int,input().split()))
  last=length-1
  ope=min(ope,length)
  for r in range(ope):
    if arr[last]>length:
      ans='No'
      break
    else:
      move=arr[last]
      last-=move
      if last<0:
        {{completion}}
  
  print(ans) ",last+=length,"ans='No'
        break
      arr[last]=arr[0]
      arr[0]=move
      out+=1
  if out==length:
    ans='No'"
"from os import path
from sys import stdin, stdout


filename = ""../templates/input.txt""
if path.exists(filename):
    stdin = open(filename, 'r')


def input():
    return stdin.readline().rstrip()


def print(*args, sep=' ', end='\n'):
    stdout.write(sep.join(map(str, args)))
    stdout.write(end)


def main():
    def solution():
        n, k = [int(num) for num in input().split()]
        b = [int(num) for num in input().split()]
        k = min(k, n)
        cur = n - 1
        while k:
            if b[cur] > n:
                {{completion}}
            cur = (cur - b[cur]) % n
            k -= 1
        print('YES')
    t = int(input())
    while t:
        solution()
        t -= 1


if __name__ == '__main__':
    main()
","print('NO')
                return","cur = (cur + b[cur]) % n
            else:
                cur = (cur + b[cur]) % n
            b[cur], b[n - 1] = (b[n - 1], b[cur]) if b[n - 1] < b[cur] else (b[cur], b[n - 1])"
"import sys,math
input=sys.stdin.readline
""""""
turn korar por index m bar hold korle YES naile NO.
""""""
for T in range(int(input())):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))
    
    m=min(k,n+4)
    f=1
    ind = n-1
    for i in range(0,m):
        cur = arr[ind]
        if(ind-cur>=0):
            ind-=cur
        else:
            left=cur-(ind+1)
            oldInd=ind
            ind=n-1
            if(ind-left<oldInd):
                f=0
                break
            else:{{completion}}
    
    if(f):print(""Yes"")
    else:print(""No"")",ind-=left,"
                ind+=left"
"import sys

input = sys.stdin.readline
for _ in range(int(input())):
    n, c = map(int, input().split())
    a = list(map(int, input().split()))
    s = t = a[0]
    last = 0
    for j in range(1, n):
        t += a[j]
        if a[j] + s >= c * (j + 1):
            {{completion}}
    print([""No"", ""Yes""][last == n - 1])
","s = t
            last = j","s += a[j]
            last = j
    if last == n - 1:
        print(""YES"")
    else:
        print(""NO"")
<|/ file dstars=0 ext=.py |>"
"import os, gc
import time
import math
import sys

input = sys.stdin.readline
 
t=int(input())

for tests in range(t):
    
    n,c=map(int,input().split())
    mapi=list(map(int,input().split()))
 
    Stri=[0]
    
    for a in mapi:
        Stri.append(Stri[-1]+a)
 
    now=mapi[0]
 
    flag=0
 
    for i in range(1,n):
        if now+mapi[i]>=1*(i+1)*c:
            {{completion}}
 
    if flag==n-1:
        print(""Yes"")
        
    else:
        print(""No"")","now=Stri[i+1]
            flag=i","flag=flag+1
            now=now+mapi[i]
        else:
            now=now+mapi[i]
 
    if flag==n-1:
        print(""Yes"")
        
    else:
        print(""No"")
 
    now=mapi[0]
 
    flag=0
 
    for i in range(1,n):
        if now+mapi[i]<=i*c:
            flag=flag+1
            now=now+mapi[i]
        else:
            now=now+mapi[i]"
"import sys

input = sys.stdin.readline


############ ---- Input Functions ---- ############
def inp():
    return int(input())


def inlt():
    return list(map(int, input().split()))


def insr():
    s = input()
    return list(s[: len(s) - 1])


def invr():
    return map(int, input().split())


for _ in range(inp()):
    n, c = invr()
    a = inlt()
    f = a[0]
    tot = a[0]
    edge = 0
    for i in range(1, n):
        tot += a[i]
        if f + a[i] >= (i + 1) * c:
            {{completion}}
    if edge == n - 1:
        print(""YES"")
    else:
        print(""NO"")
","f = tot
            edge = i","edge += 1
            f += a[i]
    if tot >= n * c:
        print(""YES"")
    else:
        print(""NO"")
    
    
############ ---- Main ---- ############
for _ in range(inp()):
    n, c = invr()
    a = inlt()
    f = a[0]
    tot = a[0]
    edge = 0
    for i in range(1, n):
        tot += a[i]
        if f + a[i] >= (i + 1) * c:
            edge += 1
            f += a[i]"
"import sys
input = sys.stdin.readline

class FenwickTree:
    def __init__(self, n):
        self.size = n
        self.data = [0] * n
    
    def update(self, idx, x):
        while idx < self.size:
            self.data[idx] += x
            idx |= idx + 1

    def query(self, end):
        x = 0
        while end:
            x += self.data[end - 1]
            end &= end - 1
        return x
 

def solve():
    q = int(input())
    n = 1
    G = [[] for _ in range(q + 1)]
    todo = []

    for _ in range(q):
        t, *query = map(int, input().split())
        if t == 1:
            v = query[0] - 1
            G[v].append(n)
            todo.append((-1, n))
            n += 1

        else:
            v, x = query
            v -= 1
            todo.append((v, x))


    first = [-1] * n
    last = [-1] * n
    m = 0
    stack = [~0, 0]

    while stack:
        u = stack.pop()
        if u >= 0:
            first[u] = m
            m += 1

            for v in G[u]:
                {{completion}}
        else:
            last[~u] = m
            m += 1


    ft = FenwickTree(m + 1)
    # add to entire subtree. To correct when new node is created, remove value to the subtree
    for v, x in todo:
        if v == -1:
            i = first[x]
            curr = ft.query(i + 1)
            
            ft.update(i, -curr)
            ft.update(i + 1, curr)

        else:
            l = first[v]
            r = last[v]
            ft.update(l, x)
            ft.update(r, -x)

    res = [0] * n
    for i, f in enumerate(first):
        res[i] = ft.query(f + 1)
    
    return "" "".join(map(str, res))


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","stack.append(~v)
                stack.append(v)",stack.append(v)
"import sys; ipt = sys.stdin.readline

def iin():
    return int(ipt())
def lmin():
    return list(map(int,ipt().split()))

for _ in range(iin()):
    Q = iin()
    Qs = [lmin() for _ in range(Q)]
    N = 1
    G = [[]]
    tmp = [0]*Q
    for i,q in enumerate(Qs):
        if q[0] == 1:
            tmp[i] = N
            G[q[1]-1].append(N)
            G.append([])
            N += 1


    order = []
    cnt = 0
    tin = [-1]*N
    tout = [-1]*N
    st = [0]
    while st:
        cur = st.pop()
        if cur >= 0:
            tin[cur] = cnt
            order.append(cur)
            cnt += 1
            st.append(~cur)
            for nxt in G[cur]:
                {{completion}}
        else:
            tout[~cur] = cnt


    data0 = [0]*(N+1)
    data1 = [0]*(N+1)
    # 区間[l, r)に x を加算
    def _add(data, k, x):
        while k <= N:
            data[k] += x
            k += k & -k
    def add(l, r, x):
        _add(data0, l, -x*(l-1))
        _add(data0, r, x*(r-1))
        _add(data1, l, x)
        _add(data1, r, -x)

    # 区間[l, r)の和を求める
    def _get(data, k):
        s = 0
        while k:
            s += data[k]
            k -= k & -k
        return s
    def query(l, r):
        return _get(data1, r-1) * (r-1) + _get(data0, r-1) - _get(data1, l-1) * (l-1) - _get(data0, l-1)
    
    ans = [-1]*N
    for i in range(Q-1,-1,-1):
        q = Qs[i]
        if q[0] == 1:
            v = tmp[i]
            ans[v] = query(tin[v]+1,tin[v]+2)
        else:
            v,x = q[1:]
            v -= 1
            add(tin[v]+1,tout[v]+1,x)
    
    ans[0] = query(tin[0]+1,tin[0]+2)
    print(*ans)
",st.append(nxt),"st.append(nxt)
        else:
            tout[~cur] = cnt
            cnt += 1
            st.append(~cur)
            order.append(~cur)
            
    data0 = [0]*(N+1)
    data1 = [0]*(N+1)
    
    def _add(data, k, x):
        while k <= N:
            data[k] += x
            k += k & -k
    def add(l, r, x):
        _add(data0, l, -x*(l-1))
        _add(data0, r, x*(r-1))
        _add(data1, l, x)
        _add(data1, r, -x)

    def _get(data, k):
        s = 0
        while k:
"
"import sys

input = sys.stdin.readline


def inp():
    return (int(input()))
def inlt():
    return (list(map(int, input().split())))
def insr():
    s = input()
    return (list(s[:len(s) - 1]))
def invr():
    return (map(int, input().split()))


def solution():
    q = inp()
    fenwick = [0] * (q + 10)

    def lowbit(x):
        return x & -x
    def update(index, d):
        while index <= q:
            fenwick[index] += d
            index += lowbit(index)
    def getsum(index):
        res = 0
        while index > 0:
            res += fenwick[index]
            index -= lowbit(index)
        return res

    size = 1
    tree = [[] for _ in range(q + 10)]
    node_create = [-1] * (q + 10)
    node_create[1] = 0
    tree_ops = [[] for _ in range(q + 10)]
    parents = [-1 for _ in range(q + 10)]
    for q_idx in range(1, q+1):
        query = inlt()
        if query[0] == 1:
            size += 1
            cur_node = query[1]
            node_create[size] = q_idx
            tree[cur_node].append(size)
            parents[size] = cur_node
        elif query[0] == 2:
            cur_node, val = query[1:]
            tree_ops[cur_node].append((val, q_idx))

    res = [0] * (size + 1)

    stack = []
    stack.append((1, 0))
    while stack:
        root, state = stack.pop()
        if state == 0:
            for val, q_idx in tree_ops[root]:
                {{completion}}
            res[root] = getsum(q) - getsum(node_create[root])
            stack.append((root, 1))
            for nxt_node in tree[root]:
                stack.append((nxt_node, 0))
        if state == 1:
            for val, q_idx in tree_ops[root]:
                update(q_idx, -val)

    print(*res[1:])
    return


if __name__ == '__main__':
    t = inp()
    for i in range(t):
        solution()
","update(q_idx, val)","update(q_idx, val)
            res[root] = getsum(q) - getsum(node_create[root])
            stack.append((root, 1))
            for nxt_node in tree[root]:
                stack.append((nxt_node, 0))
        if state == 1:
            for val, q_idx in tree_ops[root]:
                update(q_idx, -val)

    print(*res[1:])
    return


def solution():
    q = inp()
    fenwick = [0] * (q + 10)

    def lowbit(x):
        return x & -x
    def update(index, d):
        while index <= q:
            fenwick[index] += d
            index += lowbit("
"import sys
def solve():
    input = sys.stdin.readline
    t = int(input())
    for _ in range(t):
        s = input().rstrip()
        pos = int(input())
        n = len(s)
        arr = ['']
        flag = False
        for i, c in enumerate(s):
            while arr[-1] > c:
                if pos <= n:
                    if pos < len(arr):
                        print(arr[pos], end='')
                    else:
                        {{completion}}
                    flag = True
                    break
                pos -= n
                n -= 1
                arr.pop()
            if flag:
                break
            arr.append(c)
        if not flag:
            while pos > n:
                pos -= n
                n -= 1
            print(arr[pos], end='')

solve()","print(s[i+pos-len(arr)], end='')","print(arr[0], end='')
                    break
                pos -= n
                n -= 1
                arr.pop()
            arr.append(c)
        while pos > n:
            if pos <= n:
                print(arr[pos], end='')
            else:
                print(arr[0], end='')
            pos -= n
            n -= 1
            arr.pop()

solve()
<|/ file dstars=0 ext=.py |>"
"import sys
def input()   : return sys.stdin.readline().strip()
def getints() : return map(int,sys.stdin.readline().strip().split())

from math import sqrt

p = []
for _ in range(int(input())):
    s = input()
    n = int(input())
    tack = [0]
    
    a = [0]*len(s)
    t = 1
    for i in range(1,len(s)):
        while tack:
            x = tack.pop()      
            if s[i] < s[x]:
                a[x] = t
                t += 1
            else: {{completion}}
        tack.append(i)
            
    for i in range(len(s)-1,-1,-1):
        if a[i] == 0: a[i] = t; t+= 1

    u = ((len(s)*(len(s)+1))//2-n)
    t = (-1+int(sqrt(1+8*u)))//2
    while (t*(t+1)) > 2*u: t -= 1
    
    ans = t - u + (t*(t+1))//2
    for i in range(len(s)):
        if a[i] > len(s)-(t+1):
            if ans == 0: p.append(s[i]); break
            else: ans -= 1
print(''.join(p))",tack.append(x); break,"break
        "
"import sys
input=sys.stdin.readline

t=int(input())

ans=[]

def solve():

    global ans

    s=input()
    pos=int(input())
    pos-=1

    n=len(s)-1

    prev_idx=[i-1 for i in range(n)]
    skipped=[0 for _ in range(n)]
    curr_length=n

    i=0

    while i<n:

        if pos==0:
            ans.append(s[i])
            return

        if prev_idx[i]==-1:
            pos-=1
            i+=1
        else:
            if s[prev_idx[i]]>s[i]:
                skipped[prev_idx[i]]=1
                prev_idx[i]=prev_idx[prev_idx[i]]
                curr_length-=1
                if pos>=curr_length:
                    pos-=curr_length
                else:
                    {{completion}}
            else:
                pos-=1
                i+=1
  
    if i<n:
        j=i
        while 1:
            if pos==0 and skipped[j]==0:
                ans.append(s[j])
                return
            if skipped[j]==0:
                pos-=1
            j=(j+1)%n
    else:
        for i in range(n-1,-1,-1):
            if skipped[i]==0:
                skipped[i]=1
                break
        x=skipped.count(0)

        while pos>=x:
            pos-=x
            x-=1
        
        for i in range(n):
            if pos==0 and skipped[i]==0:
                ans.append(s[i])
                return
            if skipped[i]==0:
                pos-=1


while t:
    solve()
    t-=1

print(''.join(ele for ele in ans))",break,"pos-=1
                i+=1"
"import sys
input = sys.stdin.readline
mod = 998244353

for _ in range(int(input())):
    M = int(input())
    L = []
    R = []
    r_minus_l_sum = 0
    bad_num = {}
    short_num = {}
    for m in range(M):
        n, l, r = map(int, input().split())
        L.append(l)
        R.append(r)
        A = list(map(int, input().split()))
        C = list(map(int, input().split()))
        S = sum(C)
        r_minus_l_sum += r - l
        for a, c in zip(A, C):
            if a not in bad_num:
                {{completion}}
            x = S - c
            bad_num[a] += max(0, l - x)
            short_num[a] += max(0, r - max(x, l))

    l_sum = sum(L)
    r_sum = sum(R)
    ans = r_sum + 1
    for v in range(l_sum, r_sum + 1):
        if v not in bad_num:
            ans = 0
            break
        tmp = bad_num[v]
        need = v - l_sum
        ok = r_minus_l_sum - short_num[v]
        tmp += max(0, need - ok)
        ans = min(ans, tmp)
        # print(v, ans, bad_num[v], short_num[v], r_minus_l_sum)
    print(ans)
","bad_num[a] = 0
                short_num[a] = 0","bad_num[a] = c
            else:
                bad_num[a] += c
            if a not in short_num:
                short_num[a] = S
            else:"
"import math
import os
import random
import re
import sys
from collections import *
from functools import lru_cache

# t = int(sys.stdin.readline())
# n, m = map(int, sys.stdin.readline().strip().split())
# nums = map(int, sys.stdin.readline().strip().split())
# a_list = list(map(int, sys.stdin.readline().split()))
# b_list = list(map(int, sys.stdin.readline().split()))

def solute():
    m = int(sys.stdin.readline())
    d = dict()
    l_sum = 0
    r_sum = 0
    for _ in range(m):
        n, l, r = map(int, sys.stdin.readline().strip().split())
        a_list = list(map(int, sys.stdin.readline().split()))
        c_list = list(map(int, sys.stdin.readline().split()))
        sumc = sum(c_list)
        delete = sumc - r
        l_sum += l
        r_sum += r

        for i in range(n):
            a = a_list[i]
            key = str(a)
            if not key in d:
                {{completion}}
            can_del = min(c_list[i], delete)
            d[key][0] += c_list[i] - can_del
            d[key][1] += min(c_list[i] - can_del, r-l)

    count = r_sum - l_sum + 1
    res = 10 ** 20
    for key in d:
        val = int(key)
        if val < l_sum or val > r_sum:
            continue
        count -= 1
        res = min(d[key][0] - min(d[key][1], r_sum - val), res)

    if count:
        res = 0

    print(res)

t = int(sys.stdin.readline())

for _ in range(t):
    solute()","d[key] = [0, 0]","val = (l, r)
                d[key] = val
            else:
                val = d[key]
                if val[0] < l:
                    d[key] = (l, val)
                elif val[0] > r:
                    d[key] = (val, r)
                else:
                    d[key] = (val[0], min(val[1], r-l))

        for key in d:
            val = d[key]
            if val[0] < l_sum:
                d[key] = (l_sum, val)
            elif val[0] > r_sum:
                d[key] = (val, r_sum)
            else:
                d[key] = (val[0], min(val[1], r_sum - l_sum))

        for key in d:
            val = d[key]
            if val[0] < l_sum"
"import sys
input=sys.stdin.buffer.readline
def rl(): return list(map(int,input().split()))
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())

from collections import defaultdict
def main():
    m=ri()
    sml=smr=smn=0
    ds=defaultdict(int)
    fil=defaultdict(int)
    mst=[0]*m
    dif=[0]*m
    bl=defaultdict(list)
    filtt=0
    for i in range(m):
        n,l,r=rm()
        filtt+=r-l
        dif[i]=r-l
        sml+=l;smr+=r;smn+=n
        mst[i]=r
        a=rl()
        c=rl()
        smc=sum(c)
        for j in range(n):
            ds[a[j]]+=max(0,l-(smc-c[j]))
            fil[a[j]]+=min(r-l,max((smc-c[j])-l,0))
            bl[a[j]].append(i)
    if smr-sml>=smn: return 0
    res=10**18
    for i in range(sml,smr+1):
        if i not in ds.keys(): return 0
        rem=fil[i]+filtt
        for j in bl[i]: rem-=dif[j]
        if i-sml<=rem: res=min(res,ds[i])
        else: {{completion}}
    return res

t=ri()
for i in range(t):
    print(main())","res=min(res,ds[i]+i-sml-rem)",break
"for s in[*open(0)][2::2]:
 i=0
 for x in s.split():{{completion}}
 print(i)",i+=1;i+=i==int(x),"
  i+=int(x)"
"for _ in range(int(input())):
	n,b = int(input()) ,0
	for x in [int(x) for x in input().split()]:
		b+=1
		if x == b: {{completion}}
	print(b)
	",b+=1,break
"t=int(input())
for q in range(t):
    n=int(input())
    a=list(map(int,input().split(' ')))
    c=0
    for i in range(len(a)):
        c+=1
        if(a[i]==c):
            {{completion}}
    print(c)
        ",c+=1,"if(a[i]>c):
                c=a[i]
            else:
                c=a[i-1]"
"for s in[*open(0)][1:]:
 x,k=map(int,s.split())
 while sum(map(int,(str(x))))%k:{{completion}}
 print(x)",x+=1,"
  x=(x*10+x)%k"
"l = []
def somme(t):
    s = 0
    while t != 0:
        {{completion}}
    return s  
for _ in range(int(input())):
    x, k = map(int, input().split()) 
    while somme(x) % k !=0 :   
            x+=1
    l.append(x)    
print(*l)","s += t % 10
        t //= 10","s += t % 10
        t //= 10"
"L=[]
def somme(t):
           s=0
           while t!= 0:
               {{completion}}
           return s  
for _ in range(int(input())):
     x,k=map(int,input().split())
     while somme(x) % k !=0 :   
            x+=1
     L.append(x)    
print(*L)   

        
         
             
         
         ","s+=t%10
               t=t//10","s+=t%10
               t=t/10"
"from collections import Counter
from sys import stdin
input = stdin.readline
for _ in range(int(input())):
    n, k = map(int, input().split())
    o = 0
    for x in Counter(input().strip()).values():
        if x % 2:
            {{completion}}
    print(""NO"" if o > k + 1 else ""YES"")",o += 1,"o += x
    if o > 2 * 10**5:
        print(""NO"")
    else:
        print(""YES"")
<|/ a |>"
"import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    n, k = readInts()
    s = readStr()
    freq = [0] * 26
    for c in s:
        {{completion}}
    cnt = -1
    for i in range(26):
        cnt += freq[i] % 2
    return ""YES"" if cnt <= k else ""NO""

for _ in range(int(input())):
    print(solve())","freq[ord(c)-ord(""a"")] += 1","idx = ord(c) - ord('a')
        freq[idx] += 1
    freq = freq[:26]"
"t = int(input())
output = []
for _ in range(t):
    n, k = map(int, input().split())
    s =  input()
    counter = {}
    for i in range(n):
        counter[s[i]] = counter.get(s[i], 0) + 1
    
    huh = 0
    for i in counter:
        huh += 1 if counter[i] % 2 != 0 else 0
    
    ##
    if k >= huh - 1 or huh <= 1:

        output.append(""YES"")
    else:
        {{completion}}
print(""\n"".join(output))
    
    
","output.append(""NO"")","output.append(""NO"")
    ##
    "
"for s in[*open(0)][2::2]:
 i=j=t=0;r=[-1]*(len(s)-1)
 for b in s[-2::-1]:
  i+=1
  if'1'>b:{{completion}}
 print(*r)",j+=1;t+=i-j;r[j-1]=t,"
   j=i
   break
 while j>0:
  t=j%2
  j=j//2
  r[i]=t
  i+=1"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    s = input()[:-1]
    d, a, b = [], 0, 0
    for i in range(n-1, -1, -1):
        if s[i] == '0':
            b += a
            d.append(b)
        else:
            {{completion}}
    print(' '.join(map(str, d)), '-1 '*(n-len(d)))",a += 1,"a += b
            d.append(a)
            b, a = a, b
    d.append(a)"
"for _ in range(int(input())):{{completion}}
  			    	 	  	    				 					 	","print('no'if input() in ['cab', 'bca'] else'yes')","
	row = input()
	row1 = row.split()
	row2 = row1
	row3 = row2
	row4 = row3
	row5 = row4
	row6 = row5
	row7 = row6
	row8 = row7
	row9 = row8
	row10 = row9
	row11 = row10
	row12 = row11
	row13 = row12
	row14 = row13
	row15 = row14
	row16 = row15
	row17 = row16
	row18 = row17
	row19 = row18
	"
"n = int(input())
for i in range(n):
    s = input()
    if s[0] == 'a' or s[1] == 'b' or s[2] == 'c':
        print('YES')
    else:
        {{completion}}
",print('NO'),
"for _ in range(int(input())):
    if input() in [""abc"", ""acb"", ""cba"", ""bac""]:
        {{completion}}
    print(""No"")
","print(""Yes"")
        continue","ans = ""YES""
    else:
        ans = ""NO""
    print(ans)
<|/ file filename=Card_Game.py |>"
"mod=1_000_000_007
 
 
 
t=int(input())
for testid in range(t):
	n,x,k=map(int,input().split())
	ans=pow(2*k+1,n-1,mod)*(k+x)
	ans%=mod
	if x>0:
		def mul(a,b):
			c=[[0]*x for _ in range(x)]
			for i in range(x):
				for j in range(x):
					for k in range(x):
						{{completion}}
			return c
		def mpow(m,p):
			if p==0:return [[int(i==j) for i in range(x)] for j in range(x)]
			if p==1:return m
			half=mpow(m,p//2)
			full=mul(half,half)
			if p%2:full=mul(full,m)
			return full
		mat=[[0]*x for _ in range(x)]
		for i in range(x):
			for j in range(max(0,i-k),min(x,i+k+1)):
				mat[i][j]=1
		mat=mpow(mat,n-1)
		sub=sum(sum(r) for r in mat)
		ans-=sub
		ans%=mod
	print(ans)",c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod,c[i][j]+=a[i][k]*b[k][j]
"import sys
from itertools import permutations
from heapq import heappop,heappush
from collections import deque
import random
import bisect

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

mod = 10**9 + 7

def mat_mul(X,Y):
    n,m = len(X),len(Y[0])
    res = [[0 for j in range(m)] for i in range(n)]
    for i in range(n):
        for j in range(m):
            for k in range(len(Y)):
                {{completion}}
    return res

def solve(n,k,x):
    mod = 10**9 + 7
    res = pow(2*k+1,n-1,mod) * (x+k) % mod

    if x == 0:
        return res

    A = [[0]*x for i in range(x)]
    for i in range(x):
        for j in range(x):
            if abs(i-j) <= k:
                A[i][j] = 1
    
    E = [[1] for _ in range(x)]
    t = n-1
    while t:
        if t & 1:
            E = mat_mul(A,E)
        A = mat_mul(A,A)
        t >>= 1
    
    for i in range(x):
        res -= E[i][0]
        res %= mod
    
    return res

for _ in range(int(input())):
    n,x,k = mi()
    print(solve(n,k,x))","res[i][j] += X[i][k] * Y[k][j]
                res[i][j] %= mod",res[i][j] += X[i][k] * Y[k][j]
"MOD = 1_000_000_007

def fast_power(t, y):
    if y == 0:
        return 1
    if y == 1:
        return t
    el = fast_power(t, y // 2)
    el = (el * el) % MOD
    if y % 2 == 1:
        return (el * t) % MOD
    return el


def multiply_matrix(A, B):
    n = len(A)
    t = len(B)
    m = len(B[0])
    answer = [[0 for _ in range(m)] for _ in range(n)]
    for i in range(n):
        for j in range(m):
            for k in range(t):
                answer[i][j] = (answer[i][j] + A[i][k] * B[k][j]) % MOD
    return answer


def fast_power_matrix(t, y):
    if y == 1:
        return t
    el = fast_power_matrix(t, y // 2)
    el = multiply_matrix(el, el)
    if y % 2 == 1:
        return multiply_matrix(el, t)
    return el


for _ in range(int(input())):
    n, x, k = map(int, input().split())
    first = (((x + k) % MOD) * fast_power((2*k + 1) % MOD, n - 1)) % MOD
    start_dp = [[1] for _ in range(x)]
    if x > 0:
        a = [[0 for _ in range(x)] for _ in range(x)]
        for i in range(x):
            for j in range(x):
                if abs(j - i) <= k:
                    {{completion}}
        if n == 1:
            second_matrix = start_dp
        else:
            A = fast_power_matrix(a, n - 1)
            second_matrix = multiply_matrix(A, start_dp)
        second = 0
        for i in range(x):
            second = (second + second_matrix[i][0]) % MOD
        print((first - second) % MOD)
    else:
        print(first)
",a[i][j] = 1,"a[i][j] = 1
        second_matrix = start_dp"
"from sys import *
input = stdin.readline
inputlist = lambda: map(int, stdin.readline().split())
def solve():
    m = int(input())
    monocarpattack = list(inputlist())
    monocarpdefense = list(inputlist())
    b = int(input())
    bicarpattack = list(inputlist())
    bicarpdefense = list(inputlist())

    monocarp = list(zip(monocarpattack, monocarpdefense))
    bicarp = list(zip(bicarpattack, bicarpdefense))

    monocarp.sort(key = lambda x: x[1], reverse = True)
    bicarp.sort(key = lambda x: x[0], reverse = True)

    bestattackmonocarp = [0] * (m+1)
    bestdefensebicarp = [0] * (b+1)
    for i in range(m):
        bestattackmonocarp[i+1] = max(bestattackmonocarp[i], monocarp[i][0])
    for i in range(b):
        bestdefensebicarp[i+1] = max(bestdefensebicarp[i], bicarp[i][1])

    temp, wincutoff, drawcutoff = 0, 0, 0
    for i in range(m):
        while temp < b and monocarp[i][1] < bicarp[temp][0]:
            temp += 1
        if temp == 0:
            wincutoff = i + 1
        else:
            if bestattackmonocarp[wincutoff] > bestdefensebicarp[temp]:
                wincutoff = i + 1
            elif bestattackmonocarp[i+1] > bestdefensebicarp[temp]:
                {{completion}}

    return [wincutoff, max(0,drawcutoff-wincutoff), m-max(wincutoff,drawcutoff)]

        
for _ in range(int(input())):
    print(*solve())",drawcutoff = i + 1,"drawcutoff = i + 1
            else:
                drawcutoff = temp + 1
            temp = wincutoff"
"import sys
input = sys.stdin.readline
def solve():
    ls = []
    lst = []
    n = int(input())
    a = list(map(int, input().split()))
    d = list(map(int, input().split()))
    m = int(input())
    a1 = list(map(int, input().split()))
    d1 = list(map(int, input().split()))
    for i in range(n): 
        ls.append([a[i] , d[i]])
    for i in range(m): 
        lst.append([a1[i], d1[i]])
    ls.sort(key = lambda x : x[1] , reverse = 1 )
    lst.sort(key = lambda x : x[0] , reverse= 1 )
    pre1 = [0]
    for i in ls:
        pre1.append(max(pre1[-1] , i[0]))
    pre2 = [0]
    for i in lst : 
        pre2.append(max(pre2[-1] , i[1]))
    j , win , loss = 0 ,0 ,0 
    for i in range(n): 
        while j < m and ls[i][1] < lst[j][0]: 
            j += 1
        if j == 0 : 
            win = i+1
        elif pre1[win ] > pre2[j]: 
            {{completion}}
        elif pre1[i + 1] > pre2[j]:
            loss = i+1 
    print(win , max(0 ,loss - win ) , n- max(win , loss))
for _ in range(int(input())):
    solve()",win = i + 1,"win = win 
        elif pre1[win ] < pre2[j]: 
            loss = win "
"t = int(input())
for _ in range(t):
    n = int(input())
    ax = [*map(int, input().split())]
    ay = [*map(int, input().split())]
    a = []
    for x, y in zip(ax, ay):
        a.append((x, y))
    m = int(input())
    bx = [*map(int, input().split())]
    by = [*map(int, input().split())]
    b = []
    for x, y in zip(bx, by):
        b.append((x, y))
    a.sort(key=lambda z: z[1], reverse=True)
    b.sort(key=lambda z: z[0], reverse=True)
    aa, bd = [0] * (n + 1), [0] * (m + 1)
    for i in range(n):
        aa[i + 1] = max(aa[i], a[i][0])
    for i in range(m):
        bd[i + 1] = max(bd[i], b[i][1])
    k = s = t = 0
    for i in range(n):
        while k < m and a[i][1] < b[k][0]:
            k += 1
        if k == 0:
            s = i + 1
        else:
            if aa[s] > bd[k]:
                s = i + 1
            elif aa[i + 1] > bd[k]:
                {{completion}}
    print(s, max(0, t - s), n - max(s, t))",t = i + 1,"s = i + 1
            else:
                s = k
                t += 1
    print(s, max(0, t - s), n - max(s, t))
    k = s = t = 0
    for i in range(m):
        while k < n and b[i][0] < a[k][1]:
            k += 1
        if k == 0:
            s = i + 1
        else:
            if aa[s] > bd[k]:
                s = i + 1
            elif aa[i + 1] > bd[k]:
                s = i + 1
            else:
                s = k
                t += 1"
"import sys
inp = sys.stdin.readline
Inp = lambda: [*map(int, inp().split())]

for _ in range(int(inp())):
    n, q = Inp()
    A = Inp()
    X = Inp()

    Y = [0]*31
    x0 = float('inf')
    for x in X:
        if x >= x0:
            {{completion}}
        for i in range(x, 31):
            Y[i] += 2**(x-1)
        x0 = x

    Ans = []
    for a in A:
        i = 0
        while a%(1<<i+1) == 0:
            i += 1
        Ans.append(a+Y[i])
    print(' '.join(map(str, Ans)))
",continue,"Y[x] -= 2**(x0-x)
        x0 = x

    for x in X:
        if x >= x0:
            Y[x] += 2**(x0-x)
        x0 = x

    for x in X:
        if x >= x0:
            Y[x] -= 2**(x0-x)
        x0 = x

    for x in X:
        if x >= x0:
            Y[x] += 2**(x0-x)
        x0 = x

    for x in X:
        if x >= x0:
            Y[x] -= 2**(x0-x)
        x0 = x

    for x in X:
        if x >= x0:
            Y[x] += 2**(x0-x)
        x0 = x

    for "
"import sys


def main():
    q = int(sys.stdin.readline())

    ans = []
    for _ in range(q):
        _, _ = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        x = list(map(int, sys.stdin.readline().split()))
        x = [2 ** i for i in x]
        lp = []
        s = set()
        for xi in x:
            if xi in s:
                continue
            s.add(xi)

            ok = True
            for li in lp:
                if li >= xi:
                    {{completion}}
                ok = False
                break
            if ok:
                lp.append(xi)

        r = []
        for ai in a:
            for li in lp:
                if ai % li != 0:
                    continue
                ai += li // 2

            r.append(str(ai))

        ans.append(' '.join(r))

    return ans


if __name__ == '__main__':
    print('\n'.join(main()))

",continue,"ok = False
                    break
            if ok:
                lp.append(xi)

        r = []
        for ai in a:
            for li in lp:
                if ai % li != 0:
                    continue
                ai += li // 2

            r.append(str(ai))

        ans.append(' '.join(r))

    return ans


if __name__ == '__main__':
    print('\n'.join(main()))

""""""
import sys


def main():
    q = int(sys.stdin.readline())

    ans = []
    for _ in range(q):
        _, _ = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        x = list(map(int, sys.stdin.readline().split()))
        x = [2 ** "
"import sys


def f(nums, queries):
    groups = [[] for _ in range(31)]
    for i, n in enumerate(nums):
        g = 0
        while n & 1 == 0:
            g += 1
            n >>= 1
        groups[g].append(i)
    ex = [0] * 31
    actual_i = list(range(31))
    for q in queries:
        for i in range(q, 31):
            if actual_i[i] >= q:
                {{completion}}
    res = [0] * len(nums)
    for g in range(31):
        for i in groups[g]:
            res[i] = nums[i] + ex[g]
    return res



if __name__ == '__main__':
    N = int(sys.stdin.readline().strip())
    for _ in range(N):
        _ = sys.stdin.readline()
        nums = list(map(int, sys.stdin.readline().strip().split()))
        queries = map(int, sys.stdin.readline().strip().split())
        print(' '.join(map(str, f(nums, queries))))
  ","ex[i] += 1 << (q - 1)
                actual_i[i] = q - 1","actual_i[i] -= q
                ex[i] += 1
    ex = ex[:len(nums)]"
"n = int(input())
A = [int(x) for x in input().split()]
 
B = [0]
for a in A:
    B.append(B[-1] ^ a)
 
maxB = max(B)
count = [0] * maxB.bit_length()
for b in B:
    for bit in range(b.bit_length()):
        {{completion}}

c = 0
for bit in range(maxB.bit_length()):
    if n - count[bit] < count[bit]:
        c += 1 << bit
 
B = [b ^ c for b in B]
print(*B)
",count[bit] += (b >> bit) & 1,"bit = bit + maxB.bit_length()
        count[bit] += 1"
"n = int(input())
#x, y, k = map(int, input().split())
a = list(map(int, input().split()))
b = [0] * n
if n % 2 == 0:
    fe = 0
    a2 = [0] * n
    a2[1] = a[0]
    for i in range(1, n - 1):
        a2[i + 1] = a2[i] ^ a[i]
    a2.sort(reverse=True)
    for x in a2:
        x2 = x ^ fe
        while True:
            if x2 < n:
                {{completion}}
            x2 ^= fe
            fe += 1
            x2 ^= fe
    b[0] = fe
else:
    fe = 0
    for i in range(n):
        fe ^= i
        if i % 2 == 1 and i < n - 1:
            fe ^= a[i]
    b[0] = fe
for i in range(n - 1):
    b[i + 1] = b[i] ^ a[i]
print(' '.join(map(str, b)))

# j = 7
# ans = []
# n = 20
# for i in range(n):
#     if j != i:
#         ans.append(j ^ i)
# ans.sort()
# mo = 1
# for x in ans:
#     if x != mo:
#         break
#     mo += 1
# print(ans, mo ^ n)",break,"fe = x
                break"
"import sys
input = sys.stdin.readline

def readList():
    return list(map(int, input().split()))
def readInt():
    return int(input())
def readInts():
    return map(int, input().split())
def readStr():
    return input().strip()

# BF, EC, DB, CC, CL
def solve():
    n, arr = readInt(), readList()
    a = [0]
    f1, f2 = [0] * 21, [0] * 21
    for i in range(n-1):
        a.append(a[-1] ^ arr[i])
        v0, v1 = i + 1, a[-1]
        j = 0
        while v0 or v1:
            {{completion}}
    v = 0
    for i in range(21):
        v += (1 << i) if f1[i] != f2[i] else 0
    return "" "".join([str(v ^ val) for val in a])

print(solve())","f1[j] += v0 & 1
            f2[j] += v1 & 1
            v0 >>= 1
            v1 >>= 1
            j += 1","f0[v0 & v1] += 1
            v1[v1 & v0] -= 1
            v0, v1 = v1 >> 1, v0 >> 1
            j += 1
        f2[i] = j
    a.sort()"
"import sys
input = sys.stdin.readline

class FenwickTree:
    def __init__(self, n):
        self.size = n
        self.data = [0] * n
    
    def update(self, idx, x):
        while idx < self.size:
            {{completion}}

    def query(self, end):
        x = 0
        while end:
            x += self.data[end - 1]
            end &= end - 1
        return x

def solve():
    n = int(input())
    A = [int(x) - 1 for x in input().split()]
    
    res = [-1] * n
    ft = FenwickTree(2 * n)

    for i, a in enumerate(A):
        if i <= a:
            ft.update(n + a, 1)

    for i in range(n - 1, -1, -1):
        a = A[i]
        d = (a - i) % n        
        res[a] = d - (ft.query(i + d) - ft.query(i))
        ft.update(i + d, 1)

    return "" "".join(map(str, res))


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))
","self.data[idx] += x
            idx |= idx + 1","idx += x
            self.data[idx] += 1
    
    def query(self, idx):
        while idx < self.size:
            idx += self.data[idx]
        return idx"
"import sys
input=sys.stdin.buffer.readline
def rl(): return list(map(int,input().split()))
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())
class BIT:
    def __init__(self, nums):
        self.n = len(nums)
        self.tree = [0] * (self.n + 1)
        for i in range(self.n):
            {{completion}}
    # update tree[i]+=delta
    def update(self, i, delta):
        i += 1
        while i <= self.n:
            self.tree[i] += delta
            i += i & -i
    # [0,i]
    def query(self, i):
        i += 1
        res = 0
        while i > 0:
            res += self.tree[i]
            i -= i & -i
        return res
    # [l,r]
    def range_query(self, l, r):
        if r < l: return 0
        return self.query(r) - self.query(l - 1)
def main():
    n=ri()
    a=rl()
    res=[-1]*n
    for i in range(n): a[i]-=1
    bt=BIT([0]*2*n)
    for i in range(2*n-1,n-1,-1):
        x=i-n
        if a[x]>=x:
            bt.update(i+a[x]-x,1)
    for i in range(n-1,-1,-1):
        nxt=a[i] if a[i]>=i else a[i]+n
        res[nxt%n]=nxt-i-bt.range_query(i+1,nxt-1)
        bt.update(nxt,1)
    return res

t=ri()
for i in range(t):
    print(*main())","self.update(i, nums[i])","j = nums[i]
            self.tree[j] += 1
            self.tree[j] &= self.tree[j - 1]
"
"class BIT:
    def __init__(self, sz):
        self.sz = sz
        self.bit = [0]*(sz+1)
    def update(self, idx, val):
        while idx <= self.sz:
            {{completion}}
    def queri(self, R):
        ret = 0
        while R > 0 :
            ret += self.bit[R]
            R -= (R & -R)
        return ret
    def query(self, L, R):
        if L > R : return 0
        return self.queri(R) - self.queri(L-1)


def solve():
    n = int(input())
    ans, dest =  [0]*(n+1), [0]*(2*n+1)
    a = [0] + list(map(int, input().split()))

    for i in range(1, n+1):
        dest[i] = a[i]
        if i > dest[i] : dest[i] += n
        dest[i+n] = dest[i] + n

    ds = BIT(2*n)

    for i in range(2*n, n, -1):
        if dest[i] <= 2*n:
            ds.update(dest[i], 1)

    for i in range(n, 0, -1):
        ans[a[i]] = dest[i] - i - ds.query(i+1, dest[i]-1)
        ds.update(dest[i], 1)

    for i in range(1, n+1):
        print(ans[i], end=' ')

    print()

for _ in range(int(input())):
    solve()","self.bit[idx] += val
            idx += (idx & -idx)","idx += val
            self.bit[idx] += 1
    def query(self, i):
        ret = 0
        while i > self.sz:
            ret += self.bit[i]
            i -= (i & -i)
        return ret"
for s in[*open(0)][2::2]:{{completion}},print(s[-2]),"
    if s.count(""A"") > s.count(""B""):
        print(""A"")
    elif s.count(""B"") > s.count(""A""):
        print(""B"")
    else:
        print(""?"")

<|/ file source=github "
"for s in[*open(0)][2::2]:
    {{completion}}",print(s[-2]),"s=s.split()
    if s[0]=='A':
        if s[1]=='B':
            print('B')
        else:
            print('A')
    else:
        if s[1]=='B':
            print('A')
        else:
            print('B')
<|/ file source=github filename=P2.py |>"
for p in[*open(0)][2::2]:{{completion}},print(p[-2]),"
    a,b=map(int,p.split())
    if a==b==1:
        print(""A"")
    elif a==b==2:
        print(""B"")
    else:
        print(""?"")

<|/ file filename=P2.py |>"
for s in[*open(0)][2::2]:{{completion}},"*a,=map(int,s.split());print('YNEOS'[any(sorted(x:=a[1<<i:1<<i+1])<x
for i in range(5))::2])","
    s=int(s)
    if s==1:
        break
    s=2**s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1
    s=s-1"
for p in[*open(0)][2::2]:{{completion}},"*n,=map(int,p.split());print('YNEOS'[any(sorted(m:=n[1<<i:1<<i+1])<m
for i in range(5))::2])","
    n, *a = map(int, input().split())
    a.sort()
    if a[0] < a[-1]:
        print('YES')
    else:
        print('NO')

for p in[*open(0)][1::2]:
    n, *a = map(int, input().split())
    a.sort()
    if a[0] < a[-1]:
        print('YES')
    else:
        print('NO')

<|/ file dstars=0 source=github |>"
"import sys
import math
import collections
import heapq
input=sys.stdin.readline
t=int(input())
for w in range(t):
    n=int(input())
    a=[int(i) for i in input().split()]
    b=[int(i) for i in input().split()]
    s=0
    for i in range(n):
        if(a[i]>b[i]):
            {{completion}}
        s+=b[i]-a[i]
    val=max(a)-min(b)
    if(val>0):
        print(s+2*val)
    else:
        print(s)","a[i],b[i]=b[i],a[i]","s=s+a[i]-b[i]
        else:
            s=s+b[i]-a[i]
    val=max(a)-min(b)
    if(val>0):
        print(s+2*val)
    else:
        print(s)
<|/ a tags=python,python-3.x |>"
"import sys
from math import gcd,ceil,log

# Definitions 

input = lambda: sys.stdin.readline().rstrip(""\r\n"")
mod = pow(10,9)+7

def imap(): # Multiple numbers input
    return map(int,input().split())

def ilist(): # List input 
    return list(map(int,input().split()))

def freq(l): # Returns count of a number in a list/string // O(nlog(n)) //
    d = {}
    for i in l:
        d[i] = d.get(i,0)+1
    return d

# Starting off 

t = int(input())
for _ in range(t):
    n  = int(input())
    a = ilist()
    b = ilist()
    ans = 0
    for i in range(n):
        if a[i]>b[i]:
            {{completion}}
        ans += b[i]-a[i]

    # x = [[b[i],a[i]] for i in range(n)]
    # x.sort()
    # ans += max(2*(x[-1][1]-x[0][0]),0)
    print(ans + 2*max(max(a)-min(b),0))


#--- By Shri ---#
","a[i],b[i] = b[i],a[i]","a,b = b,a
        ans += abs(a[i]-b[i])
    print(ans)

#--- By Shri ---#
    
def max(a,b):
    ans = 0
    for i in range(len(a)):"
"import sys
input = sys.stdin.buffer.readline 
from itertools import permutations
        
def process(A, B):
    n = len(A)
    answer = 0
    my_min = []
    my_max = []
    for i in range(n):
        {{completion}}
    if min(my_max) < max(my_min):
        answer+=(max(my_min)-min(my_max))
    sys.stdout.write(f'{answer}\n')
    
    
t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    process(A, B)","answer+=abs(A[i]-B[i])
        my_min.append(2*min(A[i],B[i]))
        my_max.append(2*max(A[i],B[i]))","my_min.append(min(A[i]))
        my_max.append(max(A[i]))
    
    answer+=sum(abs(x-y) for x, y in zip(my_min, my_max))
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"from sys import *
input = stdin.readline
inputlist = lambda: map(int, stdin.readline().split())
print = lambda n: stdout.write(str(n) + ""\n"")
printlist = lambda list: stdout.write("" "".join(map(str,list)) + ""\n"")
 
def solve():
    rows, cols = inputlist()

    def getneighbors(block):
        neighbors = []
        row, col = divmod(block, cols)
        if row != 0: neighbors.append(block - cols)
        if row != rows - 1: neighbors.append(block + cols)
        if col != 0: neighbors.append(block - 1)
        if col != cols - 1: neighbors.append(block + 1)
        return neighbors

    board = [None] * (rows * cols)
    unblocked = 0
    exits = []
    start = None

    for i in range(rows):
        temp = input().strip()
        for j in range(cols):
            if temp[j] != ""#"":
                index = cols * i + j
                board[index] = 0
                unblocked += 1
                if temp[j] == ""V"":
                    start = index

    for i in range(cols):
        if board[i] is not None: exits.append(i)
        if board[i + cols * (rows - 1)] is not None: exits.append(i + cols * (rows - 1))

    for i in range(rows):
        if board[cols * i] is not None: exits.append(cols * i)
        if board[cols * (i + 1) - 1] is not None: exits.append(cols * (i + 1) - 1)

    if len(exits) == 0:
        return unblocked - 1

    distances = [None] * (rows * cols)
    board[start] = 1
    current = [start]
    distance = 0

    while current:
        newcurrent = []
        for block in current:
            distances[block] = distance
            for neighbor in getneighbors(block):
                if board[neighbor] == 0:
                    board[neighbor] = 1
                    newcurrent.append(neighbor)
        current = newcurrent
        distance += 1

    realexits = [exit for exit in exits if board[exit] == 1]

    if len(realexits) <= 1:
        return unblocked - 1 - distances[realexits[0]] if realexits else unblocked - 1

    sumdistances = [None] * (rows * cols)
    sourcearray = [None] * (rows * cols)
    current = [(10 ** 8 + 1) * i for i in realexits]

    for block in realexits:
        sumdistances[block] = 0
        sourcearray[block] = block

    distance = 1
    minimum = float(""inf"")

    while current and distance < minimum:
        newcurrent = set()
        for number in current:
            block, source = divmod(number, 10 ** 8)
            for neighbor in getneighbors(block):
                if board[neighbor] == 1 and sourcearray[neighbor] != source:
                    newcurrent.add(neighbor * 10 ** 8 + source)
                    if sumdistances[neighbor] is None:
                        sumdistances[neighbor] = distance
                        sourcearray[neighbor] = source
                    else:
                        {{completion}}
        current = newcurrent
        distance += 1

    return unblocked - minimum - 1
 
for _ in range(int(input())):
    print(solve())","sumdistances[neighbor] += distance
                        minimum = min(minimum, sumdistances[neighbor] + distances[neighbor])
                        board[neighbor] = 2","sumdistances[neighbor] += distance
                        sourcearray[neighbor] = source
        minimum = min(minimum, sumdistances[current[0]])"
"import sys
input = sys.stdin.readline
from heapq import heappop,heappush
for _ in range(int(input())):
    n,q=map(int,input().split())
    A=list(map(int,input().split()))
    l=[]
    r=[]
    for i in range(n):
        if A[i]==1:
            l.append(i)
            r.append(-i)
    r.reverse()
    s=sum(A)
    for tt in range(q):
        L=list(map(int,input().split()))
        if L[0]==2:
            ind,to=L[1]-1,L[2]
            if A[ind]==to:
                pass
            else:
                if to==2:
                    s+=1
                    A[ind]=to
                else:
                    s-=1
                    heappush(l,ind)
                    heappush(r,-ind)
                    A[ind]=to
                while l and A[l[0]]==2:
                    heappop(l)
                while r and A[-r[0]]==2:
                    heappop(r)
        else:
            x=L[1]
            if l==[]:
                if x<=s and x%2==0:
                    print(""YES"")
                else:
                    print(""NO"")
            else:
                S1=s-2*l[0]
                S2=s-2*(n-1+r[0])
                if x<=S1 or x<=S2:
                    print(""YES"")
                else:
                    if S1%2==x%2 and x<=s:
                        print(""YES"")
                    else:
                        {{completion}}
	  	     		 	  		  	 			 		 		","print(""NO"")","S1=s-2*l[0]
                        S2=s-2*(n-1+r[0])
                        if S2%2==x%2 and x<=s:
                            print(""YES"")
                        else:
                            print(""NO"")
<|/ file ext=.py source=github |>"
"import sys, math
from heapq import heappop, heappush

input = sys.stdin.readline

ans = []

def solve():
    N, Q = map(int, input().split())
    a = [*map(int, input().split())]
    left, right = [], []
    total = 0
    for i, x in enumerate(a):
        total += x
        if x == 1:
            heappush(left, i)
            heappush(right, N - 1 - i)
    for _ in range(Q):
        q = [*map(int, input().split())]
        if q[0] == 1:
            ok = False
            s = q[1]
            if s & 1 == total & 1:
                ok = s <= total
            else:
                if len(left) ^ 0 and len(right) ^ 0:
                    while left and a[left[0]] ^ 1:
                        {{completion}}
                    while right and a[N - 1 - right[0]] ^ 1:
                        heappop(right)

                    left_sum = total - 2 * left[0] - 1 if left else 0
                    right_sum = total - 2 * right[0] - 1 if right else 0

                    ok = max(left_sum, right_sum) >= s
            ans.append(""YES"" if ok else ""NO"")
        else:
            i, v = q[1:]
            i -= 1
            total -= a[i]
            a[i] = v
            total += a[i]
            if a[i] == 1:
                heappush(left, i)
                heappush(right, N - 1 - i)
    return


if __name__ == ""__main__"":
    cases = int(input())
    for _ in range(cases):
        solve()
    print(""\n"".join(ans))
",heappop(left),heappop(left)
"#user : @sixthcore
import math
from math import log2, sqrt, log10, log
from heapq import heapify, heappop, heappush, heappushpop
from math import floor, ceil
import sys
from collections import Counter, defaultdict
I = lambda: list(map(int, input().split()))
MAP = lambda: map(int, input().split())
SI = lambda: list(input().strip())
input = sys.stdin.readline
sys.setrecursionlimit(10000)
from itertools import combinations
from collections import deque
INF = float('inf')

for _ in range(int(input())):
    N, Q = MAP()
    A = I()
    su = sum(A)

    minHeap, maxHeap = [], []
    heapify(minHeap); heapify(maxHeap)

    for i in range(N):
        if A[i] == 1:
            heappush(minHeap, i)
            heappush(maxHeap, -i)
    
    for q in range(Q):
        ip = I()
        if (ip[0] == 1):
            s = ip[1]
            if (su%2 == s%2 and s <= su):
                print(""Yes"")
                continue 
            if not minHeap: 
                print(""No"")
                continue
            f, l = minHeap[0], N-abs(maxHeap[0])-1
            avl = su - (min(f, l)*2 + 1)
            if (avl >= s):
                print(""Yes"")
            else:
                {{completion}}

        else:
            i, v = ip[1], ip[2]
            i -= 1
            if (A[i] == v): continue
            su -= A[i]
            su += v
            A[i] = v 
            if (v == 1):
                heappush(minHeap, i)
                heappush(maxHeap, -i)
            while (minHeap and A[minHeap[0]] == 2):
                heappop(minHeap)
            while (maxHeap and A[abs(maxHeap[0])] == 2):
                heappop(maxHeap)","print(""No"")","heappush(minHeap, f)
                heappush(maxHeap, -l)
                heappush(minHeap, f)
                heappush(maxHeap, -l)
                heappush(minHeap, f)
                heappush(maxHeap, -l)
                heappush(minHeap, f)
                heappush(maxHeap, -l)
                heappush(minHeap, f)
                heappush(maxHeap, -l)
                heappush(minHeap, f)
                heappush(maxHeap, -l)
                heappush(minHeap, f)
                heappush(maxHeap, -l)
                heappush(minHeap, f)
                heappush(maxHeap, -l)
                "
"
for _ in range(int(input())):
    n=int(input())
    a=list(map(int,input()))
    if n%2 or a.count(0)!=n//2:
        print(-1)
        continue
    l,r=0,n-1
    ans=[]
    while l<r:
        if a[l]!=a[r]:
            l+=1
            r-=1
        elif a[l]==0:
            {{completion}}
        else:
            a.insert(l,1)
            a.insert(l,0)
            l+=1
            r+=1
            ans.append(l-1)
    print(len(ans))
    print(*ans)
","r+=1
            a.insert(r,0)
            a.insert(r+1,1)
            l+=1
            ans.append(r)","a.insert(l,1)
            a.insert(l,0)
            l+=1
            r-=1"
"
for _ in range(int(input())):
    h=int(input())
    j=input()
    m=[]
    l=0
    k=0
    if j.count(""0"")==j.count(""1""):
        while k<=(h//2+l-1):
            if j[k]==j[h+l*2-k-1] and j[k]==""1"":
                j=j[:k]+""01""+j[k:]
                l+=1
                m.append(k)
            elif j[k]==j[h+l*2-k-1] and j[k]==""0"":
                {{completion}}
            k+=1
        print(l)
        print(*m)
    else:
        print(""-1"")","j=j[:h+l*2-k]+""01""+j[h+l*2-k:]
                m.append(h+l*2-k)
                l+=1","j=j[:k]+""01""+j[k:]
                l+=1
                m.append(k)
            elif j[k]==j[h+l*2-k-1] and j[k]==""0"" and j[h+l*2-k-1]==""1"":
                j=j[:k]+""01""+j[k:]
                l+=1
                m.append(k)
            elif j[k]==j[h+l*2-k-1] and j[k]==""0"" and j[h+l*2-k-1]==""1"" and j[h+l*2-k-1]==""1"":
                j=j[:k]+""01""+j[k:]
"
"

def solve():
    n = int(input())
    s = str(input())

    n_ones = sum(1 if x == ""1"" else 0 for x in s)
    n_zeros = sum(1 if x == ""0"" else 0 for x in s)
    if len(s) % 2 or n_ones != n_zeros:
        print(-1)
        return
    
    res = []

    left, right = 0, n - 1
    while left < right:
        if s[left] != s[right]:
            right -= 1
        elif s[left] == ""1"":
            {{completion}}
        else:
            res.append(right)
            lsub, rsub = s[:right+1], s[right+1:]
            s = lsub + ""01"" + rsub
            right += 1
        left += 1

    print(len(res))
    for x in res:
        print(x + 1, end="" "")
    print(""\n"", end="""")
    return




def main():
    t = int(input())
    
    for _ in range(t):
        solve()


if __name__ == ""__main__"": 
    main()
","res.append(left-1)
            lsub, rsub = s[:left], s[left:]
            s = lsub + ""01"" + rsub
            right += 1","right -= 1
            res.append(left)
            left += 1"
"def solve():
    n, m = map(int, input().split())
    s = input()
    t = input()
    ind = [[] for i in range(26)]
    for i in range(n-1, -1, -1):
        ind[ord(s[i])-97].append(i)
    for c in t:
        i = ord(c)-97
        if not ind[i]:
            return ""NO""
        j = ind[i][-1]
        for k in range(i):
            while ind[k] and ind[k][-1] < j:
                {{completion}}
        ind[i].pop()
    return ""YES""


import sys
input = lambda: sys.stdin.readline().rstrip()
t = int(input())
for i in range(t):
    print(solve())
",ind[k].pop(),"ind[k].pop()
            ind[k].append(j)
        while ind[i] and ind[i][-1] < j:"
"import sys
ci = sys.stdin.readline
def sol():
    n, m = list(map(int, ci().split()))
    s = ci().strip()
    t = ci().strip()
    inds = [[] for _ in range(26)]
    for i, c in enumerate(s):
        inds[ord(c) - 97].append(i)
    for i in range(m-1, -1, -1):
        target = t[i]
        asc = ord(target) - 97
        if len(inds[asc]) == 0:
            return 'NO'
        curr = inds[asc].pop()
        for j in range(25, asc, -1):
            while inds[j] and inds[j][-1] > curr:
                {{completion}}
    return 'YES'
t = int(ci())
for _ in range(t):
    print(sol())",inds[j].pop(),"inds[j].pop()
        inds[asc].append(curr)
        inds[asc].sort()
        inds[asc].reverse()
        inds[asc] = inds[asc][1:]
        inds[asc].append(inds[asc][0])
        inds[asc] = inds[asc][1:]
        inds[asc].append(inds[asc][0])
        inds[asc] = inds[asc][1:]
        inds[asc].append(inds[asc][0])
        inds[asc] = inds[asc][1:]
        inds[asc].append(inds[asc][0])
        inds[asc] = inds[asc][1:]
        ind"
"from sys import *
input = stdin.readline
inputlist = lambda: map(int, stdin.readline().split())

def solve():
    len1, len2 = inputlist()
    original = input()[:-1]
    new = input()[:-1]
    indexdict = [[] for _ in range(26)]
    for i in range(len(original)):
        indexdict[ord(original[i])-97].append(i)
    for i in range(26):
        indexdict[i].reverse()

    min = int
    for char in new:
        num = ord(char) - 97
        if not indexdict[num]: return ""NO""
        else:
            min = indexdict[num].pop(-1)
            for i in range(num):
                while indexdict[i] and indexdict[i][-1] < min:
                    {{completion}}
    return ""YES""
            

for _ in range(int(input())):
    print(solve())",indexdict[i].pop(-1),"indexdict[i].pop()
                    min = indexdict[i].pop(-1)
    
    for i in range(26):
        indexdict[i].reverse()
    
    final = []
    for i in range(26):
        final.append(indexdict[i].pop(0))
    
    final = final[::-1]
    
    final = """".join(final)
    
    if final == original: return ""YES""
    else: return ""NO""
    
def solve():
    len1, len2 = inputlist()
    original = input()[:-1]
    new = input()[:-1]
    indexdict = [[] for _ in range(26)]
    for i in range(len(original)):
        indexdict[ord(original[i])-97].append(i)"
"import sys
input = sys.stdin.buffer.readline
n = int(input())
A = input().split()
 
precalc = [[[0] * (19 * a) for _ in range(a + 1)] for a in range(6)]
for num in A:
    tmp = precalc[len(num)]
    tmp[0][s := sum(num) - len(num) * 48] += 1
    for i,c in enumerate(num):
        tmp[i + 1][s := s - 2 * c + 96] += 1
 
luckies = 0
for a in range(1, 5 + 1):
    for b in range(1, 5 + 1):
        c = a + b
        if c & 1:
            {{completion}}
        P1 = precalc[a][min(a, c//2)]
        P2 = precalc[b][max(0, c//2 - a)]
        for s in range(-9 * min(a, b), 9 * min(a, b) + 1):
            luckies += P1[s] * P2[-s]
 
print(luckies)",continue,c -= 1
"n = int(input())
ct = [[0 for __ in range(46)] for _ in range(6)]
ls = list(input().split())
for i in range(n) :
    val = 0
    for j in range(len(ls[i])) :
        val += int(ls[i][j])
    ct[len(ls[i])][val] += 1
ans = 0
for i in range(n) :
    val, tval, sz = 0, 0, len(ls[i])
    for j in range(sz) :
        tval += int(ls[i][j])
    for j in range(sz) :
        val += int(ls[i][j])
        if (j+1)*2 < len(ls[i]) :
            ans += ct[max(j+1,len(ls[i])-j-1)-min(j+1,len(ls[i])-j-1)][tval-2*val]
        elif (2*val-tval > 0):
            {{completion}}
print(ans,'\n')","ans += ct[max(j+1,len(ls[i])-j-1)-min(j+1,len(ls[i])-j-1)][2*val-tval]","ans += ct[sz-1][tval-2*val]
        elif (j+1)*2 < len(ls[i]) :
            ans += ct[max(j+1,len(ls[i])-j-1)-min(j+1,len(ls[i])-j-1)][tval+2*val]
        elif (2*val-tval < 0):
            ans += ct[sz-1][tval+2*val]
print(ans)
<|/ a tags=python,algorithm |>"
"n = int(input())
arr = input().split()

dic = {
    1: {},
    2: {},
    3: {},
    4: {},
    5: {}
}

for i in arr:
    s = 0
    for j in i:
        s+= int(j)
    dic[len(i)][s] = dic[len(i)].get(s,0)+1

ans = 0
for i in arr:
    s = 0
    for j in i:
        s+= int(j)
    ans += dic[len(i)][s]
    
    l = len(i)
    if l>=3:
        ans += dic[l-2].get(s-2*int(i[-1]), 0)
        ans += dic[l-2].get(s-2*int(i[0]), 0)

        if l== 5:
            {{completion}}
            
print(ans)
	 	   	  			  	   	 	  	 		","ans += dic[1].get(s-2*(int(i[-1])+int(i[-2])),0)
            ans += dic[1].get(s-2*(int(i[1])+int(i[0])),0)","ans += dic[l-3].get(s-3*int(i[-1]), 0)
            ans += dic[l-3].get(s-3*int(i[0]), 0)
            ans += dic[l-3].get(s-3*int(i[1]), 0)"
"import sys, math
input = lambda: sys.stdin.readline().strip()
mapin = lambda: map(int,input().split())
for _ in range(int(input())):
    n, = mapin()
    a = list(mapin())
    mx = max(a)
    cur = 0
    for i in range(n):
        if i>0 and a[i]%2 == a[i-1]%2: {{completion}}
        cur += a[i]
        mx = max(mx,cur)
        if cur < 0: cur = 0
    print(mx)",cur = 0,"cur += a[i]
        else: cur += a[i]
        mx = max(mx,cur)
        if cur < 0: cur = 0
    print(mx)
<|/ a dscore=0 |>"
"from sys import stdin

t = int(stdin.readline().rstrip())  # кол-во наборов

for _ in range(t):
    n = int(stdin.readline().rstrip())
    arr = list(map(int, stdin.readline().rstrip().split()))

    max_res = arr[0]
    local_max = arr[0]

    for i in range(1, len(arr)):
        if (arr[i - 1] + arr[i]) % 2 == 0:
            local_max = arr[i]
        else:
            {{completion}}
        max_res = max(max_res, local_max, arr[i])

    print(max_res)
","local_max = local_max + arr[i]
            local_max = max(local_max, arr[i])","local_max = max(local_max, arr[i])"
"'''
Author       : InHng
LastEditTime : 2023-12-03 14:13:49
'''
import sys
input = sys.stdin.readline
import pypyjit
pypyjit.set_param('max_unroll_recursion=-1')
mod = 10 ** 9 + 7 # 998244353

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    judge = [(ai % 2) for ai in a]
    ans, cnt = a[0], a[0]
    for i in range(1, n):
        if judge[i] ^ judge[i - 1]:
            cnt = max(a[i], cnt + a[i])
        else:
            {{completion}}
        ans = max(ans, cnt)
    print(ans)
",cnt = a[i],"cnt = max(a[i], cnt)"
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()

N = int(1e5) + 5

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    f = [0]*N
    for x in a:
        f[x] += 1

    greater = [0]*N
    extra = [0]*N
    ct = 0
    for i in range(N-2, -1, -1):
        for j in range(f[i]):
            greater[i] += ct
            extra[i] += (f[i]-j-1)*ct
            ct += 1

    ans = 0
    g = [0]*N       # g[i] = count of pairs whose gcd is i
    for i in range(N-1, 0, -1):
        ct = 0
        pairs = 0
        for j in range(i, N, i):
            if f[j]:
                {{completion}}
            g[i] -= g[j]
        g[i] += pairs
        ans += g[i] * i

    print(ans)
","pairs += ct * greater[j]
                pairs += extra[j]
                ct += f[j]","pairs += ct
                ct += f[j]
                g[j] -= ct"
"import sys,math,bisect
input=sys.stdin.buffer.readline
from collections import defaultdict

for _ in range(int(input())):
    n=int(input())
    a=sorted([*map(int,input().split())])
    b,m=[0]*(max(a)+1),max(a)
    d,I=[0]*(m+1),[0]*(m+1)

    for i in range(n):
        d[a[i]]+=1
        I[a[i]]=i
    
    
    # print(d,I)
    for i in range(2,m+1):
        curr=0
        for j in range(i,m+1,i):
            if not d[j]:{{completion}}
            
            b[i]+=curr*((n-I[j]-1)*d[j] +  (d[j]*(d[j]-1))//2) + (n-1-I[j])*(d[j]*(d[j]-1))//2 + d[j]*(d[j]-1)*(d[j]-2)//6
            # print(j,i,b[i])
            curr+=d[j]
       
    b[1]=n*(n-1)*(n-2)//6
    # print(b)
    res=0
    for i in range(m,0,-1):
        for j in range(2*i,m+1,i):
            b[i]-=b[j]
        res+=i*b[i]
    print(res)
    






        









    
        







    
    




    
        
    
    
    
    
    


    






    
    


        
    


    
    
    




    

    




      


    
        ",continue,"
                continue"
"from sys import stdin, stdout

t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    a = [int(x) for x in stdin.readline().split()]
    m = max(a)

    count = [0]*(m+1)
    for i in range(n):
        count[a[i]] += 1

    right = [0]*(m+1)
    right[-1] = count[-1]
    for i in range(m-1,-1,-1):
        right[i] = right[i+1]+count[i]

    b = [0]*(m+1)
    b[1] = (n*(n-1)*(n-2))//6

    for i in range(2,m+1):
        l = 0
        pointer = i
        while pointer <= m:
            for j in range(count[pointer]):
                {{completion}}

            l += count[pointer]
            pointer += i

    for i in range(m-1,0,-1):
        pointer = 2*i
        while pointer <= m:
            b[i] -= b[pointer]
            pointer += i

    answer = 0
    for i in range(1,m+1):
        answer += i*b[i]

    stdout.write(str(answer)+'\n')
",b[i] += (l+j)*(right[pointer]-j-1),"right[j] -= b[pointer]
                b[pointer] += b[j]"
"
import sys
input = sys.stdin.readline


class Fenwick:

    def __init__(self, n):
        self.d = [0]*(n+1)
        self.n = n

    def update(self, i):
        while i <= self.n:
            self.d[i] += 1
            i += i & (-i)

    def sum(self, i):
        c = 0
        while i > 0:
            c += self.d[i]
            i -= i & (-i)

        return c

    def calc(self, i, j):
        return self.sum(j) - self.sum(i-1)


for _ in range(int(input())):
    n, q = map(int, input().split())

    d = [[] for _ in range(n+1)]
    for i in range(n-1):
        a, b = map(int, input().split())
        d[a].append(b)
        d[b].append(a)
    t = [0]*(n+1)
    for i, j in enumerate(map(int, input().split())):
        t[j] = i+1
    y = [[] for _ in range(n + 1)]
    for i in range(q):
        a, b, c = map(int, input().split())
        y[c].append((a, b, i))

    w = Fenwick(n)
    x = [0] * q
    e = [0] * (n+1)
    q = [(1, 1)]
    while q:
        a, b = q.pop()
        if b:
            q.append((a, 0))
            for i, j, k in y[a]:
                x[k] -= w.calc(i, j)
            w.update(t[a])
            for i in d[a]:
                if i != e[a]:
                    {{completion}}
        else:
            for i, j, k in y[a]:
                x[k] += w.calc(i, j)
    for i in x:
        print(['YES', 'NO'][i==0])","q.append((i, 1))
                    e[i] = a","q.append((i, 0))
                    w.update(t[i])
                    x[k] += w.sum(i)
        else:
            q.append((a, 1))
            w.update(t[a])
            for i in d[a]:
                if i != e[a]:
                    q.append((i, 0))
                    w.update(t[i])
                    x[k] -= w.sum(i)
    for i in x:
        print(['YES', 'NO'][i==0])
</code>
<|/ a |>"
"# https://codeforces.com/contest/1899

import sys

input = lambda: sys.stdin.readline().rstrip()  # faster!


class FenwickTree:
    def __init__(self, n):
        self.n = n
        self.bit = [0] * n

    @classmethod
    def from_array(cls, arr):
        tree = FenwickTree(len(arr))
        for i, v in enumerate(arr):
            tree.update(i, v)
        return tree

    def update(self, idx, delta):
        """"""Modifies the value at index idx by delta.""""""
        while idx < self.n:
            self.bit[idx] += delta
            idx |= (idx + 1)

    def query(self, idx):
        """"""Calculates the prefix sum for index idx.""""""
        return self.sum(idx - 1)

    def sum(self, right_idx):
        """"""Calculates the sum for the range [0, right_idx].""""""
        res = 0
        while right_idx >= 0:
            res += self.bit[right_idx]
            right_idx = (right_idx & (right_idx + 1)) - 1
        return res

    def sum2(self, left_index, right_idx):
        """"""Calculates the sum for the range [left_idx, right_idx].""""""
        return self.sum(right_idx) - self.sum(left_index - 1)


def solve_case():
    n, q = map(int, input().split())
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = map(lambda i: int(i) - 1, input().split())
        adj[u] += [v]
        adj[v] += [u]

    p = list(map(lambda x: int(x) - 1, input().split()))
    pinv = [-1] * n
    for i, x in enumerate(p):
        pinv[x] = i

    queries = [[] for _ in range(n)]
    for iq in range(q):
        l, r, x = map(lambda i: int(i) - 1, input().split())
        queries[x] += [(l, r, iq)]

    ans = [0] * q

    fenwick = FenwickTree(n)
    parent = [-1] * n
    q = [(0, 1)]
    while q:
        v, op = q.pop()
        if op:
            for l, r, i in queries[v]:
                ans[i] -= fenwick.sum2(l, r)
            fenwick.update(pinv[v], 1)
            q += [(v, 0)]
            for u in adj[v]:
                if u != parent[v]:
                    {{completion}}
        else:
            for l, r, i in queries[v]:
                ans[i] += fenwick.sum2(l, r)

    print(""\n"".join(""YES"" if x else ""NO"" for x in ans))


for _ in range(int(input())):
    solve_case()
","parent[u] = v
                    q += [(u, 1)]","parent[u] = v
                    q += [(u, op - 1)]"
"import sys
input = sys.stdin.readline

class SegTree:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n * 2)

    def build(self, arr):
        for i in range(self.size):
            self.tree[self.size + i] = arr[i]
        for i in range(self.size - 1, 0, -1):
            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]

    def update(self, p, v):
        self.tree[p + self.size] += v
        p += self.size
        i = p
        while i > 1:
            self.tree[i >> 1] = self.tree[i] + self.tree[i ^ 1]
            i >>= 1

    def query(self, l, r):
        ans = 0
        l += self.size
        r += self.size
        while l < r:
            if 1 & l:
                ans += self.tree[l]
                l += 1
            if r & 1:
                r -= 1
                ans += self.tree[r]
            l >>= 1
            r >>= 1
        return ans

for _ in range(int(input())):
    n, q = map(int, input().split())
    g = [[] * (n + 1) for i in range(n + 1)]
    for i in range(n - 1):
        u, v = map(int, input().split())
        g[u].append(v)
        g[v].append(u)
    p = [*map(int, input().split())]
    ip = [0] * (n + 1)
    for i, v in enumerate(p):
        ip[v] = i + 1
    st = SegTree(n + 1)
    ans = [0] * q
    queries = [[] for _ in range(n + 1)]
    for i in range(q):
        l, r, x = map(int, input().split())
        queries[x].append((l, r, i))
    s = [(1, 0, 1)]
    while s:
        v, p, z = s.pop()
        if z:
            s.append((v, p, 0))
            for l, r, i in queries[v]:
                ans[i] -= st.query(l, r + 1)
            st.update(ip[v], 1)
            for u in g[v]:
                if u != p:
                    {{completion}}
        else:
            for l, r, i in queries[v]:
                ans[i] += st.query(l, r + 1)
    for v in ans:
        print('YES' if v else 'NO')
","s.append((u, v, 1))","s.append((u, v, 1))"
"from collections import Counter
for _ in range(int(input())):
    {{completion}}","input()
    a=[i if i!='1' else '2' for i in input().split()]
    print(sum(i*(i-1)//2 for i in Counter(a).values()))","n, *a = map(int, input().split())
    counts = Counter(a)
    ans = 0
    for i in range(n):
        for j in range(n):
            if counts[a[i]][i] > counts[a[j]][j]:
                ans += 1
    print(ans)
<|/"
"import sys

lines = sys.stdin.readlines()

t = int(lines[0])

for tc in range(t):
    n = int(lines[2 * tc + 1])
    nums = [int(x) for x in lines[2 * tc + 2].split("" "")]
    counts = {}
    for num in nums:
        if num == 1:
            {{completion}}
        if num not in counts:
            counts[num] = 0
        counts[num] += 1

    result = 0
    for count in counts.values():
        result += (count * (count - 1)) // 2
    print(result)

",num = 2,"counts[1] = 1
            continue"
"from sys import stdin, stdout

for _ in range(int(stdin.readline())):
    n = int(stdin.readline())
    a = list(map(int, stdin.readline().split()))

    res, cnt = 0, dict()
    cnt[1], cnt[2] = 0, 0
    for i in a:
        if i == 1: res += cnt[2]
        elif i == 2: {{completion}}
        try: 
            res += cnt[i]
            cnt[i] += 1
        except:
            cnt[i] = 1
    
    stdout.write(str(res) + '\n')",res += cnt[1],"res += cnt[1]
        else: cnt[i] += 1
        
    for i in a:"
"for s in[*open(0)][2::2]:{{completion}}
",print('YNEOS'[s>'10'::2]),"
    s=int(s)
    count=0
    for i in range(1,s):
        if s[i]<s[i-1]:
            count+=1
    if count==s:
        print ""YES""
    else:
        print ""NO"""
"for a in[*open(0)][2::2]:
    {{completion}}",print('YNEOS'[a > '10'::2]),"i = 2
    while i < len(a):
        if a[i-1] < a[i]:
            a[i-1], a[i] = a[i], a[i-1]
        else:
            i += 1
    if sorted(a) == a:
        print ""YES""
    else:
        print ""NO""
<|/ file source=github |>"
for p in[*open(0)][2::2]:{{completion}},print('YNEOS'[p>'10'::2]),"
    i = 2
    while i < len(p):
        if p[i-1] < p[i]:
            p[i], p[i-1] = p[i-1], p[i]
            i = i - 1
        else:
            i = i + 1
    if p == sorted(p):
        print ""YES""
    else:
        print ""NO""

<|/ file source=github filename=P13.py "
"I=input
f=lambda x:'00'in x or'11'in x
for _ in[0]*int(I()):{{completion}}","I();print('YNeos'[f(s:=I())&(f(t:=I())or
2*t[0]in s or 2*t[-1]in s)::2])","
  s=input()
  t=input()
  if(len(s)!=len(t)):
    print('NO')
    break
  if(len(s)==1):
    if(s[0]=='0'):
      if(t[0]=='0'):
        print('YES')
      else:
        print('NO')
    else:
      if(t[0]=='0'):
        print('NO')
      else:
        print('NO')
  else:
    k=len(s)
    while(1):
      if(k==1):
        if(s[0]=='0'):
          if(t[0]=='0'):
            print('YES')
            break
          else:
            print('NO')
        else:
          if(t[0]"
"I=input
f=lambda x:'11'in x or '00'in x
for _ in[0]*int(I()):{{completion}}","I();s=I();t=I();print('YNeos'[f(s)and(f(t)or
2*t[0]in s or 2*t[-1]in s)::2])","
  s=input()
  t=input()
  s=s.replace('0',f(t))
  print(s.count('1'))
<|/ file source=github ext=.py |>"
"import sys
input = sys.stdin.buffer.readline

for _ in range(int(input())):
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    adj = [[] for _ in range(n)]
    radj = [[] for _ in range(n)]

    for _ in range(m):
        u, v = map(int, input().split())
        if u == v:
            continue
        u -= 1
        v -= 1
        adj[u].append(v)
        radj[v].append(u)

    top = []
    vis = [0] * n
    for i in range(n):
        if not vis[i]:
            s = [i]
            true_s = []
            while s:
                c = s[-1]

                if not vis[c]:
                    vis[c] = 1
                    true_s.append(c)
                    s.extend(adj[c])
                else:
                    if true_s and true_s[-1] == c:
                        {{completion}}
                    s.pop()
    top = top[::-1]

    comps = [[]]
    comp = [0] * n

    for x in top:
        if not comp[x]:
            comps.append([])
            s = [x]
            while s:
                c = s.pop()

                if not comp[c]:
                    comp[c] = len(comps) - 1
                    comps[-1].append(c)
                    s.extend(radj[c])

    ctop = []
    seen = [0] * len(comps)
    for x in top:
        if not seen[comp[x]]:
            seen[comp[x]] = 1
            ctop.append(comp[x])

    ans = [0, 0]
    dp = [[0, 0] for _ in range(len(comps))]
    for c in ctop[::-1]:
        for i in comps[c]:
            for j in adj[i]:
                if comp[j] != c:
                    dp[c] = max(dp[c], dp[comp[j]])

        dp[c] = dp[c].copy()
        dp[c][0] += len(comps[c])
        dp[c][1] -= sum(a[i] for i in comps[c])

        ans = max(ans, dp[c])

    print(ans[0], -ans[1])
","top.append(c)

                        true_s.pop()","top = [true_s[-2]]
                        true_s.pop()
                    else:"
"from sys import stdin, stdout
from sys import setrecursionlimit as srl

def I(): return stdin.readline().strip("" \r\n"")
def II(): return int(I())
def IL(): return I().split()
def ICL(): return list(I())
def IIL(): return list(map(int, IL()))
def IM(): return map(str, IL())
def IIM(): return map(int, IL())
def ICIM(): return map(int, ICL())
def P(*args,sep=' ',end=''): stdout.write(sep.join([str(s) for s in args]) + end)
def PL(*args,sep=' '): P(*args, sep=sep, end='\n')
def F(): stdout.flush()

def main():
    for _ in range(II()):
        solve()

def solve():
    n, m = IIM()
    vals1 = IIL()

    sdg1 = StaticDirectedGraph(n)
    edges = []
    for _ in range(m):
        a, b = IIM()
        sdg1.add_edge(a-1, b-1)
        edges.append((a-1, b-1))

    scc = find_SCC(sdg1.adjacents)
    
    vals2 = [sum(vals1[v] for v in l) for l in scc]
    sdg1_to_2 = [-1]*n
    for i, vs in enumerate(scc):
        for v in vs:
            sdg1_to_2[v] = i
    
    sdg2 = StaticDirectedGraph(len(scc))
    for a, b in edges:
        if sdg1_to_2[a] != sdg1_to_2[b]:
            sdg2.add_edge(sdg1_to_2[a], sdg1_to_2[b])

    dp = [(len(scc[i]), -vals2[i]) for i in range(len(scc))]
    for i in range(len(scc)):
        for j in sdg2.adjacents[i]:
            dp[j] = max(dp[j], (dp[i][0] + len(scc[j]), dp[i][1] - vals2[j]))
    #PL(dp)
    a, b = max(dp)
    PL(a, -b)
    #PL()


class StaticDirectedGraph:
    def __init__(self, size):
        self.size = size
        self.adjacents = [set() for _ in range(size)]
    
    def add_edge(self, parent, child):
        self.adjacents[parent].add(child)
    
    def remove_edge(self, parent, child):
        self.adjacents[parent].remove(child)

def find_SCC(graph):
    SCC, S, P = [], [], []
    depth = [0] * len(graph)
 
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            d = depth[~node] - 1
            if P[-1] > d:
                SCC.append(S[d:])
                del S[d:], P[-1]
                for node in SCC[-1]:
                    {{completion}}
        elif depth[node] > 0:
            while P[-1] > depth[node]:
                P.pop()
        elif depth[node] == 0:
            S.append(node)
            P.append(len(S))
            depth[node] = len(S)
            stack.append(~node)
            stack += graph[node]
    return SCC[::-1]

if __name__ == ""__main__"":
	main()",depth[node] = -1,depth[node] = d
"import sys
input = sys.stdin.readline
t=int(input())
from collections import deque
def scc(adj, adj_rev):
  N = len(adj) - 1
  seen = [0] * (N + 1)
  compressed = [0] * (N + 1)
  order = []
  for v0 in range(1, N + 1):
    if seen[v0]:
      continue
    st = deque()
    st.append(v0)
    while st:
      v = st.pop()
      if v < 0:
        order.append(-v)
      else:
        if seen[v]:
          {{completion}}
        seen[v] = 1
        st.append(-v)
        for u in adj[v]:
          st.append(u) 
  seen = [0] * (N + 1)
  num = 0
  for v0 in reversed(order):
    if seen[v0]:
      continue
    num += 1
    st = deque()
    st.append(v0)
    seen[v0] = 1
    compressed[v0] = num
    while st:
      v = st.pop()
      for u in adj_rev[v]:
        if seen[u]:
          continue
        seen[u] = 1
        compressed[u] = num
        st.append(u) 
  return num, compressed
def construct(adj, num, compressed):
  N = len(adj) - 1
  adj_compressed = [set() for _ in range(num + 1)]
  for v in range(1, N + 1):
    v_cmp = compressed[v]
    for u in adj[v]:
      u_cmp = compressed[u]
      if v_cmp != u_cmp:
        adj_compressed[v_cmp].add(u_cmp)
  return adj_compressed
INF=10**15
for _ in range(t):
  n,m=map(int,input().split())
  a=list(map(int,input().split()))
  adj = [[] for _ in range(n + 1)]
  adj_rev = [[] for _ in range(n + 1)]
  for i in range(m):
    u,v=map(int,input().split())
    adj[u].append(v)
    adj_rev[v].append(u)    
  NN, comp = scc(adj, adj_rev)
  adj_comp = construct(adj, NN, comp)
  cnt=[0]*(NN+1)
  num=[0]*(NN+1)
  for i in range(n):
    cnt[comp[i+1]]+=a[i]
    num[comp[i+1]]+=1
  dist = [-1]*(NN+1)
  dp=[0]*(NN+1)
  for i in range(1,NN+1):
    if dist[i]==-1:
      dist[i]=num[i]
      dp[i]=cnt[i]
    for j in adj_comp[i]:
      d=dist[i]+num[j]
      c=dp[i]+cnt[j]
      if dist[j]<d:
        dist[j]=d
        dp[j]=c
      elif dist[j]==d:
        dp[j]=min(dp[j],c)
  male=0
  mival=INF
  for i in range(1,NN+1):
    if male<dist[i]:
      male=dist[i]
      mival=dp[i]
    elif male==dist[i]:
      mival=min(mival,dp[i])
  print(male,mival)",continue,"continue
        seen[v] = 1
        st.append(-v)
        for u in adj[v]:
          st.append(u) 
  seen = [0] * (N + 1)
  num = 0
  for v0 in reversed(order):
    if seen[v0]:
      continue
    num += 1
    st = deque()
    st.append(v0)
    seen[v0] = 1
    compressed[v0] = num
    while st:
      v = st.pop()
      for u in adj_rev[v]:
        if seen[u]:
          continue
        seen[u] = 1
        compressed[u] = num
        st.append(u) 
  return num, compressed
"
"
t=int(input())
for i in range(t):
    n=int(input())
    l=sorted(list(map(int,input().split())))
    if len(set(l)) < 3 and abs(l.count(l[0]) - l.count(l[-1])) < 2:
        print(""Yes"")
    else:
        {{completion}}

","print(""No"")","
        print(""No"")"
"
def solve():
    n=int(input())
    v=[int(i) for i in input().split()]
    mp={}
    for i in range(n):
       if mp.__contains__(v[i]):
           mp[v[i]]+=1
       else:
           mp[v[i]]=1
    if len(mp)>2:
        print(""NO"")
    else:
        if len(mp)==1:
            print(""YES"")
        else:
            x,y=0,0
            for i ,j in mp.items():
                if x==0:
                    x=j
                else:
                    {{completion}}
            if abs(x-y)<2:
                print(""YES"")
            else:
                print(""NO"")

t= int(input())
for i in range(t):
    solve()

",y=j,y=j
"
n = int(input())


for i in range(n):
    n  = int(input())
    arr = [int(x) for x in input().split("" "")]
    d = {}
    if len(arr)<=2:
        print(""YES"")
        continue
    for x in arr:
        if x in d:
            d[x]+=1
        else:
            d[x]=1
    l = len(d)
    if l>2:
        print(""NO"")
    else:
        if l==2:
            n = list(d.values())
            m = abs((n)[0] - n[1])
            if m<=1:
                print(""YES"")
                continue
            else:
                {{completion}}
        print(""YES"")
        
    
            
        
        
    ","print(""NO"")
                continue","k = n[0]
                arr2 = []
                for x in arr:
                    if x==k:
                        arr2.append(x)
                    else:
                        arr2.append(k)
                arr2.sort()
                arr2.reverse()
                if arr2==arr:
                    print(""YES"")
                else:
                    print(""NO"")
        else:
            k = n[0]
            arr2 = []
            for x in arr:
                if x==k:
                    arr2.append(x)
                else:
                    arr2.append(k)
            arr2.sort()
            arr2.reverse()
            if arr2==arr:
                print(""YES"")
            else:
                print(""NO"")
    
    "
"import sys
input = sys.stdin.readline
INF = 10 ** 18

def bfs(start, G):
    n = len(G)
    order = [start]
    par = [-1] * n
    for i in range(n):
        u = order[i]
        for v in G[u]:
            if v == par[u]:
                {{completion}}
            par[v] = u
            order.append(v)
    return order, par

def solve():
    n = int(input())
    A = list(map(int, input().split()))
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
        
    order, par = bfs(0, G)
    dp = [-INF] * n
    ans = 0

    for u in reversed(order):
        p = par[u]
        sm = [-INF] * 4  # sum of highest j children dp
        sm[0] = 0

        for v in G[u]:
            if v == p:
                continue
            
            sm[3] = max(sm[3], sm[3] + dp[v])
            for i in range(3, 0, -1):
                sm[i] = max(sm[i], sm[i - 1] + dp[v])

        ans = max(ans, A[u])
        ans = max(ans, A[u] + sm[1])
        ans = max(ans, sm[2])
        ans = max(ans, A[u] + sm[3])
        
        dp[u] = max(dp[u], A[u])    # take no children
        dp[u] = max(dp[u], sm[1])   # take one children, delete u
        dp[u] = max(dp[u], A[u] + max(sm[2], sm[3]))    # take 2+ children

    return ans


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))",continue,"par[u] = -1
                break
        else:"
"import sys
input = sys.stdin.readline
INF = 10 ** 18
 
def bfs(start, G):
    n = len(G)
    order = [start]
    par = [-1] * n
    for i in range(n):
        u = order[i]
        for v in G[u]:
            if v == par[u]:
                {{completion}}
            par[v] = u
            order.append(v)
    return order, par
 
def solve():
    n = int(input())
    A = list(map(int, input().split()))
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
        
    order, par = bfs(0, G)
    dp = [-INF] * n
    ans = 0
 
    for u in reversed(order):
        p = par[u]
        sm = [-INF] * 4  # sum of highest j children dp
        sm[0] = 0
 
        for v in G[u]:
            if v == p:
                continue
            
            sm[3] = max(sm[3], sm[3] + dp[v])
            for i in range(3, 0, -1):
                sm[i] = max(sm[i], sm[i - 1] + dp[v])
 
        ans = max(ans, A[u])
        ans = max(ans, A[u] + sm[1])
        ans = max(ans, sm[2])
        ans = max(ans, A[u] + sm[3])
        
        dp[u] = max(dp[u], A[u])    # take no children
        dp[u] = max(dp[u], sm[1])   # take one children, delete u
        dp[u] = max(dp[u], A[u] + max(sm[2], sm[3]))    # take 2+ children
 
    return ans
 
i=0
T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))",continue,"par[u] = -1
                break
        else:"
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()
from math import gcd


for _ in range(int(input())):
    n = int(input())
    a = sorted(map(int, input().split()))
    if n == 1:
        print(1)
        continue
    g = 0
    for i in range(1, n):
        g = gcd(g, a[i] - a[i-1])

    ans = 0
    for x in a:
        ans += (a[-1] - x) // g
    
    st = set(a)

    for i in range(1, n+1):
        if a[-1] - g * i not in st:
            {{completion}}

    print(ans)","ans += i
            break",ans -= 1
"import sys
input=sys.stdin.buffer.readline

def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input().decode(""utf-8"")[:-2]
def rm():
    return map(int,input().split())

from math import gcd
def main():
    n=ri()
    a=rl()
    if n==1: return 1
    a.sort()
    g=0
    for i in range(n-1):
        g=gcd(a[i+1]-a[i],g)
    sm1=(a[-1]*n-sum(a))//g
    res=sm1+n
    for i in range(n-2,-1,-1):
        if a[-1]-a[i]!=(n-1-i)*g: {{completion}}
    return res

t=ri()
for i in range(t):
    print(main())","res=min(res,sm1+n-1-i)","res+=1
        else: res+=1
    res=min(res,sm1)"
"import sys, math
from collections import deque, defaultdict, Counter
t = int(sys.stdin.readline().strip())
for _ in range(t) : 
    n = int(sys.stdin.readline().strip())
    node = [*map(int, sys.stdin.readline().strip().split())]
    if n == 1 : 
        print(1)
    elif n == 2 : 
        print(3)
    else : 
        node.sort()
        g = node[1] - node[0]
        for i in range(1, n - 1) : 
            g = math.gcd(g, node[i + 1] - node[i])
        k = 0
        for i in range(n) : 
            k += node[-1] - node[i]
        ans = (k + n * g) // g
        M = node[-1]
        x = node[-1]
        while node : 
            if x == node[-1] : 
                node.pop()
                x -= g
            else : 
                {{completion}}
        ans = min(ans, (k + M - x) // g)
        print(ans)",break,"node.pop()
                x += g"
"import sys
input = sys.stdin.readline


for _ in range(int(input())):
    n = int(input())
    a, b = 0, 0
    for i in map(int, input().split()):
        {{completion}}
    print(a-1)
","x = i-b
        a += max(0, x)
        b = i","a, b = b, a+i"
"import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
	n = int(input())
	c = [*map(int, input().split())]

	ans = c[0] - 1
	befo = c[0]
	for ci in c[1:]:
		if befo < ci:
			{{completion}}
		befo = ci
	print(ans)",ans += ci - befo,"ans = min(ans, ci - befo)"
for s in[*open(0)][2::2]:{{completion}},print(len(s.lstrip('B').rstrip('A\n')or'*')-1),"
    s=s.replace('\n','')
    s=s.replace(' ','')
    s=s.replace('A','B')
    s=s.replace('B','A')
    s=s.replace('ABAB','ABBA')
    s=s.replace('ABBA','BABA')
    s=s.replace('BABA','BABA')
    s=s.replace('ABAB','ABBA')
    s=s.replace('ABBA','BABA')
    s=s.replace('ABAB','ABBA')
    s=s.replace('ABBA','BABA')
    s=s.replace('ABAB','ABBA')
"
"for i in range(int(input())):
    n=int(input())
    k=input()
    a=k.find(""A"")
    b=k.rfind(""B"")
    if a==-1:
        print(0)
    else:
        {{completion}}","print(max(b-a,0))","s=k[a+1:b]
        s=s+k[:a]
        s=s+k[b+1:]
        print(len(s))
<|/ file source=github "
"t = int(input())
for I in range(t):
    n = int(input())
    s = input()
    if 'A' not in s or 'B' not in s:
        {{completion}}
    print(max(s.rfind('B') - s.find('A'), 0))
","print(0)
        continue",exit()
"from __future__ import print_function
from math import *
from collections import defaultdict, deque
import os
import random
import sys
from io import BytesIO, IOBase
from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        {{completion}}
                    to = stack[-1].send(to)
            return to
    return wrappedfunc
#import time
 
def main():
    pass
 
# region fastio
 
BUFSIZE = 8192
def lcm(a,b):
    return (a*b)//gcd(a,b)
def ceilDiv(a,b):
    if a%b==0:
        return a//b
    else:
        return a//b+1
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class myDict:
    def __init__(self,func):
        self.RANDOM = random.randint(0,1<<32)
        self.default=func
        self.dict={}
    def items(self):
        return [(i^self.RANDOM,j) for i,j in self.dict.items()]
    def __getitem__(self,key):
        myKey=self.RANDOM^key
        if myKey not in self.dict:
            self.dict[myKey]=self.default()
        return self.dict[myKey]
    def __setitem__(self,key,item):
        myKey=self.RANDOM^key
        self.dict[myKey]=item
    def __iter__(self):
        return iter(i^self.RANDOM for i in self.dict)
    def __contains__(self,key):
        return key^self.RANDOM in self.dict
    def __repr__(self):
        return repr({i^self.RANDOM:j for i,j in self.dict.items()})
class mySet:
    def __init__(self):
        self.random=random.randint(0,1<<32)
        self.set = set()
    def add(self,key):
        self.set.add(key^self.random)
    def remove(self,key):
        self.set.remove(key^self.random)
    def __contains__(self,key):
        return key^self.random in self.set
    def __iter__(self):
        return iter(i^self.random for i in self.set)
    def __len__(self):
        return len(self.set)
    def __repr__(self):
        s = set()
        for item in self.set:
            s.add(item^self.random)
        return repr(s)
        
    
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
#sys.stdin, sys.stdout =open(""test.txt"",""r""),open(""result.txt"",""w"")
#ini=time.time()
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
mod=10**9+7
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) ]))
def invr():
    return(map(int,input().split()))


class XorBasis:
    
    def __init__(self, bit_length=31):
        self.bit_length=bit_length
        self.basis_size=0
        self.val = [0]*self.bit_length
    
    def is_redundant(self, x):
        for i in range(self.bit_length):
            if (x>>i)&1:
                if self.val[i]==0:
                    return False
                x^=self.val[i]
        return True
    
    def insert(self, x):
        for i in range(self.bit_length):
            if (x>>i)&1:
                if self.val[i]==0:
                    self.val[i]=x
                    self.basis_size+=1
                    return True
                x^=self.val[i]
        return False
    
n=inp()
A=inlt()
l=[[] for i in range(n)]
for i in range(n-1):
    a,b=invr()
    l[a-1].append(b-1)
    l[b-1].append(a-1)
dp=[[0]*20 for i in range(n)]
vals=[[] for i in range(n)]
depth=[0 for i in range(n)]

q=deque()
q.append(0)
v=[0]*n
v[0]=1
if A[0]!=0:
    vals[0].append((A[0],0))
while q:
    node=q.popleft()
    for child in l[node]:
        if not v[child]:
            v[child]=1
            q.append(child)
            depth[child]=1+depth[node]
            bas=XorBasis(bit_length=20)
            dp[child][0]=node
            if bas.insert(A[child]):
                vals[child].append((A[child],depth[child]))
            for val,dep in vals[node]:
                if bas.insert(val):
                    vals[child].append((val,dep))
for j in range(1,20):
    for i in range(n):
        dp[i][j]=dp[dp[i][j-1]][j-1]

for _ in range(inp()):
    a,b,v=invr()
    a-=1
    b-=1
    bas=XorBasis(bit_length=20)
    rema=a
    remb=b
    if depth[a]>depth[b]:
        a,b=b,a
    dif=depth[b]-depth[a]
    i=0
    while dif>0:
        if (dif>>i)&1:
            b=dp[b][i]
            dif^=1<<i
        i+=1
    if a==b:
        lca=a
    else:
        for i in range(19,-1,-1):
            if dp[a][i]!=dp[b][i]:
                a=dp[a][i]
                b=dp[b][i]
        lca=dp[a][0]
    for val,dep in vals[rema]:
        if dep>=depth[lca]:
            bas.insert(val)
    for val,dep in vals[remb]:
        if dep>=depth[lca]:
            bas.insert(val)
    
    if bas.is_redundant(v):
        print(""YES"")
    else:
        print(""NO"")",break,return
"import sys
from collections import defaultdict
import bisect
from functools import lru_cache
import math
import heapq

# t = int(sys.stdin.readline())
# n, m = map(int, sys.stdin.readline().strip().split())
# nums = map(int, sys.stdin.readline().strip().split())
# a_list = list(map(int, sys.stdin.readline().split()))
# b_list = list(map(int, sys.stdin.readline().split()))

def solute():
    n, q = map(int, sys.stdin.readline().split())
    s = sys.stdin.readline().strip()

    pos = [(0, 0)]
    d = defaultdict(list)
    d[""0,0""].append(0)

    curr = [0, 0]
    for i, ch in enumerate(s):
        if ch == ""R"":
            curr[0] += 1
        elif ch == ""L"":
            curr[0] -= 1
        elif ch == ""U"":
            curr[1] += 1
        else:
            curr[1] -= 1

        d["","".join(map(str, curr))].append(i+1)
        pos.append(tuple(curr))

    ans = []

    for _ in range(q):
        x, y, l, r = map(int, sys.stdin.readline().split())

        k1 = "","".join(map(str, (x, y)))
        if k1 in d and (d[k1][0] <= l-1 or d[k1][-1] >= r):
            ans.append(""YES"")
            continue

        pos_start = pos[l-1]
        pos_end = pos[r]
        new_target = [pos_start[0] + pos_end[0] - x, pos_start[1] + pos_end[1] - y]
        k2 = "","".join(map(str, new_target))
        if k2 in d:
            idx = bisect.bisect_right(d[k2], r)
            if idx > 0 and d[k2][idx-1] >= l:
                {{completion}}
        ans.append(""NO"")
    print(""\n"".join(ans))
solute()","ans.append(""YES"")
                continue","ans.append(""YES"")
                continue
            elif idx > 0 and d[k2][idx-1] < l:
                ans.append(""NO"")
                continue
            elif idx < len(d[k2]) and d[k2][idx] > r:
                ans.append(""NO"")
                continue
            elif idx < len(d[k2]) and d[k2][idx] < r:
                ans.append(""YES"")
                continue
            else:
                ans.append(""NO"")
                continue
        else:
            ans.append(""NO"")
            continue

        ans.append(""YES"")
        continue"
"import sys

input = lambda: sys.stdin.readline().strip()

n, q = map(int, input().split())
x = 0
y = 0
s = input()
d = dict()
d['0 0'] = [0]
a = [[0, 0]]
p = 1
for i in s:
    if i == 'R':
        x += 1
    elif i == 'L':
        x -= 1
    elif i == 'U':
        y += 1
    else:
        y -= 1
    a.append([x, y])
    k = str(x) + ' ' + str(y)
    if k in d:
        d[k].append(p)
    else:
        d[k] = [p]
    p += 1
for t in range(q):
    x, y, l, r = map(int, input().split())
    k1 = x - a[l - 1][0]
    k2 = y - a[l - 1][1]
    k3 = a[r][0] - k1
    k4 = a[r][1] - k2
    s1 = str(x) + ' ' + str(y)
    s2 = str(k3) + ' ' + str(k4)
    if s1 in d and (d[s1][0] < l or d[s1][-1] >= r):
        print('YES')
    elif s2 in d:
        l1 = -1
        r1 = len(d[s2])
        if d[s2][-1] >= l:
            while r1 - l1 > 1:
                m = (r1 + l1) // 2
                if d[s2][m] >= l:
                    r1 = m
                else:
                    {{completion}}
            if d[s2][r1] < r:
                print('YES')
            else:
                print('NO')
        else:
            print('NO')
    else:
        print('NO')
        
            

    
    
    
    
    
            
            

    
",l1 = m,"l1 = m
        else:
            while r1 - l1 > 1:
                m = (r1 + l1) // 2
                if d[s2][m] >= r:
                    r1 = m
                else:
                    l1 = m
        if r1 - l1 == 1:"
"# https://codeforces.com/contest/1902

import sys
from collections import defaultdict
from bisect import bisect_right

input = lambda: sys.stdin.readline().rstrip()  # faster!

DIR = {""U"": (0, +1), ""D"": (0, -1), ""L"": (-1, 0), ""R"": (+1, 0)}
SHIFT = 2 * 10 ** 5 + 5
MASK = 2 ** 20 - 1


def ff(x, y):
    return ((x + SHIFT) << 20) + (y + SHIFT)


def fr(v):
    return (v >> 20) - SHIFT, (v & MASK) - SHIFT


def check(lst, left, right):
    i = bisect_right(lst, left)
    if 0 < i and lst[i - 1] == left:
        return True
    j = bisect_right(lst, right)
    return i != j


n, q = map(int, input().split())  # 1 <= n, q <= 2 * 10**5
s = input()

pos = [0] * (n + 1)
x, y = 0, 0
pos[0] = ff(x, y)
for i, c in enumerate(s, 1):
    x, y = x + DIR[c][0], y + DIR[c][1]
    pos[i] = ff(x, y)

mem = defaultdict(list)
for i, p in enumerate(pos):
    mem[p] += [i]

ans = []
for _ in range(q):
    x, y, l, r = map(int, input().split())

    res = ""NO""

    if check(mem[ff(x, y)], 0, l - 1):
        res = ""YES""
    elif check(mem[ff(x, y)], r, n):
        res = ""YES""
    else:
        xs, ys = fr(pos[l - 1])
        xe, ye = fr(pos[r])
        dx, dy = xe - xs, ye - ys
        tdx, tdy = x - xs, y - ys
        rdx, rdy = dx - tdx, dy - tdy

        # print(""*"", xs + rdx, ys + rdy, l, r)
        if check(mem[ff(xs + rdx, ys + rdy)], l, r):
            {{completion}}

    ans += [res]

print(""\n"".join(ans))","res = ""YES""","mem[ff(xs + rdx, ys + rdy)] += [i]
            res = ""YES""
        else:
            mem[ff(xs + rdx, ys + rdy)] += [i]
            res = ""NO"""
"from sys import stdin, stdout
import math

for _ in range(int(stdin.readline())):
    n = int(stdin.readline())
    a = list(map(int, stdin.readline().split()))

    after, res = a[-1], 0
    for i in range(n - 2, -1, -1):
        {{completion}}
    stdout.write(str(res) + '\n')","d = math.ceil(a[i] / after)
        res += d - 1
        after = a[i] // d","after, a = a[i], a[:i] + [a[i]] + a[i + 1:]
        res += math.ceil((after - 1) / (n - i))
    
    stdout.write('Case #{}: {}\n'.format(_ + 1, res))
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import sys
input = sys.stdin.readline
def solve():
    n = int(input())
    ls = list(map(int, input().split()))
    last = ls[-1]
    ans = 0
    for i in range(n-2 , -1 , -1):
        if ls[i] <= last : 
            {{completion}}
        x = (ls[i] // last ) + (1 if ls[i]%last != 0 else 0) 
        last = ls[i] // x
        ans += x -1
    print(ans) 

for _ in range(int(input())):
    solve()","last = ls[i]
            continue","ans += 1
            break
        
    for i in range(n-2 , -1 , -1):"
"import sys
 
f=sys.stdin
# 13
# 13//6 ->  MIN(2)
ans = 13//6 
t=int(f.readline())
for i in range(t):
    n=int(f.readline())
    a=list(map(int,f.readline().split()))
    base=a[-1]
    ans=0
    for j in range(n):
        if a[-j-1]%base==0:
            cut=(a[-j-1])//base
            ans+=cut-1
            base=a[-j-1]//cut
        else:
            {{completion}}
        # print(j,cut,ans,base,a[-j-1]) 
    print(ans)","cut=(a[-j-1])//base+1
            # print(cut,base,j)
            ans+=cut-1
            base=a[-j-1]//cut","ans+=1
            base=base*2
        ans-=1"
"n=int(input())
arr = list(map(int, input().split()))
a = [0]*n
b = [0]*n
for i in range(1,n):
    {{completion}}
print(min(max(arr[i],a[i],b[i]) for i in range(n)))","a[i] = max(a[i-1], arr[i-1] + n - i)
    b[n-i-1] = max(b[n-i], arr[n-i] + n - i)","arr[i] = arr[i]+a[i]
    arr[i] = arr[i]+b[i]
    arr[i] = arr[i]+a[i]
    arr[i] = arr[i]+b[i]
    arr[i] = arr[i]+a[i]
    arr[i] = arr[i]+b[i]
    arr[i] = arr[i]+a[i]
    arr[i] = arr[i]+b[i]
    arr[i] = arr[i]+a[i]
    arr[i] = arr[i]+b[i]
    arr[i] = arr[i]+a[i]
    arr[i] = arr[i]+b[i]
    arr[i] = arr[i]+a[i]
    arr[i] = arr[i]+b[i]
    arr[i] = arr[i]+a[i]
    arr"
"def solve(arr):
    rmax = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        {{completion}}
    lmax = 0
    ans = float('inf')
    for i in range(n):
        ans = min(ans, max(lmax, arr[i], rmax[i+1]))
        lmax = max(lmax, arr[i] + n - i - 1)
    return ans


n = int(input())
a = [int(s) for s in input().split()]
print(solve(a))
","rmax[i] = max(rmax[i+1], arr[i] + i)","arr[i] = max(arr[i], rmax[i + 1])
        rmax[i + 1] = arr[i]
    lmax = 0
    ans = float('inf')
    for i in range(n):
        ans = min(ans, max(lmax, arr[i], rmax[i + 1]))
        lmax = max(lmax, arr[i] + n - i - 1)
    return ans


n = int(input())
a = [int(s) for s in input().split()]
print(solve(a))
""""""


def solve(arr):
    rmax = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        arr[i] = max(arr[i], rmax[i + 1])
        rmax[i + 1] = arr[i]"
"for _ in range(1):
    n = int(input())
    a = [int(x) for x in input().split()]
    start = a.copy()
    mx = a[0]
    for i in range(1, n):
        {{completion}}
    mx = a[n - 1]
    for i in range(n - 2, -1, - 1):
        mx = max(mx, a[i], a[i + 1] + i + 1)
        start[i] = max(start[i], mx)
    print(min(start))
","mx = max(mx, a[i], a[i - 1] + (n - i))
        start[i] = mx","start.append(mx)
        mx = max(a[i], a[i + 1] + i + 1)
    print(min(start))
""""""
<|/ a dscore=0 |>"
"import sys
import time

ts = time.time()

n, q = map(int, input().split())
a = list(map(int, input().split()))
#qq = [input() for i in range(q)]
qq = sys.stdin.readlines()

kmax = 20
u = [0]*(1<<kmax)
for ai in a:
    u[ai] += 1
v0 = [None]*(1<<kmax)
v1 = [0]*(1<<kmax)
for k in range(kmax):
    k2 = 1<<k
    v0, v1 = v1, v0
    for i0 in range(0, 1<<kmax, 2*k2):
        i1 = i0 + k2
        for j in range(k2):
            {{completion}}
        c = sum(u[i0:i0+k2])
        s = sum(u[i0+x]*(k2-x) for x in range(k2))
        for j in range(k2):
            v1[i1+j] = s+j*c+v0[i1+j]

qq = sorted((int(qq[i]), i) for i in range(q))

ans = [None]*q

x = (1<<kmax)-1

for qk,i in qq[::-1]:
    if qk >= v1[-1]:
        ans[i] = (1<<kmax) - 1 + (qk - v1[-1])//n
        continue
    while v1[x] > qk:
        x -= 1
    ans[i] = x

for a in ans:
    print(a)
",v1[i0+j] = v0[i0+j]+v0[i1+j],v0[i1+j] = v0[i1+j] + 1
"from sys import stdin,stdout
input = stdin.readline
from bisect import bisect,bisect_right
from math import inf,ceil,log2
from heapq import heapify,heappop,heappush
from collections import Counter


n,q = map(int,input().split())
a = list(map(int,input().split()))
ans1 = []
ans2 = []
for __ in range(q):
    k = int(input())
    a2 = list(a)
    ans = 0
    for i in range(61,-1,-1):
        p = (1<<(i+1))-1
        op = 1<<i
        cnt = 0
        for j in range(n):
            o = p&a2[j]
            cnt += max(0,op-o)
        if (cnt <= k):
            ans += op
            k -= cnt
            for j in range(n):
                o = p&a2[j]
                if (op > o):
                    {{completion}}              
    print(ans)                






                   ",a2[j] = 0,"op -= o
                    p -= o
            
    ans1.append(ans)
    ans2.append(k)
    
    
for __ in range(q):
    k = int(input())
    a2 = list(a)
    ans = 0
    for i in range(61,-1,-1):
        p = (1<<(i+1))-1
        op = 1<<i
        cnt = 0
        for j in range(n):
            o = p&a2[j]
            cnt += max(0,op-o)
        if (cnt <= k):
            ans += op
            k -= cnt
            for j in range(n):
                o = p&a2[j]
                if (op > o):
                    op -= o
                    "
"# import io,os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from sys import stdin
input = lambda: stdin.buffer.readline().rstrip(b'\r\n').decode('ascii')
# from queue import PriorityQueue as pq
# from  heapq import heappop,heappush
# from math import gcd,lcm
from collections import defaultdict as mmap
tt=1
# tt=int(input())
for _ in range(tt): 
    n,m=map(int,input().split())
    # d=mmap(int)
    a=list(map(int,input().split()))
    #s=list(input())
    #print(""YES"" if tst else ""NO"")  
    while(m): 
        k=int(input())
        cnt=0;
        vis=[1 for i in range(n)]
        ans=0;  
        for i in range(62,-1,-1) :
            x=(1<<(i)); 
            temp=0; 
            for j in range(n): 
                op= (1<<(i));
                op-=(((1<<(i+1))-1)&a[j]);
                if(vis[j] and (a[j]&x)==0):
                    temp+=max(0,op);
                 
            if(temp+cnt*(1<<i)<=k): 
                ans|=(1<<i);
                k-=temp+cnt*(1<<i);
                for j in range(n): 
                    if(vis[j] and ((1<<(i))&a[j])==0):
                        {{completion}}  
        m-=1 
          
        print(ans)
         

  ","cnt+=1
                        vis[j]=0;","vis[j]=0; 
                cnt+=1;
                if(cnt==k): 
                    break; 
            
        if(k>0): 
            ans|=(1<<i);"
"import sys
input=sys.stdin.buffer.readline
def rl(): return list(map(int,input().split()))
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())

def main():
    n,q=rm()
    b=rl()
    for i in range(q):
        k=ri()
        cur=0
        a=[num for num in b]
        for j in range(60,-1,-1):
            req=0
            tmp=cur+(1<<j)
            for z in range(n):
                req+=max((((tmp|a[z])>>j)<<j)-a[z],0)
            if req<=k:
                cur=tmp
                k-=req
                for z in range(n):
                    {{completion}}
        print(cur)

main()","a[z]+=max((((tmp|a[z])>>j)<<j)-a[z],0)","a[z]-=req
                break"
"import sys
import random

input = sys.stdin.readline
rd = random.randint(10 ** 9, 2 * 10 ** 9)

Mod = random.randint(10 ** 16, 2 * 10 ** 18)
ps = 31
Mx = 10 ** 6 + 1
from collections import Counter
c = Counter()
ans = 0
total = 0
n = int(input())
li = [input().strip() for _ in range(n)]
for k in range(n):
    # 正向hash
    s = li[k]
    hash = 0
    for i in range(len(s) - 1, -1, -1):
        {{completion}}

for k in range(n):
    s = li[k]
    hash = 0
    mi = 10 ** 18
    for i in range(len(s)):
        hash = (ps * hash + (ord(s[i]) - 96)) % Mod
        mi = min(mi, c[hash])
        ans += mi

    total += 2 * n * len(s)

print(total - 2 * ans)","hash = (ps * hash + (ord(s[i]) - 96)) % Mod
        c[hash] += 1","hash = (ps * hash + (ord(s[i]) - 96)) % Mod
        c[hash] += 1
    total += 2 * n * len(s)

print(total - 2 * ans)"
"import sys
input = sys.stdin.readline

for _ in range(int(input())):
    w = list(map(int, input().split()))
    d = []
    for i in range(3):
        if (w[(i+1)%3] + w[(i+2)%3]) % 2:
            d.append('0')
        else:
            {{completion}}
    print(' '.join(d))",d.append('1'),d.append('1')
"import sys
input=sys.stdin.buffer.readline
def rl(): {{completion}}
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())

def main():
    a,b,c=rm()
    print(1-(b+c)%2,1-(a+c)%2,1-(a+b)%2)
    
t=ri()
for i in range(t):
    main()","return list(map(int,input().split()))",return input()
"import sys
 
input = sys.stdin.readline
 
for _ in range(int(input())):
    a, b, c = map(int, input().split())
    if a % 2 == b % 2 == c % 2:
        sys.stdout.write(""1 1 1 \n"")
    elif b % 2 == c % 2:
        {{completion}}
    elif a % 2 == c % 2:
        sys.stdout.write(""0 1 0 \n"")
    elif a % 2 == b % 2:
        sys.stdout.write(""0 0 1 \n"")","sys.stdout.write(""1 0 0 \n"")","sys.stdout.write(""1 0 1 \n"")"
"test_case = int(input())
answers = []
for test in range(test_case):
    n = int(input())
    array = list(map(int,input().split("" "")))
    total_operation = array.index(min(array))
    after = array[total_operation+1:]
    if after == sorted(after):
        answers.append(total_operation)
    else:
        {{completion}}
for ans in answers:
    print(ans)",answers.append(-1),"answers.append(-1)
if answers == []:
    print(""-1"")
else:"
"def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    fm = 0
    for i in range(n):
        if a[i] < a[fm]:
            {{completion}}
    for i in range(fm + 1, n):
        if a[i] < a[i - 1]:
            print(-1)
            return
    print(fm)
 
 
for _ in range(int(input())):
    solve()",fm = i,"a[fm] = a[i]
            fm += 1
        else:
            a[fm] = a[i - 1]
            fm += 1"
"import sys
input=sys.stdin.buffer.readline
def rl(): return list(map(int,input().split()))
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())

def main():
    n=ri()
    a=rl()
    mi=10**18
    pos=-1
    for i in range(n):
        if a[i]<mi:
            {{completion}}
    for j in range(pos,n-1):
        if a[j]>a[j+1]: return -1
    return pos

t=ri()
for i in range(t):
    print(main())","pos=i
            mi=a[i]","mi=a[i]
            pos=i
    if pos==-1: return -1"
"import sys
from collections import defaultdict
import heapq

def solute():
    n = int(sys.stdin.readline())
    a_list = list(map(int, sys.stdin.readline().split()))
    adds = defaultdict(int)
    ans = 0
    idxs = dict()
    sorted = True
    for i in range(n):
        if a_list[i] != i+1:
            sorted = False
        a_list[i] -= 1
        idxs[a_list[i]] = i
    if sorted:
        print(n-2)
        return

    over = []
    missing = set()

    for i, a in enumerate(a_list):
        assert len(over) == len(missing)
        if a == i:
            if not len(over):
                ans += 1
            elif len(over) > 1:
                {{completion}}
            else:
                num = list(missing)[0]
                val, idx = over[0]
                i1 = idxs[num]
                adds[(idx, i1)] += 1

        elif a > i:
            i1 = idxs[i]
            if not over:
                adds[(i, i1)] += 1
            heapq.heappush(over, (a, i))
            if idxs[i] > i:
                missing.add(i)

        else:
            if idxs[i] > i:
                missing.add(i)
            if len(over) == 1 and over[0][0] == i:
                val, idx = heapq.heappop(over)
                adds[(idx, val)] += 1

        if a in missing:
            missing.remove(a)
        if over and over[0][0] == i:
            heapq.heappop(over)
    ans += max(adds.values())
    print(ans)

t = int(sys.stdin.readline())

for _ in range(t):
    solute()",continue,"num = list(missing)[0]
                val, idx = over[0]
                i1 = idxs[num]
                adds[(idx, i1)] += 1
                missing.remove(num)
                heapq.heappush(over, (a, i))"
"tc=int(input())
for _ in range(tc):
    n=int(input())
    a=list(map(int,input().split()))
    pos=[0]*(n+1)
    for i in range(n):pos[a[i]]=i
    pref=[a[0]]*n
    for i in range(n-1):pref[i+1]=max(pref[i],a[i+1])
    suf=[n+1]*(n+1)
    for i in range(n-1,-1,-1):suf[i]=min(suf[i+1],a[i])
    base=0
    for i in range(n):base+=suf[i]==a[i] and a[i]==i+1
    if base==n:
        print(n-2)
        continue
    ans=base
    ks={}
    i=0
    while i<n:
        r=pos[suf[i]]
        mn=n+1
        for j in range(r,i-1,-1):
            l=pos[pref[j]]
            if j!=r and j!=l:{{completion}}
            a[l],a[r]=a[r],a[l]
            if a[j]==j+1 and min(mn,a[j],suf[r+1])==a[j]:ks[l*1000000+r]=ks.get(l*1000000+r,0)+1
            a[l],a[r]=a[r],a[l]
        i=r+1
    for k in ks:ans=max(ans,base+ks[k])
    print(ans)
","mn=min(mn,a[j])","
                mn=min(mn,a[j],a[j+1])
                a[l],a[j]=a[j],a[l]
            if a[j]==j+1 and min(mn,a[j],suf[r+1])==a[j]:ks[l*1000000+r]=ks.get(l*1000000+r,0)+1
            a[l],a[j]=a[j],a[l]
        i=r+1
    for k in ks:ans=max(ans,base+ks[k])
    print(ans)
<|/ a |>"
"def _read_ints():
    return [int(tok) for tok in input().split()]
def psums(A):
    out=[None]*len(A)
    for i,v in enumerate(A):
        out[i]=(out[i-1] if i>0 else 0)+v
    return out

out_lines=[]
_T,=_read_ints()
for _t in range(_T):
    N,=_read_ints()
    P=[v-1 for v in _read_ints()]
    ret=None
    if all(P[i]==i for i in range(N)):
        ret=N-2
    else:
        cycles=[]
        seen=[False]*N
        for i0 in range(N):
            if not seen[i0]:
                v=i0
                cyc=[]
                while True:
                    seen[v]=True
                    cyc.append(v)
                    v=P[v]
                    if v==i0:
                        {{completion}}
                if len(cyc)>1:
                    cycles.append(cyc)
        # print(cycles)
        # for each cycle arc (l,r),
        #  add +1 to overlap[l+1...r-1]
        d_overlap=[0]*N
        for cyc in cycles:
            for i in range(len(cyc)):
                u,v=cyc[i],cyc[(i+1)%len(cyc)]
                l,r=min(u,v),max(u,v)
                assert l<r
                d_overlap[l+1]+=1
                d_overlap[r]-=1
        overlap=psums(d_overlap)
        # overlap=[None]*N
        # for i in range(N):
        #     overlap[i]=(overlap[i-1] if i>0 else 0)+d_overlap[i]
        # print(overlap)
        ngoods=sum(
            1 for i in range(N)
            if P[i]==i and overlap[i]==0
        )
        # print(ngoods)
        fixed_2arcs=[
            (1 if P[i]==i and overlap[i]==2 else 0)
            for i in range(N)
        ]
        # print(fixed_2arcs)
        psum_fxied_2arcs=psums(fixed_2arcs)
        ret=0
        for cyc in cycles:
            locs=sorted(cyc)
            for li in range(len(locs)-1):
                # split cycle into two cycles
                # over locations locs[..li] and locs[li+1..]
                l,r=locs[li],locs[li+1]
                # scr=ngoods+sum(
                #     1 for i in range(l+1,r)
                #     if fixed_2arcs[i]
                # )
                scr=ngoods+(psum_fxied_2arcs[r-1]-psum_fxied_2arcs[l])
                if li==0 and overlap[locs[0]]==0:
                    scr+=1
                if li+1==len(locs)-1 and overlap[locs[-1]]==0:
                    scr+=1
                ret=max(ret,scr)
    out_lines.append(ret)
    
print('\n'.join(str(l) for l in out_lines))",break,"ret=max(ret,len(cyc))
                        break
                    v=P[v]"
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()
from collections import deque


for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    def solve(order):
        dq = deque()
        for i in order:
            while dq and dq[-1] <= a[i]: {{completion}}
            while dq and dq[0] > b[i]: dq.popleft()
            dq.append(a[i])
            if dq[0] == b[i]: a[i] = b[i]

    solve(range(n))
    solve(reversed(range(n)))
    print('YES' if a == b else 'NO')",dq.pop(),dq.pop()
"import sys

R = sys.stdin.readline
inf = 10 ** 18
mod = 10 ** 9 + 7


def get_int() -> int:
    return int(R())


def get_str() -> str:
    return R().strip()


def get_int_list() -> list:
    return list(map(int, R().strip().split(' ')))


def init_matrix(n_, m_, value_=0) -> list:
    return [[value_] * m_ for _ in range(n_)]


def bits(v: int):
    return v.bit_length() - 1


def solve():
    n = get_int()
    a = get_int_list()
    b = get_int_list()

    h = 21

    st = init_matrix(h, n + 1)
    for i in range(n):
        st[0][i] = a[i]

    for k in range(1, h):
        p = 1 << (k - 1)

        for j in range(n - p + 1):
            st[k][j] = max(st[k - 1][j], st[k - 1][j + p])

    r = 0
    for i in range(n):
        while True:
            le, ri = min(i, r), max(i, r)

            k = bits(ri - le + 1)
            p = 1 << k

            if r == n or max(st[k][le], st[k][ri - p + 1]) == b[i]:
                {{completion}}

            r += 1

    print('YES' if r < n else 'NO')


for _ in range(get_int()):
    solve()
",break,"st[k][le] = b[i]
                break"
"import sys; input = lambda: sys.stdin.buffer.readline().decode().strip(); print = lambda *args, **kwargs: sys.stdout.write("" "".join(map(str, args)) + ""\n"", **kwargs)
def InputList(Dtype=int): return list(map(Dtype, input().split()))
from random import randint; RND = randint(1, 10**9)
from collections import deque

def solve():
	# print(f""================================"")
	N = int(input())
	a = InputList()
	b = InputList()

	def update(a,b):
		aLeft = deque()
		for i in range(N):
			while aLeft and aLeft[-1] <= a[i]: {{completion}}
			while aLeft and aLeft[0] > b[i]: aLeft.popleft()
			aLeft.append(a[i])
			if aLeft[0] == b[i]: a[i] = b[i]
		
	update(a,b)
	a.reverse(); b.reverse()
	update(a,b)
	return ""YES"" if a == b else ""NO""

for i in range(t:=int(input())):
	ans = solve(); print(ans)
",aLeft.pop(),"aLeft.pop()
			aLeft.append(a[i])
			if aLeft[-1] == b[i]: a[i] = b[i]
		
	update(a,b)
	a.reverse(); b.reverse()
	update(a,b)
	return ""YES"" if a == b else ""NO""

for i in range(t:=int(input())):
	ans = solve(); print(ans)
<|/ a dscore=0 |>"
"def best(n):
    x = len(n)
    cz = 0
    i = 0
    while i < x:
        if n[i]==0:
            cz += 1
            i+=1
        else:
            if cz == 0:
                i += 1
            else:
                if i+1 != x:
                    if n[i+1] == 0:
                        cz -= 1
                        n[i+1]=1
                        i+=1
                    else:
                        {{completion}}
                else:
                    cz -= 1
                    i+=1
    return cz
t = int(input())
for _i in range(t):
    nn = int(input())
    a=[int(i) for i in input()]
    b=[int(i) for i in input()]
    aa = nn-best(a)
    bb = nn-best(b)
    if (aa+1)//2 == (bb+1)//2:
        print(""YES"")
    else:
        print(""NO"")
",i += 2,"cz -= 1
                        n[i+1]=0"
"from functools import cache
mod = 998244353
@cache
def f(n):
    if n == 1:
        {{completion}}
    l, r = (n + 1) // 2, n // 2
    x, y = f(l)
    x *= 2
    a, b = f(r)
    x += 2 * a
    y += a + b
    x += (pow(2, l, mod) - 1) * (pow(2, r, mod) - 1)
    x %= mod
    y %= mod
    return x, y

print(*(sum(f(int(input()))) % mod for _ in range(int(input()))), sep='\n')
","return 1, 0","x, y = 1, 1
    elif n == 2:
        x, y = 1, 2
    else:"
"import sys
input=sys.stdin.buffer.readline
def rl(): return list(map(int,input().split()))
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())

mod=998244353

dp={1:(1,0)}
def f(n):
    if n in dp.keys(): {{completion}}
    l,r=(n+1)//2,n//2
    bin1,rem1=f(l)
    bin2,rem2=f(r)
    dp[n]=(bin1*2+bin2*2+(pow(2,l,mod)-1)*(pow(2,r,mod)-1))%mod,(rem1+rem2+bin2)%mod
    return dp[n]

def main():
    n=ri()
    bn,rem=f(n) 
    return (bn+rem)%mod
 
t=ri()
for i in range(t):
    print(main())

",return dp[n],"
        return dp[n]
    if n==1: return (1,0)
    dp.clear()
    dp[1]=(rm(),1)"
"import sys
import time
import math
import random
 
input = sys.stdin.readline
rd = random.randint(10 ** 9, 2 * 10 ** 9)
Mod = 998244353
t = int(input())
cache = {1: (1, 0)}
 
def solve(n):
    if n in cache:
        {{completion}}
    left = (n + 1) // 2
    right = n - left
    a, b = 0, 0
    a = (pow(2, left, Mod) - 1) * (pow(2, right, Mod) - 1) % Mod
    la, lb = solve(left)
    a += 2 * la % Mod
    b += lb
 
    ra, rb = solve(right)
    a += 2 * ra % Mod
    b += ra + rb
    cache[n] = (a % Mod, b % Mod)
    return a % Mod, b % Mod
 
for _ in range(t):
    n = int(input())
    solve(n)
    a, b = cache[n]
    print((a + b) % Mod)",return cache[n],"a, b = cache[n]
        return a % Mod, b % Mod
 "
"inf = int(1e9)

def Tecy() :
    n = int(input())
    val = list(map(int, input().split())) * 2
    ans = n
    pre = 0
    count = 0
    flag = False
    for i, x in enumerate(val) :
        if x >= pre :
            count += 1
            if count == n :
                {{completion}}
        else :
            count = 1
        pre = x

    pre = inf
    count = 0
    for i, x in enumerate(val) :
        if x <= pre :
            count += 1
            if count == n :
                flag = True
                ans = min(ans, (n * 2 - i - 1) % n + 1)
                ans = min(ans, (i - n + 1) % n + 1)
        else :
            count = 1
        pre = x

    if flag :
        print(ans)
    else :
        print(-1)

T = int(input())
for _ in range(T) :
    Tecy()","flag = True
                ans = min(ans, (n * 2 - i - 1) % n)
                ans = min(ans, (i - n + 1) % n + 2)","flag = True
                ans = min(ans, (n * 2 - i - 1) % n + 1)
                ans = min(ans, (i - n + 1) % n + 1)"
"from sys import stdin
def input(): return stdin.readline().rstrip()


for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    a = list(reversed(a)) * 2
    p, q = [0], [0]
    for i in range(2 * n - 1):
        p.append(p[-1] + 1 if a[i] >= a[i + 1] else 0)
        q.append(q[-1] + 1 if a[i] <= a[i + 1] else 0)
    
    MIN = 1000000
    for i in range(n - 1, len(p)):
        if p[i] == n - 1:
            {{completion}}
        if q[i] == n - 1:
            MIN = min(MIN, len(p) - i, i - n + 2)
    
    print(-1 if MIN == 1000000 else MIN)
","MIN = min(MIN, i - n + 1, len(p) - i + 1)","MIN = min(MIN, len(q) - i, i - n + 2)
    
    for i in range(n - 1, len(q)):"
"import sys

R = lambda:map(int, sys.stdin.readline().rstrip().split())

def solve():
    n ,= R()
    lst = list(R())
    if n == 1:
        print(0)
        return
    cnt = 0
    ans = 10**9
    i = 0
    while i < n:
        now = lst[i]
        while i < n and now <= lst[i]:
            {{completion}}
        cnt += 1
    #print(cnt)
    if cnt == 1:
        print(0)
        return
    if cnt == 2 and lst[-1] <= lst[0]:
        i = 0
        now = lst[0]
        while i < n and now <= lst[i]:
            now = lst[i]
            i += 1
        ans = min(n-i, i+2)
    cnt = 0
    i = 0
    while i < n:
        now = lst[i]
        while i < n and now >= lst[i]:
            now = lst[i]
            i += 1
        cnt += 1
    if cnt == 1:
        print(1)
        return
    if cnt == 2 and lst[-1] >= lst[0]:
        i = 0
        now = lst[0]
        while i < n and now >= lst[i]:
            now = lst[i]
            i += 1
        ans = min(ans, n-i+1, i+1)
        print(ans)
        return
    if ans == 10**9:
        print(-1)
        return
    print(ans)

t ,= R()
for _ in range(t):
    solve()
","now = lst[i]
            i += 1","now = lst[i]
            i += 1
        cnt += 1
    if cnt == 1:
        print(0)
        return
    if cnt == 2 and lst[-1] <= lst[0]:
        i = 0
        now = lst[0]
        while i < n and now <= lst[i]:
            now = lst[i]
            i += 1
        ans = min(n-i, i+2)
    cnt = 0
    i = 0
    while i < n:
        now = lst[i]
        while i < n and now >= lst[i]:
            now = lst[i]
            i += 1"
"import sys

input = sys.stdin.readline


# MOD = 10 ** 9 + 7


def solve():
    n = int(input())
    adj = [0] * (n + 1)
    leafs = 0

    for i in range(n - 1):
        start, end = map(int, input().split())
        adj[start] += 1
        adj[end] += 1
    for i in range(n + 1):
        if adj[i] <= 1:
            {{completion}}
    return leafs // 2


for _ in range(int(input())):
    print(solve())
",leafs += 1,"leafs += 1
            adj[i] -= 1"
"import sys
 
#input functions
readint = lambda: int(sys.stdin.readline())
readints = lambda: map(int,sys.stdin.readline().split())
readar = lambda: list(map(int,sys.stdin.readline().split()))
flush = lambda: sys.stdout.flush()
readstr = lambda: sys.stdin.readline()

t = readint()
for _ in range(t):
    n =  readint()
    a = [0]*n
    # print(a)
    for i in range(n-1):
        u, v = readints()
        a[u-1] +=1
        a[v-1] +=1
    x = a.count(1)
    if(x % 2==0 ):
        print(x//2)
    else:
        {{completion}}",print(x//2+1),"while(x>0):
            if(a[x-1]==1):
                a[x-1]=0
                x-=1
            else:
                a[x-1]+=1
                x-=1
        print(x//2)
<|/ file ext=.py |>"
"import sys
from collections import deque, defaultdict, Counter
t = int(sys.stdin.readline().strip())
for _ in range(t) : 
    n = int(sys.stdin.readline().strip())
    deg = [0 for i in range(n + 1)]
    for i in range(n - 1) : 
        a, b = map(int, sys.stdin.readline().strip().split())
        deg[a] += 1
        deg[b] += 1
    c = 0
    for i in range(1, n + 1) : 
        if deg[i] == 1 : {{completion}}
    print((c - 1) // 2 + 1)",c += 1,"
            c += 1"
"#author: Sushmanth

from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


mod = 998244353
def add(a , b):return ((a%mod) + (b%mod))%mod
def sub(a , b):return (a - b + mod)%mod
def mul(a , b):return ((a%mod) * (b%mod))%mod
def ncr(n , r):
    if(r > n):return 0
    return mul(fact[n] , mul(facti[n - r] , facti[r]))
def div(a , b):return mul(a , pow(b , mod - 2 , mod))

fact , facti = [1] , [1]
size = 2 * (10**5) + 1
for i in range(1 , size):
    fact.append(mul(fact[-1] , i))
    facti.append(pow(fact[-1] , mod - 2 , mod))


def answer():

    ca = [0 for i in range(26)]
    cb = [0 for i in range(26)]
    for i in range(n):
        ca[ord(a[i]) - 65] += 1


    for i in range(m):
        cb[ord(b[i]) - 65] += 1


    dp = [0 for i in range(max(n , m) + 1)]
    dp[0] = fact[n]

    for i in range(26 , 0 , -1):

        ndp = [0 for i in range(max(n , m) + 1)]
        for j in range(ca[i - 1] + 1):
            if(j > cb[i - 1]):{{completion}}
            ndp[cb[i - 1] - j] += dp[ca[i - 1] - j] * (facti[j] * facti[ca[i - 1] - j]) % mod
            ndp[cb[i - 1] - j] %= mod

        dp = ndp[:]
        for j in range(max(n , m) - 1 , -1 , -1):
            dp[j] += dp[j + 1]
            dp[j] %= mod


    return dp[0]



for T in range(1):

    n , m = inp()
    a = input().strip()
    b = input().strip()

    print(answer())
",break,"
                ndp[cb[i - 1] - j] += dp[ca[i - 1] - j] * (facti[j] * facti[ca[i - 1] - j]) % mod
                ndp[cb[i - 1] - j] %= mod
            else:
                ndp[cb[i - 1] - j] += dp[ca[i - 1] - j] * (facti[j] * facti[ca[i - 1] - j]) % mod
                ndp[cb[i - 1] - j] %= mod

        for j in range(cb[i - 1] + 1):"
"n,m=map(int,input().split())
a=list(str(input()))
b=list(str(input()))
cnta=[0]*26
cntb=[0]*26
for i in a:
    cnta[ord(i)-65]+=1
for i in b:
    cntb[ord(i)-65]+=1
if cntb[25]<cnta[25]:
    print(0)
else:
    #precal
    mod=998244353
    f=[0]*(n+1)
    f[0]=1
    inv=[0]*(n+1)
    for i in range (1,n+1):
        f[i]=(f[i-1]*i)%mod
    inv[n]=pow(f[n],mod-2,mod)
    for i in range (n-1,-1,-1):
        inv[i]=(inv[i+1]*(i+1))%mod
    def C(k,n):
        return ((f[n]*inv[k])%mod*inv[n-k])%mod
    #dp
    dp=[0]*cnta[25]+[1]
    pfs=[0]*(cnta[25]+2)
    for i in range (cnta[25]+1):
        pfs[i+1]=(pfs[i]+dp[i])%mod
    for i in range (24,-1,-1):   
        tmp=[0]*(cnta[i]+1)
        for j in range (min(cnta[i]+1,cntb[i]+1)):
            s=0
            if j>=cnta[i]-cntb[i+1]:
                {{completion}}
            tmp[j]=(s*C(j,cnta[i]))
        dp=[i for i in tmp]
        pfs=[0]*(cnta[i]+2)
        for j in range (cnta[i]+1):
            pfs[j+1]=(pfs[j]+dp[j])%mod
    res=0
    for i in range (cnta[0]+1):
        res=(res+dp[i])%mod
    res=(res*f[n])%mod
    for i in range (26):
        res=(res*inv[cnta[i]])%mod
    print(res)","s=pfs[min(cntb[i+1]-cnta[i]+j+1,cnta[i+1]+1)]","s=1
            cnta[i+1]-=1
            cntb[i+1]-=1"
"import sys
for _ in range(int(input())):
    s = sys.stdin.readline()
    s = s.strip()
    n = len(s)
    ans = 1
    for i in range(n):
        {{completion}}
    print(ans)

","k = int(s[i])+1
        ans*=(k*(k+1))//2","a, b, c = map(int, s.split())
        if a + b + c == n:
            ans += 1"
"import sys
input=sys.stdin.readline

Counter = [0] * 100
for i in range(10):
    for j in range(10):
        for k in range(10):
            {{completion}}

t = int(input())
for _ in range(t):
    s = str(int(input()))
    res = 1
    for i in s: res *= Counter[int(i)]
    print(res)
        
",Counter[i + j + k] += 1,Counter[i*10+j*10+k] += 1 
"from collections import defaultdict as dt
import sys
input = sys.stdin.readline
print = sys.stdout.write
dc = dt(int)
for i in range(10) :
    dc[str(i)] = ((i+1)*(i+2))//2
for _ in range(int(input())) :
    s = input().strip()
    ans = 1
    for elem in s :
        {{completion}} 
    print(str(ans)+'\n')",ans *= dc[elem],"a,b,c = elem.split('-')
        a,b,c = int(a),int(b),int(c)
        ans = ans*dc[str(a+b+c)]
        ans = ans*dc[str(a+b)]
        ans = ans*dc[str(b+c)]
        ans = ans*dc[str(b)]
        ans = ans*dc[str(c)]
        ans = ans*dc[str(c)]
        ans = ans*dc[str(c)]
        ans = ans*dc[str(c)]
        ans = ans*dc[str(c)]
        "
for s in[*open(0)][1:]:{{completion}},"x,y,k=map(int,s.split());print(max(x,y,2*y-x-k))","
    x,y,k=map(int,s.split())
    if x==y:
        if k==0:
            print 0
        else:
            print k
    else:
        if k==0:
            print 0
        else:
            print min(k+x-y,k+x-y+1,k+x-y+2)

<|/ file ext=.py |>"
"for _ in range(int(input())):
    a, b, c = map(int, input().split())
    if b < a:
        print(a)
    else:
        if b - a > c:
            print((b - a - c) * 2 + a + c)
        else:
            {{completion}}
",print(b),"k = b - a - c
            if k > c:
                print((k - c) * 2 + a + c)
            else:
                print((k - c) * 2)
<|/ file dstars=0 filename=Monocarp.py |>"
"t=int(input())
for j in range(t):
    s=0
    x,z,k=map(int,input().split())
    if x<z:
        s+=x
        if k>=z-x:
            s+=z-x
        else:
            {{completion}}
    else:
        s+=x
    print(s)","s+=k
            s+=(z-s)*2","s-=k
    else:
        s+=z
        if k>=x-z:
            s+=x-z
        else:
            s-=k
    if x==z:
        s+=x
        if k>=x-z:
            s+=x-z
        else:
            s-=k"
"import sys
input = sys.stdin.readline
def solve():
    n = int(input())
    ls = list(map(int, input().split()))
    ind = ls.index(0)+1
    ls = ls[ind :] + ls[:ind]
    stack = []
    ans = n 
    res = -1
    for i in ls : 
        cnt  = 1
        while stack and  stack[-1][1] > i :
            {{completion}}
        stack.append((cnt , i ))
        ans += (i * cnt ) 
        res = max(ans , res )
    print(res)
for _ in range(int(input())):
    solve()","x,y = stack.pop()
            cnt += x 
            ans -= (y * x)","cnt , i = stack.pop()
        stack.append((cnt , i ))
        ans += (i * cnt ) 
        res = max(ans , res )
    print(res)
for _ in range(int(input())):
    solve()
<|/ file ext=.py |>"
"# author: ankan2526

import sys,math,heapq,bisect,random,itertools
input = sys.stdin.readline
sys.setrecursionlimit(10**5)

ints = lambda : list(map(int,input().split()))
def gprint(ans=''):global t;print(f""Case #{t+1}:"",ans)
p = 10**9+7
inf = 10**20+7
ALPHA = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
alpha = ""abcdefghijklmnopqrstuvwxyz""

""""""
""""""

for t in range(int(input())):
    n = int(input())
    a = ints()
    ind = a.index(0)
    a = a[ind:] + a[:ind]
    ind = [0]*n
    b = [0]
    ans = n
    c = n
    for i in range(1, n):
        ind[a[i]] = i
        while a[i] < b[-1]:
            {{completion}}
        c += a[i]*(i-ind[b[-1]])
        ans = max(ans, c)
        b.append(a[i])
    print(ans)","c -= b[-1] * (ind[b[-1]] - ind[b[-2]])
            b.pop()","ind[a[i]] = i
            i += 1
        ind[a[i]] = i
        b.append(a[i])
    while b[-1] < n:
        ind[b[-1]] = n
        n -= 1
    for i in range(n):
        c = n
        for j in range(n):
            if j == b[-1]:
                continue
            if j == b[-2]:
                c += a[i]*(n-ind[j])
            else:
                c += a[i]*(n-ind[j])*(n-ind[j+1])
        ans = max(ans, c)
        b.append(a[i])
    print(ans)
""""""
""""""

for t in range(int(input())):
    n = int(input())"
"import sys

def inp():
    return sys.stdin.readline()

def LII():
    return [int(x) for x in inp().split()]
    
def II():
    return int(inp())

for _ in range(int(inp())):
    n = II()
    p = LII()
    assert len(p) == n
    j = p.index(0)
    p = p[j + 1 : ] + p[ : j]
    as_ = [n]
    is_ = [0]
    max_cost = cost = n 
    i = 0
    for x in p:
        i += 1
        delta_cost = 0
        removed_i = i
        while len(as_) != 0 and as_[-1] > x:
            {{completion}}
        as_.append(x)
        is_.append(removed_i)
        as_.append(n)
        is_.append(i)
        cost -= delta_cost
        cost += x * (i - removed_i) + n
        max_cost = max(max_cost, cost)
    print(max_cost)","removed_a = as_.pop()
            removed_i_new = is_.pop()
            delta_cost += (removed_i - removed_i_new) * removed_a
            removed_i = removed_i_new","delta_cost += is_[-1]
            removed_i -= 1
            as_.pop()
            is_.pop()
        removed_i -= 1"
"import sys
input = sys.stdin.readline 

for _ in range(int(input())):
    n = int(input()) 
    a = list(map(int, input().split())) 
    ans = 0 
    for i in range(1, n + 1):
        if(n % i == 0):
            mx, mn = -10 ** 18, 10 ** 18 
            for j in range(0, n, i):
                s = 0 
                for k in range(j, j + i):
                    {{completion}} 
                mx = max(mx, s) 
                mn = min(mn, s) 
            ans = max(ans, mx - mn)
    print(ans)
                ",s += a[k],"s += a[k] 
                s = abs(s) 
                if(s > mn):
                    mn = s 
                if(s < mx):
                    mx = s 
            if(mx - mn < 0):
                ans = max(ans, mx - mn) 
            else:
                ans = max(ans, mx - mn) 
        else:
            mx, mn = -10 ** 18, 10 ** 18 
            for j in range(0, n, i):
                s = 0 
                for k in range(j, j + i):
                    s += a[k] 
                s = abs(s) 
                if(s > mn):
                    mn = s 
                if(s < mx):
                    mx = s 
            if(mx - mn < 0):
                an"
"from sys import stdin, stdout

for _ in range(int(stdin.readline())):
    n = int(stdin.readline())
    a = list(map(int, stdin.readline().split()))
    
    pre = [0] * n
    pre[0] = a[0]
    for i in range(1, n): pre[i] = pre[i - 1] + a[i]
    res = 0

    for k in range(1, n):
        if n % k: {{completion}}
        mx, mn = pre[k - 1], pre[k - 1]
        for i in range(2 * k - 1, n, k):
            tmp = pre[i] - pre[i - k]
            mx = max(tmp, mx)
            mn = min(tmp, mn)
        res = max(res, mx - mn)
    stdout.write(str(res) + '\n')
        ",continue,continue
"from sys import stdin
def input(): return stdin.readline()[:-1]

def solve():
    N = int(input())
    Arr = list(map(int, input().split()))
    prefix = [0] * (N + 1)
    for i in range(N):
        prefix[i + 1] = prefix[i] + Arr[i]

    ans = 0

    for div in range(1, N+1):
        if N % div != 0:
            {{completion}}
        a = []
        for i in range(N // div):
            a.append(prefix[(i + 1) * div] - prefix[i * div])
        ans = max(ans, max(a) - min(a))
    print(ans)

for _ in range(int(input())):
    solve()",continue,"ans = max(ans, 0)
            break
    
    for div in range(1, N+1):"
"n = int(input())

a = [int(i) for i in input().split()]
s=0
for i in range(n):
    {{completion}}
print(min(s-max(a),s//3))

",s+=a[i],"s += a[i]
print(s)"
"n = int(input())
l = list(map(int,input().split("" "")))
sum_l = sum(l)
max_l = max(l)
 
if max_l > 2*(sum_l-max_l):
    print(sum_l-max_l)
else:
    {{completion}}",print(sum_l//3),"count = 0
    for i in range(sum_l-max_l):
        if l[i] > max_l:
            count += 1
    print(count)
<|/ file ext=.py |>"
"MOD = 998244353

def modmul(x, y, c = 0):
    return (x * y + c) % MOD

mod_mul = modmul

def inv(x):
    return pow(x, MOD - 2, MOD)

MAX = 10 ** 6

fact = [1]
for i in range(1, MAX):
    fact.append(modmul(i, fact[i-1]))

invfact = [1] * (MAX)
invfact[MAX - 1] = inv(fact[MAX - 1])
for i in range(MAX - 2, -1, -1):
    invfact[i] = modmul(i + 1, invfact[i+1])

def comb(x, y):
    if 0 <= y <= x:
        return modmul(fact[x], modmul(invfact[y], invfact[x - y]))
    return 0

def perm(x, y):
    if 0 <= y <= x:
        return modmul(fact[x], invfact[x - y])
    return 0

def invcomb(x, y):
    return modmul(invfact[x], modmul(fact[y], fact[x - y]))

def invs(x):
    return modmul(fact[x - 1], invfact[x])


t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))

    if a[-1] not in [-1, n]:
        print(0)
        continue

    a[-1] = n

    out = 1

    li = 0
    lv = 0
    for i in range(n):
        if a[i] == -1:
            {{completion}}

        skip = i + 1 - li
        need = a[i] - lv

        poss = 0

        for l in range(0, skip + 1):
            r = need - l

            cl = perm(skip, l) * comb(li - lv, l)
            cr = perm(i + 1 - lv - l, r) * comb(skip, r)

            poss = modmul(cl, cr, poss)

        out = modmul(out, poss)

        li = i + 1
        lv = a[i]
    print(out)

        

         
",continue,"li = i
            lv = a[i]
            continue"
"# pypy3
from collections import *
from itertools import *
from functools import *
from bisect import *
from heapq import *
import math
import sys
import struct
IN = lambda: sys.stdin.readline().rstrip(""\r\n"")
PN = lambda x: sys.stdout.write(x)
I = lambda: int(IN())
S = lambda: IN().split()
M = lambda: map(int, IN().split())
L = lambda: list(map(int, IN().split()))
G = lambda: map(lambda x: int(x) - 1, IN().split())
    
mod = 998244353 

def qpow(a, b, p = mod):
    res = 1
    while b:
        if b & 1:
            {{completion}}
        a = a * a % p
        b >>= 1
    return res
    
class Comb:
    def __init__(self, n, p = mod):
        self.__fac = [0 for _ in range(n + 1)]
        self.__ifac = [0 for _ in range(n + 1)]
        self.__fac[0] = 1
        self.__mod = p
        for i in range(1, n + 1):
            self.__fac[i] = i * self.__fac[i - 1] % self.__mod
        self.__ifac[n] = qpow(self.__fac[n], mod - 2)
        for i in range(n - 1, -1, -1):
            self.__ifac[i] = (i + 1) * self.__ifac[i + 1] % self.__mod
    
    def binom(self, a, b):
        if a < b or b < 0:
            return 0
        return self.__fac[a] * self.__ifac[b] * self.__ifac[a - b] % self.__mod
    
    def fac(self, n):
        if n < 0:
            return 0
        return self.__fac[n]
        
    def ifac(self, n):
        if n < 0:
            return 0
        return self.__ifac[n]



def calc(i, j, k):
    return comb.binom(i, k) * comb.binom(j, k) * comb.fac(k) % mod
    
for _ in range(I()):
    n = I()
    a = [0] + L()
    comb = Comb(n)
    if a[n] != n and a[n] != -1:
        print(0)
        continue
    a[n] = n
    ans = 1
    j = 0
    for i in range(1, n + 1):
        if a[i] == -1:
            continue
        cnt = a[i] - a[j]
        if cnt < 0:
            ans = 0
            break
        tmp = 0
        for k in range(cnt + 1):
            tmp += calc(i - j, j - a[j], k) * calc(i - j, i - a[j] - k, cnt - k) % mod
        ans = ans * tmp % mod
        j = i
    print(ans)",res = res * a % p,res  = (res * a) % p
"import sys
input=sys.stdin.buffer.readline
def rl(): return list(map(int,input().split()))
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())

mod=998244353
def main():
    n=ri()
    a=rl()
    if a[-1]!=n and a[-1]!=-1: return 0
    lsti=-1
    lstp=0
    res=1
    for i in range(n):
        if a[i]==-1: continue
        if not 0<=a[i]-lstp<=2*(i-lsti): return 0
        todo=a[i]-lstp
        rem1=lsti+1-lstp
        rem2=i-lsti
        lg=i-lsti
        al=i+1-lstp
        cnt=0
        cnt1=[1]*(todo+1)
        cnt2=[1]*(todo+1)
        for j in range(1,todo+1):
            if lg-j+1>0 and rem1-j+1>0:
                cnt1[j]=cnt1[j-1]*(lg-j+1)*pow(j,-1,mod)*(rem1-j+1)
                cnt1[j]%=mod
            else:
                {{completion}}
            if al-todo+j>0 and rem2-j+1>0:
                cnt2[j]=cnt2[j-1]*(al-todo+j)*pow(j,-1,mod)*(rem2-j+1)
                cnt2[j]%=mod
            else:
                cnt2[j]=0
        for j in range(todo+1):
            cnt+=cnt1[j]*cnt2[todo-j]
            cnt%=mod
        res*=cnt
        res%=mod
        lsti=i
        lstp=a[i]
    rem1=lsti+1-lstp
    lg=n-1-lsti
    al=n-lstp
    for i in range(rem1):
        res*=(lg-i)
        res%=mod
    for i in range(1,al-rem1+1):
        res*=i
        res%=mod
    return res

t=ri()
for i in range(t):
    print(main())",cnt1[j]=0,"cnt1[j]=0
        for j in range(todo+1):"
"import collections
import sys
import math
import heapq

input = sys.stdin.readline


def inp():
    return (int(input()))
def inlt():
    return (list(map(int, input().split())))
def insr():
    s = input()
    return (list(s[:len(s) - 1]))
def invr():
    return (map(int, input().split()))


def solution():
    n = inp()
    s = list(map(int, input()[:-1]))
    a = [int(x) - 1 for x in input().split()]

    indeg = [0 for i in range(n)]
    ans = []
    for x in a:
        indeg[x] += 1

    q = collections.deque()
    for i in range(n):
        if not indeg[i]:
            q.append(i)

    while q:
        i = q.popleft()
        if s[i] == 1:
            s[i] = 0
            s[a[i]] ^= 1
            ans.append(i + 1)
        indeg[a[i]] -= 1
        if not indeg[a[i]]:
            q.append(a[i])

    for i in range(n):
        if indeg[i]:
            jj = i
            ans_cur = [[], []]
            value = 0
            while True:
                indeg[jj] = 0
                value ^= s[jj]
                ans_cur[value].append(jj + 1)
                jj = a[jj]
                if jj == i:
                    break

            if value:
                print(-1)
                return
            
            if min(len(ans_cur[0]), len(ans_cur[1])) == 0:
                continue
            if len(ans_cur[0]) < len(ans_cur[1]):
                for x in ans_cur[0]:
                    ans.append(x)
            else:
                for x in ans_cur[1]:
                    {{completion}}

    print(len(ans))
    print(*ans)
    return


if __name__ == '__main__':
    t = inp()
    for i in range(t):
        solution()
",ans.append(x),ans.append(x)
"a = [input() for _ in range(3)]

d = [(1,0), (1,1), (1,-1), (0,1), (0,-1), (-1,0), (-1,1), (-1,-1)]
c = []

for i in range(3):
    for j in range(3):
        b=[]
        for x,y in d:
            if 0<=i+x<3 and 0<=j+y<3:
                {{completion}}
        b.sort()
        c.append(b[0]+a[i][j]+b[1])
print(min(c))",b.append(a[i+x][j+y]),b.append(a[i+x][j+y])
"import sys

def gcd(a, b):
    if b==0: return a
    return gcd(b, a%b)



mod = 998244353

def ok(a, b):
    return abs(a // 3 - b//3) <= 1 and abs(a % 3 - b%3) <= 1

def work(a):
    return puzzle[a//3][a%3]

while True:
    try:
        puzzle = [input() for i in range(3)]
        ans = 'CCC'
        for i in range(9):
            for j in range(9):
                for k in range(9):
                    if i == j or i == k or j == k:
                        {{completion}}
                    if ok(i, j) and ok(j, k):
                        ans = min(ans, work(i)+work(j) + work(k))
        print(ans)

    except EOFError:
        break

",continue,"ans = min(ans, work(i)+work(j) + work(k))
                    elif ok(i, j) and ok(i, k):
                        ans = min(ans, work(i)+work(j) + work(k))
                    elif ok(j, i) and ok(j, k):
                        ans = min(ans, work(i)+work(j) + work(k))
                    elif ok(i, j) and ok(j, i):
                        ans = min(ans, work(i)+work(j) + work(k))
                    elif ok(j, i) and ok(k, i):
                        ans = min(ans, work(i)+work(j) + work(k))
                    elif ok(i, j) and ok(k, j"
"mod=998244353

M = 2*(10 ** 5) + 10
fac = [1] * M
ninv = [1] * M
finv = [1] * M
for i in range(2, M):
    fac[i] = fac[i - 1] * i % mod
    ninv[i] = (-(mod // i) * ninv[mod % i]) % mod
    finv[i] = finv[i - 1] * ninv[i] % mod
def binom(n, k):
    if n < 0 or k < 0:
        {{completion}}
    if k > n:
        return 0
    return (fac[n] * finv[k] % mod) * finv[n - k] % mod
def solve():
    n,k=map(int,input().split())
    a,b=divmod(n,2*k)
    if a==0:
        print(0,binom(k-1,n-k-1)%mod)
        return
    ans1=k*a*(a-1)+b*a
    ans2=0
    for i in range(b//2+1):
        x=b-2*i
        ans2+=binom(k-1,i)*binom(k+1-i,x)
        ans2%=mod

    print(ans1,ans2)



for _ in range(int(input())):
    solve()




",return 0,exit(-1)
"M=998244353
factorial=[1,1]
inv=[]
for i in range (2,10**6+1):
    factorial.append((factorial[-1]*i)%M)
inv.append(pow(factorial[-1],M-2,M))
for i in range (10**6,0,-1):
    inv.append((inv[-1]*i)%M)
inv.reverse()
def c(k,n):
    return (factorial[n]*inv[n-k]*inv[k])%M
def f(k,n):
    if n>2*k:
        return 0
    else:
        if n>k:
            n=2*k-n
        res=0
        for i in range (k-n,k-(n+1)//2+1):
            res+=c(i,k)*c(2*k-2*i-n,k-i)
        return res
for tc in range (int(input())):
    n,k=map(int,input().split())
    a=2*k*((n//(2*k))*(n//(2*k)-1)//2)+(n%(2*k))*(n//(2*k))
    if n<2*k:
        print(a,c(n-k-1,k-1)%M)
    else:
        n%=2*k
        if n==0:
            print(a,1)
        elif n==1:
            {{completion}}
        else:
            print(a,(f(k-1,n)+2*f(k-1,n-1)+f(k-1,n-2))%M)","print(a,k+1)","k=k-1
            print(a,(f(k-1,n)+f(k-1,n-1))%M)"
"MOD = 998244353
N = 100100
fact = [0] * (N + 1)
obr = [0] * (N + 1)

def inv(x):
    return pow(x, MOD - 2, MOD)

def c(n, k):
    return fact[n] * obr[n - k] % MOD * obr[k] % MOD

def solve():
    n, k = map(int, input().split())
    num = n // (2 * k)
    ans = (2 * k) * (num * (num - 1) // 2)
    ans += (n % (2 * k)) * num
    remain = n % (2 * k)

    if num == 0:
        remain = 2 * k - remain
        if remain > k - 1:
            print(ans, 0)
        else:
            {{completion}}
        return
    
    # симметрия относительно k
    if remain > k:
        remain = 2 * k - remain

    cnt = c(k + 1, remain)
    for i in range(1, k):
        if remain < 2 * i:
            break
        cnt += c(k - 1, i) * c(k + 1 - i, remain - 2 * i) % MOD
        cnt %= MOD
    
    print(ans, cnt)

fact[0] = 1
obr[0] = 1
for i in range(1, N + 1):
    fact[i] = fact[i - 1] * i % MOD
    obr[i] = inv(fact[i])
    
q = int(input())
for i in range(q):
    solve()
","print(ans, c(k - 1, remain))","ans += remain
            print(ans, 0)"
"from sys import stdin
input = stdin.readline
ans, n = map(int, input().split())
a2 = []
for idx in range(n):
    _, *arr = map(int, input().split())
    profit = req = prevPositiveProfit = 0
    for i in arr:
        profit += i
        req = min(req, profit)
        if profit - prevPositiveProfit > 0:
            {{completion}}
a2.sort()
for req, profit in a2:
    if ans < req:
        break
    ans += profit
print(ans)

","a2.append((-req, profit - prevPositiveProfit))
            prevPositiveProfit = profit","prevPositiveProfit = profit
    a2.append((req, profit))"
"x, t = map(int,input().split())
l = []
for _ in range(t):
  a = input().split()[1:]
  m = 0
  n = 0
  for i in a:
    if int(i) < 0 and n > 0:
      {{completion}}
    n += int(i)
    m = min(m,n)
  if n > 0:
    l.append((m,n))
l.sort(reverse=True)
for i,j in l:
  if i + x <0:
    break
  x += j 
print(x)","l.append((m,n))
      n = 0",break
"from heapq import *
import sys
input = sys.stdin.readline
x, k = map(int, input().split())
cand = []
for i in range(k):
  a = list(map(int, input().split()))
  psum, mnv, cur = 0, 0, 0
  for i in range(1, len(a)):
    psum += a[i]
    mnv = max(mnv, -psum)
    if psum > cur:
      {{completion}}
cand.sort()
for [v, w] in cand:
  if x >= v:
    x += w
print(x)","cand.append([mnv, psum - cur])
      cur = psum","cur = psum
  cand.append((mnv, cur))"
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()
from collections import deque


for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    def solve(order):
        dq = deque()
        for i in order:
            while dq and dq[-1] <= a[i]: {{completion}}
            while dq and dq[0] > b[i]: dq.popleft()
            dq.append(a[i])
            if dq[0] == b[i]: a[i] = b[i]

    solve(range(n))
    solve(reversed(range(n)))
    print('YES' if a == b else 'NO')",dq.pop(),dq.pop()
"import sys
import collections
import math
import bisect
import heapq
#import itertools
#import functools
input = sys.stdin.readline


def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    for i in range(n):
        if a[i] > b[i]:
            print('NO')
            return
        if a[i] == b[i]:
            continue
        flag = False
        for j in range(i + 1, n):
            if a[j] > b[i]:
                break
            if a[j] == b[i]:
                for k in range(i + 1, j + 1):
                    if b[k] < b[i]:
                        break
                else:
                    flag = True
                    break
        if not flag:
            for j in range(i - 1, -1, -1):
                if a[j] > b[i]:
                    print('NO')
                    return
                if a[j] == b[i]:
                    for k in range(j + 1, i + 1):
                        if b[k] < b[i]:
                            {{completion}}
                    else:
                        flag = True
                        break
        if not flag:
            print('NO')
            return
    print('YES')


t = int(input())
for _ in range(t):
    solve()","print('NO')
                            return",break
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()
from collections import deque
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    def solve(order):
        dq = deque()
        for i in order:
            while dq and dq[-1] <= a[i]: {{completion}}
            while dq and dq[0] > b[i]: dq.popleft()
            dq.append(a[i])
            if dq[0] == b[i]: a[i] = b[i]
    solve(range(n))
    solve(reversed(range(n)))
    print('YES' if a == b else 'NO')",dq.pop(),dq.pop()
"import sys
# sys.setrecursionlimit(5*10**5)
input = sys.stdin.readline
from collections import defaultdict, deque, Counter
from heapq import heappop, heappush
from bisect import bisect_left, bisect_right
from math import gcd

mod = 998244353
def sol():
    n = int(input())
    a = list(map(int,input().split()))
    ans = 1
    now = 0
    if a[0] >= 2 or a[-1] != n:
        ans = 0
    if a[0] == 1:
        now = 1
    for i in range(1,n):
        dif = a[i] - now
        if dif == 0:
            ans *= 1
        elif dif == 1:
            {{completion}}
        elif dif == 2:
            ans *= (i-now)**2 
        else:
            ans *= 0
        ans %= mod
        now = a[i]
    print(*[ans])
    return 


T = int(input())
# T = 1
for i in range(T):
    sol()",ans *= 2*(i-now)+1,"ans *= (i-now)
        elif dif == 2:
            ans *= (i-now)**2
        else:
            ans *= 0
        ans %= mod
        now = a[i]
    print(*[ans])
    return 

def sol2():
    n = int(input())
    a = list(map(int,input().split()))
    ans = 1
    now = 0
    if a[0] >= 2 or a[-1] != n:
        ans = 0
    if a[0] == 1:
        now = 1
    for i in range(1,n):
        dif = a[i] - now
        if dif == 0:
            ans *= 1
        elif dif == 1:
"
"import sys
le = sys.__stdin__.read().split(""\n"")[::-1]
af = []
mo = 998244353
for zo in range(int(le.pop())):
    n=int(le.pop())
    l=list(map(int,le.pop().split()))
    if l[-1]!=n or l[0]>1:
        af.append(0)
    else:
        p = 1
        for i in range(1,n):
            d = l[i]-l[i-1]
            if d<0 or d>2 or l[i]>i+1:
                {{completion}}
            if d==2:
                p *= (i-l[i-1])**2
            if d==1:
                p *= (2*(i-l[i-1])+1)
            p %= mo
        af.append(p)
print(""\n"".join(map(str,af)))
",p = 0,"af.append(0)
                break"
"from sys import stdin, stdout

N = 998244353
t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    a = [0] + [int(x) for x in stdin.readline().split()]

    survive = True
    answer = 1
    count = 0
    for i in range(n):
        if a[i+1]-a[i] < 0 or a[i+1]-a[i] > 2:
            survive = False
            break

        elif a[i+1]-a[i] == 0:
            pass

        elif a[i+1]-a[i] == 1:
            temp = 2*i+1 - 2*count
            if temp <= 0:
                {{completion}}
            answer = (answer * temp) % N
            count += 1

        else:
            temp = i - count
            if temp <= 0:
                survive = False
                break
            answer = (answer * (temp)**2) % N
            count += 2

    if not survive or a[-1] != n:
        stdout.write('0\n')

    else:
        stdout.write(str(answer)+'\n')
","survive = False
                break","survive = False
                break"
"import sys
input = sys.stdin.readline
rounds = int(input())

for ii in range(rounds):
  out=0
  
  # https://codeforces.com/contest/1903/problem/C
  length=int(input())
  arr=list(map(int,input().split()))
  cur=0
  for l in range(length-1,-1,-1):
    cur+=arr[l]
    if cur>=0:
      {{completion}}
  if cur<0:
    out+=cur
  print(out)",out+=cur,"out+=1
      cur-=arr[l]
  
  cur=0
  for l in range(length-1,-1,-1):
    cur+=arr[l]
    if cur<0:
      out+=cur
      cur+=arr[l]
  "
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()


for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))[::-1]
    pre = sm = 0

    for i, x in enumerate(a):
        if sm - pre > sm:
            {{completion}}
        sm += x * (n-i)
        pre += x

    print(sm)",sm -= pre,"sm = pre
        if sm - pre > x:
            sm = pre
            pre = x"
"import sys

R = sys.stdin.readline
inf = 10 ** 18
mod = 10 ** 9 + 7


def get_int() -> int:
    return int(R())


def get_str() -> str:
    return R().strip()


def get_int_list() -> list:
    return list(map(int, R().strip().split(' ')))


def init_matrix(n_, m_, value_=0) -> list:
    return [[value_] * m_ for _ in range(n_)]


def solve():
    n = get_int()
    a = get_int_list()

    ans = a[0]
    suf = 0
    for i in range(n - 1, 0, -1):
        suf += a[i]
        if suf > 0:
            {{completion}}

    print(ans + suf)


for _ in range(get_int()):
    solve()
",ans += suf,"ans += suf
            suf = 0
        else:
            ans -= a[i]
            suf -= a[i]"
"def solve():
    b,n=map(int,input().split())
    t=1
    for k in range(1,n+1):
        t*=b
        t%=n
        if t==0:
            print(1,k)
            return
        elif t==1:
            {{completion}}
        elif t==n-1:
            print(3,k)
            return
    print(0)






for _ in range(int(input())):
    solve()
","print(2,k)
            return","k=k-1
            print(2,k)
            return"
"for _ in range(int(input())):
    b, n = map(int, input().split()); p, f = 1, 0
    for i in range(1, n+1):
        p = p * b % n
        if p % n in {0, 1, n-1}: {{completion}}
    if not f: print(0)","f = 1; print({0: 1, 1: 2, n-1: 3}[p % n], i); break",f += 1
"a=int(input())
for i in range(a):
    b,n=map(int,input().split())
    r=1
    for j in range(1,n+1):
        r=r*b%n
        if r==0:
            {{completion}}
        if r==1:
            print(2,j)
            break
        if r==(-1)%n:
            print(3,j)
            break
        
    else:
        print(0)

    
","print(1,j)
            break","k=j
            break
    if k==1:
        print(1)
    elif k==2:
        print(2)
    elif k==3:
        print(3)
    else:
        print(0)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
for s in [*open(0)][1:]:{{completion}},"n,p,l,t=map(int,s.split());print(n+min(-p//(l+2*t),(-p--n//7*t)//l))","
    s=s.strip().split()
    n, p, l, t = int(s[0]), int(s[1]), int(s[2]), int(s[3])
    
    if n<1 or p<1 or l<1 or t<1:
        continue
    
    
    
<|/ file source=github filename=Monocarp.py |>"
"import sys
y=lambda:sys.stdin.readline()

for _ in range(int(y())):
    {{completion}}
","n,P,l,t=map(int,y().split())
    print(n+min(-P//(l+2*t),(-P-(-n//7)*t)//l))","a,b,c,d=map(int,sys.stdin.readline().split())
    if a>b:
        a,b=b,a
    if b>c:
        b,c=c,b
    if c>d:
        c,d=d,c
    if a==b:
        if c==d:
            print 0
        else:
            print 1
    else:
        if c==d:
            print 1
        else:
            print 0
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            "
"for num in [*open(0)][1:]:
    n,p,l,t=map(int,num.split());
    w=-n//7;d=l*n-t*w-p;hi=min(n+w//2,d//l);
    x=w%2*(l+t);d-=hi*l
    if d>=x:{{completion}}
    print(hi+d//(l+2*t))",d-=x;hi+=w%2,"
        hi=hi+d//x
    else:"
"for _ in range(int(input())):
    {{completion}}","n,x = map(int, input().split())
    a = [0] + list(map(int, input().split()))
    dist = [a[i]-a[i-1] for i in range(1,n+1)] + [2*(x-a[-1])]
    print(max(dist))","n, x = map(int, input().split())
    arr = [int(x) for x in input().split()]
    arr.sort()
    ans = float('inf')
    ans = float('inf')
    for i in range(n):
        if arr[i] < x:
            ans = min(ans, arr[i] + arr[i+1])
        else:
            ans = min(ans, arr[i])
    print(ans)
<|/ file filename=gas-tank-refueling-problem.py |>"
"def LineTrip():
    n, x = [int(num) for num in input().split()]
    a = [int(num) for num in input().split()]
    v = max(a[0], (x - a[n-1]) * 2)
    if n == 1:
        {{completion}}
    for i in range(n-1):
        v = max(v, a[i+1] - a[i])
    print(v)
    
n = int(input())
for i in range(n):
    LineTrip()","print(v)
        return","v += 1
    else:
        v += 2"
"a=int(input())
for p in range(a):
    q,w=map(int,input().split())
    e=list(map(int,input().split()))
    m=e[0]
    for i in range(q):
        if i==q-1:
            k=(w-e[i])*2
        else:
            {{completion}}
        if k>m:
            m=k
    print(m)",k=e[i+1]-e[i],k=e[i]+e[i+1]
"t1 = int(input())
for _ in range(t1):
    n1, k1 = map(int, input().split())
    arr = list(map(int, input().split()))
    arr.sort()
    if k1 >= 3:
        print(0)
        continue
    ans = min(arr)

    for j in range(1, n1):
        ans = min(ans, abs(arr[j] - arr[j - 1]))
    if k1 == 2:

        for j in range(1, n1):
            start = 0
            end = j - 1
            while start <= end:
                ans = min(ans, abs(arr[j] - arr[start] - arr[end]))
                if (arr[start] + arr[end]) <= arr[j]:
                    start += 1
                else:
                    {{completion}}

    print(ans)
",end -= 1,"end -= 1
        ans = min(ans, abs(arr[n1 - 1] - arr[n1 - 2]))"
"for _ in range(int(input())):
    n,k=map(int,input().split())
    a=sorted(map(int,input().split()))
    if k>=3:print(0);continue
    if k==1:print(min(a[0],min([a[i+1]-a[i] for i in range(n-1)])));continue
    mini=1000000000000000000
    for i in range(n-1):
        for j in range(i+1,n):
            s=a[j]-a[i]
            if s<=a[0]:mini=min(mini,s,a[0]-s);continue
            if s>=a[-1]:mini=min(mini,a[0],s-a[-1]);continue
            start,end=0,n-1
            v=-1
            while start<=end:
                mid=(start+end)//2
                if s>a[mid]:start=mid+1;continue
                if s<=a[mid]:
                    if a[mid-1]<=s<=a[mid]:{{completion}}
                    end=mid-1
            mini=min(mini,a[v]-s,s-a[v-1])
    print(min(a[0],mini))


",v=mid;break,"
                        v=mid
                    else:
                        v=mid-1
                    break
                else:"
"def sol(n,k,a):
    if k>=3: return 0
    m=min(a)
    res=m
    if k==1:
        for i in range(n):
            for j in range(i):
                res=min(res,abs(a[i]-a[j]))
        return res
    a.sort()
    for i in range(1,n):
        x=a[i]
        l,r=0,i-1
        while l<=r:
            cur=a[l]+a[r]
            res=min(res,abs(cur-x),abs(a[l]-x),abs(a[r]-x))
            if cur>x:
                r-=1
            elif cur<x:
                {{completion}}
            else:
                break
        if res==0:
            break
    return res
    
    
t=int(input().strip())
for q in range(t):
    n,k=map(int,input().strip().split())
    a=list(map(int,input().strip().split()))
    print(sol(n,k,a))
",l+=1,"l-=1
            else:
                break
        if res==0:
            break
    for i in range(1,n):
        x=a[i]
        l,r=i+1,n-1
        while l<=r:
            cur=a[l]+a[r]
            res=min(res,abs(cur-x),abs(a[l]-x),abs(a[r]-x))
            if cur>x:
                r-=1
            elif cur<x:
                l-=1"
"
mod=998244353


def solve():
    n=int(input())
    A=[]
    while n>0:
        s=list(map(int,input().split()))
        A+=s
        n-=len(s)

    a0,a1,a00,a10,a01,a11=0,0,0,0,0,0
    ans=[0,0,0,0]
    for i,x in enumerate(A):
        if x&1:
            a,b,c,d=ans
            ans=[a,(b+a01+c)%mod,(c+a10+d)%mod,d]
            a0,a1,a00,a10,a01,a11=a0,a1+1,a00,a10,(a01+a0)%mod,(a11+a1)%mod
        else:
            {{completion}}
    print(sum(ans)%mod)








for _ in range(1):
    solve()

","a, b, c, d = ans
            ans = [(a00+a+a)%mod,b,c,(d+a11+b)%mod ]
            a0, a1, a00, a10, a01, a11 = a0+1, a1 , (a00+a0)%mod, (a10+a1)%mod, a01, a11","a,b,c,d=ans
            ans=[a,(b+a11+c)%mod,(c+a00+d)%mod,d]
            a0,a1,a00,a10,a01,a11=a0,a1+1,a00,a10,(a01+a0)%mod,(a11+a1)%mod
            
    ans=list(map(int,str(ans).split()))"
"import sys
input = sys.stdin.readline

mod=998244353

from random import randint

t=int(input())
for tests in range(t):
    n=int(input())
    A=list(map(int,input().split()))
    
    for i in range(2*n):
        A[i]-=1
        
    W=[randint(10**17,10**18) for i in range(n)]

    S=[0]*(2*n+1)
    for i in range(2*n):
        S[i+1]=S[i]^W[A[i]]

    LAST=dict()
    for i in range(2*n+1):
        LAST[S[i]]=i

    ANS=0
    ANS2=1

    for i in range(2*n):
        if S[i]==0:
            ANS+=1
            count=1
            j=i+1
            while S[j]!=0:
                {{completion}}

            ANS2=ANS2*count%mod

    #print(A)
    #print(S)

    print(ANS,ANS2)
","count+=1
                j=LAST[S[j]]
                j+=1","count+=1
                j+=1
                
            ANS=ANS*count%mod
            
            count=1
            j=i
            while S[j]!=0:
                count+=1
                j-=1"
"import sys
import random

input = sys.stdin.readline
rd = random.randint(10 ** 9, 2 * 10 ** 9)
Mod = 998244353
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    n *= 2
    rd = [-1] * (n + 1)
    for i in range(n):
        if rd[a[i]] == -1:
            rd[a[i]] = random.randint(0, 10 ** 18)
            a[i] ^= rd[a[i]]
        else:
            {{completion}}
    xor = [0] * n
    xor[0] = a[0]
    cnt = [0] * (n + 1)
    from collections import defaultdict
    last = defaultdict(lambda: -1)
    for i in range(1,n):
        xor[i] = xor[i - 1] ^ a[i]
    for i in range(n):
        if xor[i] and last[xor[i]] != -1:
            cnt[i] -= 1
            cnt[last[xor[i]]] += 1
        last[xor[i]] = i
    for i in range(1, n + 1):
        cnt[i] += cnt[i - 1]
    x = 0
    ans = 0
    res = 1
    # print(cnt, xor)
    for i in range(n):
        x += not cnt[i]
        if not xor[i]:
            ans += 1
            res *= x
            res %= Mod
            x = 0
    print(ans, res)
",a[i] ^= rd[a[i]],"rd[a[i]] ^= rd[a[a[i]]]
    rd = [x % Mod for x in rd]
    cnt = [0] * (n + 1)
    for i in range(1, n + 1):
        cnt[i] = cnt[i - 1]
    ans = 0
    res = 1
    for i in range(n):
        x += not cnt[i]
        if not rd[a[i]]:
            ans += 1
            res *= x
            res %= Mod
            x = 0
    print(ans, res)
'''
import sys
import random

input = sys.stdin.readline
rd = random.randint(10 ** 9, 2 * 10 ** 9)
Mod = 998244353
t = int(input())
for _ in range(t):
    n = "
"import sys
input=sys.stdin.buffer.readline
def rl(): return list(map(int,input().split()))
def ri(): return int(input())
def rs(): return input().decode(""utf-8"")[:-2]
def rm(): return map(int,input().split())

mod=998244353
def main():
    n=ri()
    a=rl()
    d=[0]*(n+1)
    for i in range(2*n): d[a[i]]+=i
    mx=-1
    res=[]
    for i in range(2*n):
        if i==mx: res.append(i)
        else:mx=max(mx,d[a[i]]-i)
    m=len(res)
    ed=set(res)
    dd={}
    cur=0
    sw=[0]*(2*n)
    for i in range(2*n):
        cur^=hash(str(a[i]))
        if cur in dd.keys() and i not in ed:
            sw[dd[cur]+1]+=1
            if i+1<2*n:{{completion}}
        dd[cur]=i
    for i in range(1,2*n): sw[i]+=sw[i-1]
    prv=-1
    cnts=1
    for i in range(m):
        cnt=0
        for j in range(prv+1,res[i]+1):
            if sw[j]==0: cnt+=1
        cnts*=cnt
        cnts%=mod
        prv=res[i]
    print(m,cnts)

t=ri()
for i in range(t):
    main()",sw[i+1]-=1,"
                cur^=hash(str(a[i+1]))
                sw[dd[cur]+1]+=1
        if cur in dd.keys() and i in ed:
            sw[dd[cur]+1]+=1
        if cur in dd.keys() and i+1<2*n:
            sw[dd[cur]+1]+=1
            
    for i in range(2*n):
        if sw[i]==0: sw[i]=1
    for i in range(2*n):
        cur=i
        while sw[cur]>1:
            cur^=hash(str(a[cur]))
            sw[cur]-=1
        cur^=hash(str(a[cur]))"
"import sys

cin = sys.stdin
cout = sys.stdout
t = int(cin.readline().strip())

for _ in range(t):
    n = int(cin.readline().strip())
    a = [int(i) for i in cin.readline().strip().split("" "")]
    b = a.copy()
    a.sort()
    m = {}
    s = 0
    target = 0
    for i in range(0, n):
        if(s < a[i]):
            s += a[i]
            target+=1
        while(True):
            if(target < n and s >= a[target]):
                s+=a[target]
                target += 1
            else:
                {{completion}}
        m[a[i]] = target-1
    ans = []
    for i in b:
        ans.append(str(m[i]))
    print(' '.join(ans))


        ",break,"target = 0
                break
        m[a[i]] = target-1
    ans = []
    for i in b:
        ans.append(str(m[i]))
    print(' '.join(ans))
<|/ file filename=Array-Manipulation.py ext=.py |>"
"import sys; input = lambda: sys.stdin.buffer.readline().decode().strip(); print = lambda *args, **kwargs: sys.stdout.write("" "".join(map(str, args)) + ""\n"", **kwargs)
def InputList(Dtype=int): return list(map(Dtype, input().split()))
from random import randint; RND = randint(1, 10**9)
from bisect import bisect_left, bisect_right

def solve():
	# print(f""================================"")
	N = int(input())
	nums = InputList()
	srt = list(sorted(nums))
	pref = [0] * (N+1)
	for i in range(N): pref[i+1] = pref[i] + srt[i]

	res = []
	for n in nums:
		while True:
			ind = bisect_right(srt, n)
			n = pref[ind]
			if (ind == N) or (srt[ind] > n): {{completion}}
	return res

for i in range(t:=int(input())):
	ans = solve(); print(*ans)",res.append(ind-1); break,"break
		res.append(ind)"
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    A = list(map(int, input().split()))
    B = [a * n + i for i, a in enumerate(A)]
    B.sort()

    P = [0] * (n + 1)
    for i, b in enumerate(B):
        a = b // n
        P[i + 1] = P[i] + a
    
    res = [0] * n
    j = B[-1] % n
    res[j] = n - 1
    
    for idx in range(n - 2, -1, -1):
        aj, j = divmod(B[idx + 1], n)
        ai, i = divmod(B[idx], n)
        if P[idx + 1] >= aj:
            ans = res[j]
        else:
            {{completion}}

        res[i] = ans

    return "" "".join(map(str, res))


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))",ans = idx,ans = ai
"import sys
from random import getrandbits
input = sys.stdin.readline
MOD = 998244353
    
def solve():
    n = int(input())
    colors = [int(x) - 1 for x in input().split()]
    
    size = 0
    ans = 1

    seen = dict()
    hash = [-1] * n
    x = 0
    drop = []
    left = 0
    
    for i, c in enumerate(colors):
        
        if hash[c] == -1:
            hash[c] = getrandbits(64)
            x ^= hash[c]
        
        else:
            x ^= hash[c] 
            
            if x == 0:
                size += 1
                
                if colors[left] == c:
                    ans *= 2
                    ans %= MOD
                
                else:
                    good = i + 1 - left
                    
                    while drop:
                        {{completion}}
                    
                    ans *= good
                    ans %= MOD
                
                drop.clear()
                seen.clear()
                left = i + 1

            elif x in seen:
                
                l = seen[x]
                
                while drop and drop[-1][0] > l:
                    drop.pop()
                
                drop.append((l, i + 1))

        if x != 0:
            seen[x] = i + 1

    return f""{size} {ans}""


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","l, r = drop.pop()
                        good -= r - l","
                        l, i = drop.pop()
                        
                        if l == left:
                            good += 1
                            
                            if colors[l] == c:
                                good *= 2
                                good %= MOD
                            
                            else:
                                break
                        
                        else:
                            break"
"def II():
    return(int(input()))
def LMI():
    return(list(map(int,input().split())))
def I():
    return(input())
def MII():
    return(map(int,input().split()))
import sys
input=sys.stdin.readline
# import io,os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# from collections import Counter
# int(math.log(len(L)))
# import math
# from collections import defaultdict
# mod=10**9+7
# from collections import deque
# import  math

import random
mod=998244353

# from functools import cache
# @cache

for _ in range(II()):
    n=II()
    P=LMI()
    L=[P[i] for i in range(2*n)]
    X=set()
    M=[0]
    for i in range(n):
        x=random.randint(193021,203213232131123)

        while x in X:
            x=random.randint(193021,203213232131123)
        X.add(x)
        M.append(x)
    for i in range(2*n):
        L[i]=M[L[i]]
    L=[0]+L
    for i in range(1,2*n+1):
        L[i]^=L[i-1]
    X={}
    ans=[0]*(2*n+1)
    for i in range(2*n+1):
        if L[i] not in X:
            X[L[i]]=i
        else:
            ans[X[L[i]]+1]=i
            X[L[i]]=i
    final=0
    cou=1
    i=1
    while i<=2*n:
        final+=1
        j=i+1
        temp=ans[i]-i+1
        while j<ans[i]:
            if ans[j]!=0:
                temp-=ans[j]-j+1
                j=ans[j]+1
            else:
                {{completion}}
        # print(temp,*P[i-1:ans[i]])
        cou*=temp
        cou%=mod
        i=ans[i]+1
    print(final,cou)






    # return



# if __name__==""__main__"":

#     for _ in range(II()):
#         t()
    # t()",j+=1,"j+=1
        if temp<0:
            temp+=mod"
"T=int(input())
from sys import stdin, setrecursionlimit
input = stdin.readline
readline = stdin.readline
import random
from collections import deque
mod=998244353
for t in range(T):
  N=int(input())
  A=list(map(int, input().split()))
  p,q=0,1
  E={}
  for i in range(N+10):
    e=random.randint(1,10**15)
    E[i]=e 
  now=0
  D={};G=[];s=-1
  D[0]=0;d=deque()
  for i in range(2*N):
    a=A[i]
    now^=E[a]
    d.append(a)
    if now not in D:
      D[now]=1
    else:
      if now!=0:
        nowx=now
        F={}
        dd=d.pop();cc=1;ee=1
        F[dd]=1
        while d:
          dd=d.pop()
          ee+=1
          if dd not in F:
            F[dd]=1 
            cc+=1
          else:
            {{completion}}
          if cc==0:
            G.append(ee)
            break
      else:
        now=0
        D={}
        D[0]=0;d=deque()   
        if i-s==2:
          p+=1;q*=2
          q%=mod
        else:
          h=i-s-sum(G)
          p+=1;q*=h 
          G=[]
          d=deque()
          q%=mod
        s=i
  print(p,q)
  ",cc-=1,"F[dd]=0
        if cc==2:
          for dd in F:
            if F[dd]==1:
              if dd!=nowx:
                G.append(dd)
                break
      else:
        now=0
        D={}
        D[0]=0;d=deque()   
        if i-s==2:
          p+=1;q*=2
          q%=mod
        else:
          h=i-s-sum(G)
          p+=1;q*=h 
          G=[]
          d=deque()
          q%=mod
        s=i
  print(p,q)
  setrecursionlimit(10**"
"for _ in range(int(input())):
    n, k = list(map(int, input().split(' ')))
    a = list(map(int, input().split(' ')))
    if a == sorted(a) or k != 1:
        print('YES')
    else:
        {{completion}}
",print('NO'),"a.sort()
        if a[:k] == sorted(a[:k]):
            print('YES')
        else:
            print('NO')
<|/ file ext=.py source=github |>"
"def solve():
    n, k = map(int, input().split())
    numbers = list(map(int, input().split()))
    
    if numbers == sorted(numbers) or k > 1:
        print(""YES"")
    else:
        {{completion}}
    
    
if __name__ == ""__main__"":
    for test in range(int(input())):
        solve()
        ","print(""NO"")","numbers = numbers[::-1]
        if numbers == sorted(numbers) or k > 1:
            print(""YES"")
        else:
            print(""NO"")"
"for t in range(0,int(input())):
    s=input().split()
    n=int(s[0])
    k=int(s[1])
    l=list(map(int,input().split()))
    f=0
    if k==1:
        for i in range(0,len(l)-1):
            if l[i]>l[i+1]:
                {{completion}}
        if f==0 or len(l)==1:
            print('YES')
        
    else:
        print('YES')
    
","print('NO')
                f=1
                break","l.insert(i+1,l[i])
                l.insert(i,l[i+1])
                l.insert(i+1,l[i])
                l.insert(i,l[i+1])
                f=1
                break
        if f==0 or len(l)==1:
            print('YES')
        
    else:
        print('YES')
    
for t in range(0,int(input())):
    s=input().split()
    n=int(s[0])
    k=int(s[1])
    l=list(map(int,input().split()))
    f=0
    if k==1:
        for i in range(0,len(l)-1):
            if l[i]>l[i+1]:
                l.insert(i+1,l[i])
                l.insert(i,"
"for _ in range(int(input())):
    num_employees = int(input())
    employee_skills = list(map(int, input().split()))
    levels, subordinates = [0] * num_employees, [[] for i in range(num_employees + 1)]

    for i in range(2, num_employees + 1):
        subordinates[employee_skills[i - 2]].append(i)

    # (employee, level), starting with employee 1 at level 0
    queue = [(1, 0)]

    while queue:
        current_employee, current_level = queue.pop()
        levels[current_level] += 1

        for subordinate in subordinates[current_employee]:
            {{completion}}

    answer, surplus = 0, 0

    for i in range(num_employees):
        if levels[i] + surplus > 1:
            answer += 1
            surplus += levels[i] - 2

    print(answer + surplus // 2)
","queue.append((subordinate, current_level + 1))","queue.append((subordinate, current_level + 1))

    levels = [0] + levels"
"from sys import stdin, stdout
from collections import deque

t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    parent = [int(x)-1 for x in stdin.readline().split()]
    children = {i:[] for i in range(n)}

    for u in range(n-1):
        children[parent[u]].append(u+1)

    queue = deque()
    queue.append(0)
    depth = [0]*n
    max_depth = 0

    while len(queue) > 0:
        v = queue.popleft()
        for w in children[v]:
            queue.append(w)
            depth[w] = depth[v] + 1
            max_depth = max(max_depth, depth[w])

    count = [0]*(max_depth+1)
    for i in range(n):
        count[depth[i]] += 1

    answer = 0
    left_pointer = max_depth
    for pointer in range(max_depth,0,-1):
        if count[pointer] > 1:
            answer += count[pointer]// 2
            count[pointer] = count[pointer] % 2

        if count[pointer] == 1:
            left_pointer = min(left_pointer, pointer-1)

            while left_pointer > 0 and count[left_pointer] == 1:
                {{completion}}

            if left_pointer == 0:
                break

            answer += 1
            count[left_pointer] -= 1
            count[pointer] -= 1

    stdout.write(str(answer)+'\n')
",left_pointer -= 1,left_pointer -= 1
"import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    par = [int(x) - 1 for x in input().split()]
    children = [[] for _ in range(n)]
    
    for i, p in enumerate(par, start=1):
        children[p].append(i)

    cnt = [0] * n
    stack = [(0, 0)]
    while stack:
        u, l = stack.pop()
        cnt[l] += 1
        for v in children[u]:
            stack.append((v, l + 1))

    ans = 0
    carry = 0
    for l in range(n - 1, -1, -1):
        if cnt[l] <= 1:
            carry += cnt[l]
            continue
        
        x = cnt[l]
        if x - 1 >= carry:
            ans += carry
            x -= carry
            carry = 0
        else:
            {{completion}}
        
        ans += x // 2
        carry += x % 2

    return ans


T = int(input())
out = [solve() for _ in range(T)]
print(""\n"".join(map(str, out)))","ans += x - 1
            carry -= x - 1
            x = 1","ans += x - 1
            carry = 0"
"import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    L = sorted(map(int, input().split()))
    R = sorted(map(int, input().split()))
    C = sorted(map(int, input().split()))

    out = []
    l = 0
    r = 0
    stack = []
    while l < n or r < n:
        if l < n and L[l] < R[r]:
            stack.append(l)
            l += 1
        else:
            {{completion}}
    out = sorted(out, reverse=True)
    print(sum(out[i] * C[i] for i in range(n)))
","ll = stack.pop()
            out.append(R[r] - L[ll])
            r += 1","stack.append(r)
            r += 1
        if l == n:
            l -= 1
        if r == n:
            r -= 1
        out.append((stack.pop(), C[stack.pop()]))"
"from sys import stdin, stdout
input = stdin.readline
inp = lambda :  list(map(int,input().split()))
for i in range(*inp()):
	n,=inp()
	L=inp()
	r=inp()
	l=[]
	for i in range(n):
		l.append(L[i]*2)
		l.append(r[i]*2+1)
	l.sort()
	c=inp()
	l_,l_1=[],[]
	for i in l:
		if i&1==0:	l_.append(i//2)
		else:	{{completion}}
	l_1.sort()
	c.sort(reverse=True)
	res=0
	for i in range(n):
		res+=c[i]*l_1[i]
	print(res)
			



























",l_1.append(i//2-l_.pop()),"l_1.append(i//2)
	l_.sort()"
"import sys
input=sys.stdin.buffer.readline

def rl():
    return list(map(int,input().split()))
def ri():
    return int(input())
def rs():
    return input().decode(""utf-8"")[:-2]
def rm():
    return map(int,input().split())

def main():
    n=ri()
    lf,rt,c=rl(),rl(),rl()
    st=[]
    ln=[]
    lf.sort()
    rt.sort()
    i=j=0
    while i<n or j<n:
        if i<n and rt[j]>lf[i]:
            st.append(lf[i])
            i+=1
        else:
            {{completion}}
    ln.sort()
    c.sort()
    res=0
    for i in range(n):
        res+=ln[n-1-i]*c[i]
    return res

t=ri()
for i in range(t):
    print(main())
","ln.append(rt[j]-st.pop())
            j+=1","st.append(rt[j])
            j+=1
    st.sort()
    ln=st"
"for _ in range(int(input())):
    {{completion}}","n,s=int(input()),input()
    print(""YES"" if s.count('0') else ""NO"")","s=input()
    zeroes=0
    ones=0
    for i in range(len(s)-1):
        if s[i]==s[i+1]:
            ones+=1
        else:
            zeroes+=1
    if zeroes>ones:
        print(""YES"")
    else:
        print(""NO"")
<|/ file source=github "
"t=int(input())
while(t>0):
    n=int(input())
    s=input()
    if s=='1'*n:
        print(""NO"",'\n')
    else:
        {{completion}}
    t=t-1","print(""YES"",'\n')","i=n-1
        while(i>=0):
            if s[i]=='1'*i:
                s=s[:i]+'0'*(i+1)+s[i+1:]
                break
            i=i-1
        if s=='1'*n:
            print(""YES"",'\n')
        else:
            print(""NO"",'\n')"
"def run_case():
    n = int(input())
    s = input()
    z = 0
    for i in range(n):
        z += (s[i] == '0')
    if z:
        print(""YES"")
    else:
        {{completion}}

tests = int(input())
while tests > 0:
    run_case()
    tests -= 1

","print(""NO"")","z = n
        for i in range(n):
            if s[i] == '1':
                z -= 1
            else:
                z += (s[i] == '0')
        if z:
            print(""YES"")
        else:
            print(""NO"")

run_case()"
"for s in[*open(0)][1:]:{{completion}}
","print(max(s.split(),key=int))","
    s=s.split()
    n, m = map(int, s)
    grid = [[0 for i in range(m)] for j in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j]=int(input())
    
    ans=0
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                ans=min(ans,rebuild(grid,i,j))
    return ans
    
def rebuild(grid,i,j):
    ans=0
    if i>0 and grid[i-1][j]==1:
        ans=ans+1
    if i<n-1 and grid[i+1][j]==1:
        ans=ans+1
    if j>0 and grid"
"for i in [*open(0)][1:]:
    {{completion}}
","print(max(map(int, i.split())))","line = i.readline()
    n, m = map(int, line.split())
    grid = [[0 for x in range(m)] for y in range(n)]
    for x in range(n):
        for y in range(m):
            grid[x][y] = int(i.readline())
    count = 0
    for x in range(n):
        for y in range(m):
            if grid[x][y] == 1:
                count += 1
                grid[x][y] = 2
                count += 1
                grid[x][y] = 2
                count += 1
                grid[x][y] = 2
                count += 1
                grid[x][y] = 2
                count += 1
                grid[x][y] = 2
                count += 1
                grid[x][y] = "
"for i in[*open(0)][1:]:
    {{completion}}","print(max(i.split(),key=int))","i = i.split()
    n, m = i[0], i[1]
    grid = [[0 for i in range(m)] for j in range(n)]
    grid[0][0] = 1
    grid[n-1][m-1] = 1
    grid[1][0] = 1
    grid[n-1][0] = 1
    grid[1][m-1] = 1
    grid[n-1][m] = 1
    grid[0][0] = 1
    grid[0][m-1] = 1
    grid[0][n-1] = 1
    grid[m-1][0] = 1
    grid[m-1][n-1] = 1
    grid[n-1][m] = 1
    grid[n-1][m-1] = 1
    grid[m][n-1] = 1
    grid[m][n] = 1
    "
"for _ in range(int(input())):
    a, b = map(int, input().split())

    
    xk, yk = map(int, input().split())
    xq, yq = map(int, input().split())
    attacking_position = [(a,b),(a,-b),(-a,b),(-a,-b),(b,a),(b,-a),(-b,a),(-b,-a)]

    K = set()
    Q = set()

    for x,y in attacking_position:
        {{completion}}
    print(len(K.intersection(Q)))   
    
   
    
     ","K.add((xk+x, yk+y))    
        Q.add((xq+x, yq+y))","K.add( (xk,yk) )
        Q.add( (xq,yq) )

    "
"test=int(input())
for _ in range(test):
        a, b = map(int, input().rstrip().split())
        c, d = map(int, input().rstrip().split())
        e, f = map(int, input().rstrip().split())
        l1=[]
        l2=[]
        count=0

        l1.extend(((c + a, d + b), (c + b, d + a),(c - a, d - b), (c - b, d - a),(c - a, d + b), (c - b, d + a),(c + a, d - b), (c + b, d - a)))
        l2.extend(((e - a, f - b), (e - b, f - a),(e + a, f + b), (e + b, f + a),(e + a, f - b), (e + b, f - a),(e - a, f + b), (e - b, f + a)))
        for i in (set(l1)):
            for j in (set(l2)):
                if i==j:
                    {{completion}}
        print(count)
",count+=1,"count+=1
                    break"
"
t=int(input())

def solve(a,b,k1,k2,q1,q2):
    k=set()
    q=set()
    x=[-1,1,-1,1]
    y=[-1,-1,1,1]
    for i in range(4):
        k.add((k1 + a * x[i], k2 + b * y[i]))
        k.add((k1 + b * x[i], k2 + a * y[i]))
        q.add((q1 + a * x[i], q2 + b * y[i]))
        q.add((q1 + b * x[i], q2 + a * y[i]))
    res=0
    for i in k:
        if i in q:
            {{completion}}
    return res
for i in range(t):
    a,b=map(int,input().split())
    k1,k2=map(int,input().split())
    q1,q2=map(int,input().split())
    print(solve(a,b,k1,k2,q1,q2))",res+=1,res+=1
"for s in[*open(0)][2::2]:
 *a,=s[:-1];b=[];c=m='';i=len(a)
 while i:
  i-=1
  if a[i]>=m:{{completion}}
 for x in c:a[b.pop()]=x
 print((len(c.strip(c[-1])),-1)[a>sorted(a)])","m=a[i];b+=i,;c+=a[i]","
   m=a[i]
   c=b
  b.append(i)
 while b:"
"M=998244353;P=pow;n,p,k=map(int,input().split());a=[1];m=P(p,n,M);i=1;R=1;g=1
for r in range(k):
    {{completion}}
print("" "".join(map(str, a)))
","i=(i*(m-R))%M
    R=(R*p)%M
    g=(g*P(p,r,M)*(R-1))%M
    a.append((i*i*P(g,-1,M))%M if g else 0)","a.append(R);R=R*m
    i=i+1
    for j in range(1,i+1):
        g=g*m
        a[j]=a[j]%P(P,n,g);g=P(g,n,M)
print(""\n"".join(map(str,a)))
<|/ a dscore=0 |>"
"M=998244353;P=pow;n,p,k=map(int,input().split());a=[1];m=P(p,n,M);i=1;R=1;g=1
for r in range(k):
    {{completion}}
print("" "".join(map(str, a)))","i=(i*(m-R))%M
    R=(R*p)%M
    g=(g*P(p,r,M)*(R-1))%M
    a.append((i*i*P(g,-1,M))%M if g else 0)","i=1;R=1;g=1
    while R<n:
        if g==1:
            R=R+m
            g=0
        else:
            R=R+m
            g=g-1
        a[i]=R
        i=i+1
    a=a[1:]"
"
for s in[*open(0)][2::2]:{{completion}}","print((s.count('.'),2)['...'in s])","
    s=s.split()
    s=sorted(s)
    s="""".join(s)
    s=s.replace('#','0')
    s=s.replace('.','1')
    s=s.replace('0','.')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
    s=s.replace('1','#')
"
"for _ in range(int(input())):
    n=int(input())
    s=input()
    if(""..."" in s):
        print(2)
    else:
        {{completion}}","print(s.count("".""))","ans=0
        for i in range(n):
            if(s[i]=="".""):
                ans=ans+2
            else:
                ans=ans+1
        print(ans)
<|/ file dstars=1 source=github |>"
for p in[*open(0)][2::2]:{{completion}},"print((p.count('.'),2)['...'in p])","
    s=input()
    s=s.split()
    s=sorted(s)
    s=list(s)
    s=list(filter(lambda x: x!='#',s))
    s=list(filter(lambda x: x!='.',s))
    s=list(filter(lambda x: len(x)>0,s))
    s=list(filter(lambda x: len(x)<n,s))
    s=list(filter(lambda x: len(x)>1,s))
    s=list(filter(lambda x: len(x)<n,s))
    s=list(filter(lambda x: len(x)>1,s))
    s=list(filter(lambda x: len(x)<n,s))
    s=list(filter(lambda x: len(x)>1,s))
    s=list(filter(lambda x: len(x)<n,s))"
"M=998244353;P=pow;n,p,k=map(int,input().split());a=[1];m=P(p,n,M);i=1;R=1;g=1
for r in range(k):
    {{completion}}
print("" "".join(map(str, a)))
","i=(i*(m-R))%M
    R=(R*p)%M
    g=(g*P(p,r,M)*(R-1))%M
    a.append((i*i*P(g,-1,M))%M if g else 0)","a.append(R);R=R*m
    i=i+1
    k=k+1
print(k)"
"n,p,k = list(map(int, input().split()))
m=998244353
def f(x,y):
    return pow(x,y,m)

pn = f(p,n)
pe = [1]
for i in range(k):
    pe.append(pe[i]*p%m)
pi=f(p,-1)
pei=[1]
for i in range(k):
    pei.append(pei[i]*pi%m)
    
num=1
den=1
ans=[1]
for r in range(1,k+1):
    num *= (pn-pe[r-1])**2
    num %= m
    if r>n or num==0: {{completion}}
    den *= f(pe[r]-1,-1)
    den %= m
    den *= pei[r-1]
    den %= m
    ans.append(num*den%m)

while len(ans)<k+1: ans.append(0)
print(*ans)
    ",break,"break
    den *= f(pn-pe[r-1],r)
    den %= m
    den *= pe[r]
    den %= m
    ans.append(num*den%m)
    
num=1
den=1
for r in range(1,k+1):
    num *= (pe[r]-pei[r-1])**2
    num %= m
    if r>n or num==0: break"
"import math
from sys import stdin
input=lambda:stdin.readline().strip()
T=int(input())
V=[""a"",""e""]
C=[""b"",""c"",""d""]
while T:
    n=int(input())
    A=[]
    B=[]
    ALL=[]
    for i in range(n):
        a,b=map(int,input().split())
        A.append(a)
        B.append(b)
    temp=A[::]
    temp.sort()
    index=1
    dic=dict()
    for i in temp:
        dic[i]=index
        index+=1
    for i in range(n):
        ALL.append((dic[A[i]],B[i]))
    ALL.sort(key=lambda x:x[1])
    # print(ALL)
    SUM=[0]*(n+1)
    def low_bit(x):
        return x&(-x)
    def add(index):
        while index<n+1:
            {{completion}}
    def get(index):
        ret=0
        while index>0:
            ret+=SUM[index]
            index-=low_bit(index)
        return ret
    ret=0
    # print(ALL)
    for a,b in ALL:
        ret+=get(n)-get(a)
        add(a)
    print(ret)
    # print(ALL)
    # S=SortedList()
    T-=1","SUM[index]+=1
            index+=low_bit(index)","SUM[index]+=1
            index+=1
    "
"#from io import BytesIO
#from os import read,fstat
from sys import stdin
from sys import stdout
#input=BytesIO(read(0,fstat(0).st_size)).readline
input=stdin.readline
print=stdout.write

def ms(a,l,r):
    if l<r:
        c=(l+r)//2
        return ms(a,l,c)+ms(a,c+1,r)+m(a,l,c,r)
    else:
        return 0

def m(a,l,c,r):
    i,j,k,x=l,c+1,l,0
    while i<=c and j<=r:
        if a[i]<=a[j]:
            aa[k]=a[i]
            i+=1
        else:
            {{completion}}
        k+=1
    while i<=c:
        aa[k]=a[i]
        i+=1
        k+=1
    while j<=r:
        aa[k]=a[j]
        j+=1
        k+=1
    for i in range(l,r+1):
        a[i]=aa[i]
    return x

t=int(input())
for _ in range(t):
    i=int(input())
    l=[tuple(map(int,input().split())) for _ in range(i)]
    l.sort(key=lambda x:x[1])
    s=[i[0] for i in l]
    aa=[0]*i
    print(f'{ms(s,0,i-1)}\n')","aa[k]=a[j]
            x+=(c-i+1)
            j+=1","aa[k]=a[j]
            j+=1"
"import sys

def main():
    input = sys.stdin.readline
     
    class Fenwick:
        def __init__(self, arr):
            self.pref = [0]
            for i in arr:
                {{completion}}
     
            self.tree = [0] * len(self.pref)
            
            for i in range(1, len(self.pref)):
                self.tree[i] = (self.pref[i] - self.pref[i - (i&-i)])
     
        def query(self,k):
            s = 0
            while k>= 1:
                s += self.tree[k]
                k -= k&-k
            return s
     
        def update(self,k,x):
            while k < len(self.tree):
                self.tree[k] += x
                k += k&-k
     
    outl = []
     
    for case in range(int(input())):
        a = []
        b = []
        ba = {}
        for node in range(int(input())):
            x,y = map(int, input().split())
            a.append(x)
            b.append(y)
            ba[y] = x
     
        b.sort()
     
        ab = {}
        
        for i,v in enumerate(b):
            ab[ba[v]] = i
     
        a.sort()
     
        arr = [1]*len(b)
     
        fenwick = Fenwick(arr)
     
        tot = 0
        for i,v in enumerate(a):
            remainA = len(a) - i - 1
            remainB = fenwick.query(ab[v])
            tot += min(remainA, remainB)
            fenwick.update(ab[v] + 1, -1)
        outl.append(tot)
     
    print('\n'.join(map(str, outl)))



main()
",self.pref.append(self.pref[-1] + i),"temp = self.pref.copy()
                temp.append(i)
                self.pref = temp"
"for t in range(int(input())):
    n=int(input())
    #a,b=map(int,input().split())
    l=list(map(int,input().split()))
    m=list(map(int,input().split()))
    score=0-sum(m)+n 
    k=[]
    for i in range(n):
        {{completion}}
    k.sort(reverse=True)
    i=0
    while(i<=n-1):
        score+=k[i]
        i+=2
    print(score)
",k.append(l[i]+m[i]-2),"k=k+[l[i]]
    k=k+[m[n-1]]"
"import sys
from math import *
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def inp():
    return int(input())

def inlt():
    return list(map(int, input().split()))

def insr():
    s = input()
    return list(s[: len(s) - 1])

def invr():
    return map(int, input().split())

def solve():

    n = inp()
    a = inlt()
    b = inlt()
    s = sum(a) - n

    c = [ai + bi for ai, bi in zip(a,b)]
    c = sorted(c, reverse=True)

    for i in range(n):
        if i % 2 == 1:
            {{completion}}

    print(s)

if __name__ == '__main__':
    t = inp()
    for i in range(t):
        solve()",s = s - c[i] + 2,"s += c[i]
        else:
            s -= c[i]"
"import sys
input = lambda: sys.stdin.readline().rstrip()  # faster!
def solve_case():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    idx = sorted(range(n), key=lambda i: a[i] + b[i], reverse=True)
    ans = 0
    for i in range(n):
        if i & 1:
            ans -= b[idx[i]] - 1
        else:
            {{completion}}
    return str(ans)
ans = []
for _ in range(int(input())):
    ans += [solve_case()]
print(""\n"".join(ans))",ans += a[idx[i]] - 1,"ans += a[idx[i]] - 1
    return ans
def solve_case2():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    idx = sorted(range(n), key=lambda i: a[i] + b[i], reverse=True)
    ans = 0
    for i in range(n):
        if i & 1:
            ans += a[idx[i]] - 1
        else:
            ans -= b[idx[i]] - 1"
"from sys import stdin
input = lambda: stdin.buffer.readline().decode().strip()


for _ in range(int(input())):
    n = int(input())
    f = [1]*4
    for _ in range(n):
        {{completion}}

    print('YES' if sum(f) else 'NO')","x, y = map(int, input().split())
        f[0] &= x >= 0
        f[1] &= x <= 0
        f[2] &= y >= 0
        f[3] &= y <= 0","x, y = map(int, input().split())
        if x == 0 or y == 0:
            break
        f[x-1] -= 1
        f[y-1] -= 1
        if f[x-1] == 0 and f[y-1] == 0:
            break"
"import sys
for _ in range(int(sys.stdin.readline().strip())):
    n = int(sys.stdin.readline().strip())
    dx = [False, False, False, False]
    for _ in range(n):
        x, y = map(int, sys.stdin.readline().split())
        if x > 0:
            {{completion}}
        if x < 0:
            dx[1] = True
        if y > 0:
            dx[2] = True
        if y < 0:
            dx[3] = True
    print('YES' if sum(dx) <= 3 else 'NO')",dx[0] = True,"dy = [False, False, False, False]
            for _ in range(n):
                x2, y2 = map(int, sys.stdin.readline().split())
                if x2 > x:
                    dy[2] = True
                if x2 < x:
                    dy[1] = True
                if y2 > y:
                    dy[3] = True
                if y2 < y:
                    dy[0] = True
            if sum(dy) <= 3:
                dx[0] = True
            if sum(dy) >= 3:
                dx[1] = True
            if sum(dy) >= 3:
                dx[2] = True
            if sum(dy) >= 3:
                dx[3] = True
        else:
            dx[0] = True"
"import sys
input=sys.stdin.readline
Q=int(input())
for _ in range(Q):
  N=int(input())
  X=[]
  Y=[]
  for i in range(N):
    {{completion}}
  X.sort()
  Y.sort()
  if X[0]>=0 or X[-1]<=0:
    print('YES')
    continue
  if Y[0]>=0 or Y[-1]<=0:
    print('YES')
    continue
  print('NO')","x,y=map(int,input().split())
    X.append(x)
    Y.append(y)","x,y=map(int, input().split())
    X.append(x)
    Y.append(y)"
"import sys

def input(data_type=int): return data_type(sys.stdin.readline().strip())
def print(*args, sep=' ', end='\n'): sys.stdout.write(sep.join(map(str, args))+end)
def input_list(data_type=int): return list(map(data_type, sys.stdin.readline().strip().split()))

def Solve(n, k):
    l = n**2-k
    
    # Pattern
    if k > n**2 or k%2 == 1:
        matrix=[]
    
    elif k == 0:
        matrix=[[0]*n for _ in range(n)]
    
    elif k == n:
        matrix=[[1 if i==j else 0 for i in range(n)] for j in range(n)]
    
    elif k == n**2:
        matrix=[[1]*n for _ in range(n)]
        
    elif k == 2 or l == 2:
        if n == 2:
            matrix = [[1, 0], [0, 1]]
        else:
            matrix=[]
    
    # Main case
    else:
        q = min(k, l)
        matrix=[[0 for _ in range(n)] for __ in range(n)]
        
        if q % 4 != 0:
            matrix[-1][-1] = 1
            matrix[-1][-2] = 1
            matrix[-1][-3] = 0
            matrix[-2][-1] = 1
            matrix[-2][-2] = 0
            matrix[-2][-3] = 1
            matrix[-3][-1] = 0
            matrix[-3][-2] = 1
            matrix[-3][-3] = 1
            q -= 6
        
        row=2*n
        rnum = q // row
        left = (q % row) // 2
        for i in range(2*rnum):
            for j in range(n):
                matrix[i][j] = 1
    
        for i in range(left):
            matrix[2*rnum][i] = 1
            matrix[2*rnum + 1][i] = 1
        
        if l < k:
            for i in range(n):
                for j in range(n):
                    {{completion}}
    
    # Output
    if matrix!=[]:
        print(""Yes"")
        for i in matrix:
            print(*i)
    else:
        print(""No"")
    
if __name__ == ""__main__"":
    for _ in range(input()):
        n, k = input_list()
        Solve(n, k)",matrix[i][j] ^= 1,"matrix[i][j] = 1 if matrix[i][j] == 0 else 0
    
        for i in range(n):
            for j in range(n):
                matrix[i][j] = 1 if matrix[i][j] == 1 else 0
    
        for i in range(n):
            for j in range(n):
                matrix[i][j] = 1 if matrix[i][j] == 0 else 0
    
        for i in range(n):
            for j in range(n):
                matrix[i][j] = 1 if matrix[i][j] == 1 else 0
    
        for i in range(n):
            for j in range(n):
                matrix[i][j] = 1 if matrix[i][j] == 0 else 0
    
        for i in range(n):
            for j in range(n):
                matrix[i][j] = 1 if matrix[i][j] == 0 else 0
    
        for i in range(n):
            for j in range(n):
                matrix[i][j] = 1 if matrix[i][j] == 0 else 0
    
        for i in range(n):"
"import sys 
input = sys.stdin.buffer.readline 

def process(n, k):
    if k % 2 ==1:
        sys.stdout.write('No\n')
        return 
    elif k % 4==0:
        answer = [[0 for j in range(n)] for i in range(n)]
        for i in range(0, n, 2):
            for j in range(0, n, 2):
                if k > 0:
                    answer[i][j] = 1 
                    answer[i+1][j] = 1 
                    answer[i][j+1] = 1 
                    answer[i+1][j+1] = 1 
                    k-=4 
        sys.stdout.write('Yes\n')
        for row in answer:
            row = ' '.join(map(str, row))
            sys.stdout.write(f'{row}\n')
    elif n % 4==2 and n <= k <= n*(n-1):
        answer = [[0 for j in range(n)] for i in range(n)]
        for i in range(0, n, 2):
            answer[i][i] = 1 
            answer[i+1][i+1] = 1 
            k-=2 
        for i in range(0, n, 2):
            for j in range(0, n, 2):
                if i != j and k > 0:
                    answer[i][j] = 1 
                    answer[i+1][j] = 1 
                    answer[i][j+1] = 1 
                    answer[i+1][j+1] = 1 
                    k-=4 
        sys.stdout.write('Yes\n')
        for row in answer:
            row = ' '.join(map(str, row))
            sys.stdout.write(f'{row}\n')
    elif n >= 4 and k >= 6 and k-6 <= n*n-16:
        answer = [[None for j in range(n)] for i in range(n)]
        M = [[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0], [0, 1, 0, 1]]
        for i in range(4):
            for j in range(4):
                answer[i][j] = M[i][j]
        k-=6 
        for i in range(0, n, 2):
            for j in range(0, n, 2):
                if answer[i][j] is None:
                    if k >= 4:
                        answer[i][j] = 1 
                        answer[i][j+1] = 1 
                        answer[i+1][j] = 1 
                        answer[i+1][j+1] =1
                        k-=4 
                    else:
                        {{completion}}
        sys.stdout.write('Yes\n')
        for row in answer:
            row = ' '.join(map(str, row))
            sys.stdout.write(f'{row}\n')
    elif k >= 10 and n >= 4 and k-10 <= n*n-16:
        answer = [[None for j in range(n)] for i in range(n)]
        M = [[1, 1, 1, 1], [1, 1, 0, 0], [1, 0, 1, 0], [1, 0, 0, 1]]
        for i in range(4):
            for j in range(4):
                answer[i][j] = M[i][j]
        k-=6 
        for i in range(0, n, 2):
            for j in range(0, n, 2):
                if answer[i][j] is None:
                    if k >= 4:
                        answer[i][j] = 1 
                        answer[i][j+1] = 1 
                        answer[i+1][j] = 1 
                        answer[i+1][j+1] =1
                        k-=4 
                    else:
                        answer[i][j] = 0 
                        answer[i][j+1] = 0
                        answer[i+1][j] = 0
                        answer[i+1][j+1] =0
        sys.stdout.write('Yes\n')
        for row in answer:
            row = ' '.join(map(str, row))
            sys.stdout.write(f'{row}\n')
    else:
        sys.stdout.write('No\n')
        return
        
                    
                    
    return 

t = int(input())
for i in range(t):
    n, k = [int(x) for x in input().split()]
    process(n, k)","answer[i][j] = 0
                        answer[i][j+1] = 0 
                        answer[i+1][j] = 0
                        answer[i+1][j+1] =0","answer[i][j] = 0 
                        answer[i][j+1] = 0
                        answer[i+1][j] = 0
                        answer[i+1][j+1] =0
        sys.stdout.write('Yes\n')
        for row in answer:
            row = ' '.join(map(str, row))
            sys.stdout.write(f'{row}\n')
    elif n >= 4 and k >= 6 and k-6 <= n*n-16:
        answer = [[None for j in range(n)] for i in range(n)]
        M = [[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0], [0, 1, 0, 1]]
        for i in range(4):
            for j in range(4):
                answer[i][j] = M[i][j]
        k-=6 
        for i in range(0, n, 2):
            for j in range(0, n, 2):
                if answer[i][j] is None:
                    if k >= 4:"
"for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    b = [*map(int, input().split())]
    s = 0
    c = sorted((a[i]+b[i]-2, a[i]-1, 1-b[i], i) for i in range(n))
    for i in range(n): {{completion}}
    print(s)",s += c.pop()[i%2+1],"s += c[i]
    print(s)
<|/ a dscore=0 |>"
"

def takeintinput():
    arr = input().split()
    arr = [int(i) for i in arr]
    return arr

def solve():
    n = takeintinput()[0]
    arr3 = takeintinput()
    arr2 = takeintinput()
    arr = []
    for i in range(n):
        arr.append([arr3[i]+arr2[i], arr3[i], arr2[i]])
    arr = sorted(arr)[::-1]
    co = 0
    # print(arr)
    for i in range(n):
        if i%2==0:
            co+=arr[i][1]-1
        else:
            {{completion}}
    print(co)

for i in range(int(input())):
    solve()",co-=arr[i][2]-1,co+=arr[i][2]-1
"test = int(input())

for _ in range(test):
    n, turn, sum_a, sum_b = 0, 0, 0, 0
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    arr = [(a[i] + b[i], i) for i in range(n)]
    arr.sort(reverse=True)
    is_alice =True

    for i in range(n):
        if is_alice:
            a[arr[i][1]] -= 1
            b[arr[i][1]] = 0
            is_alice = False
        else:
            {{completion}}
        

    for i in range(n):
        sum_a += a[i]
        sum_b += b[i]

    print(sum_a - sum_b)
","b[arr[i][1]] -= 1
            a[arr[i][1]] = 0
            is_alice = True","a[arr[i][1]] += 1
            b[arr[i][1]] -= 1
            is_alice = True"
"import sys

rd = lambda: sys.stdin.readline().rstrip()


class FenwickTree:
    def __init__(self, n):
        self.tree = [0] * (n + 1)

    def query(self, pos: int) -> int:
        """"""return arr[0] + arr[1] + ... + arr[pos]""""""
        pos += 1
        ret = 0
        while pos > 0:
            {{completion}}
        return ret

    def rangeSum(self, s: int, e: int) -> int:
        """"""return arr[s] + arr[s+1] + ... + arr[e]""""""
        return self.query(e) - self.query(s - 1)

    def add(self, pos: int, val: int) -> None:
        """"""same as arr[pos] += val""""""
        pos += 1
        while pos < len(self.tree):
            self.tree[pos] += val
            pos += pos & -pos


def solve():
    n, k = map(int, rd().split())
    p = list(map(int, rd().split()))
    q = list(map(int, rd().split()))

    s = 0
    qt = FenwickTree(k)
    for v in q:
        s += n * qt.rangeSum(v, k - 1)
        qt.add(v, 1)

    pt = FenwickTree(2 * n)
    for i in range(n):
        v = p[i]
        wgh = k * (k + 1) // 2
        tmp = k - 1
        while v < 2 * n:
            s += wgh * pt.rangeSum(v, min(v * 2, 2 * n - 1))
            wgh += tmp
            tmp = max(tmp - 1, 0)
            v *= 2

        v = p[i]
        wgh = k * (k + 1) // 2
        tmp = k
        while v > 0:
            wgh -= tmp
            s += wgh * pt.rangeSum(v // 2 + 1, v)
            tmp = max(tmp - 1, 0)
            v //= 2

        pt.add(p[i], 1)

    print(s % 998244353)


def main():
    t = int(rd())
    for _ in range(t):
        solve()


if __name__ == ""__main__"":
    main()
","ret += self.tree[pos]
            pos &= pos - 1","pos = (pos >> 1) + self.tree[pos & ((1 << 1) - 1)]
            ret += self.tree[pos]"
"import sys; R = sys.stdin.readline
S = lambda: map(int,R().split())

def f(a):
    n = len(a)
    M = 1<<(n-1).bit_length()
    t = [0]*2*M
    r = 0
    for c in reversed(a):
        y,z = M,c+M-1
        while y<z:
            if not z&1: r += t[z]; z -= 1
            y //= 2; z //= 2
        if y==z: r += t[z]
        y = c+M
        while y: t[y] += 1; y //= 2
    return r
    
def g(a,k):
    n = len(a)
    M = 1<<(2*n-1).bit_length()
    t = [0]*2*M
    r = 0
    for i,c in enumerate(reversed(a)):
        d,j = c,0
        while d and j<k:
            y,z = M,d+M
            while y<z:
                if not z&1: {{completion}}
                y //= 2; z //= 2
            if y==z: r += t[z]*(k-j)
            d //= 2; j += 1
        d,j = 2*c,1
        while d<2*n and j<k:
            y,z = M,d+M-1
            while y<z:
                if not z&1: r += t[z]*(k-j); z -= 1
                y //= 2; z //= 2
            if y==z: r += t[z]*(k-j)
            d *= 2; j += 1
        r += i*(k-j)*(k-j+1)//2
        y = c+M
        while y: t[y] += 1; y //= 2
    return r

X = 998244353
for _ in range(int(R())):
    n,k = S()
    p = [*S()]
    q = [*S()]
    r = f(q)*n
    print((r+g(p,k))%X)",r += t[z]*(k-j); z -= 1,r += t[z]*(k-j); z -= 1
"from math import ceil,log2
def s(A,l,r,w):
    l+=w
    r+=w+1
    res=0
    while l<r:
        if l%2==1:
            res+=A[l]
            l+=1
        if r%2==1:
            res+=A[r-1]
            r-=1
        l//=2
        r//=2
    return res
for tc in range (int(input())):
    n,k=map(int,input().split())
    P=list(map(int,input().split()))
    Q=list(map(int,input().split()))
    res1=0
    w=2**ceil(log2(n))
    T=[0]*(2*w)
    for i in range (n):
        m=P[i]
        j=0
        while m>0:
            r=(m-1)//2
            m//=2
            l=(m+1)//2
            if j<k:
                res1+=s(T,l,r,w)*(k-j)*(k-j-1)//2
            j+=1
        m=P[i]
        j=0
        while m<2*n-1:
            l=m//2
            m*=2
            r=min(n-1,(m-1)//2)
            if j<=k:
                res1+=s(T,l,r,w)*(k*k-(k-j)*(k-j-1)//2)
            else:
                {{completion}}
            j+=1
        j=w+P[i]//2
        T[j]=1
        j//=2
        while j>0:
            T[j]=T[2*j]+T[2*j+1]
            j//=2
    res2=0
    w=2**ceil(log2(k))
    R=[0]*(2*w)
    for i in range (k):
        res2+=s(R,Q[i],k-1,w)
        j=w+Q[i]
        R[j]=1
        j//=2
        while j>0:
            R[j]=R[2*j]+R[2*j+1]
            j//=2
    res2*=n
    print((res1+res2)%998244353)","res1+=s(T,l,r,w)*k*k","res1+=s(T,l,r,w)*(k*k-(k-j)*(k-j-1)//2)"
"import sys;input=sys.stdin.readline;R=lambda:list(map(int,input().split()))
for _ in range(int(input())):
    n, k = R()
    a = R()
    b = R()
    mx = 0
    res = 0
    s = 0
    for i in range(n):
        s += a[i]
        mx = max(mx, b[i])
        if k - i - 1 >= 0: {{completion}}
    print(res)

        
","res = max(res, s + (k - i - 1) * mx)","
            s += b[i - k + mx - 1]
        if s - b[i] >= 0: 
            res = max(res, s - b[i])"
"import sys

t = int(sys.stdin.readline())
res = [0] * t
for i in range(t):
    n, k = map(int, sys.stdin.readline().split())
    a = list(map(int, sys.stdin.readline().split()))
    b = list(map(int, sys.stdin.readline().split()))
    ans = 0
    exp = 0
    curMaxOfB = b[0]
    for j in range(n):
        if j >= k:
            {{completion}}
        curMaxOfB = max(curMaxOfB, b[j])
        maxExp = a[j] + (k - j - 1) * curMaxOfB + exp
        if maxExp > ans:
            ans = maxExp
        exp += a[j]
    res[i] = ans
sys.stdout.write('\n'.join([str(elem) for elem in res]))",break,"ans = max(ans, exp + b[j])
            exp = 0
        else:
            exp += a[j]"
"from sys import stdin
input = stdin.readline
inp = lambda :  list(map(int,input().split()))
for _ in range(int(input())):
	n,k=inp()
	a=inp()
	b=inp()
	l=0
	s1,s2,s3=0,0,0
	li=[]
	for i in range(min(k,n)):
		{{completion}}
	print(max(li))","s1+=a[i]
		l=max(l,b[i])
		li.append(s1+(k-i-1)*l)","l+=a[i]
		li.append(l)
		l+=b[i]
		s1+=a[i]
		s2+=b[i]
		s3+=a[i]
	for i in range(min(k,n)):
		l+=a[i]
		li.append(l)
		l+=b[i]
		s1+=a[i]
		s2+=b[i]
		s3+=a[i]
	for i in range(min(k,n)):
		l+=a[i]
		li.append(l)
		l+=b[i]
		s1+=a[i]
		s2+=b[i]
		s3+=a[i]
	for i in range(min(k,n)):
		l+=a[i]
		li.append(l)"
"from sys import stdin
from collections import Counter
from heapq import heappush, heappop

T = int(stdin.readline())
for t in range(T):
    {{completion}}","n = int(stdin.readline())
    counts = Counter(stdin.readline()[:n])
    mc = max(counts.values())
    # print(f""{mc=}"")
    print(max(mc-(sum(counts.values())-mc), n%2))","n, s = map(int, stdin.readline().split())
    s = list(s)
    heap = []
    heappush(heap, (0, 0))
    ans = 0
    while heap:
        i, j = heappop(heap)
        if i == len(s):
            ans = j
            break
        if j == len(s):
            ans = i
            break
        if s[j] == s[j + 1]:
            s[j], s[j + 1] = s[j + 1], s[j]
            heappush(heap, (j + 1, i))
            heappush(heap, (i, j + 1))
    ans = min(ans, j - i + 1)
    print(ans)
<|/ file filename=Vlad.py source=github"
"import sys
input  = sys.stdin.readline

# div3 C
def main():
    # all testcases
    orda = ord('a')

    for _ in range(int(input())):
        n = int(input())
        s = input()
        cnt = [0] * 26

        for i in range(n):
            {{completion}}

        mx = max(cnt)

        print(max(2 * mx - n, n % 2))
        


if __name__ == '__main__':
    main()
",cnt[ord(s[i]) - orda] += 1,cnt[ord(s[i]) - orda] += 1
"#        ┏┓　　　┏┓+ +
#　　　┏┛┻━━━┛┻┓ + +
#　　　┃　　　　　　　┃ 　
#　　　┃　　　━　　　┃ ++ + + +
#　　 ████━████ ┃+
#　　　┃　　　　　　　┃ +
#　　　┃　　　┻　　　┃
#　　　┃　　　　　　　┃ + +
#　　　┗━┓　　　┏━┛
#　　　　　┃　　　┃　　　　　　　　　　　
#　　　　　┃　　　┃ + + + +
#　　　　　┃　　　┃　　　　　　　
#　　　　　┃　　　┃ + 　　　　
#　　　　　┃　　　┃
#　　　　　┃　　　┃　　+　　　　　　　　　
#　　　　　┃　 　　┗━━━┓ + +
#　　　　　┃ 　　　　　　　┣┓
#　　　　　┃ 　　　　　　　┏┛
#　　　　　┗┓┓┏━┳┓┏┛ + + + +
#　　　　　　┃┫┫　┃┫┫
#　　　　　　┗┻┛　┗┻┛+ + + +

import sys,math
# from collections import Counter
input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    s = input().strip()
    c = [0]*26
    for i in s:
        {{completion}}
    ans = max(c)
    print(max(n%2,ans*2-n))",c[ord(i)-ord('a')] += 1,"j = ord(i)-ord('a')
        if j<26:
            c[j] += 1
        else:
            c[j-26] += 1"
"from bisect import bisect_left, bisect_right
from itertools import combinations, permutations, product
from collections import defaultdict, Counter
from math import gcd
import sys

lol = lambda func=int: list(map(func, sys.stdin.readline().split()))
t = lol()[0]


def check(k):
    pq = [(0, 0)]
    for e in a:
        x = pq[-1][1] + e
        if x <= k:
            hmm = [(0, x)]
        else:
            hmm = []
        for p, q in pq:
            if q < x:
                if p + e <= k:
                    hmm.append((p + e, q))
                else:
                    {{completion}}
        pq = hmm
        if not pq:
            return False
    return True


for _ in range(t):
    n = lol()[0]
    a = lol()
    l, r = 0, sum(a)
    while l < r:
        mid = (l + r) // 2
        if check(mid):
            r = mid
        else:
            l = mid + 1
    print(l)
",break,"hmm.append((p, q))
            else:
                break
        pq = hmm
        if not pq:
            return False
    return True


for _ in range(t):
    n = lol()[0]
    a = lol()
    l, r = 0, sum(a)
    while l < r:
        mid = (l + r) // 2
        if check(mid):
            r = mid
        else:
            l = mid + 1
    print(l)
    l += 1


def check(k):
    pq = [(0, 0)]
    for e in a:
        x = pq[-1][1] + e
        if x <= k:
            hmm = [(0, x)]
        else:
            hmm = []
        for p, q in pq:
            if q"
"# -*- coding: utf-8 -*-

from sys import stdin
from collections import deque

n_tests = int(stdin.readline())
for test_id in range(n_tests):
    n = int(stdin.readline())
    nums = [int(w) for w in stdin.readline().split()]
    nums.append(0)
    cumsum = [0]
    for x in nums:
        cumsum.append(cumsum[-1] + x)
    
    def try_cost(C):
        min_blocks = [0] * (n + 2)
        prev_blocks = deque([0])
        l = 0
        for r in range(n + 1):
            while cumsum[l] + C < cumsum[r]:
                {{completion}}
            while prev_blocks and prev_blocks[0] < l:
                prev_blocks.popleft()
            min_blocks[r + 1] = min_blocks[prev_blocks[0]] + nums[r]
            while prev_blocks and min_blocks[prev_blocks[-1]] >= min_blocks[r + 1]:
                prev_blocks.pop()
            prev_blocks.append(r + 1)
        return min_blocks[-1] <= C

    l, r = max(nums) - 1, sum(nums)
    while l + 1 < r:
        mid = (l + r) // 2
        if try_cost(mid):
            r = mid
        else:
            l = mid
    print(r)
",l += 1,"l += 1
            min_blocks[r] = l
            prev_blocks.append(l)"
"# https://codeforces.com/contest/1918

import sys
from collections import deque

input = lambda: sys.stdin.readline().rstrip()  # faster!

dp = [0] * (10 ** 5 + 5)


def check(n, a, cost):
    j = 0
    sm = 0
    q = deque([0])
    for i in range(n):
        sm += a[i - 1]
        while sm > cost:
            j += 1
            sm -= a[j]
        while q and q[0] < j:
            q.popleft()
        if dp[q[0]] > cost:
            return False
        dp[i] = dp[q[0]] + a[i]
        while q and dp[q[-1]] >= dp[i]:
            q.pop()
        q.append(i)
    return dp[n - 1] <= cost


def solve_case():
    n = int(input())
    a = list(map(int, input().split()))

    low, high = min(a) - 1, sum(a)
    a = [0] + a + [0]
    n += 2

    while low + 1 < high:
        mid = (low + high) // 2
        if check(n, a, mid):
            high = mid
        else:
            {{completion}}
    return high


ans = []
for _ in range(int(input())):
    ans += [str(solve_case())]
print(""\n"".join(ans))
",low = mid,"low = mid + 1
    high += 2"
"from sys import stdin

def check(arr):
    n = len(arr)
    ballance = 0
    all_ballances = [0] * (n + 1)
    for i, a in enumerate(arr):
        if i % 2 == 0:
            ballance += a
        else:
            {{completion}}
        all_ballances[i] = ballance
    # all_ballances.sort()
    # return any(a == b for a, b in zip(all_ballances, all_ballances[1:]))
    return len(set(all_ballances)) <= n

for s in [*open(0)][2::2]:
    arr = list(map(int, s.split()))
    print(""YES"" if check(arr) else ""NO"")




# for s in [*open(0)][2::2]:
#     a=[0]
#     i=1
#     for x in s.split():
#         a+= a[-1] + int(x) * i
#         i=-i
#     print('YNEOS'[len(a)==len({*a})::2])











",ballance -= a,"ballance -= a
        all_ballances[i + 1] = ballance
        all_ballances[i] = ballance
    all_ballances.sort()
    return any(a == b for a, b in zip(all_ballances, all_ballances[1:]))

for s in [*open(0)][2::2]:
    arr = list(map(int, s.split()))
    print(""YES"" if check(arr) else ""NO"")




# for s in [*open(0)][2::2]:
#     a=[0]
#     i=1
#     for x in s.split():
#         a+= a[-1] + int(x) * i
#         i=-i
#     print('YNEOS'[len("
"#from io import BytesIO
from sys import stdin
from sys import stdout
#import os
#input=BytesIO(os.read(0,os.fstat(0).st_size)).readline
input=stdin.readline
print=stdout.write

t=int(input())
for _ in range(t):
    k=int(input())
    l=list(map(int,input().split()))
    d=[0]*(k+1)
    for h in range(k):
        d[h+1]=(d[h]+((h%2)*2-1)*l[h])
    d.sort()
    for i in range(k):
        if d[i]==d[i+1]:
            {{completion}}
    else:
        print('NO\n')","print('YES\n')
            break","s=0
            for j in range(i+1,k):
                s+=l[j]
            if s==d[i]:
                print('YES')
                break"
"def find_numbers(t, testcases):
    results = []
    for i in range(t):
        s = testcases[i]
        n = len(s)
        found = False
        for j in range(n // 2, 0, -1):
            a = s[:j]
            b = s[j:]
            if not (a[0] == '0' or b[0] == '0') and int(b) > int(a):
                {{completion}}
        if not found:
            results.append(-1)
    
    return results

t = int(input())
testcases = []
for _ in range(t):
    testcases.append(input())

output = find_numbers(t, testcases)
for result in output:
    if result == -1:
        print(-1)
    else:
        a, b = result
        print(a, b)
","results.append((a, b))
                found = True
                break","found = True
                results.append(int(a), int(b))
                break"
"import sys
def input(): return sys.stdin.readline().rstrip(""\r\n"")


try:
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
except:
    pass


def splitAndCheck(idx, t):
    l, r = t[:idx], t[idx:]

    if not l or not r or r[0] == '0':
        {{completion}}

    if int(l) >= int(r):
        return False
    return True


def solve():
    t = input()

    n = len(t)

    mid = n // 2

    while mid > -1 and not splitAndCheck(mid, t):
        mid -= 1

    if mid != -1:
        return ' '.join([t[:mid], t[mid:]])
    return -1


if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        print(solve())
",return False,"l = r
        r = t[:idx]
        idx = len(t)"
"for s in[*open(0)][1:]:
 b=m,k=[*map(s.count,'01')];i=0
 while k<b[0]or m<b[1]:{{completion}}
 print(i)",i+=1;b[int(s[~i])]-=1,"
  i+=1
  m+=k[i]
  k[i]=0
  k[i+b[0]]=1
 t=i
 while t>0:
  t=t//2
  print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print(t)
 print(i)
 print("
"t = int(input())
for task in range(t):
	s = input()
	n = len(s)
	l, u = [], []
	for i in range(n):
		if s[i].islower():
			if s[i] == 'b':
				if l: l.pop()
			else: l.append(i)
		else:
			if s[i] == 'B':
				if u: {{completion}}
			else: u.append(i)
	print(''.join(s[i] for i in sorted(l+u)))",u.pop(),u.pop()
"import sys 

t = int( input() )

for _ in range(t):
    word = sys.stdin.readline().rstrip('\n')

    deleted = set()
    lower, upper = [], []

    for i, w in enumerate(word):
        if w == 'b':
            if lower:
                deleted.add(lower.pop())
            deleted.add(i)

        elif w == 'B':
            if upper:
                {{completion}}
            deleted.add(i)

        elif w.islower():
            lower.append(i)

        else:
            upper.append(i)

    print(''.join(word[i] for i in range(len(word)) if i not in deleted))",deleted.add(upper.pop()),deleted.add(upper.pop())
"for _ in range((int)(input())) :
    s = input()
    is_capital = lambda x: x >= 'A' and x <= 'Z'
    capital = []
    small = []
    for index in range(len(s)) :
        if s[index] == 'b' :
            if len(small) > 0 : small.pop()
        elif s[index] == 'B' :
            if len(capital) > 0 : {{completion}}
        elif is_capital(s[index]) : capital.append(index)
        else : small.append(index)
    print("""".join(s[index] for index in sorted(capital + small)))
        ",capital.pop(),capital.pop()
"P = 998244353
N = 5005

def main():
    T = int(input())
    
    C = [[0] * N for _ in range(N)]
    
    # 初始化组合数
    C[0][0] = 1
    for i in range(1, N):
        for j in range(i + 1):
            C[i][j] = (C[i - 1][j] + (C[i - 1][j - 1] if j > 0 else 0)) % P

    for _ in range(T):
        n = int(input())
        p = list(map(int, input().split()))
        
        cnt = [0] * (n * 2 + 1)
        for i in range(n):
            cnt[p[i] - p[0]] += 1

        ans = 0

        def add(x, y):
            nonlocal ans
            x += y
            if x >= P:
                x -= P
            ans = x

        def get_ans(s):
            nonlocal ans
            tmp = cnt.copy()
            now = 0

            for i in range(p[n - 1]):
                now += 1
                tmp[now - p[0]] -= 1

            while now > s:
                now -= 1
                tmp[now - p[0]] -= 1

            for x in tmp:
                if x < 0:
                    {{completion}}

            ret = 1
            for i in range(p[n - 1] - p[0], 0, -1):
                if tmp[i - 1] < tmp[i] or tmp[i] < 0:
                    return 0
                if cnt[i] - 1 + (i == -p[0]) < 0:
                    continue
                ret = (ret * C[cnt[i] - 1 + (i == -p[0])][tmp[i]]) % P
                tmp[i - 1] -= tmp[i]

            if tmp[0]:
                ret = 0

            return ret

        for i in range(p[0], p[n - 1] + 1):
            add(ans, get_ans(i))

        print(ans)

if __name__ == ""__main__"":
    main()
",return 0,"x -= P
                tmp[x] += 1

            tmp[n - 1] -= tmp[n - p[0]]"
"import math
import heapq
import itertools
import bisect
import random
import time
from collections import deque
import sys
from cmath import exp,pi
from functools import cmp_to_key
input=sys.stdin.readline    

mod=998244353

fact=[1]*5005
rfact=[1]*5005

for i in range(1,5005):
    fact[i]=fact[i-1]*i%mod
    rfact[i]=pow(fact[i],mod-2,mod)

def C(n,r):
    if n<r or r<0:
        return 0
    return fact[n]*rfact[r]*rfact[n-r]%mod

cnt=[0]*10005

t=int(input())
for _ in range(t):
    n=int(input())
    arr=list(map(int,input().split()))+[0]
    arr.sort()
    m,M=arr[0],arr[-1]
    flag=0
    for i in range(n-1):
        if arr[i+1]-arr[i]>1:
            flag=1
            break
    if flag==1 or m*M>0:
        print(0)
    else:
        for i in range(m,M+1):
            cnt[i]=0
        for i in arr:
            cnt[i]+=1

        dp=[[[0,0] for _ in range(cnt[i+m]+1)] for i in range(M-m+1)]
        dp[0][cnt[m]-1][0]=1

        for i in range(1,M-m+1):
            p=i+m
            for j in range(cnt[p]+1):
                for j2 in range(cnt[p-1]+1):

                    if p<=0:
                        hole=cnt[p]-j
                        if hole==j2+2:
                            dp[i][j][0]=(dp[i][j][0]+
                                         dp[i-1][j2][0]*C(cnt[p]-1,hole-1))%mod
                        if hole==j2+1:
                            dp[i][j][1]=(dp[i][j][1]+
                                     dp[i-1][j2][0]*C(cnt[p]-1,hole-1)+
                                     dp[i-1][j2][1]*C(cnt[p]-1,hole-1))%mod


                    else:
                        hole=cnt[p]-j
                        if hole==j2+1:
                            {{completion}}
                        if hole==j2:
                            dp[i][j][1]=(dp[i][j][1]+
                                     dp[i-1][j2][0]*C(cnt[p]-1,hole-1)+
                                     dp[i-1][j2][1]*C(cnt[p]-1,hole-1))%mod

        ans=0
        for i in dp[-1][0]:
            ans=(ans+i)%mod
        print(ans)
                                     
            


        
","dp[i][j][0]=(dp[i][j][0]+
                                         dp[i-1][j2][0]*C(cnt[p]-1,hole-1))%mod","dp[i][j][0]=(dp[i][j][0]+
                                         dp[i-1][j2][0]*C(cnt[p]-1,hole-1))%mod"
"Narendra = 55555
Moduloo = 998244353

def ad(xender, yoda):
    xender += yoda
    if xender >= Moduloo:
        xender -= Moduloo
    return xender

def mul(xender, yoda):
    return (xender * yoda) % Moduloo

def fpow(xender, yoda=Moduloo-2):
    zeta = 1
    while yoda:
        if yoda & 1:
            {{completion}}
        xender = mul(xender, xender)
        yoda >>= 1
    return zeta

def getc(xender, yoda):
    if xender < yoda or yoda < 0:
        return 0
    return mul(fac[xender], mul(ifac[yoda], ifac[xender - yoda]))

def solve(palamu, qurua):
    surendra = 1
    xender = 0
    for i in range(nunu * 2 + 1):
        yoda = began[i] * 2 - xender - (i == palamu) - (i == qurua)
        if yoda < 0:
            return 0
        zeta = xender - (palamu < i) - (qurua < i)
        if zeta % 2:
            return 0
        zeta //= 2
        if began[i]:
            surendra = mul(surendra, getc(began[i] - 1, zeta))
        xender = yoda
    return surendra

try:
    Tasty = int(input())
    nunu = Narendra - 1
    fac = [0] * (Narendra + 1)
    ifac = [0] * (Narendra + 1)
    fac[0] = 1
    for i in range(1, nunu + 1):
        fac[i] = mul(fac[i - 1], i)
    ifac[nunu] = fpow(fac[nunu])
    for i in range(nunu, 0, -1):
        ifac[i - 1] = mul(ifac[i], i)

    for _ in range(Tasty):
        nunu = int(input())
        began = [0] * (nunu * 2 + 1)
        aloos = list(map(int, input().split()))
        began[nunu] += 1
        for i in range(1, nunu + 1):
            began[aloos[i-1] + nunu] += 1

        surendra = 0
        for i in range(nunu * 2 + 1):
            surendra = ad(surendra, solve(nunu, i))

        print(surendra)

except Exception as e:
    print(""Error:"", e)
","zeta = mul(zeta, xender)","zoda = xender
        else:
            zoda = mul(xender, xender)
        yoda >>= 1
        xender = zoda
    return xender

def solve(palamu, qurua):
    surendra = 1
    xender = 0
    for i in range(nunu * 2 + 1):
        yoda = began[i] * 2 - xender - (i == palamu) - (i == qurua)
        if yoda < 0:
            return 0
        zeta = xender - (palamu < i) - (qurua < i)
        if zeta % 2:
            return 0
        zeta //"
"import sys
input = sys.stdin.readline

for t in range(int(input())):
    n, k, d = map(int, input().split())
    a = list(map(int, input().split()))
    v = list(map(int, input().split()))
    c = sum([1 if a[i] == i+1 else 0 for i in range(n)])
    ret = c+(d-1)//2
    for i in range(min(d, 2*n+1)-1):
        for j in range(v[i%k]):
            if a[j] == j+1: c -= 1
            elif a[j] == j: {{completion}}
            a[j] += 1
        ret = max(ret, c+(d-i-2)//2)
    print(ret)",c += 1,c += 1
"import sys
input = sys.stdin.readline
t = int(input().strip())

def score(arr):
	eq = 0
	le = 0
	for i in range(len(arr)):
		eq += (arr[i] == i + 1)
		le += (arr[i] < i + 1)
	return eq, (le < eq or le == 0)

for line in range(t):
	n, k, d = [int(x) for x in input().strip().split()]
	a = [int(x) for x in input().strip().split()]
	v = [int(x) for x in input().strip().split()]

	max_score = score(a)[0] + ((d - 1) // 2)

	for i in range(min(2 * n, d - 1)):
		b = v[i % k]
		for j in range(b):
			{{completion}}
		eq, end = score(a)
		max_score = max(max_score, eq + ((d - i - 2) // 2))
		if end:
			break

	print(max_score)",a[j] += 1,a[j] += 1
"from sys import *
input = stdin.readline
inputlist = lambda: map(int, stdin.readline().split())

def solve():
    n,k,d = inputlist()
    array = list(inputlist())
    cycle = list(inputlist())

    def count(array):
        freq = 0
        for i in range(n):
            if array[i] == i+1:
                {{completion}}
        return freq

    moves = [0]+[count(array)]

    for i in range(min(d-1, 2*n+1)):
        for j in range(cycle[i%k]):
            array[j] += 1
        moves.append(count(array))

    maximum = 0
    for i in range(1, len(moves)):
        maximum = max(maximum, moves[i]+(d-i)//2)

    return maximum

for _ in range(int(input())):
    print(solve())",freq += 1,freq += 1
"import math
for s in[*open(0)][1:]:{{completion}}","a,b=map(int,s.split());print(math.lcm(a,b)*(b//a,1)[b%a>0])","
    a,b=map(int,s.split())
    if a<b<math.pow(10,9):
        x=math.pow(10,9)
        while x%a!=0 and x%b!=0:
            x=x//b
        if x%a!=0 and x%b!=0:
            x=x//a
        print(x)
<|/ file source=github |>"
"import sys
input = sys.stdin.readline

T = int(input())

for _ in range(T):
    N = int(input())
    A = list(map(int, input().split()))
    sum = 0
    cnt = [0] * 2
    ans = []
    for i, a in enumerate(A):
        {{completion}}
    print(*ans)
","sum += a
        cnt[a % 2] += 1
        ans.append(sum - cnt[1] // 3 - (cnt[1] % 3 == 1 and i > 0))","sum += a
        if sum % 2 == 0:
            cnt += [1, 1]
        else:
            cnt += [1, -1]
        if sum > N:
            ans.append(sum)
            break
        if sum < N:
            ans.append(sum)
            break
        if sum == N:
            ans.append(sum)
            break
        if sum > N:
            ans.append(sum)
            break
        if sum < N:
            ans.append(sum)
            break
        if sum == N:
            ans.append(sum)
            break
        if sum > N:
            ans.append(sum)
            break
        if sum < N:
            "
"import sys
input = sys.stdin.readline
for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    if n==1:
        {{completion}}
    prefix = [a[0]]
    odd = a[0]%2
    total = a[0]
    for i in range(1,n):
        total+=a[i]
        odd+=a[i]%2
        prefix.append(total-((odd//3) +(odd%3==1)))
    print(*prefix)

","print(a[0])
        continue","prefix = [a[0]]
        odd = a[0]%2
        total = a[0]
        for i in range(1,n):
            total+=a[i]
            odd+=a[i]%2
            prefix.append(total-((odd//3) +(odd%3==1)))
        print(*prefix)
    else:
        prefix = [a[0]]
        odd = a[0]%2
        total = a[0]
        for i in range(1,n):
            total+=a[i]
            odd+=a[i]%2
            prefix.append(total-((odd//3) +(odd%3==1)))
        prefix.sort()
        print(*prefix)
<|/ file source=github dstars=0 |>"
"import sys
input = sys.stdin.readline
t = int(input().strip())
for i in range(t):
	n = int(input())
	a = [int(x) for x in input().strip().split()]
	s = 0
	o = 0
	r = []
	for j, k in enumerate(a):
		{{completion}}
	print(' '.join(r))","s += k
		o += k % 2
		r.append(str((s - (o // 3) - (o % 3 == 1)) if j > 0 else k))","s += k
		if j == 0:
			o += k
		else:
			r.append(int(s/2))
			s = s - k*2
	r.append(int(s/2))
	r.append(o)"
"for s in[*open(0)][2::2]:{{completion}}
","t=sum(map(int,s.split()));print('YNEOS'[int(t**.5)**2<t::2])","
    s=s.split()
    s=int(s[0])
    ans=False
    for i in range(1,s+1):
        if i==1:
            ans=True
            break
        if i%2==0:
            ans=ans
        else:
            ans=ans
    if ans:
        print(""YES"")
    else:
        print(""NO"")
<|/ a dscore=0 |>"
for siri in[*open(0)][2::2]:{{completion}},"t=sum(map(int,siri.split()));print('YNEOS'[int(t**.5)**2<t::2])","
    siri=siri.replace(""\n"","""")
    siri=siri.replace(""\r"","""")
    siri=siri.replace(""\t"","""")
    siri=siri.replace(""  "","" "")
    siri=siri.replace(""  "","" "")
    siri=siri.replace(""  "","" "")
    siri=siri.replace(""  "","" "")
    siri=siri.replace(""  "","" "")
    siri=siri.replace(""  "","" "")
    siri=siri.replace(""  "","" "")
    siri=siri.replace(""  "","" "")
    siri=siri.replace("""
for p in[*open(0)][2::2]:{{completion}},print(abs(len(p)-2*p.count('+')-1)),"
    s=input()
    s=s.split()
    s=list(map(int,s))
    s=sorted(s)
    s=list(s)
    s=sum(s)
    print(abs(s))
<|/ file dstars=0 filename="
"for _ in range(int(input())):
    {{completion}}
    ","n = int(input())
    s = input()
    c = s.count('+')
    print(abs((n - c) - c))","s=input()
    s=s.split()
    s=list(map(int, s))
    s=sorted(s)
    s=list(s)
    s=sum(s)
    s=abs(s)"
for s in[*open(0)][2::2]:{{completion}},f=s.count;print(abs(f('+')-f('-'))),"
    s=s.strip()
    s=s.split()
    s=sorted(s)
    s=list(s)
    s=sum(s)
    print(s)
<|/ file ext=.py source=github |>"
"import sys

input = lambda: sys.stdin.readline().rstrip()

# k, n = map(int, input().split())

const = 10 ** 9 + 7
for t in range(int(input())):
    a, b, r = map(int, input().split())
    if a < b:
        a, b = b, a
    x = 0
    fl = False
    for i in range(len(bin(a)), -1, -1):
        temp = 1 << i
        if a & temp > b & temp:
            if fl and x + temp <= r:
                {{completion}}
            fl = True
    print((a ^ x) - (b ^ x))

",x += temp,"x += temp
            else:
                x = temp
                fl = True
        else:"
"import sys
input = sys.stdin.readline
write_output = sys.stdout.write

out = []
def the_solution():
    a, b, r = map(int, input().split())
    ans = 0
    x = 0
    for i in range(60, -1, -1):
        if ((a >> i) & 1) == ((b >> i) & 1):
            continue
        elif ans == 0:
            if ((a >> i) & 1) == 1:
                ans += (1 << i)
            else:
                ans -= (1 << i)
        elif ans > 0:
            if ((a >> i) & 1) == 1:
                if x + (1 << i) > r:
                    {{completion}}
                x += (1 << i)
            ans -= (1 << i)
        elif ans < 0:
            if ((b >> i) & 1) == 1:
                if x + (1 << i) > r:
                    ans -= (1 << i)
                    continue
                x += (1 << i)
            ans += (1 << i)
    out.append(abs(ans))

for _ in range(int(input())):
    the_solution()

write_output('\n'.join(map(str, out)))","ans += (1 << i)
                    continue","ans -= (1 << i)
                    continue
                x += (1 << i)
            else:"
"import sys
input=sys.stdin.readline
from math import log2
t=int(input())
for _ in range(t):
    a,b,r=map(int,input().split())
    if a<b:a,b=b,a
    if a==0:
        print(0)
        continue
    n=int(log2(a))
    flag=False
    ans=0
    for i in range(n,-1,-1):
        m=1<<i
        if not flag:
            if m&a !=0 and m&b ==0:
                {{completion}}
        
        if (m)&a !=0 and (m)&b == 0 and (ans|(m))<=r:
            ans|=(m)
    #print(ans,a^ans,b^ans)
    res=abs((a^ans) - (b^ans))
    sys.stdout.write(str(res)+'\n')





","flag=True
                continue","ans|=(m)
                flag=True
                continue
        if flag and m&a !=0 and m&b != 0:
            ans|=(m)
            flag=False
            continue
        if flag and m&a !=0 and m&b == 0:
            ans|=(m)
            flag=True
            continue"
"for n in[*open(0)][1:]:{{completion}}
",print('SFeicrosntd'[int(n)%3>0::2]),"
    if n%3==0:
        print ""First""
    else:
        print ""Second""
<|/ q dscore=0 |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| a tags=python,python-3."
"for _ in range(int(input())):
    if(int(input())%3==0):
        print(""Second"")
    else:
        {{completion}}","print(""First"")","
        print(""First"")
<|/ file dstars=0 "
"n=int(input())
for i in range(n):
    m=int(input())
    if m%3==0:
        print(""Second"")
    else:
        {{completion}}
","print(""First"")",
"for s in[*open(0)][2::2]:
 r=0;t=set()
 for x in s[:-1]:{{completion}}
 print(r)",t|={x};r+=len(t),"
  r+=len(x)
  t=t.union({x})
 t=t.union({s[:-1]})
 t=t.union({s[:-1]+s[0]})
 t=t.union({s[:-1]+s[1]})
 t=t.union({s[:-1]+s[2]})
 t=t.union({s[:-1]+s[3]})
 t=t.union({s[:-1]+s[4]})
 t=t.union({s[:-1]+s[5]})
 t=t.union({s[:-1]+s[6]})
 t=t.union({s[:-1]+s[7]})
 t=t.union({s[:-1]+s[8]})
 t=t.union({s[:-1]+s[9]})"
"for x in[*open(0)][1:]:
    {{completion}}","a, b = map(int, x.split());
    print(b//2*a)","y=x.split()
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y[0])
    z=int(y[1])
    y=int(y"
"masres=[]
for i in range(int(input())):
    {{completion}}
for x in masres:
    print(x)","n,m=map(int, input().split())
    masres.append((m//2)*n)","masres.append(input())
masres=list(map(int, masres))
masres=masres[::-1]
masres=masres[::2]
masres=masres[::-1]
masres=masres[::2]
masres=masres[::-1]
masres=masres[::2]
masres=masres[::-1]
masres=masres[::2]
masres=masres[::-1]
masres=masres[::2]
masres=masres[::-1]
masres=masres[::2]
masres=masres[::-1]
masres=masres[::2]
masres=masres[::-1]
mas"
"for s in[*open(0)][1:]:{{completion}}
","n,m=map(int,s.split());print(m//2*n)","
    s=s.split()
    n=int(s[0])
    m=int(s[1])
    stability=0
    for x in range(1,n+1):
        for y in range(1,m+1):
            if x==1 or y==1 or x==n or y==m:
                stability+=1
            else:
                stability=0
    if stability>stability:
        stability=stability-1
    print(stability)
<|/ file filename=Stability.py |>"
"for _ in range(int(input()) * 3):
    s = input()
    for t in ""ABC"":
        if t not in s:
            {{completion}}",print(t),"s += t
            break
    print(s)
<|/ file filename=LatinSquare.py "
"for _ in[0]*int(input()):
 for _ in'***':{{completion}}",print(({*'ABC'}-{*input()}or['']).pop()),"
  print(_)
<|/ file source=github filename=LatinSquare.py "
"t = int(input())

for _ in range(t):
    for i in range(3):
        row = input()
        
        if '?' in row:
            if ""A"" in row:
                if ""B"" in row:
                    print(""C"")
                else:
                    {{completion}}
            else:
                print(""A"")","print(""B"")","row = row.replace(""B"", ""C"")
                    
                    if ""C"" in row:
                        print(""C"")
                    else:
                        print(""A"")
                else:
                    print(""A"")
            else:
                print(""A"")
        else:
            if ""A"" in row:
                if ""B"" in row:
                    print(""C"")
                else:
                    row = row.replace(""A"", ""C"")
                    
                    if ""C"" in row:
                        print(""C"")
                    else:
                        print(""A"")
                else:
                    print(""A"")"
"import sys
input = sys.stdin.readline

for t in range(int(input())):
    n = int(input())
    a = map(int, input().split())
    ret = 0
    s = t = 10**10
    for e in a:
        if s >= e: s = e
        elif t >= e: {{completion}}
        else:
            ret += 1
            s = t
            t = e
    print(ret)
",t = e,t = e
"import math
import sys


def solute():
    n = int(sys.stdin.readline())
    a_list = list(map(int, sys.stdin.readline().split()))
    INF = 10**6
    curr = [INF] * 2

    res = 0
    for a in a_list:
        if a <= curr[0]:
            curr[0] = a
        elif a <= curr[1]:
            {{completion}}
        else:
            curr = [curr[1], a]
            res += 1
    print(res)


t = int(sys.stdin.readline())

for _ in range(t):
    solute()
",curr[1] = a,curr[1] = a
"from sys import stdin
def inp(): return stdin.readline().rstrip(""\r\n"")

t = int(inp())

for _ in range(t):
    n = int(inp())
    arr = [int(x) for x in inp().split()]
    p = 200001
    q = 200001
    ans = 0
    for i in arr:
        if i <= p:
            p = i
        elif i <= q:
            {{completion}}
        else:
            p = i
            ans += 1
        if p > q:
            p, q = q, p
    print(ans)
",q = i,q = i
"x=int(input())
for i in range(x):
    {{completion}}","a,b,c=map(int,input().split())
    print(a^b^c)","a,b,c=map(int,input().split())
    if a==b and a==c:
        print(a)
    elif a!=b and a!=c:
        print(a)
    elif b!=c and b!=a:
        print(b)
    elif c!=a and c!=b:
        print(c)
    else:
        print(""Error"")
<|/"
"for i in [[int(i) for i in input().split()] for j in range(int(input()))]:
    a, b, c = i[0], i[1], i[2]
    if a==b:
        print(c)
    elif a==c:
        {{completion}}
    else:
        print(a)",print(b),pass #do nothing
"m=int(input())
for i in range(m):
    x=input().split()
    for j in x :
       l=x.count(j)
       if l==1:
          {{completion}}",print(j),"print(j)
       else:
          break
<|/ file source=github dstars=1 "
"for _ in range(int(input())):
    {{completion}}","n = int(input())
    s = input()
    print(sum([s.count(chr(ord('A') + i)) >= i + 1 for i in range(26)]))","n, s = input().split()
    count=0
    for letter in s:
        if letter=='A':
            count+=1
    print(count)
<|/ file ext=.py source=github |>"
"tc = int(input())
 
for _ in range(tc):
    n= int(input())
    st = input()
    di = {}
    for ch in st:
        if di.get(ch):
            di[ch] +=1
        else:
            {{completion}}
    cnt= 0
    for key,value in di.items():
        if ord(key)%64 <= value:
            cnt+=1
            
    print(cnt)",di[ch] =1,"di[ch] = 1
    "
"t=int(input())
for _ in range(t):
    a=[0]*26
    n=int(input())
    s=input()
    for i in s:
        z = ord(i)-ord('A')
        a[z]+=1
    ans = 0
    for i in range(26):
        if a[i]>=(i+1):
            {{completion}}
    print(ans)
",ans+=1,ans += 1
for s in[*open(0)][1:]:{{completion}},"print(('Bob','Alice')[sum(map(int,s.split()))%2])","
    s=s.split()
    a,b=int(s[0]),int(s[1])
    if a==0 and b==1:
        print ""Alice""
    elif a==0 and b==0:
        print ""Bob""
    elif a==1 and b==2:
        print ""Alice""
    elif a==1 and b==1:
        print ""Bob""
    elif a==2 and b==2:
        print ""Alice""
    elif a==2 and b==1:
        print ""Bob""
    else:
        print ""Alice""
<|/ file ext=.py |>"
"


testcase = int(input())

for test in range(0, testcase):
    a, b = map(int, input().split())
    if (a+b)%2==0:
        print(""Bob"", end=""\n"")
    else:
        {{completion}}","print(""Alice"", end=""\n"")","coins = (a+b)/2
        print(""Alice"", end=""\n"")
        for i in range(1, coins+1):
            if (coins-i)%2==0:
                print(""Bob"", end=""\n"")
            else:
                print(""Alice"", end=""\n"")
        print(""Alice"", end=""\n"")
        print(""Bob"", end=""\n"")

<|/ file source=github "
for i in range(int(input())):{{completion}},"print(['Bob','Alice'][sum(list(map(int,input().split())))%2])","
    a,b = map(int, input().split())
    if a==0 and b==1:
        print(""Alice"")
    elif a==1 and b==0:
        print(""Bob"")
    else:
        print(""Alice"")
<|/ file source=github filename=AliceAndBob.py "
