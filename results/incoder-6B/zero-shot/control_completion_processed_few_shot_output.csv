eval_prompt,ground_truth,model_output
"n,q = map(int,input().split())
graph = [set() for _ in range(n)]
start = [0xffffffff]*n
for _ in range(q):
    i,j,x = map(int,input().split())
    i -= 1; j -= 1
    graph[i].add(j)
    graph[j].add(i)
    start[i] &= x
    start[j] &= x
for i in range(n):
    if {{completion}}:
        continue
    val = start[i]
    for j in graph[i]:
        val &= start[j]
    start[i] ^= val
print(*start)",i in graph[i],start[i] != 0xffffffff
"n,q = map(int,input().split())
graph = [set() for _ in range(n)]
start = [0xffffffff]*n
for _ in range(q):
    i,j,x = map(int,input().split())
    i -= 1; j -= 1
    graph[i].add(j)
    graph[j].add(i)
    start[i] &= x
    start[j] &= x
for i in range(n):
    if i in graph[i]:
        continue
    val = start[i]
    for {{completion}}:
        val &= start[j]
    start[i] ^= val
print(*start)",j in graph[i],"j in graph[i]:
        val |= start[j]
    start[i] ^= val
print(*start)
<|/ a tags=arrays,algorithm,sorting,python |>
<| a dscore=0 |>
<code>
n,q = map(int,input().split())
graph = [set() for _ in range(n)]
start = [0xffffffff]*n
for _ in range(q):
    i,j,x = map(int,input().split())
    i -= 1; j -= 1
    graph[i].add(j)
    graph[j].add(i)
    start[i] &= x
    start[j] &= x
for i in range(n):
    if i in graph[i]:
        continue
    val = start[i]"
"import sys

n, Q = list(map(int, sys.stdin.readline().strip().split()))
m = [0] * n
M = [2 ** 30 - 1] * n
L = [[] for i in range (0, n)]
for q in range (0, Q):
    i, j, x = list(map(int, sys.stdin.readline().strip().split()))
    i -= 1
    j -= 1
    M[i] &= x
    M[j] &= x
    L[i].append((j, x))
    L[j].append((i, x))
for i in range (0, n):
    for (j, x) in L[i]:
        if {{completion}}:
            m[i] |= x ^ M[j]
        else:
            m[i] = x
    M[i] = m[i]
print(*m)
",j != i,"M[i] > M[j]:
            m[i] |= x ^ M[j]
        elif M[i] < M[j]:
            m[i] = x
        elif M[i] == M[j] and m[i] > m[j]:
            m[i] |= x ^ M[j]
        elif M[i] == M[j] and m[i] < m[j]:
            m[i] = x
        elif M[i] == M[j] and m[i] == m[j] and m[i] < m[j]:
            m[i] |= x ^ M[j]
        elif M[i] == M[j] and m[i] > m[j]:
            m[i] |= x ^ M[j]
        elif M[i] == M[j] and m[i] < m[j]:
            m[i] = x"
"from sys import stdin, stdout
input, print = stdin.buffer.readline, stdout.write

n, T = [int(x) for x in input().split()]

ans = [(1<<31)-1] * n


from collections import defaultdict
R = defaultdict(list)

for _ in range(T):
    a,b, x = [int(_a) for _a in input().split()]
    a -= 1
    b -= 1
    a,b = min(a,b), max(a,b)
    ans[a] &=  x
    ans[b] &=  x
    R[a].append(b)
    R[b].append(a)



for i in range(len(ans)):
    for b in range(30,-1,-1):
        mask = 1 << b
        if mask & ans[i] == 0:
            continue
        can_remove = True
        for j in R[i]:
            if {{completion}}:
                can_remove = False
                break
        if can_remove:
            ans[i] ^= mask

print("" "".join(str(x)for x in ans)+""\n"")
",i == j or mask & ans[j] == 0,ans[i] & mask == ans[j] & mask
"n,q = map(int, input().split())
adj = [list() for i in range(n+1)]
val = [-1]*(n+1)
for _ in range(q):
    i,j,x=map(int, input().split())
    val[i] &= x
    val[j] &= x
    adj[i].append(j)
    adj[j].append(i)
# print(*val[1:], sep="" "")
# print(*adj, sep=""\n"")

for a in range(1, n+1):
    if val[a] == -1:
        val[a] = 0
        continue
    t = val[a]
    for b in adj[a]: 
        if {{completion}}:
            t = 0
            break
        t &= val[b]
    val[a] ^= t
    # print(*val[1:], sep="" "")

print(*val[1:], sep="" "")
        


    
",b == a,"t > val[b]:
            t = 0
            break
        t &= val[b]
    val[a] ^= t
    # print(*val[1:], sep="" "")

print(*val[1:], sep="" "")
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        "
"n, q = map(int, input().strip().split())

qs = [[] for _ in range(n)]
refers_self = [False for _ in range(n)]
for _ in range(q):
    i, j, x = map(int, input().strip().split())
    if i==j:
        refers_self[i-1] = True
    qs[i-1].append((j-1, x))
    qs[j-1].append((i-1, x))

a = []
for i in range(n):
    if qs[i]:
        ans = (2<<32) - 1
        for {{completion}}:
            ans = ans & x
        a.append(ans)
    else:
        a.append(0)


for i in range(n):
    if refers_self[i]:
        continue
    ans = (2<<32) - 1
    for j, x in qs[i]:
        ans = ans & a[j]

    a[i] = a[i] - (a[i]&ans)

print(*a)
","j, x in qs[i]","j, x in qs[i]:
            ans = ans | a[j]
        if ans != a[i]:
            a.append(ans)
            refers_self[i] = True
        ans = 0
        for j, x in qs[i]:
            ans = ans | x
        if ans != a[i]:
            a.append(ans)
            refers_self[i] = True
        ans = 0
        for j, x in qs[i]:
            ans = ans & a[j]
        if ans != a[i]:
            a.append(ans)
            refers_self[i] = True
        ans = 0
        for j, x in qs[i]:
            ans = ans & x
        if an"
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def update(i , t):

    global ans

    if(i + 1 < n and a[i] == a[i + 1]):
        ans += t * (i + 1)
    else:
        ans += t * (n - i) * (i + 1)

    return ans

def answer():

    global ans

    ans = 0
    for i in range(n):

        update(i , 1)


    for q in range(m):
        i , x = inp()
        i -= 1

        if{{completion}}:update(i - 1 , -1)
        update(i , -1)

        a[i] = x
        if(i >= 0):update(i - 1 , 1)
        update(i , 1)

        print(ans)

        
for T in range(1):

    n , m = inp()
    a = inp()
    
    answer()
",(i >= 0),"(i == 0):
            update(i , -1)
            update(i , -1)
        
        if(i == n):
            update(i , -1)
            update(i , -1)
        
        if(i == 0):
            update(i , -1)
            update(i , -1)
        
        if(i == n):
            update(i , -1)
            update(i , -1)
        
        if(i == 0):
            update(i , -1)
            update(i , -1)
        
        if(i == n):
            update(i , -1)
            update(i , -1)
        
        if(i == 0):
            update(i , -1)
            update(i , "
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def update(i , t):

    global ans

    if(i + 1 < n and a[i] == a[i + 1]):
        ans += t * (i + 1)
    else:
        ans += t * (n - i) * (i + 1)

    return ans

def answer():

    global ans

    ans = 0
    for i in range(n):

        update(i , 1)


    for q in range(m):
        i , x = inp()
        i -= 1

        if(i >= 0):update(i - 1 , -1)
        update(i , -1)

        a[i] = x
        if{{completion}}:update(i - 1 , 1)
        update(i , 1)

        print(ans)

        
for T in range(1):

    n , m = inp()
    a = inp()
    
    answer()
",(i >= 0),"(i + 1 < n and a[i] == a[i + 1]):
            ans += (i + 1) * (i + 1)
        else:
            ans += (n - i) * (n - i) * (n - i)

        
        i -= 1

        if(i >= 0):update(i - 1 , -1)
        update(i , -1)

        a[i] = x
        if(i + 1 < n and a[i] == a[i + 1]):
            ans += (i + 1) * (i + 1)
        else:
            ans += (n - i) * (n - i) * (n - i)

        i -= 1

        if(i >= 0):update(i - 1 , -1)
        update(i , -1)

        a[i] = x
        if(i + 1 < n and a[i] == a[i + 1]"
"import sys
input = sys.stdin.readline 

n, m = map(int, input().split())
a = list(map(int, input().split()))
a.insert(0, 0)
a.append(0)
ans = 0 
for {{completion}}:
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    
while(m):
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    m -= 1
","i in range(1, n + 1)","_ in range(m):
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import sys
input = sys.stdin.readline 

n, m = map(int, input().split())
a = list(map(int, input().split()))
a.insert(0, 0)
a.append(0)
ans = 0 
for i in range(1, n + 1):
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    
while{{completion}}:
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    m -= 1
",(m),"(m):
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    m -= 1
    
while(m):
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
"
"import time, sys

n, m = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]
t1 = time.time()
w = [(i+1)*(n-i-1) for i in range(n-1)]
c = sum([w[i] if a[i+1] != a[i] else 0 for i in range(n-1)])
for _ in range(m):
    ix, x = [int(i) for i in sys.stdin.readline().split()]
    ix -= 1
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += w[ix-1]
        elif {{completion}}:
            c -= w[ix-1]
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif a[ix] != a[ix+1] == x:
            c -= w[ix]
    a[ix] = x

    sys.stdout.write(str(c+(n*(n+1))//2) + '\n')",a[ix] != a[ix-1] == x,"a[ix] != a[ix-1] == x:
            c -= w[ix-1]
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif a[ix] != a[ix+1] == x:
            c -= w[ix]
    a[ix] = x

    sys.stdout.write(str(c+(n*(n+1))//2) + '\n')
t2 = time.time()
print(t2-t1)
<|/ file filename=Stanley_PC.py |>"
"import time, sys

n, m = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]
t1 = time.time()
w = [(i+1)*(n-i-1) for i in range(n-1)]
c = sum([w[i] if a[i+1] != a[i] else 0 for i in range(n-1)])
for _ in range(m):
    ix, x = [int(i) for i in sys.stdin.readline().split()]
    ix -= 1
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += w[ix-1]
        elif a[ix] != a[ix-1] == x:
            c -= w[ix-1]
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif {{completion}}:
            c -= w[ix]
    a[ix] = x

    sys.stdout.write(str(c+(n*(n+1))//2) + '\n')",a[ix] != a[ix+1] == x,"a[ix] != a[ix+1] == x:
            c -= w[ix]
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += w[ix-1]
        elif a[ix] != a[ix-1] == x:
            c -= w[ix-1]
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif a[ix] != a[ix+1] == x:
            c -= w[ix]
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += "
"import sys
import collections
inf=float('inf')
mod=10**5+7
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())
# for case in range(inpint()):
n,m=inpnm()
arr=inparr()
res=[1]
cnt=0
se=1
t=1
for i in range(1,n):
    if arr[i]==arr[i-1]:
        cnt+=1
        res.append(res[-1]+1)
    else:
 
        se+=1
        t=res[-1]
        res.append(res[-1]+se+cnt)
 
ans=sum(res)
for q in range(m):
 
    i,x=inpnm()
    i-=1
    if {{completion}}:
        ans-=i*(n-i)
    if i!=n-1 and arr[i+1]!=arr[i]:
        ans-=(i+1)*(n-i-1)
 
    arr[i]=x
 
    if i!=0 and arr[i-1]!=x:
        ans+=i*(n-i)
 
    if i!=n-1 and arr[i+1]!=x:
        ans+=(i+1)*(n-i-1)
    print(ans)",i!=0 and arr[i-1]!=arr[i],"i!=0 and arr[i-1]!=arr[i]:
        ans-=i*(n-i)
    if i!=n-1 and arr[i+1]!=arr[i]:
        ans-=(i+1)*(n-i-1)
 
    arr[i]=x
 
    if i!=0 and arr[i-1]!=x:
        ans+=i*(n-i)
 
    if i!=n-1 and arr[i+1]!=x:
        ans+=(i+1)*(n-i-1)
    print(ans)
    ans=1
    cnt=0
    se=1
    t=1
for i in range(1,n):
    if arr[i]==arr[i-1]:
        cnt+=1
        res.append(res"
"import sys
import collections
inf=float('inf')
mod=10**5+7
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())
# for case in range(inpint()):
n,m=inpnm()
arr=inparr()
res=[1]
cnt=0
se=1
t=1
for i in range(1,n):
    if arr[i]==arr[i-1]:
        cnt+=1
        res.append(res[-1]+1)
    else:
 
        se+=1
        t=res[-1]
        res.append(res[-1]+se+cnt)
 
ans=sum(res)
for q in range(m):
 
    i,x=inpnm()
    i-=1
    if i!=0 and arr[i-1]!=arr[i]:
        ans-=i*(n-i)
    if {{completion}}:
        ans-=(i+1)*(n-i-1)
 
    arr[i]=x
 
    if i!=0 and arr[i-1]!=x:
        ans+=i*(n-i)
 
    if i!=n-1 and arr[i+1]!=x:
        ans+=(i+1)*(n-i-1)
    print(ans)",i!=n-1 and arr[i+1]!=arr[i],"i!=n-1 and arr[i+1]!=arr[i]:
        ans-=(i+1)*(n-i-1)
 
    arr[i]=x
 
    if i!=0 and arr[i-1]!=x:
        ans+=i*(n-i)
 
    if i!=n-1 and arr[i+1]!=x:
        ans+=(i+1)*(n-i-1)
    print(ans)
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
"
"def update_awesomeness(arr, i, x, curr_aws):
    left_edit = (x != arr[i - 1]) - (arr[i] != arr[i - 1]) if i != 0 else 0
    right_edit = (x != arr[i + 1]) - (arr[i] != arr[i + 1]) if i != n - 1 else 0
    arr[i] = x
    return curr_aws + left_edit * i * (n - i) + right_edit * (i + 1) * (n - i - 1)


INPUT = [*open(0)]

n, m = map(int, INPUT[0].split())
arr = list(map(int, INPUT[1].split()))
tar = [0] * n
aws = (n * (n + 1)) // 2

for {{completion}}:
    aws = update_awesomeness(tar, i, x, aws)

for line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i - 1, x, aws)
    print(aws)","i, x in enumerate(arr)","line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i, x, aws)
    print(aws)

for line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i, x, aws)
    print(aws)

for line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i, x, aws)
    print(aws)

for line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_aweso"
"def update_awesomeness(arr, i, x, curr_aws):
    left_edit = (x != arr[i - 1]) - (arr[i] != arr[i - 1]) if i != 0 else 0
    right_edit = (x != arr[i + 1]) - (arr[i] != arr[i + 1]) if i != n - 1 else 0
    arr[i] = x
    return curr_aws + left_edit * i * (n - i) + right_edit * (i + 1) * (n - i - 1)


INPUT = [*open(0)]

n, m = map(int, INPUT[0].split())
arr = list(map(int, INPUT[1].split()))
tar = [0] * n
aws = (n * (n + 1)) // 2

for i, x in enumerate(arr):
    aws = update_awesomeness(tar, i, x, aws)

for {{completion}}:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i - 1, x, aws)
    print(aws)",line in INPUT[2:],line in INPUT
"""""""
author: Manoj
inp_start
5 5
1 2 3 4 5
3 2
4 2
3 1
2 1
2 2

inp_end
""""""
n, m = list(map(int, input().split()))
li = list(map(int, input().split()))
ans = int((n*(n+1))/2)

for i in range(1, n):
	if li[i]!=li[i-1]:
		ans += i*(n-i) 

al = []
for tc in range(m):
	i, x = list(map(int, input().split()))
	i -= 1
	if i>0:
		if {{completion}}:
			ans-=i*(n-i)
		if x!=li[i-1]:
			ans+=i*(n-i)
	if i+1<n:
		if li[i]!=li[i+1]:
			ans-=(i+1)*(n-i-1)
		if x!=li[i+1]:
			ans+=(i+1)*(n-i-1)
			
	li[i]=x
	al.append(ans)
	
print(*al)
	
	",li[i]!=li[i-1],li[i]!=li[i-1]
"""""""
author: Manoj
inp_start
5 5
1 2 3 4 5
3 2
4 2
3 1
2 1
2 2

inp_end
""""""
n, m = list(map(int, input().split()))
li = list(map(int, input().split()))
ans = int((n*(n+1))/2)

for i in range(1, n):
	if li[i]!=li[i-1]:
		ans += i*(n-i) 

al = []
for tc in range(m):
	i, x = list(map(int, input().split()))
	i -= 1
	if i>0:
		if li[i]!=li[i-1]:
			ans-=i*(n-i)
		if {{completion}}:
			ans+=i*(n-i)
	if i+1<n:
		if li[i]!=li[i+1]:
			ans-=(i+1)*(n-i-1)
		if x!=li[i+1]:
			ans+=(i+1)*(n-i-1)
			
	li[i]=x
	al.append(ans)
	
print(*al)
	
	",x!=li[i-1],x!=li[i-1]
"import sys
input=lambda:sys.stdin.readline().rstrip()
n,q=map(int,input().split())
arr=[0]+[*map(int,input().split())]+[0]
awe=0
awr=[0]*(n+1)
for i in range(1,n+1):
    if {{completion}}:
        awr[i]+=awr[i-1]+(i-1)
    else:
        awr[i]+=awr[i-1]
    awr[i]+=1
awe=sum(awr)
for _ in range(q):
    i,x=map(int,input().split())
    lprev=arr[i]!=arr[i-1]
    rprev=arr[i]!=arr[i+1]
    arr[i]=x
    laftr=arr[i]!=arr[i-1]
    raftr=arr[i]!=arr[i+1]
    dl=laftr-lprev
    dr=raftr-rprev
    awe+=dl*(i-1)*(n-i+1)
    awe+=dr*(i)*(n-i)
    print(awe)",arr[i]!=arr[i-1],i==n
"



import sys
input=sys.stdin.readline #文字列入力はするな！！



########################################
from heapq import heappush, heappop
B=10**5+10
def dijkstra( G, dist, INF=10**11):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    G[v] = [(nod, cost)]:
        頂点vから遷移可能な頂点(nod)とそのコスト(cost)
    s: 始点の頂点""""""

    N=len(dist)
    hp=[]
    for i in range(N):
        heappush(hp,dist[i]*B+i)
    while hp:
        cv=heappop(hp)
        c, v = cv//B,cv%B
        if dist[v] < c:
            continue
        for u, cost in G[v]:
            if {{completion}}:
                dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)
    return dist
##################################################




#########################################
from collections import deque
class Convex_Hull_Trick():

    #https://tjkendev.github.io/procon-library/python/convex_hull_trick/deque.html
    #追加する傾きが単調かつqueryのxが単調
    #単調性なしが良いならこちらへ(queryのxは先読み) https://judge.yosupo.jp/submission/30579

    def __init__(self):
        self.deq=deque()
    def check(self,f1, f2, f3):
        return (f2[0] - f1[0]) * (f3[1] - f2[1]) >= (f2[1] - f1[1]) * (f3[0] - f2[0])
    def f(self,f1, x):
        return f1[0] * x + f1[1]

    # add f_i(x) = a*x + b
    def add_line(self,a, b):
        f1 = (a, b)
        while len(self.deq) >= 2 and self.check(self.deq[-2], self.deq[-1], f1):
            self.deq.pop()
        self.deq.append(f1)

    # min f_i(x)
    def query(self,x):
        while len(self.deq) >= 2 and self.f(self.deq[0], x) >= self.f(self.deq[1], x):
            self.deq.popleft()
        return self.f(self.deq[0], x)

##################################


n,m,k=map(int,input().split())
root=[[] for i in range(n+2)]
for i in range(m):
    a,b,c=map(int,input().split())
    root[a].append((b,c))
    root[b].append((a,c))
dp=[10**11]*(n+1)
dp[1]=0
dp=dijkstra(root,dp)
for iii in range(k):
    newdp=[10**11]*(n+1)
    cht=Convex_Hull_Trick()
    for i in range(1,n+1):
        cht.add_line(-2*i,dp[i]+i**2)
    for i in range(1,n+1):
        newdp[i]=cht.query(i)+i**2


    dp=newdp[:]
    dp=dijkstra(root,dp)
print(*dp[1:])




",dist[v] + cost < dist[u],dist[u] > INF
"



import sys
input=sys.stdin.readline #文字列入力はするな！！



########################################
from heapq import heappush, heappop
B=10**5+10
def dijkstra( G, dist, INF=10**11):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    G[v] = [(nod, cost)]:
        頂点vから遷移可能な頂点(nod)とそのコスト(cost)
    s: 始点の頂点""""""

    N=len(dist)
    hp=[]
    for i in range(N):
        heappush(hp,dist[i]*B+i)
    while hp:
        cv=heappop(hp)
        c, v = cv//B,cv%B
        if dist[v] < c:
            continue
        for {{completion}}:
            if dist[v] + cost < dist[u]:
                dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)
    return dist
##################################################




#########################################
from collections import deque
class Convex_Hull_Trick():

    #https://tjkendev.github.io/procon-library/python/convex_hull_trick/deque.html
    #追加する傾きが単調かつqueryのxが単調
    #単調性なしが良いならこちらへ(queryのxは先読み) https://judge.yosupo.jp/submission/30579

    def __init__(self):
        self.deq=deque()
    def check(self,f1, f2, f3):
        return (f2[0] - f1[0]) * (f3[1] - f2[1]) >= (f2[1] - f1[1]) * (f3[0] - f2[0])
    def f(self,f1, x):
        return f1[0] * x + f1[1]

    # add f_i(x) = a*x + b
    def add_line(self,a, b):
        f1 = (a, b)
        while len(self.deq) >= 2 and self.check(self.deq[-2], self.deq[-1], f1):
            self.deq.pop()
        self.deq.append(f1)

    # min f_i(x)
    def query(self,x):
        while len(self.deq) >= 2 and self.f(self.deq[0], x) >= self.f(self.deq[1], x):
            self.deq.popleft()
        return self.f(self.deq[0], x)

##################################


n,m,k=map(int,input().split())
root=[[] for i in range(n+2)]
for i in range(m):
    a,b,c=map(int,input().split())
    root[a].append((b,c))
    root[b].append((a,c))
dp=[10**11]*(n+1)
dp[1]=0
dp=dijkstra(root,dp)
for iii in range(k):
    newdp=[10**11]*(n+1)
    cht=Convex_Hull_Trick()
    for i in range(1,n+1):
        cht.add_line(-2*i,dp[i]+i**2)
    for i in range(1,n+1):
        newdp[i]=cht.query(i)+i**2


    dp=newdp[:]
    dp=dijkstra(root,dp)
print(*dp[1:])




","u, cost in G[v]","u, cost in G[v]:
            if dist[u] > dist[v] + cost:
                dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)
    return dist
##################################################




#########################################
from heapq import heappush, heappop
B=10**5+10
def dijkstra( G, dist, INF=10**11):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    G[v] = "
"n,k=map(int,input().split())
l=list(map(int,input().split()))

ans=-2
b=l.count(0)

for y in range(n):
	a=l[y:]+l[:y]
	ind=[]
	s=0
	
	for i in range(n):
		if {{completion}}:
			ind+=[i]
			a[i]=k
		s+=a[i]
	
	while s>0 and len(ind)>0:
		a[ind[-1]]=max(k-s,-k)
		s+=(-k+a[ind[-1]])
		ind=ind[:-1]
	
	s=0
	f=0
	for i in range(n):
		s+=a[i]
		f=max(f,s)
	
	if sum(a)==0:
		ans=max(ans,f)
	

print(ans+1)
",a[i]==0,"a[i]==0:
			ind+=[i]
			a[i]=k
		s+=a[i]
	
	while s>0 and len(ind)>0:
		a[ind[-1]]=max(k-s,-k)
		s+=(-k+a[ind[-1]])
		ind=ind[:-1]
	
	s=0
	f=0
	for i in range(n):
		s+=a[i]
		f=max(f,s)
	
	if sum(a)==0:
		ans=max(ans,f)
	

print(ans+1)
'''
n,k=map(int,input().split())
l=list(map(int,input().split()))

ans="
"R=lambda:map(int,input().split())
n,k=R();n+=1
a=[0]+[*R()]

p0,p=[0]*n,[0]*n
for i in range(1,n):
  p0[i]=p0[i-1]+int(a[i]==0)
  p[i]=p[i-1]+a[i]
s=p[-1]

if p0[-1]*k<abs(s):
  res=-1
else:
  res=0
  for i in range(n):
    for {{completion}}:
      l0=p0[j]-p0[i];r0=p0[-1]-l0
      l,r=max(-l0*k, -s-r0*k),min(l0*k, -s+r0*k)
      v=p[j]-p[i]
      res=max(res, 1+abs(v+l), 1+abs(v+r))
print(res)","j in range(i+1,n)","j in range(i+1,n):
      if a[i]==0: continue
      if p[j]-p[i]>k*k:
        continue
      if p[j]-p[i]<-k*k:
        continue
      if p[j]-p[i]==k*k:
        continue
      if p[j]-p[i]==-k*k:
        continue
      if p[j]-p[i]>k*k and p[j]-p[i]<-k*k:
        continue
      if p[j]-p[i]<-k*k and p[j]-p[i]>k*k:
        continue
      if p[j]-p[i]==k*k and p[j]-p[i]==-k*k:
        continue
      if p[j]-p[i]=="
"import sys
input = sys.stdin.readline

def ProGamerMove():
	n, k = map(int, input().split())
	a = list(map(int, input().split()))
	zeros = a.count(0)
	sm = sum(a)
	s1, s2 = 0, 0
	c1, c2 = 0, 0
	res = -2
	def intersect(m1, b1, m2, b2):
		l1, r1 = m1 - b1 * k, m1 + b1 * k
		l2, r2 = m2 - b2 * k, m2 + b2 * k
		return not (r1 < l2 or r2 < l1)
	for l in range(0, n + 1):
		s2, c2 = 0, 0
		for r in range(0, n + 1):
			if l <= r:
				b1, b2, b3 = c1, c2 - c1, zeros - c2
				m1, m2, m3 = s1, s2 - s1, sm - s2
				# b1 + b3 == -b2
				# min b1, b3
				if {{completion}}: continue
				r1 = max(m1 + m3 - (b1 + b3) * k, -m2 - b2 * k)
				r2 = min(m1 + m3 + (b1 + b3) * k, -m2 + b2 * k)
				res = max(res, abs(r1), abs(r2))
			if r < n:
				s2 += a[r]
				c2 += a[r] == 0
		if l < n:
			s1 += a[l]
			c1 += a[l] == 0
	print(res + 1)

n = 1
#n = int(input())
for _ in range(0, n): ProGamerMove()
","not intersect(m1 + m3, b1 + b3, -m2, b2)","b1 + b3 < 0:
					b1, b3 = -b1, -b3
				# min m1, m3
				if m1 + m3 < 0:
					m1, m3 = -m1, -m2
				# b1 + b3 <= 0
				# m1 + m3 <= 0
				if b1 + b3 <= 0 or m1 + m3 <= 0: continue
				# b1 + b3 >= k
				# m1 + m3 >= k
				if b1 + b3 > k: continue
				if m1 + m3 > k: continue
				# b1 + b3 <= k
				# m1 + m3 <= k
				if b1 + b3 <= k and "
"n, k = map(int, input().split())
A = list(map(int, input().split()))

ans = 0
for i in range(n):
    C = [0]*n
    for j in range(n-1, -1, -1):
        if A[j] == 0:
            C[j] = 1
        if j+1 < n:
            C[j] += C[j+1]
    B = A.copy()
    s = sum(B)
    flag = True
    for j in range(n):
        if B[j] == 0:
            if {{completion}}:
                x = C[j+1]
            else:
                x = 0
            B[j] = min(k, x*k-s)
            if B[j] < -k:
                flag = False
            s += B[j]
    if flag:
        pos = 0
        mn = 0
        mx = 0
        for j in range(n):
            pos += B[j]
            mn = min(mn, pos)
            mx = max(mx, pos)
        if pos == 0:
            ans = max(ans, mx-mn+1)
    A = A[1:]+A[0:1]

if ans != 0:
    print(ans)
else:
    print(-1)
",j+1 < n,"j+1 < n:
                B[j+1] = 0
            else:
                B[j+1] = s
        else:
            if j+1 < n:
                x = C[j+1]
            else:
                x = 0
            B[j] = min(k, x*k-s)
            if B[j] < -k:
                flag = False
            s += B[j]
    if flag:
        pos = 0
        mn = 0
        mx = 0
        for j in range(n):
            pos += B[j]
            mn = min(mn, pos)
            mx = max(mx, pos)
        if pos == 0:
            ans = max(ans, mx-mn+1)
    A = A[1:]+A[0:1]

if ans != 0:"
"n, k = map(int, input().split())
A = list(map(int, input().split()))

ans = 0
for i in range(n):
    C = [0]*n
    for j in range(n-1, -1, -1):
        if A[j] == 0:
            C[j] = 1
        if j+1 < n:
            C[j] += C[j+1]
    B = A.copy()
    s = sum(B)
    flag = True
    for j in range(n):
        if B[j] == 0:
            if j+1 < n:
                x = C[j+1]
            else:
                x = 0
            B[j] = min(k, x*k-s)
            if {{completion}}:
                flag = False
            s += B[j]
    if flag:
        pos = 0
        mn = 0
        mx = 0
        for j in range(n):
            pos += B[j]
            mn = min(mn, pos)
            mx = max(mx, pos)
        if pos == 0:
            ans = max(ans, mx-mn+1)
    A = A[1:]+A[0:1]

if ans != 0:
    print(ans)
else:
    print(-1)
",B[j] < -k,"B[j] > s:
                flag = False
            s += B[j]
        else:
            if j+1 < n:
                x = C[j+1]
            else:
                x = 0
            B[j] = max(k, x*k-s)
            if B[j] < s:
                flag = False
            s += B[j]
    if flag:
        pos = 0
        mn = 0
        mx = 0
        for j in range(n):
            pos += B[j]
            mn = min(mn, pos)
            mx = max(mx, pos)
        if pos == 0:
            ans = max(ans, mx-mn+1)
    A = A[1:]+A[0:1]

if ans != 0:
    print(ans)
else:
    print("
"MOD = 998244353
TRANS = [6, 3, 7, 4, 1, 0]
 
s = input().strip()
dp = [0] * 7 + [1]
for c in map(int, s):
    dp1 = [0] * 8
    for i in range(8):
        for k in TRANS:
            if c:
                dp1[k & i] += dp[i]
            elif {{completion}}:
                dp1[i] += dp[i]
    dp = [x % MOD for x in dp1]
n = int(s, base=2) + 1
print((n**3 + 3 * n**2 - n - 3 * sum(dp)) % MOD)",(k & i) == 0,"not c:
                dp1[k & i] -= dp[i]
            else:
                dp1[k & i] = 0
        for i in range(8):
            if dp1[i] > MOD"
"MOD=998244353
TRANS=[6,3,7,4,1,0]
s=input().strip()
dp=[0]*7+[1]
for c in map(int,s):
    dp1=[0]*8
    for i in range(8):
        for k in TRANS:
            if c:
                dp1[k&i]+=dp[i]
            elif{{completion}}:
                dp1[i]+=dp[i]
    dp=[x%MOD for x in dp1]
n=int(s,base=2)+1
print((n**3+3*n**2-n-3*sum(dp))%MOD)",(k&i)==0,"(i):
                dp1[k&i]+=dp[i]
            else:
                dp1[k&i]+=dp[i]
    for i in range(8):
        if dp1[i]!=dp[i]:
            for j in range(8):
                dp1[j&i]+=dp[i]
    for i in range(8):
        if dp1[i]!=dp[i]:
            for j in range(8):
                dp1[j&i]+=dp[i]
    for i in range(8):
        if dp1[i]!=dp[i]:
            for j in range(8):
                dp1[j&i]+=dp[i]
    for i in range(8):
        if dp1[i]!=dp[i]:
            for j in range(8):
                dp1[j"
"I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if {{completion}}:z=0;break
    if p==0:zero=True
    if p<0:z=0;break
  print(['NO','YES'][zero and z])",zero and p>0,"p==1:z=1
    if p<0:z=0;break
  print(['NO','YES'][zero and z])
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if p==1:z=1
    if p<0:z=0;break
  print(['NO','YES'][zero and z])
</code>
<|/ a tags=python |>
<| c |>
Please add some explanation to your answer such that others can learn "
"I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if zero and p>0:z=0;break
    if {{completion}}:zero=True
    if p<0:z=0;break
  print(['NO','YES'][zero and z])",p==0,"p<0:z=0;break
  print(['NO','YES'][zero and z])
<|/ a |>
<| a tags=arrays,algorithm,python,dynamic-programming |>
<code>
I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if zero and p>0:z=0;break
    if p<0:z=0;break
  print(['NO','YES'][zero and z])
</code>
<|/ a dscore=0 |>
<| c |>
Please explain your answer
<|/ c |>
<|"
"import sys
input = lambda : sys.stdin.readline().rstrip()

dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]


def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    if sum(arr)!=0:
        return 0

    psum = 0
    f = 0
    
    for i in range(len(arr)):
        psum += arr[i]
        if psum < 0:
            return 0
        if psum==0:
            f = 1
        elif {{completion}}:
            return 0
        
    return 1


for __ in range(int(input())):
    print('Yes' if solve() else 'No')",f,"psum > 0:
            f = 0
        if psum == 0 and f==0:
            return 1
        if psum > 0 and f==1:
            return 1
        if psum < 0 and f==-1:
            return 1
        if psum == 0 and f==-1:
            return 1
        if psum > 0 and f==1:
            return 1
        if psum < 0 and f==-1:
            return 1
        if psum == 0 and f==1:
            return 1
        if psum > 0 and f==-1:
            return 1
        if psum < 0 and f==1:
            return 1
        if psum == 0 and f==-1:
            return 1
        if p"
"for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    tot = a[0]

    for i in range(1, n):
        if tot < 0:
            break
        elif tot == 0:
            if {{completion}}:
                break
        else:
            tot += a[i]
    else:
        if tot == 0:
            print(""Yes"")
            continue

    print(""No"")
",a[i] != 0,"a[i] < 0:
                tot += a[i]
            elif a[i] > 0:
                tot -= a[i]
            elif a[i] == a[i-1]"
"from sys import stdin

t = int(stdin.readline())
for h in range(t):
    n = int(stdin.readline())
    a = list(map(int,stdin.readline().split(' ')))
    b = 0
    v = True
    for i in range(n):
        b += a[i]
        if b<0:
            v = False
            break
        elif b==0:
            for j in range(i+1,n):
                if {{completion}}:
                    v = False
                    break
            break
    if v and sum(a) == 0:
        print('YES')
    else:
        print('NO')",a[j] != 0,"a[i]>a[j]:
                    v = False
                    break
                elif a[i]<a[j]:
                    v = True
                    break
                elif a[j]==a[i]:
                    v = False
                    break
                else:
                    v = True
                    break
        else:
            for j in range(i+1,n):
                if a[i]>a[j]:
                    v = False
                    break
                elif a[i]<a[j]:
                    v = True
                    break
                elif a[j]==a[i]:
                    v = False
                    break
                else:
                    v = True
                    break
            if v and sum(a) == 0:
                print('YES')
            else:
                print('NO')
<|/ a dscore=0 |>
<| a tags=python"
"for _ in [0]*int(input()):
    input()
    n = list(map(int,input().split()))
    s,f,m = 0,0,0
    for i in n:
        s+=i
        if {{completion}}:m = 1;break
        if s==0:f=1
        if f and s>0:m=1;break
    print(""YNEOS""[(m or not f)::2])",s<0,"s==2:f=0
        if f and s>2:m=0
        if f and s<2:m=1;break
        if f and s==1:m=0
        if f and s==-1:m=1
        if f and s==-2"
"for _ in [0]*int(input()):
    input()
    n = list(map(int,input().split()))
    s,f,m = 0,0,0
    for i in n:
        s+=i
        if s<0:m = 1;break
        if {{completion}}:f=1
        if f and s>0:m=1;break
    print(""YNEOS""[(m or not f)::2])",s==0,"s==0 and f==0:f=1
        if s==0 and f==1:f=0
        if s==0 and f==-1:f=1
        if s==0 and f==-1:f=-1
        if s==0 and f==1:f=-1
        if s==0 and f==-1:f=-1
        if s==0 and f==1:f=-1
        if s==0 and f==-1:f=1
        if s==0 and f==-1:f=1
        if s==0 and f==1:f=1
        if s==0 and f==-1:f=1
        if s==0 and f==1:f=1
        if s==0 and f==-1:f=1
"
"if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        n = int(input())
        a = [int(i) for i in input().split()]

        x = a[0]

        ok = True
        for v in a[1:]:
            if {{completion}}:
                ok = False
                break
            if x == 0 and v != 0:
                ok = False
                break
            x += v

        print(""yes"" if ok and x == 0 else ""no"")
",x < 0,"x == 0 and v != 0:
                ok = False
                break
            if x == 0 and v == 0:
                ok = False
                break
            if x == 0 and v < 0:
                ok = False
                break
            if x == 0 and v > 0:
                ok = False
                break
            if x == 0 and v == -1:
                ok = False
                break
            if x == 0 and v == 1:
                ok = False
                break
            if x == 0 and v == -2"
"if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        n = int(input())
        a = [int(i) for i in input().split()]

        x = a[0]

        ok = True
        for v in a[1:]:
            if x < 0:
                ok = False
                break
            if {{completion}}:
                ok = False
                break
            x += v

        print(""yes"" if ok and x == 0 else ""no"")
",x == 0 and v != 0,"x == 0 and v < 0:
                ok = False
                break
            if x == 0 and v > 0:
                ok = False
                break
            if x == 0 and v == 0:
                ok = False
                break
            if x != 0 and v == 0:
                ok = False
                break
            if x != 0 and v > 0:
                ok = False
                break
            if x != 0 and v < 0:
                ok = False
                break
            if x != 0 and v == 0:
                ok = False
                break
            if x != 0 and v < 0:
                ok = False
                break
            if x != 0 and v > 0:
                ok = False
                break
            if x != 0 and v == 0:
                ok = False
                break
            if x "
"input = __import__('sys').stdin.readline


def solve():
    n = int(input())
    allzeros = False
    total = 0
    for x in map(int, input().split()):
        total += x
        if {{completion}}:
            print('No')
            return
        allzeros = allzeros or total == 0

    print('YES' if total == 0 else 'NO')


for _ in range(int(input())):
    solve()",total < 0 or total != 0 and allzeros,"x == 0 and not allzeros:
            print('Yes')
            return
        if x == 0 and allzeros:
            print('No')
            return
        allzeros = allzeros or total == 0

    print('YES' if total == 0 else 'NO')


for _ in range(int(input())):
    solve()
'''
    
def solve():
    n = int(input())
    allzeros = False
    total = 0
    for x in map(int, input().split()):
        total += x
        if x == 0 and not allzeros:
            print('Yes')
            return
        if x == 0 and allzeros:
            print('No')
            return
        allzeros = allzeros or total"
"import sys
input=sys.stdin.readline
I = lambda : list(map(int,input().split()))

t,=I()
for _ in range(t):
	n, = I()
	l = I()
	pos = 0
	if sum(l)!=0 or l[-1]>0:
		pos=1
	else:
		pref = l[0]
		seen = 0
		if pref<0:
			pos=1
		if pref==0:
			seen = 1
		for i in range(1,n):
			pref+=l[i]
			if pref<0:
				pos=1
				break
			elif pref==0:
				seen = 1
			else:
				if {{completion}}:
					pos=1
					break
	print(""YNeos""[pos::2])",seen,seen
"for t in range(int(input())):
    
    n=int(input())
    a=list(map(int,input().split()))
    i=n-1
    while(a[i]==0 and i!=0):
        i-=1 
    while(i>0):
        if a[i]>=0:
            print(""NO"")
            break
        a[i-1]+=a[i]
        i-=1
    else:
        if {{completion}}:
            print(""YES"")
        else:
            print(""NO"")
",a[i]==0,"a[i]>0:
            print(""NO"")
            break
        a[i-1]-=a[i]
        i-=1
    if i==0:
        if a[0]>0:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if a[i]<0:
            print(""YES"")
        else:
            print(""NO"")
<|/ a tags=arrays,python,algorithm |>
<| a tags=arrays,python,algorithm |>
<code>
for t in range(int(input())):
    n=int(input())
    a=list(map(int,input().split()))
    i=n-1
    while(a[i]==0 and i!=0):
        i-=1 
    while"
"for i in range(int(input())):
    n=int(input())
    c=[int(j) for j in input().split()]
    k=1
    if [0]*n==c:
        print('Yes')
    else:
        g=0
        while c[-1]==0:
            c.pop()
        while len(c)-1:
            if {{completion}}:
                k=0
                break
            g=g-c.pop()
        print(['No','Yes'][g==c[0] and k])",g<=c[-1],"c[-1]<0:
                c.pop()
            elif c[-1]>0:
                c.pop()
            elif c[-1]==c[0]:
                k=0
                break
            else:
                c.pop()
        while len(c)>1:
            if c[-1]<0:
                c.pop()
            elif c[-1]>0:
                c.pop()
            elif c[-1]==c[0]:
                k=0
                break
            else:
                c.pop()
        while len(c)>2:
            if c[-1]<0:
                c.pop()
            elif c[-1]>0:
                c.pop()
            elif c[-1]==c[0]:
                k=0
                break
            else:
                c.pop()
"
"import heapq as hq
INF = 1001001001
N, M = map(int, input().split())
G = [[] for _ in range(N)]
d = [0] * N
for _ in range(M):
    U, V = map(int, input().split())
    G[V - 1].append(U - 1)
    d[U - 1] += 1

dists = [INF] * N
dists[N - 1] = 0
queue = [(0, N - 1)]
while queue:
    dist, V = hq.heappop(queue)
    if dists[V] < dist: continue
    for v in G[V]:
        if {{completion}}:
            dists[v] = dist + d[v]
            hq.heappush(queue, (dist + d[v], v))
        d[v] -= 1
print(dists[0])",dist + d[v] < dists[v],dists[v] > dist
"from heapq import*;I=input;R=lambda:map(int,I().split())
n,m=R();g,q,vis=[[] for _ in range(n)],[(0,n-1)],[0]*n
d,out=[m+1]*n,[0]*n;d[-1]=0
for _ in range(m):u,v=R();u,v=u-1,v-1;g[v].append(u);out[u]+=1
while q:
  _,u=heappop(q)
  if vis[u]:continue
  vis[u]=1
  for v in g[u]:
    if {{completion}}:d[v]=d[u]+out[v];heappush(q,(d[v],v))
    out[v]-=1
print(d[0])",d[u]+out[v]<d[v],"out[v]==d[v]:continue
    if d[v]<d[u]:d[v]=d[u]+out[v];heappush(q,(d[v],v))
    out[v]-=1
print(d[0])
<|/ a tags=algorithm,dynamic-programming,graph-theory,python,graph |>
<| c |>
Thanks for your answer. Can you please explain how this code is working?
<|/ c |>
<| c |>
, I have added some explanation to the code. Hope it helps.
<|/ c |>
<| c |>
Thanks for your explanation. Can you please explain "
"


import sys
input=sys.stdin.readline #文字列入力はするな！！
from heapq import *

n,m=map(int,input().split())
root=[[] for i in range(n+2)]
rootinv=[[] for i in range(n+2)]
no=[0]*(n+2)
for i in range(m):
    u,v=map(int,input().split())
    root[u].append(v)
    rootinv[v].append(u)
    no[u]+=1
dp=[10**18]*(n+3)
dp[n]=0
hp=[(0,n)]
while hp:
    c,x=heappop(hp)
    if dp[x]<c:continue
    for y in rootinv[x]:
        no[y]-=1
        cost=no[y]+1
        if {{completion}}:
            dp[y]=dp[x]+cost
            heappush(hp,(dp[y],y))
print(dp[1])



",dp[y]>dp[x]+cost,"cost<=dp[y]:
            dp[y]=cost
            heappush(hp,(cost,y))
    for y in root[x]:
        no[y]-=1
        cost=no[y]+1
        if cost<=dp[y]:
            dp[y]=cost
            heappush(hp,(cost,y))
    for y in root[x]:
        no[y]-=1
        cost=no[y]+1
        if cost<=dp[y]:
            dp[y]=cost
            heappush(hp,(cost,y))
    for y in root[x]:
        no[y]-=1
        cost=no[y"
"import sys, heapq
input=sys.stdin.readline

n,m=map(int,input().split())
iadj=[{} for _ in range(n)]  # inverted road
nadj=[0]*n
dist=[n+1]*n
cost=[float(""inf"")]*n
visit=[0]*n

for _ in range(m):
    v,u=map(int,input().split())
    v-=1
    u-=1
    pi=iadj[u].setdefault(v,0)
    iadj[u][v]=1+pi  # road from v->u
    nadj[v]+=1

q = [(0,n-1)]
cost[n-1]=0
while q:
    d,v=heapq.heappop(q)
    if visit[v]:
        continue
    visit[v]=1
    for u in iadj[v]:
        nadj[u]-=iadj[v][u]
        if {{completion}}:
            cost[u]=cost[v]+nadj[u] + 1
            heapq.heappush(q, (cost[u], u))

print(cost[0])",cost[v] + nadj[u] + 1 < cost[u],"nadj[u]==0:
            dist[u]=d
            cost[u]=cost[v]+nadj[u] + 1
            heapq.heappush(q, (cost[u], u))

print(dist[0])
print(cost[0])
<|/ a tags=algorithm,graph,graph-theory,python |>
<| c |>
This code is not working as expected. Can you please help me to fix it?
<|/ c |>
<| c |>
What is the expected output?
<|/ c |>
<| c |>
The expected output should be the smallest possible integer $$$d$$$ to make sure that AmShZ and Ke"
"input = __import__('sys').stdin.readline


n = int(input())
a = list(map(int, input().split())) + [n+1]


ans = 0
cache = {}
for i in range(n):
    u = 0
    d = n+1
    
    keys = []
    j = i
    while j+1 <= n:
        key = (j, u, d)
        v = cache.get(key, -1)
        if v != -1:
            j = v
            break
        
        keys.append(key)
        # greedy
        if u < a[j] < d: # if can insert to both
            if a[j] < a[j+1]:
                u = max(u, a[j])
            elif {{completion}}:
                d = min(d, a[j])
        elif u < a[j]: # if only can insert to increasing subsequence
            u = a[j]
        elif d > a[j]: # if only can insert to decreasing subsequence
            d = a[j]
        else:
            break

        j += 1
    
    for key in keys:
        cache[key] = j

    ans += j - i
    # print(f'at {i} max {j} ans {ans}', u, d)

# print(f'count={len(cache)}')
print(ans)
",a[j] > a[j+1],a[j] > a[j+1]
"input = __import__('sys').stdin.readline


n = int(input())
a = list(map(int, input().split())) + [n+1]

cache = {}
def check(i, u, d):
    keys = []
    j = i
    while j+1 <= n:
        key = (j, u, d)
        v = cache.get(key, -1)
        if v != -1:
            j = v
            break
        
        keys.append(key)
        if u < a[j] < d: # if can insert to both
            if a[j] < a[j+1]:
                u = max(u, a[j])
            elif {{completion}}:
                d = min(d, a[j])
        elif u < a[j]: # if only can insert to increasing subsequence
            u = a[j]
        elif d > a[j]: # if only can insert to decreasing subsequence
            d = a[j]
        else:
            break

        j += 1
    
    for key in keys:
        cache[key] = j
    
    return j

ans = 0
for i in range(n):
    u = 0
    d = n+1
    j = check(i, u, d)
    ans += j - i
    # print(f'at {i} max {j} ans {ans}', u, d)

# print(f'count={count}')
print(ans)
",a[j] > a[j+1],a[j] > a[j+1]
"#from niumeng

from itertools import accumulate
I=input;R=lambda:map(int,I().split())
n,q=R();a=sorted(R())[::-1];p=[0]+list(accumulate(a))
for {{completion}}:
  x,y=R();print(p[x]-p[x-y])
",_ in range(q),"_ in range(q):
  x,y=R();print(p[x]-p[x-y])
#for _ in range(q):
#  x,y=R();print(p[x]-p[x-y])
#for _ in range(q):
#  x,y=R();print(p[x]-p[x-y])
#for _ in range(q):
#  x,y=R();print(p[x]-p[x-y])
#for _ in range(q):
#  x,y=R();print(p[x]-p[x-y])
#for _ in range(q):
#  x,y=R();print(p[x]-p[x-y])
#for _ in range(q):
#  x,y=R"
"n, q = [int(x) for x in input().split()]
prices = [int(price) for price in input().split("" "")]
prices.sort(reverse=True)
for {{completion}}:
    prices[i] += prices[i-1]
 
while q:
    # 5 5 3 2 1
    # 5 10 13 15 16
    x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1","i in range(1, len(prices))","x in range(q):
    x, y = [int(x) for x in input().split()]
    if x == y:
        l = prices[x - y - 1]
    else:
        l = prices[x - y - 1] - prices[x - y - 2]
    print(l)
 
q -= 1
for i in range(q):
    x, y = [int(x) for x in input().split()]
    if x == y:
        l = prices[x - y - 1]
    else:
        l = prices[x - y - 1] - prices[x - y - 2]
    prices[x-1] += l
 
for i in range(q):
    x, y = [int(x) for x in input().split()]
    if x == y:
        l = prices[x - y - 1]
    else:"
"n, q = [int(x) for x in input().split()]
prices = [int(price) for price in input().split("" "")]
prices.sort(reverse=True)
for i in range(1, len(prices)):
    prices[i] += prices[i-1]
 
while {{completion}}:
    # 5 5 3 2 1
    # 5 10 13 15 16
    x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1",q,q
"n,q=map(int,input().split())
a=[0]
for {{completion}}:a+=a[-1]+x,
for _ in[0]*q:x,y=map(int,input().split());print(a[x]-a[x-y])
","x in sorted(map(int,input().split()))[::-1]","_ in range(q):
    x,y=map(int,input().split())
    a+=a[-1]+x,a[-1]-a[x-y]
print(a[-1])
<|/ file filename=P02_02_01.py |>"
"n,q=map(int,input().split())
a=[0]
for x in sorted(map(int,input().split()))[::-1]:a+=a[-1]+x,
for {{completion}}:x,y=map(int,input().split());print(a[x]-a[x-y])
",_ in[0]*q,"_ in range(q):x,y=map(int,input().split())
print(a[x]-a[x-y])
<|/ a tags=python |>
<| c |>
Please don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| c |>
Thanks for the suggestion, I have added the explanation.
<|/ c |>
<| c |>
Thanks for the solution, can you please explain how this works?
"
"f=open(0)
R=lambda:map(int,next(f).split())
n,q=R();p=[0]
for {{completion}}: p+=p[-1]+w,
for _ in "" ""*q: x, y=R();print(p[n-x+y]-p[n-x])
",w in sorted(R()),"_ in ""0""*q"
"f=open(0)
R=lambda:map(int,next(f).split())
n,q=R();p=[0]
for w in sorted(R()): p+=p[-1]+w,
for {{completion}}: x, y=R();print(p[n-x+y]-p[n-x])
","_ in "" ""*q","x in range(1,q):
    for y in range(1,x):
        print(p[n-x+y]-p[n-x])
#Output"
"from sys import stdin
# t = int(stdin.readline().rstrip())
# while t>0:
    
#     t-=1
n,q = map(int,stdin.readline().split())
l = list(map(int,stdin.readline().split()))
l.sort()
for i in range(1,n):
    l[i] += l[i-1]
# print(l)
for i in range(q):
    x,y = map(int,stdin.readline().split())
    actual = n-x+y-1
    val = l[actual]
    if {{completion}}:
        val -= l[n-x-1]
    print(val)
    ",n-x > 0,val < l[n-1]
"Y=lambda:map(int,input().split())
O=[];n,q=Y();p=sorted(Y())[::-1];s=[0]
for {{completion}}:s+=[s[-1]+i]
for _ in[0]*q:x,y=Y();O+=[str(s[x]-s[x-y])]
print('\n'.join(O))",i in p,"i in[0]*q:
    if p[i]<=p[i+1]:
        s[i]=s[i]+p[i]
    else:
        s[i]=s[i]+p[i+1]
for i in range(q):
    if s[i]>s[i-1]:
        s[i]=s[i-1]
    if s[i]>s[i-q]:
        s[i]=s[i-q]
    if s[i]>s[i-q-1]:
        s[i]=s[i-q-1]
    if s[i]>s[i-q-2]:
        s[i]=s[i-q-2]
    if s[i]>s[i-q-3]:
        s[i]=s[i-q-3]
    if s[i]>s[i-q-4]:
        s[i]=s[i-q-4]
    if s[i]>"
"Y=lambda:map(int,input().split())
O=[];n,q=Y();p=sorted(Y())[::-1];s=[0]
for i in p:s+=[s[-1]+i]
for {{completion}}:x,y=Y();O+=[str(s[x]-s[x-y])]
print('\n'.join(O))",_ in[0]*q,"_ in range(q):
    x,y=Y();O+=[str(s[x]-s[x-y])]
print('\n'.join(O))
<|/ file source=github |>"
"arr=[int(i) for i in input().split()]
ans=[]
prices=[int(i) for i in input().split()]
prices.sort(reverse=True)
for i in range(1,arr[0]):
    prices[i]=prices[i]+prices[i-1]
    
for i in range(arr[1]):
    xy=[int(i) for i in input().split()]
    if{{completion}}:
        ans.append(prices[xy[0]-1])
    else:
        ans.append(prices[xy[0]-1]-prices[xy[0]-xy[1]-1])
for ele in ans:
    print(ele)",(xy[0]==xy[1]),"(xy[0]>xy[1]):
        ans.append(prices[xy[1]-1])
    elif(xy[0]==xy[1]):
        ans.append(prices[xy[0]-1])
    else:
        ans.append(prices[xy[0]-1]-prices[xy[0]-xy[1]-1])
for ele in ans:
    print(ele)
<|/ file dstars=0 source=github |>"
"import sys

n, p = map(int, sys.stdin.readline().split())
l = map(int, sys.stdin.readline().split())
l = sorted(l, reverse=True)

for i in range(n-1, 0, -1):
    l[i-1] += l[i]

for _ in range(p):
    xi, yi = map(int, sys.stdin.readline().split())
    a = n-xi
    b = a+yi

    if {{completion}}:
        print(l[-b])
    else:
        print(l[-b]-l[-a])
",a == 0,a < b
"## cf does not have numpy so with lists
r=open(0)
g=lambda:map(int,next(r).split())
n,q=g()
a=[0]
for {{completion}}:a+=a[-1]+x,
for b in[0]*q:x,y=g();print(a[x]-a[x-y])


",x in sorted(g())[::-1],"b in[0]*q:a+=a[-1]+x,
for b in[0]*q:x,y=g();print(a[x]-a[x-y])

## cf does not have numpy so with lists
r=open(0)
g=lambda:map(int,next(r).split())
n,q=g()
a=[0]
for b in[0]*q"
"## cf does not have numpy so with lists
r=open(0)
g=lambda:map(int,next(r).split())
n,q=g()
a=[0]
for x in sorted(g())[::-1]:a+=a[-1]+x,
for {{completion}}:x,y=g();print(a[x]-a[x-y])


",b in[0]*q,y in sorted(g())[::-1]
"(n, q) = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort(reverse=True)
for i in range (1,n):
   arr[i] = arr[i] + arr[i-1]
for trial in range(q):
    (x, y) = map(int, input().split())
    if {{completion}}:
        print (arr[x-1])
    else:
        print (arr[x-1] - arr[x-y-1])",(x==y),"x == y:
        print (arr[x-1])
    elif x > y:
        print (arr[x-1] - arr[x-y-1])
    elif x < y:
        print (arr[x-1] - arr[x-y-1])
    elif x == y-1:
        print (arr[x-1])
    elif x > y-1:
        print (arr[x-1] - arr[x-y-1])
    elif x < y-1:
        print (arr[x-1] - arr[x-y-1])
    elif x == y-2"
"from collections import deque

def solve():
    n = int(input())
    MOD = 998244353
    arr = [list(map(int, input().split())) for i in range(n)]
    dis = [[10**9]*n for i in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                dis[i][j] = abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1])
    g = [[] for i in range(n)]
    adj = [[0]*n for i in range(n)]
    for i in range(n):
        m = min(dis[i])
        for j in range(n):
            if dis[i][j] == m:
                g[i].append(j)
                adj[i][j] = 1

    gr = []
    for i in range(n):
        cur = []
        queue = deque()
        queue.append(i)
        v = [0] * n
        v[i] = 1
        while queue:
            x = queue.popleft()
            cur.append(x)
            for y in g[x]:
                if {{completion}}:
                    v[y] = 1
                    queue.append(y)
        ok = 1
        for x in cur:
            for y in cur:
                if x != y and adj[x][y] == 0:
                    ok = 0
                    break
        if ok:
            if min(cur) == i:
                gr.append(len(cur))
        else:
            gr.append(1)
    dp = [0]*(n+1)
    dp[0] = 1
    for a in gr:
        dp1 = [0]*(n+1)
        for i in range(n):
            dp1[i+1] = (dp1[i+1]+dp[i])%MOD
            if a > 1 and i+a <= n:
                dp1[i+a] = (dp1[i+a]+dp[i])%MOD
        dp = dp1
    ans = 0
    k = n
    for i in range(1, n+1):
        ans = (ans+dp[i]*k)%MOD
        k = k*(n-i)%MOD
    return ans


import sys
input = lambda: sys.stdin.readline().rstrip()
print(solve())
",v[y] == 0,"y == x:
                    continue
                if v[y] == 0 and adj[x][y] == 1:
                    v[y] = 1
                    queue.append(y)
                elif v[y] == 1 and adj[x][y] == 0 and adj[y][x] == 1:
                    v[y] = 1
                    queue.append(y)
                elif v[y] == 1 and adj[x][y] == 1 and adj[y][x] == 0 and adj[y][y] == 1:
                    v[y] = 1
                    queue.append(y)
                elif v[y] == 1 and adj[x][y] == 1 and adj[y][x] == 1 and adj[y][y] == 0 and adj[x][x] == 1:
                    v[y] = 1
                    queue.append(y)"
"from collections import deque

def solve():
    n = int(input())
    MOD = 998244353
    arr = [list(map(int, input().split())) for i in range(n)]
    dis = [[10**9]*n for i in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                dis[i][j] = abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1])
    g = [[] for i in range(n)]
    adj = [[0]*n for i in range(n)]
    for i in range(n):
        m = min(dis[i])
        for j in range(n):
            if dis[i][j] == m:
                g[i].append(j)
                adj[i][j] = 1

    gr = []
    for i in range(n):
        cur = []
        queue = deque()
        queue.append(i)
        v = [0] * n
        v[i] = 1
        while queue:
            x = queue.popleft()
            cur.append(x)
            for y in g[x]:
                if v[y] == 0:
                    v[y] = 1
                    queue.append(y)
        ok = 1
        for x in cur:
            for y in cur:
                if {{completion}}:
                    ok = 0
                    break
        if ok:
            if min(cur) == i:
                gr.append(len(cur))
        else:
            gr.append(1)
    dp = [0]*(n+1)
    dp[0] = 1
    for a in gr:
        dp1 = [0]*(n+1)
        for i in range(n):
            dp1[i+1] = (dp1[i+1]+dp[i])%MOD
            if a > 1 and i+a <= n:
                dp1[i+a] = (dp1[i+a]+dp[i])%MOD
        dp = dp1
    ans = 0
    k = n
    for i in range(1, n+1):
        ans = (ans+dp[i]*k)%MOD
        k = k*(n-i)%MOD
    return ans


import sys
input = lambda: sys.stdin.readline().rstrip()
print(solve())
",x != y and adj[x][y] == 0,"x == y:
                    continue
                if adj[x][y] == adj[x][y-1] == adj[x-1][y] == adj[x-1][y-1]"
"from math import perm, comb
import sys
input = sys.stdin.readline
 
M = 998244353
 
n = int(input())
x, y = [0]*n, [0]*n
for i in range(n):
    x[i], y[i] = map(int, input().split())
# print(x, y)
 
dist = [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        dist[i].append(abs(x[i] - x[j]) + abs(y[i] - y[j]))
# print(dist)
 
mindist, nbr = [M] * n, [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        if i == j:
            continue
        if dist[i][j] < mindist[i]:
            mindist[i] = dist[i][j]
            nbr[i] = [j]
        elif {{completion}}:
            nbr[i].append(j)
# print(mindist, nbr)
 
grp = [0] * n
for i in range(n):
    if grp[i] > 0:
        continue
    if len(nbr[i]) > 3:
        grp[i] = 1
        continue
 
    checknbr = [False] * n
    checknbr[i] = True
    for j in nbr[i]:
        checknbr[j] = True
 
    check = False
    for j in nbr[i]:
        if len(nbr[j]) != len(nbr[i]):
            check = True
            break
        for c in nbr[j]:
            if not checknbr[c]:
                check = True
                break
    if check:
        grp[i] = 1
    else:
        grp[i] = len(nbr[i]) + 1
        for j in nbr[i]:
            grp[j] = grp[i]
# print(grp)
 
cnt = [0] * 5
for i in grp:
    cnt[i] += 1
cnt[2] //= 2
cnt[3] //= 3
cnt[4] //= 4
# print(cnt)
 
ans = 0
for i in range(cnt[2] + 1):
    for j in range(cnt[3] + 1):
        for k in range(cnt[4] + 1):
            z = (comb(cnt[2], i) * comb(cnt[3], j) * comb(cnt[4], k)) % M
            z *= perm(n, n - i - 2*j - 3*k)
            z %= M
            ans = (ans + z) % M
print(ans)",dist[i][j] == mindist[i],"dist[i][j] == mindist[i] and nbr[i][j] != []:
            nbr[i].append(j)
        elif dist[i][j] == mindist[i] and nbr[i][j] == []:
            nbr[i] = [j]
        elif dist[i][j] > mindist[i] and nbr[i][j] != [] and nbr[i][j] != nbr[i][j]:
            nbr[i] = nbr[i][j]
        elif dist[i][j] > mindist[i] and nbr[i][j] == nbr[i][j]:
            nbr[i] = [j]
 
# print(mindist, nbr)
 
grp = [0] * n
for i in range(n):
    if grp[i] > 0:
        continue
    if len(nbr[i]) > 3:
        grp[i] = 1
        continue
 
    checknbr = [False"
"input = __import__('sys').stdin.readline


MOD = 998244353

fact = [1]
invfact = [1]

for i in range(1, 101):
    fact.append(fact[-1] * i % MOD)
    invfact.append(pow(fact[-1], MOD-2, MOD))


def C(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD


def P(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[n-k] % MOD


n = int(input())
coords = []
for _ in range(n):
    x, y = map(int, input().split())
    coords.append((x, y))

min_dist = [10**9] * n
dist = [[-1] * n for _ in range(n)]
for u in range(n):
    for v in range(n):
        dist[u][v] = abs(coords[u][0] - coords[v][0]) + abs(coords[u][1] - coords[v][1])
        if u != v:
            min_dist[u] = min(min_dist[u], dist[u][v])

cnt = [0, 0, 0, 0, 0]
vis = [False]*n
for u in sorted(range(n), key=lambda x: min_dist[x]):
    if vis[u]:
        continue

    vis[u] = True
    seen = [False]*n
    seen[u] = True    
    ptr = 0
    found = [u]
    while ptr < len(found):
        v = found[ptr]
        ptr += 1
        for w in range(n):
            if {{completion}}:
                seen[w] = True
                found.append(w)
    
    ok = all(dist[found[i]][found[j]] == min_dist[u] for i in range(len(found)) for j in range(i+1, len(found)))
    if len(found) == 1 or not ok:
        cnt[1] += 1
    else:
        # print('found', found, ok)
        cnt[len(found)] += 1
        for u in found:
            vis[u] = True


# print('cnt', cnt[1:])

ans = 0
for two in range(cnt[2] + 1):
    for three in range(cnt[3] + 1):
        for four in range(cnt[4] + 1):
            ans += P(n, n - two - 2*three - 3*four) * C(cnt[2], two) % MOD \
                * C(cnt[3], three) % MOD \
                * C(cnt[4], four) % MOD
            if ans >= MOD:
                ans -= MOD
            # print(f'add P({n},{n - two - 2*three - 3*four})*C({cnt[2]},{two})*C({cnt[3]},{three})*C({cnt[4]},{four}) {ans}')
print(ans)",not seen[w] and dist[v][w] == min_dist[v],"w != v and seen[w]:
                dist[w][v] = min(dist[w][v], dist[u][v])
                if dist[w][v] == dist[u][v]:
                    found[ptr] = w
                    seen[w] = True
                    ptr += 1
                    break
            elif w != v and not seen[w]:
                dist[w][v] = dist[u][v]
                found[ptr] = w
                seen[w] = True
                ptr += 1
                break
            elif w != v and seen[w] and dist[w][v] < dist[u][v]:
                dist"
"



#############################
#############
cnb_max=10**5
mod=998244353
#############

kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod

rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod

def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod


def inv(n):
    return kai[n-1]*rkai[n]%mod

##################################



n=int(input())
x=[]
y=[]
for i in range(n):
    a,b=map(int,input().split())
    x.append(a)
    y.append(b)
ok=[[0]*n for i in range(n)]
tto=[0]*n
def dist(i,j):
    return abs(x[i]-x[j])+abs(y[i]-y[j])
for i in range(n):
    mi=10**18
    for j in range(n):
        if i==j:continue
        mi=min(mi,dist(i,j))
    for j in range(n):
        if i==j:continue
        if mi==dist(i,j):
            ok[i][j]=1
            tto[i]+=1

s=[]
for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
            for d in range(c+1,n):
                nod=[a,b,c,d]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=3:flag=0
                if flag:s.append(4)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if {{completion}}:continue
                        flag&=ok[i][j]
                    if tto[i]!=2:flag=0
                if flag:s.append(3)

for a in range(n):
    for b in range(a+1,n):
                nod=[a,b]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=1:flag=0
                if flag:s.append(2)

dp=[0]*(n+1)
dp[n-sum(s)]=1
for cnt in s:
    newdp=[0]*(n+1)
    for i in range(n+1):
        dp[i]%=mod
        if i+cnt<=n:newdp[i+cnt]+=dp[i]
        if i+1<=n:newdp[i+1]+=dp[i]
    dp=newdp[:]
ans=0
for k in range(n+1):
    ans+=dp[k]*cnb(n,k)*kai[k]
    ans%=mod
print(ans)



",i==j,"i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=2:flag=0
                if flag:s.append(3)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=1:flag=0
                if flag:s.append(2)

for a in range(n):
    for b in range(a+1,n):
                nod=[a,b]
                flag=1
                for i in nod:
                    for j in nod:"
"



#############################
#############
cnb_max=10**5
mod=998244353
#############

kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod

rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod

def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod


def inv(n):
    return kai[n-1]*rkai[n]%mod

##################################



n=int(input())
x=[]
y=[]
for i in range(n):
    a,b=map(int,input().split())
    x.append(a)
    y.append(b)
ok=[[0]*n for i in range(n)]
tto=[0]*n
def dist(i,j):
    return abs(x[i]-x[j])+abs(y[i]-y[j])
for i in range(n):
    mi=10**18
    for j in range(n):
        if i==j:continue
        mi=min(mi,dist(i,j))
    for j in range(n):
        if i==j:continue
        if mi==dist(i,j):
            ok[i][j]=1
            tto[i]+=1

s=[]
for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
            for d in range(c+1,n):
                nod=[a,b,c,d]
                flag=1
                for {{completion}}:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=3:flag=0
                if flag:s.append(4)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=2:flag=0
                if flag:s.append(3)

for a in range(n):
    for b in range(a+1,n):
                nod=[a,b]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=1:flag=0
                if flag:s.append(2)

dp=[0]*(n+1)
dp[n-sum(s)]=1
for cnt in s:
    newdp=[0]*(n+1)
    for i in range(n+1):
        dp[i]%=mod
        if i+cnt<=n:newdp[i+cnt]+=dp[i]
        if i+1<=n:newdp[i+1]+=dp[i]
    dp=newdp[:]
ans=0
for k in range(n+1):
    ans+=dp[k]*cnb(n,k)*kai[k]
    ans%=mod
print(ans)



",i in nod,"i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=4:flag=0
                if flag:s.append(5)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=3:flag=0
                if flag:s.append(4)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=["
"for {{completion}}:
    r = int(input())
    print('Division', 4 - sum(r >= p for p in (1400, 1600, 1900)))
",_ in range(int(input())),"_ in range(int(input())):
    rating = int(input())
    if rating <= 5000:
        print('Division', 4 - sum(rating >= p for p in (1400, 1600, 1900)))
    else:
        print('Division', 4 - sum(rating >= p for p in (1600, 1899, 1599)))
<|/ file source=github |>"
"for {{completion}}:r=int(n)/100;print('Division',1+(r<19)+(r<16)+(r<14))",n in[*open(0)][1:],"_ in range(int(input())):
    n=input()
    r=int(n)
    print('Division',1+(r<19)+(r<16)+(r<14))
<|/ file ext=.py |>
<| c |>
Please add your solution to the question and format it properly.
<|/ c |>
<| c |>
"
"from bisect import bisect
b = [-5001, 1400, 1600, 1900]
for {{completion}}: print(f'Division {-bisect(b, int(input()))+5}')",i in range(int(input())),"_ in range(int(input())):
    try: print(b[int(input())])
    except: pass
<|/ file ext=.py |>"
"n=int(input())
while n:
    num=int(input())
    if num>=1900:print(""Division 1"")
    elif {{completion}}:print(""Division 2"")
    elif num>=1400:print(""Division 3"")
    else:print(""Division 4"")
    n-=1",num>=1600,"num>=1600:print(""Division 2"")
    elif num>=1400:print(""Division 3"")
    else:print(""Division 4"")
    n-=1
<|/ file source=github |>
<| c |>
Please don't post code as images. See [How do I ask and answer homework questions?](https://meta.stackoverflow.com/questions/334822/how-do-i-ask-and-answer-homework-questions)
<|/ c |>
<| a tags=python-3.x,python |>
<code>
n=int(input())
while n:
    num=int(input())
    if num>=1900:print(""Division 1"")
    elif num>=1600:print(""Division "
"n=int(input())
while n:
    num=int(input())
    if num>=1900:print(""Division 1"")
    elif num>=1600:print(""Division 2"")
    elif {{completion}}:print(""Division 3"")
    else:print(""Division 4"")
    n-=1",num>=1400,"num>=1400:print(""Division 3"")
    elif num>=1399"
"def div(n):
    return 1 if n >= 1900 else 2 if n >= 1600 else 3 if n >= 1400 else 4

for {{completion}}:
    print(f'Division {div(int(input()))}')
",_ in range(int(input())),"_ in range(int(input())):
    n = int(input())
    if div(n) == "
"x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif {{completion}}:
        print('Division 2')
    elif int(z) >= 1400:
        print('Division 3')
    else:
        print('Division 4')
",int(z) >= 1600,"int(z) >= 1600:
        print('Division 2')
    elif int(z) >= 1400:
        print('Division 3')
    else:
        print('Division 4')
'''
x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif int(z) >= 1600:
        print('Division 2')
    elif int(z) >= 1400:
        print('Division 3')
    else:
        print('Division 4')
'''
x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif int(z) >= 1600:
        print('Division 2')"
"x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif int(z) >= 1600:
        print('Division 2')
    elif {{completion}}:
        print('Division 3')
    else:
        print('Division 4')
",int(z) >= 1400,"int(z) >= 1400:
        print('Division 3')
    elif int(z) >= 1679"
"k = 0
a = int(input())
for x in range(1, a+1):
    b = int(input())
    if 1900<= b:
        d = 1
    elif {{completion}}:
        d = 2
    elif 1400 <= b <= 1599:
        d = 3
    elif b <= 1399:
        d = 4
    print('Division', d)",1600 <= b <= 1899,1600 <= b <= 1899
"k = 0
a = int(input())
for x in range(1, a+1):
    b = int(input())
    if 1900<= b:
        d = 1
    elif 1600 <= b <= 1899:
        d = 2
    elif {{completion}}:
        d = 3
    elif b <= 1399:
        d = 4
    print('Division', d)",1400 <= b <= 1599,1400 <= b <= 1599
"t = int(input())
while t > 0:
	n = int(input())
	if n >= 1900:
		print(""Division"",1)
	elif {{completion}}:
		print(""Division"", 2)
	elif n >= 1400 and n < 1600:
		print(""Division"", 3)
	else:
		print(""Division"",4)
	t -= 1
",n >= 1600 and n <1900,"n >= 1600 and n < 1900:
		print(""Division"", 2)
	elif n >= 1400 and n < 1600:
		print(""Division"", 3)
	else:
		print(""Division"",4)
	t -= 1
<|/ file source=github ext=.py |>"
"t = int(input())
while t > 0:
	n = int(input())
	if n >= 1900:
		print(""Division"",1)
	elif n >= 1600 and n <1900:
		print(""Division"", 2)
	elif {{completion}}:
		print(""Division"", 3)
	else:
		print(""Division"",4)
	t -= 1
",n >= 1400 and n < 1600,"n >= 1400 and n <1600:
		print(""Division"", 3)
	elif n >= 1300 and n <1400:
		print(""Division"", 4)
	else:
		print(""Division"",4)
	t -= 1
<|/ file source=github |>
<| c |>
Please don't post code as images. See [Why may I not upload images of code on SO when asking a question?](//meta.stackoverflow.com/a/285557/208273)
<|/ c |>
<| a |>
<code>
t = int(input())
while t > 0:
	n = int(input())
	if n >= 1900:
		print(""Division"",1)
	elif "
"x=int(input(""""))
for i in range (x):
    c=int(input(""""))
    if c<=1399:
        print("" Division 4"")
    elif {{completion}}:
        print("" Division 3"")
    elif 1600<=c<=1899:
       print("" Division 2"") 
    else :
       print("" Division 1"")",1400<=c<=1599,"1400<=c<=1599:
        print("" Division 3"")
    elif 1600<=c<=1899:
       print("" Division 2"") 
    else :
       print("" Division 1"")
""""""
<|/ a dscore=0 |>
<| a tags=python,python-3.x |>
<code>
x=int(input(""""))
for i in range (x):
    c=int(input(""""))
    if c<=1399:
        print("" Division 4"")
    elif 1400<=c<=1599"
"x=int(input(""""))
for i in range (x):
    c=int(input(""""))
    if c<=1399:
        print("" Division 4"")
    elif 1400<=c<=1599:
        print("" Division 3"")
    elif {{completion}}:
       print("" Division 2"") 
    else :
       print("" Division 1"")",1600<=c<=1899,"1600<=c<=1899:
        print("" Division 2"")
    elif 1900<=c<=2999:
        print("" Division 1"")
    elif c>2999"
"'''
How pros write B)
'''

for {{completion}}:
    x = int(input())
    print(""Division 4"" if x < 1400 else ""Division 3"" if x < 1600 else ""Division 2"" if x < 1900 else ""Division 1"")",i in range(int(input())),"_ in range(int(input())):
    x = int(input())
    print(""Division 4"" if x < 1400 else ""Division 3"" if x < 1600 else ""Division 2"" if x < 1900 else ""Division 1"")
<|/ file source=github ext=.py |>"
"from collections import deque
for _ in range(int(input())):
    n = int(input())
    l = deque(map(int, input().split()))
    a, b = 0, 0
    ans = 0
    cur = 0
    while l:
        cur+=1
        if {{completion}}:
            b += l.pop()
        else:
            a += l.popleft()
        if a==b:
            ans = cur
    print(ans)
",a>=b,l.popleft()<cur
"from collections import deque
for _ in range(int(input())):
    n = int(input())
    l = deque(map(int, input().split()))
    a, b = 0, 0
    ans = 0
    cur = 0
    while l:
        cur+=1
        if a>=b:
            b += l.pop()
        else:
            a += l.popleft()
        if {{completion}}:
            ans = cur
    print(ans)
",a==b,"cur==n:
            ans = max(a,b)
            break
        if cur>n"
"for n in[*open(0)][2::2]:
    n=[*map(int,n.split())]
    a,b,l,f=[0]*4;r=len(n)-1
    while l<=r:
        if a<=b:
            a+=n[l]
            l+=1
        elif {{completion}}:
            b+=n[r]
            r-=1
        if a==b:
            f=len(n)-r+l-1
    print(f)",b<a,"a>b:
            b+=n[r]
            r-=1
        if a==b:
            f=len(n)-r+l-1
    print(f)
<|/ a tags=python,algorithm |>
<| a tags=python,algorithm |>
<code>
for n in[*open(0)][2::2]:
    n=[*map(int,n.split())]
    a,b,l,f=[0]*4;r=len(n)-1
    while l<=r:
        if a<=b:
            a+=n[l]
            l+=1
        elif a>b:
            b+=n[r]
            r-=1
        if a==b:
            f=len(n)"
"from bisect import *
from itertools import *

t = int(input())
for _ in range(t):
	n = int(input())
	w = list(map(int, input().split()))
	aw = list(accumulate(w))
	bw = list(accumulate(w[::-1]))
	mx = 0
	for i, a in enumerate(aw):
		c = bisect_left(bw, a, hi=len(bw)-i-2)
		if {{completion}}:
			mx = max(mx, (i+1)+(c+1))
	print(mx)
",a==bw[c] and i<(len(bw)-c-1),"c > 0 and c < len(bw) and bw[c-1] == a:
			mx = max(mx, i+1)
		elif c > 0 and bw[c-1] != a:
			mx = max(mx, i+1)
		elif c == 0 and bw[c-1] != a:
			mx = max(mx, i+1)
		elif c == len(bw) and bw[c-1] != a:
			mx = max(mx, i+1)
		elif c == len(bw) and bw[c-1] == a:
			mx = max(mx, i+1)
		elif c == len(bw) and bw[c-1] == a:
			mx = max(mx, i+1)
		elif c == len(bw) and bw[c-1] != a:
			mx = max("
"def solve():
 n=int(input())
 a=[*map(int,input().split())]
 b=a[:]
 for i in range(n-1):a[i+1]+=a[i]
 for i in range(n-1,0,-1):b[i-1]+=b[i]
 l,r=0,n-1
 sol=0
 while r-l>=1:
  if {{completion}}:sol=l+n-r+1;l+=1
  if a[l]<b[r]:l+=1
  else:r-=1
 return sol
for _ in [0]*int(input()):print(solve())",a[l]==b[r],"a[l]>b[r]:sol+=b[r]-a[l]
  else "
"def solve():
 n=int(input())
 a=[*map(int,input().split())]
 b=a[:]
 for i in range(n-1):a[i+1]+=a[i]
 for i in range(n-1,0,-1):b[i-1]+=b[i]
 l,r=0,n-1
 sol=0
 while r-l>=1:
  if a[l]==b[r]:sol=l+n-r+1;l+=1
  if {{completion}}:l+=1
  else:r-=1
 return sol
for _ in [0]*int(input()):print(solve())",a[l]<b[r],"a[r]==b[l]:sol=r+n-l-1;r+=1
  if a[l]>a[r]:sol=l+n-r+1
  if a[r]>a[l]:sol=r+n-l-1
  if a[l]<a[r]:sol=l+n-r-1
  if a[r]<a[l]:sol=r+n-l+1
  if sol==n-1:break
  if a[l]>a[r]:l-=1
  if a[r]>a[l]:r+=1
  if a[l]<a[r]:l-=1
  if a[r]<a[l]:r+=1"
"I=lambda:[int(i) for i in input().split()]
for _ in range(I()[0]):
    n=I()[0]
    l=I()
    l2=[]
    s1,s2=0,0
    p1,p2=0,n-1
    while (p1-1<=p2):
        if {{completion}}: l2.append(p1 + n-1-p2); s1+=l[p1]; p1+=1
        if s1 < s2: s1+=l[p1]; p1+=1
        if s2 < s1: s2+=l[p2]; p2-=1
    print(l2[-1])

    ",s1 == s2,s1 > s2
"I=lambda:[int(i) for i in input().split()]
for _ in range(I()[0]):
    n=I()[0]
    l=I()
    l2=[]
    s1,s2=0,0
    p1,p2=0,n-1
    while (p1-1<=p2):
        if s1 == s2: l2.append(p1 + n-1-p2); s1+=l[p1]; p1+=1
        if {{completion}}: s1+=l[p1]; p1+=1
        if s2 < s1: s2+=l[p2]; p2-=1
    print(l2[-1])

    ",s1 < s2,s1 < s2
"import math as m

i = input()
inp = []
for a in range(0,int(i)):
    inp += [[input(), input()]]

def maxx(arr):
    if arr == []:
        return 0
    else:
        return max(arr)

for s in inp:
    n = int(s[0])
    arr = [int(x) for x in s[1].split()]
    
    i = 0
    j = n-1
    lsum = arr[i]
    rsum = arr[j]

    best = 0
    while i < j:
        if lsum < rsum:
            i += 1
            lsum += arr[i]
        elif {{completion}}:
            j -= 1
            rsum += arr[j]
        else:
            best = i + (n-1-j) + 2
            i += 1
            lsum += arr[i]
    print(best)
    
    
",rsum < lsum,lsum > rsum
"for t in range(int(input())):
    n=int(input())
    l1=list(map(int,input().split()))
    l=0
    h=n-1
    ans=0
    a=0
    b=0
    while(l<=h):
        if{{completion}}:
            b=b+l1[h]
            h=h-1
        else:
            a=a+l1[l]
            l=l+1
        if(a==b):
            ans=l+n-h-1
    print(ans)",(a>b),"(a<l1[l] and b<l1[h]):
            a=a+l1[l]
            l=l+1
        elif(a<l1[l] and b>=l1[h]):
            b=b+l1[h]
            h=h-1
        elif(a>=l1[l] and b<l1[h]):
            a=a+l1[l]
            l=l+1
        elif(a>=l1[l] and b>=l1[h]):
            b=b+l1[h]
            h=h-1
        else:
            a=a+l1[l]
            l=l+1
        if"
"for t in range(int(input())):
    n=int(input())
    l1=list(map(int,input().split()))
    l=0
    h=n-1
    ans=0
    a=0
    b=0
    while(l<=h):
        if(a>b):
            b=b+l1[h]
            h=h-1
        else:
            a=a+l1[l]
            l=l+1
        if{{completion}}:
            ans=l+n-h-1
    print(ans)",(a==b),"(a==b):
            ans=ans+l
    if(ans==n):
        ans=ans-1
    else:
        if(ans==0):
            ans=1
        else:
            ans=ans
    print(ans)
<|/ a dscore=0 |>
<| c |>
Please don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| a tags=python |>
<code>
for t in range(int(input"
"for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    x = sum(a) // 2
    s, d = 0, {}
    for idx, i in enumerate(a):
        s += i
        if {{completion}}: break
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if s in d: r = idx + 1 + d[s]
    print(r)",s > x,"s in d: break
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if s in d: r = idx + 1 + d[s]
    print(r)
'''
<|/ a dscore=0 |>
<| c |>
Thank you so much for the help! I really appreciate it!
<|/ c |>
<| c |>
You're welcome. Don't forget to accept the answer if it solved your problem.
<|/ c |>
<| c |>
I tried to upvote but I don't have enough reputation. Sorry about that!
<|/ c |>
<|"
"for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    x = sum(a) // 2
    s, d = 0, {}
    for idx, i in enumerate(a):
        s += i
        if s > x: break
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if {{completion}}: r = idx + 1 + d[s]
    print(r)",s in d,"s > x: break
        if s in d: r = idx + 1 + d[s]
    print(r)
""""""
<|/ a dscore=0 |>
<| a tags=python,algorithm |>
<code>
for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    x = sum(a) // 2
    s, d = 0, {}
    for idx, i in enumerate(a):
        s += i
        if s > x: break
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if s > x: break
        if s in d: r = idx + 1 + d[s]
    print(r)
</code>"
"n = int(input())
for i in range(n):
    h = 1
    g = 1
    counter = 0
    m = int(input())
    lst = list(map(int, input().split()))
    index =0
    e= 0
    r =m-1
    highest = lst[m-1]
    lowest = lst[0]
    while h+g <= m:
        if lowest<highest:
            lowest+=lst[e+1]
            e+=1
            g +=1
        elif {{completion}}:
            highest+=lst[r-1]
            r-=1
            h+=1
        elif highest == lowest:
            lowest+=lst[e+1]
            e+=1
            g+=1
            index = e + (m - r)
    print(index)
",highest<lowest,highest == lowest
"n = int(input())
for i in range(n):
    h = 1
    g = 1
    counter = 0
    m = int(input())
    lst = list(map(int, input().split()))
    index =0
    e= 0
    r =m-1
    highest = lst[m-1]
    lowest = lst[0]
    while h+g <= m:
        if lowest<highest:
            lowest+=lst[e+1]
            e+=1
            g +=1
        elif highest<lowest:
            highest+=lst[r-1]
            r-=1
            h+=1
        elif {{completion}}:
            lowest+=lst[e+1]
            e+=1
            g+=1
            index = e + (m - r)
    print(index)
",highest == lowest,"highest==lowest:
            h+=1
            g+=1
            index +=1
        elif highest>lowest"
"def read():
    return int(input())

def readline():
    return list(map(int,input().split()))

def solve():
    n=read()
    arr=readline()
    ans,cur=0,0
    a,suma=-1,0
    b,sumb=n,0
    while True:
        if a>=b: break
        elif {{completion}}:
            b-=1
            sumb+=arr[b]
            cur+=1
        elif suma<sumb:
            a+=1
            suma+=arr[a]
            cur+=1
        else :
            ans=cur
            a+=1
            b-=1
            suma+=arr[a]
            sumb+=arr[b]
            cur+=2
    print(ans)


if __name__ == ""__main__"":
    T=read()
    for i in range(T):
        solve()",suma>sumb,"suma>sumb:
            b+=1
            suma-=arr[b]
            cur+=1
        elif suma<sumb:
            a+=1
            suma+=arr[a]
            cur+=1
        else :
            ans=cur
            a+=1
            b-=1
            suma+=arr[a]
            sumb+=arr[b]
            cur+=2
    print(ans)

def solve1():
    n=read()
    arr=readline()
    ans,cur=0,0
    a,suma=-1,0
    b,sumb=n,0
    while True:
        if a>=b: break
        elif suma>"
"def read():
    return int(input())

def readline():
    return list(map(int,input().split()))

def solve():
    n=read()
    arr=readline()
    ans,cur=0,0
    a,suma=-1,0
    b,sumb=n,0
    while True:
        if a>=b: break
        elif suma>sumb:
            b-=1
            sumb+=arr[b]
            cur+=1
        elif {{completion}}:
            a+=1
            suma+=arr[a]
            cur+=1
        else :
            ans=cur
            a+=1
            b-=1
            suma+=arr[a]
            sumb+=arr[b]
            cur+=2
    print(ans)


if __name__ == ""__main__"":
    T=read()
    for i in range(T):
        solve()",suma<sumb,"suma<sumb:
            a-=1
            suma+=arr[a]
            cur+=1
        elif suma==sumb"
"for _ in range(int(input())):
    n, _ = map(int, input().split())
    a = map("""".join, zip(*(input() for _ in range(n))))
    a = (""o"".join("""".join(sorted(y, reverse=True)) for y in x.split(""o"")) for x in a)
    for {{completion}}:
        print("""".join(x))
 			  	 	    				   	  	 	    	",x in zip(*a),"x in a:
        if x == 'o':
            print(x, end='')
        elif x == '*':
            print(x, end='')
        elif x == '.':
            print(x, end='')
        else:
            print(x, end='')
    print()
<|/ file ext=.py |>"
"# Write your code here :-)
# Fall Down
def solution():
    n, m = [int(i) for i in input().split()]
    grid = [list(input()) for _ in range(n)]
    for i in range(m):
        for j in range(n - 1, -1, -1):
            if grid[j][i] == ""*"":
                grid[j][i] = "".""
                pos = j
                while {{completion}}:
                    pos += 1
                grid[pos][i] = ""*""
    for row in grid:
        print(*row, sep="""")


t = int(input())
for _ in range(t):
    solution()
","pos < n - 1 and grid[pos + 1][i] == "".""","pos > 0 and grid[pos - 1][i] == ""*"":
                    pos -= 1
                grid[pos][i] = ""*""
    for i in range(m):
        for j in range(n):
            if grid[j][i] == ""*"":
                grid[j][i] = "".""
                pos = j
                while pos < n - 1 and grid[pos][i] == ""*"
"def res(s):
 a=s.split('o');t=''
 for i in a:t+=i.count('*')*'*'+i.count('.')*'.'+'o'
 return t[:-1]

for _ in[0]*int(input()):
 n,m=map(int,input().split())
 a=[[*input()] for x in[0]*n]
 b=[]
 for i in range(m):b+=res(''.join([a[~j][i] for j in range(n)])),
 for i in range(n):
  for {{completion}}:print(b[j][~i],end='')
  print()
 print()",j in range(m),"j in range(m):
   if j<n:
    if i==j:print(b[j][~i],end='')
   else:print(b[j][~i],end='')
  print()
 print()
 a=[[*input()] for x in[0]*n]
 b=[]
 for i in range(m):b+=res(''.join([a[~j][i] for j in range(n)])),
 for i in range(n):
  for j in range(m):
   if j<n:
    if i==j:print(b[j][~i],end='')
   else:print(b[j][~i],end='')
  print()
 print()
 a=[[*input()] for x in[0]*n]
"
"c=input()
for _ in range(int(c)):
    b=input().split()
    a=[]
    for i in range(int(b[0])):
        a.append(list(input()))
    for i in range(int(b[1])):
        count=0
        row=int(b[0])-1
        for j in range(int(b[0])):
            if a[row][i]=='.':
                count+=1
            elif {{completion}}:
                count=0
            else:
                a[row][i],a[row+count][i]='.',a[row][i]
            row-=1
    for i in range(int(b[0])):
        print("""".join(a[i]))


",a[row][i]=='o',"a[row][i]=='o' and count==0 and row<int(b[0]):
                count+=1
            elif a[row][i]=='o' and count==0 and row>int(b[0]):
                count+=1
            elif a[row][i]=='o' and count==0 and row==int(b[0]):
                count+=1
            elif a[row][i]=='o' and count==0 and row==int(b[0])-1:
                count+=1
            elif a[row][i]=='o' and count==0 and row==int(b[0])-2"
"import sys
input = sys.stdin.readline
for _ in [0]*int(input()):
    n,m=map(int,input().split())
    s=['']*m
    for _ in [0]*n:
        s=[s[i]+j for i,j in zip(range(m),input())]
    col=['']*n
    k=0
    for i in s:
        bl=0
        x=''
        for j in i[::-1]:
            if j=='o':
                x=j+'.'*bl+x
                bl=0
            elif {{completion}}:
                x=j+x
            else:
                bl=bl+1
        x='.'*bl+x
        col=[col[ind]+val for val,ind in zip(x,range(n))]
        k=k+1
    for j in col:
        print(j)",j=='*',"j=='*':
                x=j+x
            elif j=='.':
                x=j+'.'*bl+x
                bl=bl+1
            elif j=='o':
                x=j+'.'*bl+x
                bl=0
            elif j=='*':
                x=j+x
            elif j=='.':
                x=j+'.'*bl+x
                bl=bl+1
            elif j=='o':
                x=j+'.'*bl+x
                bl=0
            elif j=='*':
                x=j+x
            elif j=='.':
                x=j+'.'*bl+x
                bl=bl+1
"
"for i in range(int(input())):
    n,m=map(int,input().split())
    s=[list(input()) for j in range(n)]
    for _ in range(n):
        for a in reversed(range(n-1)):
            for b in range(m):
                if s[a][b]=='*':
                    if {{completion}}:
                        continue
                    else:
                        s[a][b]='.'
                        s[a+1][b]='*'
    for a in range(n):
        print(*s[a],sep='')",s[a+1][b]=='o' or s[a+1][b]=='*',"s[a+1][b]=='o':
                        s[a][b]='o'
                        s[a+1][b]='*'
                    elif s[a+1][b]=='*':
                        s[a][b]='o'
                        s[a+1][b]='*'
                    elif s[a+1][b]=='.':
                        s[a][b]='o'
                        s[a+1][b]='*'
                    elif s[a+1][b]=='.':
                        s[a][b]='o'
                        s[a+1][b]='*'
                    elif s[a+1][b]=='.':
                        s[a"
"I=lambda:map(int,input().split())
for _ in range(int(input())):
    n,m=I()
    a=[input() for _ in range(n)]
    
    at=[''.join(col).split('o') for col in zip(*a)]
    f=lambda s:''.join(sorted(s,reverse=True))
    at=['o'.join(map(f, col)) for col in at]
    
    for {{completion}}:
      print(''.join(row))",row in zip(*at),row in at
"I = input
for _ in range(int(I())):
    n,m = map(int,I().split())
    grid = [I().strip() for __ in range(n)]
    res = []
    for col in range(m):
        newcol = ''
        for {{completion}}:
            newcol += '.'*seg.count('.')+'*'*seg.count('*')+'o'
        res.append(newcol[0:-1])
    for row in range(n):
        print(''.join(res[col][row] for col in range(m)))",seg in (''.join(grid[row][col] for row in range(n))).split('o'),seg in grid
"for ii in range(int(input())):
	n,m = map(int, input().split())
	mat=[]
	r=[0]*m
	for jj in range(n):
		a=list(input())
		for kk in range(m):
			if a[kk]==""*"":
				r[kk]+=1
				a[kk]="".""
			elif a[kk]==""o"":
				while {{completion}}:
					mat[jj-r[kk]][kk]=""*""
					r[kk]-=1
		mat.append(a)
	for jj in range(m):
		while r[jj]:
			mat[n-r[jj]][jj]=""*""
			r[jj]-=1
	for jj in range(n):
		print("""".join(mat[jj]))",r[kk],"r[kk]:
					mat[jj-r[kk]][kk]=""*""
					r[kk]-=1
				mat.append(a)
				a=list(input())
				for kk in range(m):
					if a[kk]==""*"":
						r[kk]+=1
						a[kk]="".""
					elif a[kk]==""o"":
						while r[kk]:
							mat[jj-r[kk]][kk]=""*""
							r[kk]-=1
						mat.append(a)
						a=list(input())
						for kk in range(m):
							if a[kk]==""*"":"
"t = int(input())

for i in range (t):
    n, m = map(int,input().split())
    arr = [[0]*m]*n
    for j in range(n):
        arr[j] = list(input())
        # for h in range(m):
            # print(arr[j][h])
    for k in range(m):
        for l in range(n-1, -1, -1):
           if arr[l][k]=='.':
            #    print(""yes"")
               for f in range(l-1,-1,-1):
                   if arr[f][k]=='o':
                       break
                   elif {{completion}}:
                    #    print(""yes"")
                       arr[f][k]='.'
                       arr[l][k]='*'
                       break
    for g in range(n):
        for h in range(m-1):
            print(arr[g][h],end="""")
        print(arr[g][m-1],end=""\n"")
                
                
            
            
        

",arr[f][k]=='*',"arr[f][k]=='*':
                       arr[f][k]='.'
                       break
               for g in range(l+1,n):
                   if arr[l][k]=='o':
                       break
                   elif arr[l][k]=='*':
                       arr[l][k]='.'
                       break
               for h in range(l+1,m):
                   if arr[l][h]=='o':
                       break
                   elif arr[l][h]=='*':
                       arr[l][h]='.'
                       break
               for h in range(l-1,-1,-1):
                   if arr[l][h]=='o':
                       break"
"from collections import Counter
for _ in range(int(input())):
    n = int(input())
    num = Counter(input() for x in [1]*n)
    cnt = 0
    for x in num:
        for y in num:
            if {{completion}}:
                cnt+=num[x]*num[y]
    print(cnt//2)",x!=y and (x[0] == y[0] or x[1] == y[1]),"x!=y and num[x]==num[y] and x<y:
                cnt+=1
    print(cnt//2)
<|/ a tags=python,algorithm |>
<| a dscore=0 |>
<code>
from collections import Counter
for _ in range(int(input())):
    n = int(input())
    num = Counter(input() for x in [1]*n)
    cnt = 0
    for x in num:
        for y in num:
            if x!=y and num[x]==num[y] and x<y:
                cnt+=1
    print(cnt//2)
</code>
<|/ a tags=python,algorithm |>
<| c |>
Please don't post only code as an answ"
"from collections import Counter
from itertools import islice
from sys import stdin

LETTERS = 'abcdefghijk'

data = (line.strip() for line in stdin.readlines()[1:])

res = []
for line in data:
    n = int(line)
    s = 0
    ctr = Counter()
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if {{completion}}:
                s += ctr[f'{l}{b}']
            if l != b:
                s += ctr[f'{a}{l}']
    res.append(s)

print('\n'.join(str(x) for x in res))
",l != a,"l != a:
                s += ctr[f'{a}{l}']
            if l != b:
                s += ctr[f'{b}{l}']
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] -= 1
        for l in LETTERS:
            if l != a:
                s += ctr[f'{a}{l}']
            if l != b:
                s += ctr[f'{b}{l}']
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if l != a:
                s += ctr[f'{a}{"
"from collections import Counter
from itertools import islice
from sys import stdin

LETTERS = 'abcdefghijk'

data = (line.strip() for line in stdin.readlines()[1:])

res = []
for line in data:
    n = int(line)
    s = 0
    ctr = Counter()
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if l != a:
                s += ctr[f'{l}{b}']
            if {{completion}}:
                s += ctr[f'{a}{l}']
    res.append(s)

print('\n'.join(str(x) for x in res))
",l != b,"l != b:
                s += ctr[f'{a}{l}']
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if l != a:
                s += ctr[f'{l}{b}']
            if l != b:
                s += ctr[f'{a}{l}']
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if l != a:
                s += ctr[f'{l}{b}']
            if l != b:
                s += ctr[f'{a}{l"
"for i in range(int(input())):
    data = [[0 for l in range(11)] for k in range(11)]

    for j in range(int(input())):
        first, second = input()
        data[ord(first)-ord('a')][ord(second)-ord('a')] += 1

    answer = 0
    for j in range(11):
        for k in range(11):
            for l in range(11):
                if {{completion}}:
                    answer += data[j][k]*data[l][k]

                if k != l:
                    answer += data[j][k]*data[j][l]

    print(answer//2)",j != l,"j != k:
                    answer += data[j][k]*data[k][l]

                if j != l and k != l:
                    answer += data[j][k]*data[l][k]

                if j != l and k != l and l != k:
                    answer += data[j][k]*data[l][k]

                if j != l and k != l and l != k and l != j:
                    answer += data[j][k]*data[l][k]

                if j != l and k != l and l != k and l != j and l != k:
                    answer += data[j][k]*data[l]["
"for i in range(int(input())):
    data = [[0 for l in range(11)] for k in range(11)]

    for j in range(int(input())):
        first, second = input()
        data[ord(first)-ord('a')][ord(second)-ord('a')] += 1

    answer = 0
    for j in range(11):
        for k in range(11):
            for l in range(11):
                if j != l:
                    answer += data[j][k]*data[l][k]

                if {{completion}}:
                    answer += data[j][k]*data[j][l]

    print(answer//2)",k != l,"k == l and j != l:
                    answer += data[j][k]*data[j][l]

                if k == l and j == l and j != l:
                    answer += data[j][k]*data[j][l]

                if j == l and k == l and j != l:
                    answer += data[j][k]*data[j][l]

                if j == l and k == l and j == l:
                    answer += data[j][k]*data[j][l]

                if j != l and k == l and j != l:
                    answer += data[j][k]*data[j][l"
"from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if c != s[0]:
                if {{completion}}:
                    count += d[c + s[1]]
            if c != s[1]:
                if d[s[0] + c] > 0:
                    count += d[s[0] + c]
        d[s] += 1
    print(count)",d[c + s[1]] > 0,"d[c + s[1]] > 0:
                    count += d[c + s[1]]
            if c != s[1]:
                if d[s[0] + c] > 0:
                    count += d[s[0] + c]
        d[s] += 1
    print(count)
<|/ a tags=algorithm,string,python,arrays |>
<| a tags=algorithm,string,python,arrays |>
<code>
from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if "
"from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if c != s[0]:
                if d[c + s[1]] > 0:
                    count += d[c + s[1]]
            if c != s[1]:
                if {{completion}}:
                    count += d[s[0] + c]
        d[s] += 1
    print(count)",d[s[0] + c] > 0,"d[s[0] + c] > 0:
                    count += d[s[0] + c]
        d[s] += 1
    print(count)
<|/ a |>
<| c |>
Thank you so much! I really appreciate your help!
<|/ c |>
<| a tags=algorithm,c++ |>
<code>
from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if c != s[0]:
                if d["
"for ii in range(int(input())):
	n=int(input())
	a=[]
	co=0
	x=set()
	for jj in range(n):
		a.append(input())
	for jj in range(n):
		mul=1
		if jj not in x:
			for kk in range(jj+1,n):
				if a[jj][0]!=a[kk][0] and a[jj][1]==a[kk][1]:
					co+=mul
				elif {{completion}}:
					co+=mul
				elif a[jj][0]==a[kk][0] and a[jj][1]==a[kk][1]:
					mul+=1
					x.add(kk)
	print(co)",a[jj][0]==a[kk][0] and a[jj][1]!=a[kk][1],"a[jj][0]==a[kk][0] and a[jj][1]!=a[kk][1]:
					mul+=1
					x.add(kk)
	print(co)

for ii in range(int(input())):
	n=int(input())
	a=[]
	co=0
	x=set()
	for jj in range(n):
		a.append(input())
	for jj in range(n):
		mul=1
		if jj not in x:
			for kk in range(jj+1,n):
				if a[jj][0]!=a[kk][0] and a[jj][1]!=a[kk][1]"
"t=int(input())
for i in range(t):
  n=int(input())
  result=0
  dic1={}
  dic2={}
  dic3={}
  for i in range(n):
    S=input()
    if {{completion}}:
      result+=dic1[S[0]]
      dic1[S[0]]+=1
    else:
      dic1[S[0]]=1
    if S[1] in dic2:
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      dic2[S[1]]=1
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)",S[0] in dic1,"S[0] in dic1:
      result+=dic1[S[0]]
      dic1[S[0]]+=1
    else:
      dic1[S[0]]=1
    if S[1] in dic2:
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      dic2[S[1]]=1
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)
<|/ q dscore=0 |>
<| c |>
Please post the code you have tried so far.
<|/ c "
"t=int(input())
for i in range(t):
  n=int(input())
  result=0
  dic1={}
  dic2={}
  dic3={}
  for i in range(n):
    S=input()
    if S[0] in dic1:
      result+=dic1[S[0]]
      dic1[S[0]]+=1
    else:
      dic1[S[0]]=1
    if {{completion}}:
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      dic2[S[1]]=1
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)",S[1] in dic2,"S[1] in dic2:
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      dic2[S[1]]=1
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)
<|/ q tags=algorithm,python |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have "
"for i in range(int(input())):
    n= int(input())
    a = dict()
    b = dict()
    c = dict()
    ans = 0
    for j in range(n):
        d,e = str(input())
        try:
            ans += a[d]
            a[d] += 1
        except KeyError:
            a[d] = 1
        try:
            ans += b[e]
            b[e] += 1
        except KeyError:
            b[e] = 1
        if {{completion}}:
            c[d+e] = 0
        else:
            ans -= c[d+e]
        c[d+e] += 2
    print(ans)",d+e not in c,"ans < 0:
            c[d+e] = 0
        elif ans > "
"from collections import Counter

t=int(input())
while(t!=0):
    n=int(input())
    s = Counter(input() for x in [1]*n)
    cnt = 0
    for x in s:
        for y in s:
            if{{completion}}: cnt += s[x]*s[y]
    print(cnt//2)
   
    t-=1
",(x!=y and (x[1]==y[1] or x[0]==y[0])),"(x!=y):
                if(x==y):
                    cnt+=1
                else:
                    cnt+=2
                break
    if(cnt//2==0):
        print(""-1"")
    else:
        print(cnt//2)
    t-=1
""""""
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
from collections import Counter

t=int(input())
while(t!=0):
    n=int(input())
    s = Counter(input() for x in [1]*n)
    cnt = 0
    for x in s:
        for y in s:
            if(x!=y):
                if(x==y):
                    cnt+=1
                else:
                    cnt+="
"t = int(input())
for x in range(t):
    n = int(input())
    d1 = {}
    for i in range(97,109):
        for j in range(97,109):
            d1[chr(i)+chr(j)] = 0
    ans1 = 0
    for y in range(n):
        s = input()
        for l in range(2):
            for m in range(97,109):
                a = list(s)
                a[l] = chr(m)
                a = ''.join(a)
                if {{completion}}:
                    continue
                ans1+=d1[a]
        d1[s]+=1
    print(ans1)",a == s,"a in d1:
                    if d1[a]>ans1:
                        ans1 = d1[a]
                elif a!=s and d1[a]>ans1:
                    ans1 = d1[a]
                elif a!=s and d1[a]==ans1:
                    continue
                elif a!=s and d1[a]<d1[a] and d1[a]<d1[a] and d1[a]<d1[a] and d1[a]<d1[a] and d1[a]<d1[a] and d1[a]<d1[a] and d1[a]<d1[a] and d1[a]<d1[a] and d1[a]<d"
"for n in range(int(input())):
    a = {}
    for j in range(int(input())):
        c = input()
        if c not in a:
            a[c] = 1
        elif c in a:
            a[c] += 1
    count = 0
    for i in a.keys():
        for j in a.keys():
            if {{completion}}:
                count += a[i] * a[j]
    print(count // 2)
",i != j and (i[0] == j[0] or i[1] == j[1]),"i != j and a[i] == a[j] and i != j and a[i] != a[j] and a[i] != 1 and a[j] != 1 and a[i] != a[j] and a[i] != 1 and a[j] != 1:
                count += 1
    print(count)
""""""
<|/ a |>
<| a dscore=0 |>
<code>
for _ in range(int(input())):
    count=0
    a=list(map(int,input().split()))
    for i in range(0,len(a)):
        for j in range(0,len(a)):
            if i!=j and a[i]!=a[j] and a[i]!=1 and a[j]!=1 and a[i]!=a[j] and a[j]!=1 and a[i]!=1 and a[j]!=1:
                "
"for {{completion}}:print('YNEOS'[1in map(len,map(set,s[:-1].split('W')))::2])",s in[*open(0)][2::2],"test in xrange(t):
    s=raw_input()
    if s=='YES':
        s=raw_input()
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]
        s=s[:-1]"
"for {{completion}}:
	l = int(input())
	print(""NO"" if any (len(set(x)) == 1 for x in input().split('W') ) else ""YES"")",_ in range(int(input())) ,"test in range (1,101):
	n = int(input())
	s = input()
	print(""NO"" if any (len(set(x)) == 1 for x in s.split('W') ) else ""YES"")
<|/ file ext=.py |>"
"def solve():
    n = int(input())
    s = input().split('W')
    for i in s:
        bs = 'B' in i
        rs = 'R' in i
        if {{completion}}:
            print('NO')
            return

    print('YES')

for t in range(int(input())):
    solve()
",bs ^ rs,"bs and rs:
            print('NO')
            return
        if bs and not rs:
            print('NO')
            return
        if not bs and rs:
            print('NO')
            return
        if bs and rs and not bs and not rs:
            print('NO')
            return
        if bs and not rs and not bs and rs:
            print('NO')
            return
        if not bs and not rs and not bs and not rs:
            print('NO')
            return
        if bs and rs and bs and not rs:
            print('NO')
            return
        if not bs and rs and bs and not rs:
            print('NO')
            return
        if bs and rs and not bs and rs:
            print('NO')"
for {{completion}}:print('YNEOS'[1in[len({*x})for x in s[:-1].split('W')]::2]),s in[*open(0)][2::2],"test in xrange(int(raw_input())):
    n=int(raw_input())
    s=raw_input()
    s=s.replace('W','')
    s=s.replace('R','')
    s=s.replace('B','')
    s=s.replace('W','')
    s=s.replace('R','')
    s=s.replace('B','')
    s=s.replace('W','')
    s=s.replace('R','')
    s=s.replace('B','')
    s=s.replace('W','')
    s=s.replace('R','')
    s=s.replace('B','')
    s=s.replace('W','')
    s=s.replace('R"
"g = input()
for i in range(int(g)):
    input()
    numb = input().split('W')
    ans = 'yes'
    for z in numb:
        if z == '':
            pass
        else:
            if {{completion}}:
                pass
            else:
                ans = 'no'
    print(ans)
",('R' in z) and ('B' in z),"z[0] == 'R':
                ans = 'no'
                break
            elif z[0] == 'B':
                ans = 'no'
                break
            elif z[0] == 'R':
                ans = 'no'
                break
            elif z[0] == 'B':
                ans = 'no'
                break
            elif z[0] == 'R':
                ans = 'no'
                break
            elif z[0] == 'B':
                ans = 'no'
                break
            elif z[0] == 'R':
                ans = 'no'
                break
            elif z[0] == 'B':
                ans = 'no'
                break
            elif z[0] == 'R':
                ans = 'no'
                break
            elif z[0] == '"
"for s in[*open(0)][2::2]:
    b=0
    for {{completion}}:b|=len({*i})%2
    print('YNEOS'[b::2])",i in s[:-1].split('W'),"i,j in enumerate(s):
        if j=='W':
            b+=i
    b"
"t=int(input())

for i in range(t):
    n=int(input())
    s=input()
    s=s.strip(""W"")
    temp=list(s.split('W'))

    for i in temp:
        if i:
            if {{completion}}:
                print(""NO"")
                break
    else:
        print(""YES"")
        ",'B' not in i or 'R' not in i,"i[0]=='R':
                temp.remove(i)
            elif i[0]=='B':
                temp.remove(i)
            else:
                temp.remove(i)
    temp=list(set(temp))
    temp=sorted(temp)
    temp=list(set(temp))
    temp=sorted(temp)
    temp=list(set(temp))
    temp=sorted(temp)
    temp=list(set(temp))
    temp=sorted(temp)
    temp=list(set(temp))
    temp=sorted(temp)
    temp=list(set(temp))
    temp=sorted(temp)
    temp=list(set(temp))
    temp=sorted(temp)
"
"for {{completion}}:
    num = int(input())
    line = [elem for elem in input().split(""W"") if elem != """"]
    print(""YES"" if all([""B"" in elem and ""R"" in elem for elem in line]) else ""NO"")",i in range(int(input())),"_ in range(int(input())):
    n, s = input().split()
    s = list(s)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"for s in[*open(0)][2::2]:
    b = 0
    for {{completion}}:
        b|=(len(set(i))==1)
    print('YNEOS '[b::2])","i in s[:-1].split(""W"")","i in s.split():
        b|=(len(set(i))==2)
    print('YES '[b::2])
for s in[*open(0)][1::2]:
    b = 0
    for i in s.split():
        b|=(len(set(i))==1)
    print('NO '[b::2])
for s in[*open(0)][0::2]:
    b = 0
    for i in s.split():
        b|=(len(set(i))==2)
    print('YES '[b::2])
for s in[*open(0)][1::2]:
    b = 0
    for i in s.split():
        b|=(len(set(i))==1)
    print('NO '[b::"
"t = int(input())
Ans = [-1]*t
for z in range(t):
    n = int(input())
    l = input().split('W')
    bad = False
    for s in l:
        b1 = 'R' in s
        b2 = 'B' in s
        if {{completion}}:
        	bad = True
    print(""NO"" if bad else ""YES"")
    

",(b1 ^ b2),"b1 and b2:
            bad = False
            break
        elif b1:
            bad = True
            break
        elif b2:
            bad = True
            break
    if bad"
"n=int(input())
l=[int(i) for i in input().split()]

def f(l):
    cur = 0
    n = 0
    for {{completion}}:
        n += cur // i + 1
        cur = i * (cur // i + 1)
    return n

print(min(f(l[i+1:])+f(l[:i][::-1]) for i in range(n)))",i in l,"i,v in enumerate(l):
        cur += v
        if cur > n:
            n = cur
            cur = 0
        elif cur < n:
            n = cur
            cur = 0
        elif cur == n:
            cur = 0
    return n

def min(f):
    cur = 0
    n = 0
    for i in range(1,n+1):
        cur += f
        if cur < n:
            n = cur
            cur = 0
        elif cur == n:
            cur = 0
    return n

def min2(f):
    cur = 0
    n = 0
    for i in range(1,n+1):
        cur += f
        if cur < n:
            n = cur
            cur = 0
        elif cur == n:
            cur = 0
    return "
"n = int(input().strip())
a = list(map(int, input().strip().split()))
ans = None

for i in range(n):
    acc, p = 0, 0
    for {{completion}}:
        x = (p - 1) // a[j]
        acc += -x
        p = x * a[j]
    p = 0
    for j in range(i+1, n):
        x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]
    ans = min(ans, acc) if ans is not None else acc

print(ans)
","j in range(i-1, -1, -1)","j in range(n):
        if a[j] < a[i]:
            acc += a[j] - a[i]
            p = a[j]
        elif a[j] > a[i]:
            acc += a[i] - a[j]
            p = a[i]
    if ans is None or acc < ans:
        ans = acc
    if ans is not None and acc > ans:
        ans = acc

for i in range(n):
    acc, p = 0, 0
    for j in range(n):
        if a[j] < a[i]:
            acc += a[j] - a[i]
            p = a[j]
        elif a[j] > a[i]:
            acc += a[i] - a[j]
            p = a[i]
    if ans is None or acc < ans:
"
"n = int(input().strip())
a = list(map(int, input().strip().split()))
ans = None

for i in range(n):
    acc, p = 0, 0
    for j in range(i-1, -1, -1):
        x = (p - 1) // a[j]
        acc += -x
        p = x * a[j]
    p = 0
    for {{completion}}:
        x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]
    ans = min(ans, acc) if ans is not None else acc

print(ans)
","j in range(i+1, n)","j in range(i-1, -1, -1):
        x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]
    ans = min(ans, acc) if ans is not None else acc

print(ans)
""""""
<|/ a dscore=0 |>
<| c |>
Thank you for your answer. Can you please explain how you came up with the solution?
<|/ c |>
<| c |>
I used the formula to find the minimum number of moves needed to make $$$b$$$ increasing. I also used the formula to find the minimum number of moves needed to make $$$b$$$ decreasing. I then added the two "
"from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float(""inf"")
for i in range(len(a)):
    t=[0]*n
    temp=0
    j=i-1
    prev =0
    while {{completion}}:
        x=(ceil((prev+1)/a[j]))
        temp+=x
        prev=(a[j]*x)
        j-=1
    
    k=i+1
    prev=0
    while k<len(a):
        x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1
    ans=min(ans,temp)
print(int(ans))",j>=0,"j>=0:
        x=(ceil((prev+1)/a[j]))
        temp+=x
        prev=(a[j]*x)
        j-=1
    k=i
    prev=0
    while k<len(a):
        x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1
    ans=min(ans,temp)
print(int(ans))
<|/ a tags=algorithm,python,dynamic-programming |>
<| a dscore=0 |>
<code>
from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float("""
"from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float(""inf"")
for i in range(len(a)):
    t=[0]*n
    temp=0
    j=i-1
    prev =0
    while j>=0:
        x=(ceil((prev+1)/a[j]))
        temp+=x
        prev=(a[j]*x)
        j-=1
    
    k=i+1
    prev=0
    while {{completion}}:
        x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1
    ans=min(ans,temp)
print(int(ans))",k<len(a),"k<n:
        x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1
    ans=min(ans,temp)
print(int(ans))
<|/ a tags=python,algorithm |>
<| a tags=python,algorithm |>
<code>
from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float(""inf"")
for i in range(len(a)):
    t=[0]*n
    temp=0
    j=i-1
    prev =0
    while j>=0:
        x=(ceil((prev+1)/a[j]))
        temp+=x"
"
for _ in range(1):
    n = int(input())
    a = list(map(int, input().split()))
    Min = 1e18
    for l in range(n):
        m = a[l]
        answer = 1
        for i in range(l-1, -1, -1):
            answer += (m + a[i]) // a[i]
            m = a[i] * ((m + a[i]) // a[i])
        if l + 1 < n:
            m = 0
            for {{completion}}:
                answer += (m + a[i]) // a[i]
                m = a[i] * ((m + a[i]) // a[i])
        Min = min(answer, Min)
    print(Min)","i in range(l + 2, n)","k in range(l+1, n):
                m += a[k]
            answer += (m + a[l+1]) // a[l+1]
            m += a[l+1]
            answer += (m + a[l+1]) // a[l+1]
        Min = min(answer, Min)
    print(Min)
<|/ a dscore=0 |>
<| a tags=python,algorithm |>
<code>
for _ in range(1):
    n = int(input())
    a = list(map(int, input().split()))
    Min = 1e18
    for l in range(n):
        m = a[l]
        answer = 1
        for i in range(l-1, -1, -1):
            answer += (m + a[i]) // a[i]
            m = a[i] * ((m + "
"m=int(input())
a=[int(i)for i in input().split()]
t1,min=0,10**20
while(t1<m):
    t2=t1
    k,t=0,0
    while{{completion}}:
        t+=(k//a[t2+1]+1)
        k=a[t2+1]*(k//a[t2+1]+1)
        t2+=1
    t2=t1
    k=0
    while(t2>0):
        t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1
    if(min>t):
        min=t
    t1+=1
print(min)
",(t2<m-1),"(t2<m):
        t+=(k//a[t2+1]+1)
        k=a[t2+1]*(k//a[t2+1]+1)
        t2+=1
    t2=t1
    k=0
    while(t2>0):
        t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1
    if(min>t):
        min=t
    t1+=1
print(min)
'''
<|/ q dscore=0 |>
<| c |>
Please post the code you've tried so far.
<|/ c |>
<| c |>"
"m=int(input())
a=[int(i)for i in input().split()]
t1,min=0,10**20
while(t1<m):
    t2=t1
    k,t=0,0
    while(t2<m-1):
        t+=(k//a[t2+1]+1)
        k=a[t2+1]*(k//a[t2+1]+1)
        t2+=1
    t2=t1
    k=0
    while{{completion}}:
        t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1
    if(min>t):
        min=t
    t1+=1
print(min)
",(t2>0),"(t2<m-1):
        t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1
    if(min>t):
        min=t
    t1+=1
print(min)
<|/ a dscore=0 |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/"
"import math
n = int(input())
a = list(map(int, input().split(' '))) # numbers w/ ws

c = None
d = 0
for i in range(len(a)):
	p = 0
	t = 0
	for {{completion}}:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	t = 0
	for k in reversed(a[:i]):
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	if c == None or p < c:
		c = p

print(c)",k in a[i+1:],"k in a[:i]:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	t = 0
	for k in a[:i]:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	if c == None or p < c:
		c = p

print(c)
<|/ a |>
<| a tags=arrays,algorithm,python,sorting |>
<code>
import math
n = int(input())
a = list(map(int, input().split(' '))) # numbers w/ ws

c = None
d = 0
for i in range(len(a)):
	p = 0
	t = 0
	for "
"import math
n = int(input())
a = list(map(int, input().split(' '))) # numbers w/ ws

c = None
d = 0
for i in range(len(a)):
	p = 0
	t = 0
	for k in a[i+1:]:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	t = 0
	for {{completion}}:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	if c == None or p < c:
		c = p

print(c)",k in reversed(a[:i]),"k in a[:i]:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	if c == None or p < c:
		c = p

print(c)
<|/ file filename=P2.py |>"
"def f(b, i):
    return e(b[::-1], i)

def e(b, i):
    if b == []:
        return 0
    count = 0
    ggg = [0] * len(b)
    for {{completion}}:
        ggg[i] = (b[i - 1] * ggg[i - 1]) // b[i] + 1
        count += ggg[i]
    return count

def c(b, i):
    return e(b[i + 1:], 0) + f(b[:i], 0)

a = int(input())
b = input().split()
for i in range(a):
    b[i] = int(b[i])
d = c(b, 1)
for i in range(2, a - 1):
    d = min(d, c(b, i))
print(d)
",i in range(len(b)),"j in range(len(b)):
        ggg[j] = (b[j] * ggg[j]) // b[j] + 1
        count += ggg[j]
    ggg = [0] * len(b)
    for j in range(len(b)):
        ggg[j] = (b[j] * ggg[j]) // b[j] + 1
        count += ggg[j]
    return count

def g(b, i):
    count = 0
    ggg = [0] * len(b)
    for j in range(len(b)):
        ggg[j] = (b[j] * ggg[j]) // b[j] + 1
        count += ggg[j]
    ggg = [0] * len(b)
    for j in range(len(b)):
        ggg"
"

n=int(input())


a=list(map(int,input().split()))
b=[int(0) for _ in range(n)]
m=1e18
for i in range(n):
    c=0
    p=0
    for {{completion}}:
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i-1,-1,-1):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    m=min(m,c)

print(m)


","j in range(i+1,len(b))","j in range(i):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i+1,n):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i+1,n):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i+1,n):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i+1,n):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i+1,n):
"
"

n=int(input())


a=list(map(int,input().split()))
b=[int(0) for _ in range(n)]
m=1e18
for i in range(n):
    c=0
    p=0
    for j in range(i+1,len(b)):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for {{completion}}:
        p+=a[j]-p%a[j]
        c+=p//a[j]
    m=min(m,c)

print(m)


","j in range(i-1,-1,-1)","j in range(i,0,-1):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    m=min(m,c)

print(m)


n=int(input())


a=list(map(int,input().split()))
b=[int(0) for _ in range(n)]
m=1e18
for i in range(n):
    c=0
    p=0
    for j in range(i+1,len(b)):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i,0,-1):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    m=min(m,c)

print(m)


n=int(input())"
"t=lambda:map(int,input().split())
for {{completion}}:n,m=t();a=[*t()];print(""YNEOS""[sum(a)+max(a)-min(a)+n>m::2])",_ in range(int(input())),"_ in range(int(input())):
    n,m=map(int,input().split())
    a=list(map(int,input().split()))
    print(""YES""[sum(a)+max(a)-min(a)+n>m])
<|/ a dscore=0 |>
<| c |>
Please don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| c |>
Thanks for the suggestion. I will keep that in min"
"for _t in range(int(input())):
	n,m = map(int, input().split(' ')) # numbers w/ ws
	a = sorted(map(int, input().split(' ')))

	tot = 0
	dis = 0
	p_i = a[-1]
	for i in a:
		tot += 2*i+1
		if {{completion}}:
			dis += p_i
		else:
			dis += i
		p_i = i

	if tot-dis <= m:
		print(""YES"")
	else:
		print(""NO"")",p_i < i,"p_i%2 == 1:
			dis += p_i
		else:
			dis += i
		p_i = i

	if tot-dis <= m:
		print(""YES"")
	else:
		print(""NO"")
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
for _t in range(int(input())):
	n,m = map(int, input().split(' ')) # numbers w/ ws
	a = sorted(map(int, input().split(' ')))

	tot = 0
	dis = 0
	p_i = a[-1]
	for i in a:
		tot += 2*i+1
		if p_i%2 == 1:
			di"
"
import sys


def solve():
    n, m = map(int, input().split())
    num = list(map(int , input().split())) 
    num.sort()
    s = sum(num[1:]) + num[-1] + n
    print(""YES"" if s <= m else ""NO"")


for {{completion}}:
    solve()
",_ in range(int(input())),"_ in range(int(input())):
    solve()

<|/ file ext=.py |>"
"import sys
for t in range(int(sys.stdin.readline())):
    n,m = map(int, sys.stdin.readline().strip().split())
    a = list(map(int, sys.stdin.readline().strip().split()))
    if {{completion}}:print('yes')
    else:print('no')",sum(a)-min(a)+max(a) + n <= m,"n>m:
        print('no')
        continue
    if n==m:
        if a[0]==a[1] and a[0]==a[2]:print('yes')
        elif a[0]==a[1] and a[0]==a[3]:print('yes')
        elif a[0]==a[2] and a[0]==a[3]:print('yes')
        elif a[0]==a[1] and a[0]==a[4]:print('yes')
        elif a[0]==a[2] and a[0]==a[4]:print('yes')
        elif a[0]==a[3] and a[0]==a[4]:print('yes')
        elif a[0]==a[1] and a[0]==a"
"x = lambda: map(int,input().split())
t,= x()
for {{completion}}:
    p,n = x()
    a = [*x()]
    s = sum(a) + (p-1) - min(a)
    print(""YNEOS""[n-1-s<max(a)::2])",_ in [1]*t,"_ in range(t):
    x,y = x()
    a,b = x()
    if sum(a)+b-min(a) < max(a):
        print(""YES""[n-1-s<max(a)::2])
    else:
        print(""NO""[n-1-s<max(a)::2])
<|/ a tags=python-3.x,python |>
<| a tags=python-3.x,python |>
<code>
x = lambda: map(int,input().split())
t,= x()
for _ in range(t):
    x,y = x()
    a,b = x()
    if sum(a)+b-min(a) < max(a):
        print(""YES""[n-1-s<max(a"
"def Dist():
    num_nm = input().split()
    m = int(num_nm[1])
    n = int(num_nm[0])
    
    a = input().split()
    a = list(map(int, a))
    
    wish = n + sum(a) - min(a) + max(a) 
    print(""NO"" if wish >m else ""YES"")


num_iter = int(input())
for {{completion}}:
    Dist()
    
    ",_ in range(num_iter),"_ in range(num_iter):
    Dist()
    
<|/ file ext=.py |>"
"for T in range (int(input())) :
    n,m = map(int, input().strip().split())
    a = sorted(list(map(int,input().strip().split())),reverse=True)
    m -= 2*a[0] + 1
    cont = 0
    for i in range(1,n) :
        if {{completion}}: break
        m -= a[i] + 1
        cont +=1

    if cont == n-1 : print('YES')
    else : print ('NO')
",m <= 0 ,a[i] % m == 0 
"I=lambda:[*map(int,input().split())]
t,=I()
while {{completion}}:t-=1;n,m=I();a=sorted(I());print('YNEOS'[sum(max(a[i-1],a[i])for i in range(n))+n>m::2])",t,"t:
    n,m=I()
    a=sorted(I())
    print('YNEOS'[sum(max(a[i-1],a[i])for i in range(n))+n>m::2])
    t-=1
<|/ a dscore=0 |>
<| c |>
Please don't post only code as answer, but also provide an explanation what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| c |>
Thanks for your suggestion. I will keep that in mind.
<|/ "
"for i in range(int(input())):
	n,m=map(int,input().split())
	a=list(map(int,input().split()))
	if {{completion}}:
		print(""no"")
	else:
		print(""yes"")",n+sum(a)+max(a)-min(a)>m,"n>m:
		print(""no"")
	else:
		for i in range(n):
			j=a[i]%m
			if j<(a[i]-a[i]%m)%m:
				print(""no"")
				break
			else:
				print(""yes"")
<|/ a |>
<| a dscore=0 tags=python-3.x,python |>
<code>
for i in range(int(input())):
	n,m=map(int,input().split())
	a=list(map(int,input().split()))
	if n>m:
		print(""no"")
	else:
		for i in range(n):
			j=a[i]%m
			if j<(a[i]-a[i]%m)%m:"
"from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


MOD = 998244353
input = stdin.readline
finp = [int(x) for x in stdin.buffer.read().split()]

def inp(force_list=False):
    re = list(map(int, input().split()))
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def qmod(a, b, mod=MOD):
    res = 1
    while b:
        if b&1:
            res = (res*a)%mod
        b >>= 1
        a = (a*a)%mod
    return res

def inv(a):
    return qmod(a, MOD-2)

INF = 1<<30

class Seg(object):
    def __init__(self, n):
        self._da = [-INF] * (n * 5)
        self._op = [-INF] * (n * 5)

    def update(self, p):
        self._op[p] = max(self._op[p*2], self._op[p*2+1])

    def modify(self, pos, x, p, l, r):
        if l==r-1:
            self._da[p] = self._op[p] = x
            return
        mid = (l+r)//2
        if pos < mid:
            self.modify(pos, x, p*2, l, mid)
        else:
            self.modify(pos, x, p*2 + 1, mid, r)
        self.update(p)

    def query(self, x, y, p, l, r):
        if x <= l and r <= y:
            return self._op[p]
        if x >= r or y<=l:
            return -INF
        mid = (l+r)//2
        return max(self.query(x, y, p*2, l, mid), self.query(x, y, p*2+1, mid, r))


class Fenwick(object):
    def __init__(self, n):
        self._da = [-INF] * (n+2)
        self._mx = n+2

    def max(self, x):
        res = -INF
        while {{completion}}:
            res = max(res, self._da[x])
            x = (x&(x+1))-1
        return res

    def modify(self, p, x):
        while p < self._mx:
            self._da[p] = max(self._da[p], x)
            p |= p+1

def my_main():
    # print(500000)
    # for i in range(500000):
    #     print(1)
    #     print(-1000000000)
    ii = 0 
    kase = finp[ii];ii+=1
    pans = []
    for skase in range(kase):
        # print(""Case #%d: "" % (skase+1), end='')
        n = finp[ii];ii+=1
        da = finp[ii:ii+n];ii+=n
        pref = [0]
        for i in da:
            pref.append(pref[-1] + i)
        spos, sneg = sorted([(pref[i], -i) for i, v in enumerate(pref)]), sorted([(pref[i], i) for i, v in enumerate(pref)])
        ordpos, ordneg = [0] * (n+1), [0] * (n+1)
        pfen, nfen = Fenwick(n), Fenwick(n)
        dmx = {}
        for i in range(n+1):
            ordpos[-spos[i][-1]] = i
            ordneg[sneg[i][-1]] = i
        dp = [0] * (n+1)
        dmx[0] = 0
        pfen.modify(ordpos[0], 0)
        nfen.modify(n+1-ordneg[0], 0)
        for i in range(1, n+1):
            dp[i] = max(i+pfen.max(ordpos[i]), nfen.max(n+1-ordneg[i])-i, dmx.get(pref[i], -INF))
            pfen.modify(ordpos[i], dp[i]-i)
            nfen.modify(n+1-ordneg[i], dp[i]+i)
            if dp[i] > dmx.get(pref[i], -INF):
                dmx[pref[i]] = dp[i]
        pans.append(str(dp[n]))
    print('\n'.join(pans))


my_main()


",x>0,"x > 0:
            res -= self._da[x]
            x -= x&(x+1)
        return res

    def update(self, p):
        self._da[p] = self._da[p*2] + self._da[p*2+1]

    def query(self, x, y, p):
        if x <= p or y <= p:
            return self._da[p]
        mid = (p+y)//2
        return max(self.query(x, y, p*2), self.query(x, y, p*2+1), self.query(x, y, mid))

    def querymax(self, x):
        res = -INF
        x = (x&(x+1))-1
        while x > 0:
            res -= self._da[x]
            x -= x&(x+1)
        return res

    def "
"from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


MOD = 998244353
input = stdin.readline
finp = [int(x) for x in stdin.buffer.read().split()]

def inp(force_list=False):
    re = list(map(int, input().split()))
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def qmod(a, b, mod=MOD):
    res = 1
    while b:
        if b&1:
            res = (res*a)%mod
        b >>= 1
        a = (a*a)%mod
    return res

def inv(a):
    return qmod(a, MOD-2)

INF = 1<<30

class Seg(object):
    def __init__(self, n):
        self._da = [-INF] * (n * 5)
        self._op = [-INF] * (n * 5)

    def update(self, p):
        self._op[p] = max(self._op[p*2], self._op[p*2+1])

    def modify(self, pos, x, p, l, r):
        if l==r-1:
            self._da[p] = self._op[p] = x
            return
        mid = (l+r)//2
        if pos < mid:
            self.modify(pos, x, p*2, l, mid)
        else:
            self.modify(pos, x, p*2 + 1, mid, r)
        self.update(p)

    def query(self, x, y, p, l, r):
        if x <= l and r <= y:
            return self._op[p]
        if x >= r or y<=l:
            return -INF
        mid = (l+r)//2
        return max(self.query(x, y, p*2, l, mid), self.query(x, y, p*2+1, mid, r))


class Fenwick(object):
    def __init__(self, n):
        self._da = [-INF] * (n+2)
        self._mx = n+2

    def max(self, x):
        res = -INF
        while x>0:
            res = max(res, self._da[x])
            x = (x&(x+1))-1
        return res

    def modify(self, p, x):
        while {{completion}}:
            self._da[p] = max(self._da[p], x)
            p |= p+1

def my_main():
    # print(500000)
    # for i in range(500000):
    #     print(1)
    #     print(-1000000000)
    ii = 0 
    kase = finp[ii];ii+=1
    pans = []
    for skase in range(kase):
        # print(""Case #%d: "" % (skase+1), end='')
        n = finp[ii];ii+=1
        da = finp[ii:ii+n];ii+=n
        pref = [0]
        for i in da:
            pref.append(pref[-1] + i)
        spos, sneg = sorted([(pref[i], -i) for i, v in enumerate(pref)]), sorted([(pref[i], i) for i, v in enumerate(pref)])
        ordpos, ordneg = [0] * (n+1), [0] * (n+1)
        pfen, nfen = Fenwick(n), Fenwick(n)
        dmx = {}
        for i in range(n+1):
            ordpos[-spos[i][-1]] = i
            ordneg[sneg[i][-1]] = i
        dp = [0] * (n+1)
        dmx[0] = 0
        pfen.modify(ordpos[0], 0)
        nfen.modify(n+1-ordneg[0], 0)
        for i in range(1, n+1):
            dp[i] = max(i+pfen.max(ordpos[i]), nfen.max(n+1-ordneg[i])-i, dmx.get(pref[i], -INF))
            pfen.modify(ordpos[i], dp[i]-i)
            nfen.modify(n+1-ordneg[i], dp[i]+i)
            if dp[i] > dmx.get(pref[i], -INF):
                dmx[pref[i]] = dp[i]
        pans.append(str(dp[n]))
    print('\n'.join(pans))


my_main()


",p < self._mx,p>
"import sys
input = sys.stdin.readline

n = int(input())

o1 = [0] * (n * n)
o2 = [0] * (n * n)
for i in range(n):
    curr = (list(map(int, input().split())))

    for {{completion}}:
        o1[curr[j] - 1] = i
        o2[curr[j] - 1] = j
        

row_count = [0] * n
col_count = [0] * n

ct = 0

for u in range(n * n):
    i = o1[u]
    j = o2[u]

    ct += row_count[i] * col_count[j]

    row_count[i] += 1
    col_count[j] += 1


n2 = (n * n - n)//2

ct -= n2 * n2

print(n2 * n2 - ct)
",j in range(n),"j in range(n):
        if i != j and curr[j] > curr[i]:
            o1[curr[j] - 1] = i
            o2[curr[j] - 1] = j
        elif i == j and curr[j] > curr[i]:
            o1[curr[j] - 1] = i
            o2[curr[j] - 1] = j
        elif j != i and curr[j] > curr[i]:
            o1[curr[j] - 1] = i
            o2[curr[j] - 1] = j
        elif i == j and curr[j] < curr[i]:
            o1[curr[j] - 1] = i
            o2[curr[j] - 1] = j
        elif j != i and curr[j] < curr[i]:
            o1["
"import sys
import random

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N = int(input())
As = [list(map(int, input().split())) for _ in range(N)]

# N = 1500
# As = list(range(1, N ** 2 + 1))
# random.shuffle(As)
# As = [As[i * N:(i + 1) * N] for i in range(N)]

ijs = [0] * (N ** 2)
for i in range(N):
    for {{completion}}:
        ijs[As[i][j] - 1] = (i, j)

answer = 0
row_sum = [0] * N
col_sum = [0] * N
for i, j in ijs:
    l_row = row_sum[i]
    g_row = N - 1 - row_sum[i]
    l_col = col_sum[j]
    g_col = N - 1 - col_sum[j]
    answer += l_col * g_row + g_col * l_row
    row_sum[i] += 1
    col_sum[j] += 1

assert answer % 2 == 0
print(answer // 2)
",j in range(N),"j in range(N):
        if As[i][j] > N ** 2 - 1:
            ijs[As[i][j] - N ** 2 + 1] = (i, j)
        elif As[i][j] < 0:
            ijs[As[i][j] + 1] = (i, j)
        elif As[i][j] == "
"import sys
import bisect

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N, V = map(int, input().split())
Ts = list(map(int, input().split()))
As = list(map(int, input().split()))

points = []
for T, A in zip(Ts, As):
    B = T * V
    x = B - A
    y = B + A
    if {{completion}}:
        continue
    points.append((x, y))

points.sort()
# print(points)

lis = []
for _, w in points:
    index = bisect.bisect_right(lis, w)
    if index < len(lis):
        lis[index] = w
    else:
        lis.append(w)

print(len(lis))

",x < 0 or y < 0,x < 0 or y < 0 or x > N or y > N
"import sys
import bisect

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N, V = map(int, input().split())
Ts = list(map(int, input().split()))
As = list(map(int, input().split()))

points = []
for T, A in zip(Ts, As):
    B = T * V
    x = B - A
    y = B + A
    if x < 0 or y < 0:
        continue
    points.append((x, y))

points.sort()
# print(points)

lis = []
for _, w in points:
    index = bisect.bisect_right(lis, w)
    if {{completion}}:
        lis[index] = w
    else:
        lis.append(w)

print(len(lis))

",index < len(lis),index != len(lis) and lis[index] == w
"from bisect import bisect_right,bisect_left
n,v = map(int,input().split())
t = [*map(int,input().split())]
a = [*map(int,input().split())]
res = []
for i in range(n):
    xi,yi = t[i]*v+a[i],t[i]*v-a[i]
    if{{completion}}:
        res.append((xi,yi))
res.sort()
dp = [float(""inf"")]*(n+3)
dp[0] = 0
dp[n+2] = 0
for i in range(len(res)):
    pos = bisect_right(dp,res[i][1],0,n+2)
    dp[pos] = res[i][1]
for i in range(n,-1,-1):
    if(dp[i]!=float(""inf"")):
        print(i)
        break",(xi>=0 and yi>=0),"(xi>=0 and yi>=0):
        xi,yi = xi+v,yi+v
    if(xi<0 and yi>=0):
        xi,yi = xi+-v,yi+-v
    if(xi>=0 and yi<0):
        xi,yi = xi+v,yi+-v
    if(xi<0 and yi<0):
        xi,yi = xi+-v,yi+v
    if(xi>=0 and yi>=0):
        xi,yi = xi+v,yi+v
    if(xi<0 and yi>=0):
        xi,yi = xi+-v,yi+-v
    if(xi>=0 and yi<0):
"
"from bisect import bisect_right,bisect_left
n,v = map(int,input().split())
t = [*map(int,input().split())]
a = [*map(int,input().split())]
res = []
for i in range(n):
    xi,yi = t[i]*v+a[i],t[i]*v-a[i]
    if(xi>=0 and yi>=0):
        res.append((xi,yi))
res.sort()
dp = [float(""inf"")]*(n+3)
dp[0] = 0
dp[n+2] = 0
for i in range(len(res)):
    pos = bisect_right(dp,res[i][1],0,n+2)
    dp[pos] = res[i][1]
for i in range(n,-1,-1):
    if{{completion}}:
        print(i)
        break","(dp[i]!=float(""inf""))","(i>0):
        dp[i] = dp[i-1]
print(dp[n])
<|/ a tags=python,algorithm |>
<| c |>
Thank you so much for your answer. I tried your code, but I got this error: `IndexError: list index out of range`. I think it's because of the `dp` array. I don't know why it happens.
<|/ c |>
<| c |>
I fixed the error, but I got this error: `RuntimeWarning: divide by zero encountered in long_scalars`. Do you know why?
<|/ c |>
<| c |>
I fixed the error, but I got this error"
"t = int(input())
for _ in range(t):

    field = [[0 for _ in range(2*360)] for _ in range(42)]
    vis = [[False for _ in range(2*360)] for _ in range(42)]
    
    n = int(input())
    for _ in range(n):

        line = input().split()
        a, b, c = map(int, line[1:])

        if line[0] == ""C"":
            y = 2*a

            x = 2*b
            while x != 2*c:
                field[y][x] = -1
                x = (x + 1) % 720

            field[y][x] = -1
        else:
            x = 2*c

            for y in range(2*a, 2*b+1):
                field[y][x] = -1


    # for row in field: print(*row)

    def check():
        st = [(0, 0)]

        while st:
            y, x = st.pop(-1)

            x = (x + 720) % 720
            if y < 0 or y >= 42 or field[y][x] < 0: continue

            if vis[y][x]: continue
            vis[y][x] = True

            if y > 40: return True

            for ny in range(y-1, y+1+1):
                for {{completion}}:
                    st.append((ny, nx))

        return False

    print(""YES"" if check() else ""NO"")
","nx in range(x-1, x+1+1)","nx in range(x-1, x+1+1):
                    if field[ny][nx] == -1 and vis[ny][nx] == False"
"t = int(input())
for _ in range(t):

    field = [[0 for _ in range(2*360)] for _ in range(42)]
    vis = [[False for _ in range(2*360)] for _ in range(42)]
    
    n = int(input())
    for _ in range(n):

        line = input().split()
        a, b, c = map(int, line[1:])

        if line[0] == ""C"":
            y = 2*a

            x = 2*b
            while x != 2*c:
                field[y][x] = -1
                x = (x + 1) % 720

            field[y][x] = -1
        else:
            x = 2*c

            for {{completion}}:
                field[y][x] = -1


    # for row in field: print(*row)

    def check():
        st = [(0, 0)]

        while st:
            y, x = st.pop(-1)

            x = (x + 720) % 720
            if y < 0 or y >= 42 or field[y][x] < 0: continue

            if vis[y][x]: continue
            vis[y][x] = True

            if y > 40: return True

            for ny in range(y-1, y+1+1):
                for nx in range(x-1, x+1+1):
                    st.append((ny, nx))

        return False

    print(""YES"" if check() else ""NO"")
","y in range(2*a, 2*b+1)","y in range(42):
                if field[y][x] == -1: continue
                if field[y][x] == -2: continue
                if field[y][x] == -3: continue
                if field[y][x] == -4: continue
                if field[y][x] == -5: continue
                if field[y][x] == -6: continue
                if field[y][x] == -7: continue
                if field[y][x] == -8: continue
                if field[y][x] == -9: continue
                if field[y][x] == -10: continue
                if field[y][x] == -11: continue
                if field[y][x] == -12: continue
                if field[y"
"from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited

for tc in range(int(input())):
    graph = {}
    for r in range(0, 22):
        for angle in range(0, 360):
            graph[(r,angle)] = set([
                (r, (angle+1)%360),
                (r, (angle-1)%360)])
            if r < 21:
                graph[(r,angle)].add((r+1, angle))
            if r > 0:
                graph[(r,angle)].add((r-1, angle))
    nwalls = int(input())
    for wallid in range(nwalls):
        typ, a, b, c = input().split()
        if typ == 'C':
            rad, t1, t2 = map(int, (a,b,c))
            th = t1
            while th != t2:
                graph[(rad, th)].remove((rad-1, th))
                graph[(rad-1, th)].remove((rad, th))
                th = (th + 1) % 360
                #print(th)
                #print((rad, th%360), (rad-1, th%360))
        else:
            r1, r2, th = map(int, (a,b,c))
            for {{completion}}:
                graph[(rad, th)].remove((rad, (th-1)%360))
                graph[(rad, (th-1)%360)].remove((rad, th))
        
    if (0,0) in bfs(graph, (21, 0)):
        print('YES')
    else:
        print('NO')
","rad in range(r1, r2)","th in range(th):
                graph[(rad, th)].remove((rad, th))
                graph[(rad, th)].remove((rad-1, th))
                graph[(rad-1, th)].remove((rad, th))
            while r1 < r2:
                graph[(rad, th)].remove((rad, (th+1)%360))
                graph[(rad, (th+1)%360)].remove((rad, th))
            while r1 > r2:
                graph[(rad, th)].remove((rad, (th-1)%360))
                graph[(rad, (th-1)%360)].remove((rad, "
"from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited

for tc in range(int(input())):
    graph = {}
    for r in range(0, 22):
        for angle in range(0, 360):
            graph[(r,angle)] = set([
                (r, (angle+1)%360),
                (r, (angle-1)%360)])
            if {{completion}}:
                graph[(r,angle)].add((r+1, angle))
            if r > 0:
                graph[(r,angle)].add((r-1, angle))
    nwalls = int(input())
    for wallid in range(nwalls):
        typ, a, b, c = input().split()
        if typ == 'C':
            rad, t1, t2 = map(int, (a,b,c))
            th = t1
            while th != t2:
                graph[(rad, th)].remove((rad-1, th))
                graph[(rad-1, th)].remove((rad, th))
                th = (th + 1) % 360
                #print(th)
                #print((rad, th%360), (rad-1, th%360))
        else:
            r1, r2, th = map(int, (a,b,c))
            for rad in range(r1, r2):
                graph[(rad, th)].remove((rad, (th-1)%360))
                graph[(rad, (th-1)%360)].remove((rad, th))
        
    if (0,0) in bfs(graph, (21, 0)):
        print('YES')
    else:
        print('NO')
",r < 21,"angle > 0:
                graph[(r,angle)].add((r+1, angle))
            if angle < 90:
                graph[(r,angle)].add((r-1, angle))
    nwalls = int(input())
    for wallid in range(nwalls):
        typ, a, b, c = input().split()
        if typ == 'C':
            rad, t1, t2 = map(int, (a,b,c))
            th = t1
            while th != t2:
                graph[(rad, th)].remove((rad-1, th))
                graph[(rad-1, th)].remove((rad, th))
                th = (th + 1) % 360
        else:
"
"from itertools import islice, chain
from sys import stdin

MAX_RADIUS = 20

lines = iter(stdin.readlines()[1:])

for line in lines:
    n = int(line)
    circular_wall, straight_wall = ([[False] * 360 for _ in range(MAX_RADIUS)] for _ in range(2))
    for shape, *params in map(str.split, islice(lines, n)):
        params = map(int, params)
        if shape == 'C':
            r, theta_1, theta_2 = params
            r -= 1
            theta_range = range(theta_1, theta_2) if theta_1 <= theta_2 \
                else chain(range(theta_1, 360), range(0, theta_2))
            for theta in theta_range:
                circular_wall[r][theta] = True
        else:
            assert shape == 'S'
            r1, r2, theta = params
            r1 -= 1
            r2 -= 1
            for {{completion}}:
                straight_wall[r][theta] = True

    queue = [(0, i) for i, inner_wall in enumerate(circular_wall[0]) if not inner_wall]
    seen = set(queue)
    while queue:
        row, col = queue.pop()
        # print(row, col)
        neighbors = []
        if row >= 1 and not circular_wall[row][col]:
            neighbors.append((row - 1, col))
        right_col = (col + 1) % 360
        if not straight_wall[row][right_col]:
            neighbors.append((row, right_col))
        if not straight_wall[row][col]:
            neighbors.append((row, (col - 1) % 360))
        next_row = row + 1
        if not circular_wall[next_row][col]:
            if next_row == MAX_RADIUS - 1:
                print('YES')
                break
            neighbors.append((next_row, col))

        for neighbor in neighbors:
            if neighbor in seen:
                continue
            queue.append(neighbor)
            seen.add(neighbor)
    else:  # no break
        print('NO')
","r in range(r1, r2)","r in range(r1, r2 + 1):
                circular_wall[r][theta] = True
                circular_wall[r][(theta + 180) % 360] = True
                circular_wall[r][(theta - 180) % 360] = True
            for r in range(r2, r1 + 1):
                circular_wall[r][theta] = True
                circular_wall[r][(theta + 180) % 360] = True
                circular_wall[r][(theta - 180) % 360] = True
            for r in range(r1, r2 + 1):
                circular_wall[r][theta] = True
                circular_wall[r][(theta + 180) % 360] = True"
"from itertools import islice, chain
from sys import stdin

MAX_RADIUS = 20

lines = iter(stdin.readlines()[1:])

for line in lines:
    n = int(line)
    circular_wall, straight_wall = ([[False] * 360 for _ in range(MAX_RADIUS)] for _ in range(2))
    for shape, *params in map(str.split, islice(lines, n)):
        params = map(int, params)
        if shape == 'C':
            r, theta_1, theta_2 = params
            r -= 1
            theta_range = range(theta_1, theta_2) if theta_1 <= theta_2 \
                else chain(range(theta_1, 360), range(0, theta_2))
            for {{completion}}:
                circular_wall[r][theta] = True
        else:
            assert shape == 'S'
            r1, r2, theta = params
            r1 -= 1
            r2 -= 1
            for r in range(r1, r2):
                straight_wall[r][theta] = True

    queue = [(0, i) for i, inner_wall in enumerate(circular_wall[0]) if not inner_wall]
    seen = set(queue)
    while queue:
        row, col = queue.pop()
        # print(row, col)
        neighbors = []
        if row >= 1 and not circular_wall[row][col]:
            neighbors.append((row - 1, col))
        right_col = (col + 1) % 360
        if not straight_wall[row][right_col]:
            neighbors.append((row, right_col))
        if not straight_wall[row][col]:
            neighbors.append((row, (col - 1) % 360))
        next_row = row + 1
        if not circular_wall[next_row][col]:
            if next_row == MAX_RADIUS - 1:
                print('YES')
                break
            neighbors.append((next_row, col))

        for neighbor in neighbors:
            if neighbor in seen:
                continue
            queue.append(neighbor)
            seen.add(neighbor)
    else:  # no break
        print('NO')
",theta in theta_range,theta in theta_range
"from itertools import chain
from sys import stdin

(n, m), population, shops = [[int(x) for x in line.split()] for line in stdin.readlines()]
shops.sort()
shops = chain([float('-inf')], (v / 100 for v in shops), [float('inf')])

shop_left, shop_right = next(shops), next(shops)
hut_left_idx = max_score = score = 0
for hut_right_idx, hut_right_score in enumerate(population):
    score += hut_right_score
    # print(f'{score=}')
    while {{completion}}:
        shop_left, shop_right = shop_right, next(shops)
    # print(f'{hut_right_idx=} {shop_left=} {shop_right=}')
    shop_delta = shop_right - shop_left
    while shop_left >= hut_left_idx or 2 * (hut_right_idx - hut_left_idx) >= shop_delta:
        score -= population[hut_left_idx]
        hut_left_idx += 1
    # print(f'{score=} {hut_left_idx=} {hut_right_idx=} {shop_delta=}')
    if score > max_score:
        max_score = score
print(max_score)
",shop_right <= hut_right_idx,"hut_left_idx <= hut_right_idx and hut_right - hut_left > shops[hut_left_idx] - shop_left:
        score -= population[hut_left_idx]
        hut_left_idx += 1
    while hut_left_idx <= hut_right_idx and hut_right - hut_left < shops[hut_left_idx] - shop_right:
        score += population[hut_left_idx]
        hut_left_idx += 1
    while hut_left_idx <= hut_right_idx and hut_right - hut_left == shops[hut_left_idx] - shop_left and hut_right - hut_left == shop"
"from itertools import chain
from sys import stdin

(n, m), population, shops = [[int(x) for x in line.split()] for line in stdin.readlines()]
shops.sort()
shops = chain([float('-inf')], (v / 100 for v in shops), [float('inf')])

shop_left, shop_right = next(shops), next(shops)
hut_left_idx = max_score = score = 0
for hut_right_idx, hut_right_score in enumerate(population):
    score += hut_right_score
    # print(f'{score=}')
    while shop_right <= hut_right_idx:
        shop_left, shop_right = shop_right, next(shops)
    # print(f'{hut_right_idx=} {shop_left=} {shop_right=}')
    shop_delta = shop_right - shop_left
    while {{completion}}:
        score -= population[hut_left_idx]
        hut_left_idx += 1
    # print(f'{score=} {hut_left_idx=} {hut_right_idx=} {shop_delta=}')
    if score > max_score:
        max_score = score
print(max_score)
",shop_left >= hut_left_idx or 2 * (hut_right_idx - hut_left_idx) >= shop_delta,"hut_left_idx < hut_right_idx and hut_left_idx < n - 1 and hut_right_idx < m - 1:
        if population[hut_left_idx] <= population[hut_right_idx]:
            score -= population[hut_left_idx]
            hut_left_idx += 1
        else:
            score += population[hut_right_idx]
            hut_right_idx += 1
    if score > max_score:
        max_score = score
print(max_score)
'''
from itertools import chain
from sys import stdin

(n, m), population, shops = [[int(x) for x in line.split()] for line in stdin.readlines()]
shops.sort()
shops = chain([float('-inf')], (v"
"n,m=map(int,input().split())
p=list(map(int,input().split()))
x=sorted(list(map(int,input().split())))
s=sum(p[:-(-(x[0])//100)])
for i in range(len(x)-1):
    if x[i]//100+1>=n:
       break
    num=int(((x[i+1]-x[i])/2)//(100)+1)
    l=x[i]//100+1
    r=-(-(x[i+1])//100)
    r=min(r,n)
    prefs=0
    if {{completion}}:
        prefs=sum(p[l:l+num])
        s=max(s,prefs)
    while l+num<r:
        prefs-=p[l]
        prefs+=p[l+num] if l+num<n else 0
        s=max(s,prefs)
        l+=1
s=max(s,sum(p[x[-1]//100+1:]))
print(s)",l+num<=r,"l<r:
        prefs=sum(p[l:r])
        s=max(s,prefs)
    else:
        prefs=sum(p[l:n])
        s=max(s,prefs)
    while l<r and l+num<n:
        prefs-=p[l]
        prefs+=p[l+num] if l+num<n else 0
        s=max(s,prefs)
        l+=1
    if l+num<n:
        prefs=sum(p[l:n])
        s=max(s,prefs)
    else:
        prefs=sum(p[l:r])
        s=max(s,prefs)
"
"N, M = [int(x) for x in input().split()]
hut = [int(x) for x in input().split()]
shop = [int(x) for x in input().split()]
shop = sorted([-1e9] + shop + [1e9])
events = []
j = 0
for i in range(N):
  while {{completion}}:
    j += 1
  if shop[j] != 100 * i:
    d = min(100*i - shop[j-1], shop[j] - 100*i)
    events.append((100*i-d, hut[i]))
    events.append((100*i+d, -hut[i]))
events.sort()
cont = 0
max = 0
for a in events:
    cont += a[1]
    if cont > max:
        max = cont
print(max)
",shop[j] < 100*i,"j != i and shop[j] == 100 * i + hut[i]:
    j += 1
  if j != i and shop[j] != 100 * i + hut[i]:
    d = min(100*i + hut[i] - shop[j-1], shop[j] - 100*i + hut[i])
    events.append((100*i+d, hut[i]))
    events.append((100*i-d, -hut[i]))
events.sort()
cont = 0
max = 0
for a in events:
    cont += a[1]
    if cont > max:
        max = cont
print(max)
""""""
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>"
"N, M = [int(x) for x in input().split()]
hut = [int(x) for x in input().split()]
shop = [int(x) for x in input().split()]
shop = sorted([-1e9] + shop + [1e9])
events = []
j = 0
for i in range(N):
  while shop[j] < 100*i:
    j += 1
  if {{completion}}:
    d = min(100*i - shop[j-1], shop[j] - 100*i)
    events.append((100*i-d, hut[i]))
    events.append((100*i+d, -hut[i]))
events.sort()
cont = 0
max = 0
for a in events:
    cont += a[1]
    if cont > max:
        max = cont
print(max)
",shop[j] != 100 * i,j == N
"from math import sqrt, floor
from sys import stdin

data = [int(x) for x in stdin.read().split()[1:]]
res = []
for w, l in zip(data[::2], data[1::2]):
    half_perimeter = w + l - 2
    solutions = {1, 2}
    for i in range(2, floor(sqrt(half_perimeter)) + 1):
        div, mod_i = divmod(half_perimeter, i)
        if mod_i != 0:
            continue
        for a in [i, div]:
            mod_a = w % a
            if {{completion}}:
                assert (l - 2 + mod_a) % a == 0
                solutions.add(a)
    res.append(f""{len(solutions)} {' '.join(map(str, sorted(solutions)))}"")
print('\n'.join(res))
",mod_a <= 2,"mod_a != 0 and mod_a != a:
                continue
            if mod_a == 0 and a != div"
"t = int(input())
for _ in range(t):
    a, b, c, d = [int(i) for i in input().split()]
    s = input()
    if s.count('A') != a+c+d:
        print(""NO"")
        continue
    ult = 'X'
    k = 0
    z = []
    for x in s:
        if x == ult:
            z.append((k, ult))
            k = 1
        else:
            ult = x
            k += 1
    z.append((k, ult))
    r = 0
    z.sort()
    for k,v in z:
        if k % 2 == 0:
            if v == 'A' and d >= k//2:
                d -= k//2
            elif {{completion}}:
                c -= k//2
            else:
                r += k//2 - 1
        else:
            r += k//2
    print(""YES"" if r >= c+d else ""NO"")",v == 'B' and c >= k//2,"v == 'B' and c >= k//2:
                c -= k//2
            elif v == 'AB' and r >= k//2:
                r -= k//2
            elif v == 'BA' and r >= k//2:
                r -= k//2
            elif v == 'A' and c >= k//2:
                c -= k//2
            elif v == 'B' and d >= k//2:
                d -= k//2
            elif v == 'AB' and c >= k//2:
                c -= k//2
            elif v == 'BA' and d >= k//2:
                d -= k//2
            elif v == 'A' and "
"def canmake(s,a,b,c,d):
    anum = s.count('A')
    bnum = s.count('B')

    cnum = s.count('AB')
    dnum = s.count('BA')

    if cnum < c or dnum < d or anum != a + c + d or bnum != b + c + d:
        return False

    n=len(s)

    ans=0

    abls=[]
    bals=[]
    l=0
    while l<n:
        while l<n-1 and  s[l]==s[l+1]:
            l+=1

        r=l
        while {{completion}}:
            r+=1

        if s[l]== s[r]=='B':
            ans+=(r-l+1)//2
        if s[l]==s[r]=='A':
            ans+=(r-l+1)//2

        if s[l]=='A' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='B' and s[r]=='A':
            bals.append((r-l+1)//2)


        l=r+1
    abls.sort()
    bals.sort()

    for i in abls:
        if i<=c:
            c-=i
        else:

            d-=i-c-1
            c = 0

    for i in bals:
        if i<=d:
            d-=i
        else:

            c-=i-d-1
            d = 0



    return (c+d)<=ans


t=int(input())

for _ in range(t):
    a,b,c,d=[int(x) for x  in input().split()]
    s=input()
    res=canmake(s,a,b,c,d)
    if res:
        print('YES')
    else:
        print('NO')",r<n-1 and s[r]!=s[r+1],r<n and s[r]==s[r-1]
"def canmake(s,a,b,c,d):
    anum = s.count('A')
    bnum = s.count('B')

    cnum = s.count('AB')
    dnum = s.count('BA')

    if cnum < c or dnum < d or anum != a + c + d or bnum != b + c + d:
        return False

    n=len(s)

    ans=0

    abls=[]
    bals=[]
    l=0
    while l<n:
        while l<n-1 and  s[l]==s[l+1]:
            l+=1

        r=l
        while r<n-1 and s[r]!=s[r+1]:
            r+=1

        if {{completion}}:
            ans+=(r-l+1)//2
        if s[l]==s[r]=='A':
            ans+=(r-l+1)//2

        if s[l]=='A' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='B' and s[r]=='A':
            bals.append((r-l+1)//2)


        l=r+1
    abls.sort()
    bals.sort()

    for i in abls:
        if i<=c:
            c-=i
        else:

            d-=i-c-1
            c = 0

    for i in bals:
        if i<=d:
            d-=i
        else:

            c-=i-d-1
            d = 0



    return (c+d)<=ans


t=int(input())

for _ in range(t):
    a,b,c,d=[int(x) for x  in input().split()]
    s=input()
    res=canmake(s,a,b,c,d)
    if res:
        print('YES')
    else:
        print('NO')",s[l]== s[r]=='B',"s[l]==s[r]=='B':
            ans+=(r-l+1)//2
        if s[l]==s[r]=='A':
            ans+=(r-l+1)//2

        if s[l]=='B' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='B' and s[r]=='A':
            bals.append((r-l+1)//2)

        if s[l]=='A' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='A' and s[r]=='A':
            bals.append((r"
"for _ in range(int(input())):
    a,b,ab,ba=map(int,input().split());s=input()
    if s.count('A')!=a+ab+ba:print('NO');continue
    stack=[[1,s[0]]]
    for i in range(1,len(s)):
        if stack[-1][1]!=s[i]:
            x=stack.pop()
            stack.append([x[0]+1,s[i]])
        else: stack.append([1,s[i]])
    stack.sort();trash=0
    for val,ele in stack:
        if not val%2:
            if ele=='A' and ba>=val//2:ba-=(val//2)
            elif {{completion}}:ab-=(val//2)
            else:trash+=(val//2-1)
        else:
            trash+=(val//2)
    print('YES' if trash>=ab+ba else 'NO')",ele=='B' and ab>=val//2,"ele=='B' and ab>=val//2:ab-=(val//2)
            elif ele=='AB' and ab>=val//2:ab-=(val//2)
            elif ele=='BA' and ba>=val//2:ba-=(val//2)
            elif ele=='A' and ab>=val//2:ab-=(val//2)
            elif ele=='B' and ba>=val//2:ba-=(val//2)
            elif ele=='AB' and ab>=val//2:ab-=(val//2)
            elif ele=='BA' and ba>=val//2:ba-=(val//2)
            elif ele=='A' and ba>=val//2:"
"import sys,os,io
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
input = sys.stdin.readline

for _ in range (int(input())):
    c = [int(i) for i in input().split()]
    s = list(input().strip())
    if s.count('A') != c[0] + c[2] + c[3] or s.count('B') != c[1] + c[2] + c[3]:
        print(""NO"")
        continue
    n = len(s)
    a = [[s[0]]]
    for i in range (1,n):
        if s[i]==s[i-1]:
            a.append([s[i]])
        else:
            a[-1].append(s[i])
    extra = 0
    for i in a:
        if len(i)%2:
            c[ord(i[0]) - ord('A')] -= 1
            extra += len(i)//2
    
    a.sort(key = lambda x: len(x))
    
    for i in a:
        if len(i)%2==0:
            cnt = len(i)//2
            if {{completion}}:
                c[2 + ord(i[0]) - ord('A')]-=cnt
            else:
                extra += cnt - 1              
    if min(c)<0 or extra < c[2]+c[3]:
        print(""NO"")
    else:
        print(""YES"")",cnt <= c[2 + ord(i[0])-ord('A')],"ord(i[0]) - ord('A') < ord(i[1]) - ord('A'):
                c[2 + ord(i[0]) - ord('A')]+=cnt
            elif ord(i[0]) - ord('A') > ord(i[1]) - ord('A'):
                c[2 + ord(i[1]) - ord('A')]+=cnt
            elif ord(i[1]) - ord('A') < ord(i[0]) - ord('A'):
                c[2 + ord(i[1]) - ord('A')]-=cnt
            elif ord(i[1]) - ord('A') > ord(i[0]) - ord('A'):
                c[2 + ord(i[0]) - ord('A')]-=cnt
            else:
                extra += cnt - 1"
"import sys
import math

def do_test():

    a,b,ab,ba = map(int, input().split())
    S = input().strip()
    n = len(S)
    
    ac = 0
    for i in S:
        if i == 'A':
            ac += 1

    if (ac != a + ab + ba):
        return ""NO""

    

    a_parts = []
    b_parts = []
    ab_total = 0

    l = 0
    f = -1
    p = S[0]
    S = S + S[n-1]
    
    for i in S:
        
        if i == p:
            
            if l > 1:
                if l % 2 == 1:
                    ab_total += l // 2
                elif {{completion}}:
                    a_parts.append(l // 2)
                else:
                    b_parts.append(l // 2)
                
            l = 1
            f = i
        else:
            l += 1

        p = i

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = i
        if ba >= k:
            ba -= k
        else:
            k -= ba
            ba = 0
            if ab > 0:
                ab -= k-1

    if ab + ba > ab_total:
        return ""NO""

    return ""YES""               
                

    
    

input = sys.stdin.readline
t = int(input())
for _test_ in range(t):
    print(do_test())

    
    
        
    
    
    
    
    
        
    

    
",f == 'A',"l % 2 == 0:
                    ba += l // 2
                else:
                    ab_total += l // 2
                    ba += l // 2
                    
                a_parts.append(l // 2)
                b_parts.append(l // 2)
                
                l = 1
                f = i
            else:
                l += 1

            p = i
        else:
            l += 1

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = "
"import sys
import math

def do_test():

    a,b,ab,ba = map(int, input().split())
    S = input().strip()
    n = len(S)
    
    ac = 0
    for i in S:
        if i == 'A':
            ac += 1

    if (ac != a + ab + ba):
        return ""NO""

    

    a_parts = []
    b_parts = []
    ab_total = 0

    l = 0
    f = -1
    p = S[0]
    S = S + S[n-1]
    
    for i in S:
        
        if i == p:
            
            if l > 1:
                if {{completion}}:
                    ab_total += l // 2
                elif f == 'A':
                    a_parts.append(l // 2)
                else:
                    b_parts.append(l // 2)
                
            l = 1
            f = i
        else:
            l += 1

        p = i

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = i
        if ba >= k:
            ba -= k
        else:
            k -= ba
            ba = 0
            if ab > 0:
                ab -= k-1

    if ab + ba > ab_total:
        return ""NO""

    return ""YES""               
                

    
    

input = sys.stdin.readline
t = int(input())
for _test_ in range(t):
    print(do_test())

    
    
        
    
    
    
    
    
        
    

    
",l % 2 == 1,"f == 'B':
                    b_total += l // 2
                elif f == 'A':
                    a_parts.append(l // 2)
                else:
                    b_parts.append(l // 2)
                
            l = 1
            f = i
        else:
            l += 1

        p = i

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = i
        if ba >= k:
            ba -= k
        else:
            k -= ba"
"def solve():
    cnt_a, cnt_b, cnt_ab, cnt_ba = map(int, input().strip().split())
    # print(cntA, cntB, cntAB, cntBA)
    s = input()
    if s.count('A') != cnt_a + cnt_ba + cnt_ab:
        print(""NO"")
        return

    stk = [[1, s[0]]]
    for i in range(1, len(s)):
        if i == 0:
            continue
        c = s[i]
        if c != stk[-1][1]:
            x = stk.pop()
            stk.append([x[0] + 1, c])
        else:
            stk.append([1, c])
    stk.sort()
    rest = 0
    for cnt, last in stk:
        # print(cnt, last)
        if not cnt % 2:
            if last == 'A' and cnt_ba >= (cnt >> 1):
                cnt_ba -= cnt >> 1
            elif {{completion}}:
                cnt_ab -= cnt >> 1
            else:
                rest += (cnt >> 1) - 1
        else:
            rest += cnt >> 1
    # print(rest, cnt_ab, cnt_ba)
    if rest >= cnt_ab + cnt_ba:
        print(""YES"")
    else:
        print(""NO"")


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        solve()
",last == 'B' and cnt_ab >= (cnt >> 1),"last == 'B' and cnt_ab >= (cnt >> 1):
                cnt_ab -= cnt >> 1
            elif last == 'AB' and cnt_ba >= (cnt >> 1) and cnt_ab >= (cnt >> 1):
                cnt_ba -= cnt >> 1
                cnt_ab -= cnt >> 1
            elif last == 'BA' and cnt_ab >= (cnt >> 1) and cnt_ba >= (cnt >> 1):
                cnt_ab -= cnt >> 1
                cnt_ba -= cnt >> 1
            elif last == 'ABA' and cnt_ab >= (cnt >> 1) and cnt_ba >= (cnt >> 1) and "
"def solve():
    cnt_a, cnt_b, cnt_ab, cnt_ba = map(int, input().strip().split())
    # print(cntA, cntB, cntAB, cntBA)
    s = input()
    if s.count('A') != cnt_a + cnt_ba + cnt_ab:
        print(""NO"")
        return

    stk = [[1, s[0]]]
    for i in range(1, len(s)):
        if i == 0:
            continue
        c = s[i]
        if c != stk[-1][1]:
            x = stk.pop()
            stk.append([x[0] + 1, c])
        else:
            stk.append([1, c])
    stk.sort()
    rest = 0
    for cnt, last in stk:
        # print(cnt, last)
        if not cnt % 2:
            if {{completion}}:
                cnt_ba -= cnt >> 1
            elif last == 'B' and cnt_ab >= (cnt >> 1):
                cnt_ab -= cnt >> 1
            else:
                rest += (cnt >> 1) - 1
        else:
            rest += cnt >> 1
    # print(rest, cnt_ab, cnt_ba)
    if rest >= cnt_ab + cnt_ba:
        print(""YES"")
    else:
        print(""NO"")


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        solve()
",last == 'A' and cnt_ba >= (cnt >> 1),"last == 'A' and cnt_ba >= (cnt >> 1):
                cnt_ba -= cnt >> 1
            elif last == 'B' and cnt_ab >= (cnt >> 1):
                cnt_ab -= cnt >> 1
            else:
                rest += (cnt >> 1) - 1
        else:
            rest += cnt >> 1
    # print(rest, cnt_ab, cnt_ba)
    if rest >= cnt_ab + cnt_ba:
        print(""YES"")
    else:
        print(""NO"")

def solve():
    cnt_a, cnt_b, cnt_ab, cnt_ba = map(int, input().strip().split())
    s = input()
    if s.count('A') != "
"import fileinput

lines = []

for line in fileinput.input():
    line_f = [int(x) for x in line.split()]
    if len(line_f) > 0:
        lines.append(line_f)
    # print ffs



for i in range(1, len(lines), 2):
    n = lines[i][0]
    a = lines[i+1]

    b = 123 + 23
    c=  b + 1


    sm = 0
    for elem in a:
        sm += elem

    found = False
    for elem in a:
        lhs = elem
        rhs = ((sm - elem) / (n-1))
        if {{completion}}:
            found = True
            break
    if found:
        print(""YES"")
    else:
        print(""NO"")
",lhs == rhs,"lhs == rhs:
            found = True
            break
    if found:
        print(""YES"")
    else:
        print(""NO"")


<|/ file filename=EverythingEverywhereAllAtOnce.py ext=.py |>"
"import fileinput

lines = []

for line in fileinput.input():
    line_f = [int(x) for x in line.split()]
    if len(line_f) > 0:
        lines.append(line_f)
    # print ffs



for i in range(1, len(lines), 2):
    n = lines[i][0]
    a = lines[i+1]

    numoddseg = 0
    prev = -1
    i = 0
    while i < n:
        if {{completion}}:
            numoddseg += 1
            prev = -1
        else:
            prev = a[i]
        i += 1

    print(numoddseg)
    ",a[i] < prev,a[i] > prev
"from sys import stdin, stderr

data = [int(x) for x in stdin.read().split()[1:]]

ns, ms = data[::2], data[1::2]

output = []
for n, m in zip(ns, ms):
    # n = 2 ** a * 5 ** b * c
    a = b = 0
    c = n
    while c % 2 == 0:
        a += 1
        c //= 2
    while c % 5 == 0:
        b += 1
        c //= 5
    t = 1  # our result should be a multiple of t
    if a > b:
        while a > b and 5 * t <= m:
            t *= 5
            b += 1
    elif b > a:
        while {{completion}}:
            t *= 2
            a += 1
    while 10 * t <= m:
        t *= 10
    #print(n, m, t, file=stderr)
    output.append(n * (m - (m % t)))

print('\n'.join(str(x) for x in output))
",b > a and 2 * t <= m,"b > a and 2 * t <= m:
            t *= 2
            a += 1
    while 10 * t <= m:
        t *= 10
    #print(n, m, t, file=stderr)
    output.append(n * (m - (m % t)))

print('\n'.join(str(x) for x in output))
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
from sys import stdin, stderr

data = [int(x) for x in stdin.read().split()[1:]]

ns, ms = data[::2], data[1::2]

output = []
for n, m in zip(ns, ms):
    a = b = 0
    c = n
    while c % 2 == 0:
        a "
"t=int(input())
while(t):
    i=0
    s=input()
    if(len(s)==1):
        print(""NO"")
        t=t-1
        continue
    while(i<len(s)):
        if(i==0):
            if(s[0:2]==""ab"" or s[0:2]==""ba""):
                print(""NO"")
                t=t-1
                break
        if(i>0 and i<len(s)-1):
            if(s[i-1:i+2]==""bab"" or s[i-1:i+2]==""aba""):
                print(""NO"")
                t=t-1
                break
        if(i==len(s)-1):
            if{{completion}}:
                print(""NO"")
                t=t-1
                break
            else:
                print(""YES"")
                t=t-1
                break
        i+=1
                ","(s[i-1:]==""ba"" or s[i-1:]==""ab"")","((s[0:3]==""abb"" or s[0:3]==""bba"")and s[i-1]==""a""):
                print(""NO"")
                t=t-1
                break
        if(i==len(s)-2):
            if((s[0:3]==""abb"" or s[0:3]==""bba"")and s[i+1]==""a""):
                print(""NO"")
                t=t-1
                break
        if(i>0 and i<len(s)-2):
            if(s[i-1:i+3]==""babab"" or s[i-1:i+3]==""baba""):
                print(""NO"")
                t=t-1
                break
        if(i==len(s)-3):
            if((s[0:3]==""abb"" or "
"n = int(input())
s = input()

c = 1


def dfs(i):
    if {{completion}}:
        return s[i]
    global c
    l = dfs(2*i + 1)
    r = dfs(2*i + 2)
    if l != r:
        c *= 2
    if l > r:
        l, r = r, l
    return s[i] + l + r


dfs(0)
print(c % 998244353)
",i >= 2**(n-1)-1,"i == len(s):
        return s[i]
    if s[i] == 'A':
        return s[i]
    if s[i] == 'B':
        return s[i]
    if s[i] == 'B' and s[i - 1] == 'A':
        return s[i]
    if s[i] == 'A' and s[i - 1] == 'B':
        return s[i]
    if s[i] == 'B' and s[i - 1] == 'A':
        return s[i]
    if s[i] == 'A' and s[i - 1] == 'B':
        return s[i]
    if s[i] == 'B' and s[i - 1] == 'A':
        return s[i]
    if s[i] == 'A' and s[i - 1] == 'B':
        return s[i]
    if s[i] == 'B' and s[i - 1] == 'A':
        return s[i]
    if s[i] == 'A' and "
"n = int(input())
s = input()

c = 1


def dfs(i):
    if i >= 2**(n-1)-1:
        return s[i]
    global c
    l = dfs(2*i + 1)
    r = dfs(2*i + 2)
    if {{completion}}:
        c *= 2
    if l > r:
        l, r = r, l
    return s[i] + l + r


dfs(0)
print(c % 998244353)
",l != r,l == r
"mod=998244353
cnt=0
n=int(input())
s=input()

import random
q=random.randint(10**9,2*10**9)
p=random.randint(10**9,2*10**9)
r=10**9+7

a=[-1]
for i in s:
  if {{completion}}:
    a.append(p)
  else:
    a.append(q)

for i in range(2**(n-1)-1,0,-1):
  if a[2*i]!=a[2*i+1]:
    cnt+=1
  a[i]=a[i]^(2*a[2*i]+2*a[2*i+1])
  a[i]%=r
  

print(pow(2,cnt,mod))",i=='A',"i=='A':
    a.append(p)
  elif i=='B':
    a.append(q)
  elif i=='a':
    a.append(p)
  elif i=='b':
    a.append(q)
  elif i=='A':
    a.append(p)
  elif i=='B':
    a.append(q)
  elif i=='a':
    a.append(p)
  elif i=='b':
    a.append(q)
  elif i=='A':
    a.append(p)
  elif i=='B':
    a.append(q)
  elif i=='a':
    a.append(p)
  elif i=='b':
    a."
"mod=998244353
cnt=0
n=int(input())
s=input()

import random
q=random.randint(10**9,2*10**9)
p=random.randint(10**9,2*10**9)
r=10**9+7

a=[-1]
for i in s:
  if i=='A':
    a.append(p)
  else:
    a.append(q)

for i in range(2**(n-1)-1,0,-1):
  if {{completion}}:
    cnt+=1
  a[i]=a[i]^(2*a[2*i]+2*a[2*i+1])
  a[i]%=r
  

print(pow(2,cnt,mod))",a[2*i]!=a[2*i+1],"a[i]==-1:
    a[i]=a[i]+2*a[2*i]
    a[i]%=r
  if a[i]==2*a[2*i]+2*a[2*i+1]"
"MOD = 998244353
 
n, s = int(input()), input()
 
 
def calc(u: int) -> tuple:
    if {{completion}}:
        return (0, 0)
    t1, t2 = calc(u * 2), calc(u * 2 + 1)
    return (t1[0] + t2[0] + (t1[1] != t2[1]),
            hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))
 
 
print(pow(2, calc(1)[0], MOD))
",u >= (1 << n),"u == 0:
        return (0, 0)
    t1, t2 = calc(u - 1), calc(u * 2)
    return (t1[0] + t2[0], t1[1] + t2[1])
 
 
def hash(t: tuple) -> int:
    return (t[0] * (t[0] + 1) // 2 + t[1] * (t[1] + 1) // 2)
 
 
def solve(u: int) -> tuple:
    if u == 0:
        return (0, 0)
    t1, t2 = calc(u - 1), calc(u * 2)
    return (t1[0] + t2[0] + (t1[1] != t2[1]),
            hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))
 
 
print(pow"
"def dfs(tree,i,h):
    if {{completion}}:
        return [tree[i],1]
    ls,li=dfs(tree,i*2+1,h)
    rs,ri=dfs(tree,i*2+2,h)
    res=li*ri
    if ls!=rs:
        res*=2
    if ls>rs:
        return [tree[i]+rs+ls,res]
    else:
        return [tree[i]+ls+rs,res]


h=int(input())
tree=input()
print(dfs(tree,0,h)[1]%998244353 )
",i>=2**(h-1)-1,"i==len(tree)-1:
        return [tree[i],1]
    if h==1:
        return [tree[i],1]
    if h==2:
        return [tree[i],2]
    if h==3:
        return [tree[i],3]
    if h==4:
        return [tree[i],4]
    if h==5:
        return [tree[i],5]
    if h==6:
        return [tree[i],6]
    if h==7:
        return [tree[i],7]
    if h==8:
        return [tree[i],8]
    if h==9:
        return [tree[i],9]
    if h==10:
        return [tree[i],10]
    if h==11:
        return [tree[i],11]
    if h==12:
"
"def dfs(tree,i,h):
    if i>=2**(h-1)-1:
        return [tree[i],1]
    ls,li=dfs(tree,i*2+1,h)
    rs,ri=dfs(tree,i*2+2,h)
    res=li*ri
    if {{completion}}:
        res*=2
    if ls>rs:
        return [tree[i]+rs+ls,res]
    else:
        return [tree[i]+ls+rs,res]


h=int(input())
tree=input()
print(dfs(tree,0,h)[1]%998244353 )
",ls!=rs,"ls>rs:
        res*=2
    if ls>rs:
        return [tree[i]+rs+ls,res]
    else:
        return [tree[i]+ls+rs,res]

h=int(input())
tree=input()
print(dfs(tree,0,h)[1]%998244353 )
<|/ a |>
<| a dscore=0 tags=python,algorithm,dynamic-programming |>
<code>
def dfs(tree,i,h):
    if i>=2**(h-1)-1:
        return [tree[i],1]
    ls,li=dfs(tree,i*2+1,h)
    rs,"
"import sys

N = int(sys.stdin.readline().strip())
s = sys.stdin.readline().strip()

# print(N, s)
m = 1 << N
mod = 998244353


def dfs(i):
    if i >= m: return (1, '')
    ln, ls = dfs(i * 2)
    rn, rs = dfs(i * 2 + 1)
    ln = ln % mod
    rn = rn % mod
    if ls < rs:
        return ln * rn * 2, ls + s[i - 1] + rs
    elif {{completion}}:
        return ln * rn * 2, rs + s[i - 1] + ls
    else:
        return ln * rn, ls + s[i - 1] + rs


n, _ = dfs(1)
print(n % mod)
",ls > rs,"ls > rs:
        return ln * rn, ls + s[i - 1] + rs
    elif ls == rs and s[i - 1] == 'A':
        return ln * rn * 2, ls + s[i - 1] + rs
    elif ls == rs and s[i - 1] == 'B':
        return ln * rn, ls + s[i - 1] + rs
    elif ls < rs and s[i - 1] == 'A':
        return ln * rn * 2, ls + s[i - 1] + rs
    elif ls < rs and s[i - 1] == 'B"
"# trans rights
N = int(input())
N = 2 ** N
S = input()
U = [0] * N
cnt = 0
for i in range(N - 2, -1, -1):
    a = 2 * i + 1
    b = 2 * i + 2
    if {{completion}}:
        U[i] = ord(S[i])
        continue
    if U[a] != U[b]:
        cnt += 1
    U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
    U[i] %= 2 ** 104

print(pow(2, cnt, 998244353))
",b >= N,a > N or b > N
"# trans rights
N = int(input())
N = 2 ** N
S = input()
U = [0] * N
cnt = 0
for i in range(N - 2, -1, -1):
    a = 2 * i + 1
    b = 2 * i + 2
    if b >= N:
        U[i] = ord(S[i])
        continue
    if {{completion}}:
        cnt += 1
    U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
    U[i] %= 2 ** 104

print(pow(2, cnt, 998244353))
",U[a] != U[b],"U[a] > U[b]:
        U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
        U[i] %= 2 ** 104
        continue
    if U[a] < U[b]:
        U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
        U[i] %= 2 ** 104
        continue
    if U[a] == U[b]:
        U[i] = ord(S[i]) + 331 * min(U"
"import sys;I=sys.stdin.readline;R,P,G=lambda:map(int,I().split()),print,range
n,q=R();n+=1;a=[0]+[*R()];p,s,last,oe=[0]*n,[0]*n,[0]*n,[{},{}]
for i in G(1,n):
  p[i]=a[i]^p[i-1]
  if a[i]==0:s[i]=s[i-1]+1
  d=oe[i&1]
  if p[i] in d:last[i]=d[p[i]]
  oe[i&1][p[i-1]]=i
for _ in G(q):
  l,r=R()
  if s[r]>=r-l+1:P(0)
  elif p[l-1]^p[r] or r-l<2:P(-1)
  elif {{completion}}:P(1)
  elif last[r]>l:P(2)
  else:P(-1)",(r-l)&1==0 or a[l]==0 or a[r]==0,"last[l]>r:P(1)
  elif last[r]>l:P(2)
  else:P(-1)
  last[l],last[r]=last[r],last[l]
print(*G(n),sep='')
<|/ a dscore=0 |>
<| a tags=python,algorithm |>
<code>
import sys;I=sys.stdin.readline;R,P,G=lambda:map(int,I().split()),print,range
n,q=R();n+=1;a=[0]+[*R()];p,s,last,oe=[0]*n,[0]*n,[0]*n,[{},{}]
for i in G(1,n):
  p[i]=a[i]"
"import sys;I=sys.stdin.readline;R,P,G=lambda:map(int,I().split()),print,range
n,q=R();n+=1;a=[0]+[*R()];p,s,last,oe=[0]*n,[0]*n,[0]*n,[{},{}]
for i in G(1,n):
  p[i]=a[i]^p[i-1]
  if a[i]==0:s[i]=s[i-1]+1
  d=oe[i&1]
  if p[i] in d:last[i]=d[p[i]]
  oe[i&1][p[i-1]]=i
for _ in G(q):
  l,r=R()
  if s[r]>=r-l+1:P(0)
  elif p[l-1]^p[r] or r-l<2:P(-1)
  elif (r-l)&1==0 or a[l]==0 or a[r]==0:P(1)
  elif {{completion}}:P(2)
  else:P(-1)",last[r]>l,"last[l]==last[r]:P(s[l]-s[r]+1)
  elif last[l]==last[r]^a[l]^a[r]:P(s[l]-s[r]+1)
  elif last[l]==last[r]^a[l]^a[r]^a[l-1]^a[r-1]"
"import sys

n, q = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]

cur = 0
odd = {}
even = {}
last = [-1]*(n+1)
pxor = [0]*(n+1)
psum = [0]*(n+1)

for i, num in enumerate(a):
    pxor[i+1] = pxor[i] ^ num
    psum[i+1] = psum[i] + num
    cur = pxor[i+1]
    if i&1 == 0:
        if cur in odd:
            last[i+1] = odd[cur]
        even[cur] = i + 1
    else:
        if cur in even:
            last[i+1] = even[cur]
        odd[cur] = i + 1

for _ in range(q):
    l, r = [int(i) for i in sys.stdin.readline().split()]
    if pxor[l-1] != pxor[r]:
        print(""-1"")
    elif psum[l-1] == psum[r]:
        print(""0"")
    else:
        if (r-l)%2==0:
            print(""1"")
        elif a[l-1]==0 or a[r-1]==0:
            print(""1"")
        elif {{completion}}:
            print(""2"")
        else:
            print(""-1"")

",last[r] >= l,last[l-1]==last[r-1]
"import sys
input = sys.stdin.readline
n,q = map(int,input().split())
a = [0] + list(map(int,input().split()))
cml = a[::1]
for i in range(1, n+1):
  a[i] ^= a[i-1]
  cml[i] += cml[i-1]
qs = [list(map(int,input().split())) for i in range(q)]

from collections import defaultdict
d = defaultdict(list)
dd = defaultdict(list)
cnt = defaultdict(int)
ord = [0]*(n+1)
for i in range(n+1):
  dd[a[i]].append(i % 2)
  cnt[a[i]] += 1
  ord[i] = cnt[a[i]]
for k,v in dd.items():
  dd[k] = [0] + v
  for i in range(len(v)+1):
    if i == 0: continue
    else:
      dd[k][i] += dd[k][i-1]
for l,r in qs:
  if a[r] != a[l-1]: 
    print(-1)
  else:
    if cml[r] - cml[l-1] == 0:
      print(0)
    elif (r-l) % 2 == 0 or a[l] == a[l-1] or a[r] == a[r-1]:
      print(1)
    else:
      ll = ord[l-1]-1
      rr = ord[r]
      tot = dd[a[r]][rr] - dd[a[r]][ll]
      if {{completion}}:
        print(-1)
      else:
        print(2)
",tot == rr-ll or tot == 0,"tot == 0:
        print(0)
      elif tot < 0 or tot > 2:
        print(-1)
      else:
        print(tot)
  
for l,r in qs:
  if a[r] != a[l-1]: 
    print(-1)
  else:
    if cml[r] - cml[l-1] == 0:
      print(0)
    elif (r-l) % 2 == 0 or a[l] == a[l-1] or a[r] == a[r-1]:
      print(1)
    else:
      ll = ord[l-1]-1
      rr = ord[r]
      tot = dd[a[r]][rr] - dd[a[r]][ll]
      if tot == "
"import sys
 
def input():
    return sys.stdin.readline().strip()
    
n, q = map(int, input().split())
a = list(map(int, input().split()))
b, s = [0], [0]
nx = [n+5] * (n + 1)
d = {0: [0]}
for i, e in enumerate(a):
    bx = b[-1]^e
    sx = s[-1] + e
    b.append(bx)
    s.append(sx)
    if bx in d.keys():
        if (i + 1 - d[bx][-1]) % 2 == 0:
            d[bx].append(i + 1)
        else:
            for x in d[bx]:
                nx[x] = i + 1
            d[bx] = [i + 1]
    else:
        d[bx] = [i + 1]
        
# print(nx)
for i in range(q):
    l, r = map(int, input().split())
    if b[r] != b[l-1]:
        sys.stdout.write(""-1\n"")
    else:
        if s[r] - s[l-1] == 0:
            sys.stdout.write(""0\n"")
        elif (r - l + 1) % 2:
            sys.stdout.write(""1\n"")
        else:
            if a[l - 1]*a[r - 1] == 0:
                sys.stdout.write(""1\n"")
            elif {{completion}}:
                sys.stdout.write(""2\n"")
            else:
                sys.stdout.write(""-1\n"")
",nx[l-1] <= r,"a[l - 1]*a[r - 1] == 1:
                sys.stdout.write(""2\n"")
            else:
                sys.stdout.write(""-1\n"")
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
"
"import collections
import sys
input = sys.stdin.readline
def sol(arr, n, m, q):
    xor = [0]
    curr = 0
    for i in arr:
        curr ^= i
        xor.append(curr)
    pre = [0]
    curr = 0
    for i in arr:
        curr += i
        pre.append(curr)
    qd = collections.defaultdict(list)
    for i in range(m):
        qd[q[i][1]].append((q[i][0], i))
    
    
    res = [-1] * m
    last = [collections.defaultdict(int), collections.defaultdict(int)]
    for r in range(1, n + 1):
        last[r & 1][xor[r]] = r
        for l, i in qd[r]:
            if xor[r] ^ xor[l - 1] != 0: 
                res[i] = (-1)
            elif pre[r] == pre[l - 1]: 
                res[i] = (0)
            elif (r - l) & 1 and arr[l - 1] and arr[r - 1]:
                if {{completion}}:
                    res[i] = (2)
                else:
                    res[i] = (-1)
            else: 
                res[i] = (1)
    
    for i in res:
        print(i)


n, m = list(map(int,input().split()))
arr = list(map(int,input().split()))
q = []
for i in range(m):
    q.append(list(map(int,input().split())))
(sol(arr, n, m, q))
",last[(r & 1) ^ 1][xor[r]] >= l,xor[l - 1] == xor[r - 1]
"import collections
import sys
input = sys.stdin.readline
def sol(arr, n, m, q):
    xor = [0]
    curr = 0
    for i in arr:
        curr ^= i
        xor.append(curr)
    pre = [0]
    curr = 0
    for i in arr:
        curr += i
        pre.append(curr)
    qd = collections.defaultdict(list)
    for i in range(m):
        qd[q[i][1]].append((q[i][0], i))
    
    
    res = [-1] * m
    last = [collections.defaultdict(int), collections.defaultdict(int)]
    for r in range(1, n + 1):
        last[r & 1][xor[r]] = r
        for l, i in qd[r]:
            if xor[r] ^ xor[l - 1] != 0: 
                res[i] = (-1)
            elif {{completion}}: 
                res[i] = (0)
            elif (r - l) & 1 and arr[l - 1] and arr[r - 1]:
                if last[(r & 1) ^ 1][xor[r]] >= l:
                    res[i] = (2)
                else:
                    res[i] = (-1)
            else: 
                res[i] = (1)
    
    for i in res:
        print(i)


n, m = list(map(int,input().split()))
arr = list(map(int,input().split()))
q = []
for i in range(m):
    q.append(list(map(int,input().split())))
(sol(arr, n, m, q))
",pre[r] == pre[l - 1],xor[r] ^ xor[l - 1] == 0 and xor[l - 1] == xor[l - 1]
"for t in range(int(input())):
    n = int(input())
    if {{completion}}:
        print(""1\n1 2"")
        continue
    i = 2
    j = 3*n
    ans = []
    while i<j:
        ans.append((i,j))
        i += 3
        j -= 3
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

",n == 1,"n<1 or n>100:
        print(""0\n0 0"")
        continue
    if n==1:
        print(""1\n1 1"")
        continue
    if n==2:
        print(""1\n1 2"")
        continue
    i = 2
    j = 3*n
    ans = []
    while i<j:
        ans.append((i,j))
        i += 3
        j -= 3
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

for t in range(int(input())):
    n = int(input())
    if n<1 or n>100:
        print(""0\n0 0"")
        continue
    if n==1:
        print(""1\n1 1"")
        continue"
"for t in range(int(input())):
    n = int(input())
    if n == 1:
        print(""1\n1 2"")
        continue
    i = 2
    j = 3*n
    ans = []
    while {{completion}}:
        ans.append((i,j))
        i += 3
        j -= 3
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

",i<j,"i <= n and j <= 3*n:
        if i != j and (j - i) % 3 == 0:
            ans.append((i,j))
            i += 3
            j -= 3
        elif i == j:
            ans.append((i,j))
            i += 3
            j -= 3
        elif (j - i) % 3 == 0:
            ans.append((i,j))
            i += 3
            j -= 3
        elif (j - i) % 3 != 0:
            ans.append((i,j))
            i += 3
            j -= 3
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

for t in range(int(input())):
    n = int(input"
"t = int(input())
for i in range(t):
    n = int(input())
    if n == 1:
    	print(1)
    	print(1,2)
    elif n%2 :
        print(int((n+1)/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            print(e,e + int((3*n)/2))
    else :
        print(int(n/2))
        for {{completion}}:
            print(e,e + int(3*n/2) + 1)","e in range(2, int((3 * n + 1)/2) + 1, 3)","e in range(2, int(n/2) + 1, 3):
            print(e,e + int(n/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            print(e,e + int((3*n)/2))
        for e in range(2, int(n/2) + 1, 3):
            print(e,e + int((3*n)/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            print(e,e + int((3*n)/2))
        for e in range(2, int(n/2) + 1, 3):
            print(e,e + int((3*n)/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            print(e,e + int((3*n)/2))
        for e in "
"from sys import stdin
t = int(stdin.readline().strip())
for i in range(t):
    n = int(stdin.readline().strip())
    b = list('ban'*n)
    if n==1:
        print(1)
        print(1, 2)
    else:
        z = n*3-1
        print(n//2+n%2)
        for i3 in range(n//2+n%2):
            for i2 in range(n*3):
                if {{completion}}:
                    c = b[z]
                    b[z] = 'a'
                    b[i2] = c
                    print(min(i2+1, z+1), max(i2+1, z+1))
                    z-=3
                    break",b[i2]=='a',"i2 == i3:
                    continue
                if i2 > z"
"# get testcase input
t = int(input())
result = """"

while t:
    t -= 1
    n = int(input())
    aux = int(n/2 if n%2==0 else n/2+1)

    if {{completion}}:
        result += ""1\n1 2\n""
        continue
    
    result += str(aux) + ""\n""
    for i in range(aux):
        result += str(2+3*i) + ' ' + str(3+3*(n-i-1)) + ""\n""
print(result[:-1])",n == 1,"aux == 1 and n%2 == 0:
        result += ""BAN\n""
        continue
    
    if aux == 2 and n%2 == 0:
        result += ""BANBAN\n""
        continue
    
    if aux == 2 and n%2 != 0:
        result += ""BANBANBAN\n""
        continue
    
    if aux == 1 and n%2 != 0:
        result += ""ABN\n""
        continue
    
    if aux == 2 and n%2 != 0:
        result += ""BNNBAA\n""
        continue
    
    if aux == 1 and n%2 == 0:
        result += ""ABN\n""
        continue
    
    if "
"# get testcase input
t = int(input())
result = """"

while t:
    t -= 1
    n = int(input())
    aux = int(n/2 if n%2==0 else n/2+1)

    if n == 1:
        result += ""1\n1 2\n""
        continue
    
    result += str(aux) + ""\n""
    for {{completion}}:
        result += str(2+3*i) + ' ' + str(3+3*(n-i-1)) + ""\n""
print(result[:-1])",i in range(aux),"_ in range(aux):
        result += str(n-1) + ""\n""
    
    for i in range(1,n):
        result += str(i+1) + ""\n""
    
    result += ""1\n""
    
    for i in range(1,n):
        result += str(i+1) + ""\n""
    
    result += ""1\n""
    
    for i in range(1,n):
        result += str(i+1) + ""\n""
    
    result += ""1\n""
    
    for i in range(1,n):
        result += str(i+1) + ""\n""
    
    result += ""1\n""
    
    for i in range(1,n):
        result += str(i+1) + ""\n""
    
    result += ""1\n""
    
    for i in range(1,n):
"
"def ban(n):
	if {{completion}}:
		return [1, [[1, 2]]]

	x = 0
	lt = []
	i = 2
	j = 3 * n
	while i < j:
		lt.append([i, j])
		x += 1
		i += 3
		j -= 3

	return [x, lt]

OUTPUT = []
for _ in range(int(input())):
	N = int(input())
	OUTPUT.append(ban(N))

for _ in OUTPUT:
	print(_[0])
	for i in _[1]:
		print(*i)
",n == 1,"n == 1:
		return ""BAN""
	if n == 2:
		return ""BANBAN""

	x = 1
	lt = []
	i = 2
	j = 3 * n
	while i < j:
		lt.append([i, j])
		x += 1
		i += 3
		j -= 3

	return ""BAN""

def ban2(n):
	if n == 1:
		return [1, [[1, 2]]]
	if n == 2:
		return [1, [[1, 2]], [[1, 6]]]

	x = 0
	lt = []
	i = 2
	j = 3 * n
	while i < j:
		"
"def ban(n):
	if n == 1:
		return [1, [[1, 2]]]

	x = 0
	lt = []
	i = 2
	j = 3 * n
	while {{completion}}:
		lt.append([i, j])
		x += 1
		i += 3
		j -= 3

	return [x, lt]

OUTPUT = []
for _ in range(int(input())):
	N = int(input())
	OUTPUT.append(ban(N))

for _ in OUTPUT:
	print(_[0])
	for i in _[1]:
		print(*i)
",i < j,i <= j
"n = int(input())
for i in range(n):
    k = int(input())

    if k == 1:
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
    else:
        t = []
        p = [0, 1, 2] * k
        x, y = 0, len(p) - 1
        while x < y:
            while {{completion}}: x += 1
            while x < y and p[y] != 2: y -= 1
            if x >= y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
",x < y and p[x] != 1,"x < y and p[x] != p[y]: x += 1
            while x < y and p[x] != 2: x += 1
            while x < y and p[y] != p[x]: y -= 1
            while x < y and p[y] != 2: y -= 1
            if x >= y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
</code>
<|/ a tags=algorithm,string,python |>
<| c |>
Thanks for your answer. Can you please explain me the code a bit?
<|/ c |>
<| c |>
I have added "
"n = int(input())
for i in range(n):
    k = int(input())

    if k == 1:
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
    else:
        t = []
        p = [0, 1, 2] * k
        x, y = 0, len(p) - 1
        while x < y:
            while x < y and p[x] != 1: x += 1
            while {{completion}}: y -= 1
            if x >= y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
",x < y and p[y] != 2,"y < x and p[y] != 1: y -= 1
            if x == y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
n = int(input())
for i in range(n):
    k = int(input())

    if k == 1:
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
    else:
        t = []
        p = [0, 1, 2] * k
        "
"input = __import__('sys').stdin.readline


n = int(input())

adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v, x = map(lambda x: int(x)-1, input().split())
    adj[u].append((v, x))
    adj[v].append((u, x))


TRAVERSE = 0
UPDATE_DP = 1

prev_node_stack = [[0] for _ in range(n)]
prev_node = [0]*n
sz = [1]*n
dp_root = [0]*n
dp_remove = [0]*n

stack = [(TRAVERSE, (0, -1, 0))]
while len(stack) > 0:
    state, param = stack.pop()
    if state == TRAVERSE:
        u, par, i = param
        if {{completion}}:
            i += 1
        if i < len(adj[u]):
            v, x = adj[u][i]
            stack.append((TRAVERSE, (u, par, i+1)))
            stack.append((UPDATE_DP, (v, u, x)))
            stack.append((TRAVERSE, (v, u, 0)))
            prev_node_stack[x].append(v)

    if state == UPDATE_DP:
        v, u, x = param
        prev_node_stack[x].pop()
        sz[u] += sz[v]
        prev_node[v] = prev_node_stack[x][-1]
        if prev_node[v] == 0:
            dp_root[x] += sz[v]
        else:
            dp_remove[prev_node[v]] += sz[v]


# print('prev_node', prev_node)
# print('dp_root', dp_root)
# print('dp_remove', dp_remove)

ans = sum((sz[v] - dp_remove[v]) * (sz[prev_node[v]] - (dp_root[x] if prev_node[v] == 0 else dp_remove[prev_node[v]]))
    for u in range(n) for v, x in adj[u] if sz[u] > sz[v])
print(ans)
",i < len(adj[u]) and adj[u][i][0] == par,"par == -1:
            sz[u] += 1
            prev_node[u] = i
            stack.append((UPDATE_DP, (u, u, i)))
        elif par"
"input = __import__('sys').stdin.readline


n = int(input())

adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v, x = map(lambda x: int(x)-1, input().split())
    adj[u].append((v, x))
    adj[v].append((u, x))


TRAVERSE = 0
UPDATE_DP = 1

prev_node_stack = [[0] for _ in range(n)]
prev_node = [0]*n
sz = [1]*n
dp_root = [0]*n
dp_remove = [0]*n

stack = [(TRAVERSE, (0, -1, 0))]
while len(stack) > 0:
    state, param = stack.pop()
    if state == TRAVERSE:
        u, par, i = param
        if i < len(adj[u]) and adj[u][i][0] == par:
            i += 1
        if {{completion}}:
            v, x = adj[u][i]
            stack.append((TRAVERSE, (u, par, i+1)))
            stack.append((UPDATE_DP, (v, u, x)))
            stack.append((TRAVERSE, (v, u, 0)))
            prev_node_stack[x].append(v)

    if state == UPDATE_DP:
        v, u, x = param
        prev_node_stack[x].pop()
        sz[u] += sz[v]
        prev_node[v] = prev_node_stack[x][-1]
        if prev_node[v] == 0:
            dp_root[x] += sz[v]
        else:
            dp_remove[prev_node[v]] += sz[v]


# print('prev_node', prev_node)
# print('dp_root', dp_root)
# print('dp_remove', dp_remove)

ans = sum((sz[v] - dp_remove[v]) * (sz[prev_node[v]] - (dp_root[x] if prev_node[v] == 0 else dp_remove[prev_node[v]]))
    for u in range(n) for v, x in adj[u] if sz[u] > sz[v])
print(ans)
",i < len(adj[u]),"i == len(adj[u]):
            sz[u] += 1
            stack.append((UPDATE_DP, (u, par, 0)))
        else:
            stack.append((UPDATE_DP, (u, par, i)))
            stack.append((TRAVERSE, (u, par, i+1)))
            stack.append((UPDATE_DP, (v, u, x)))
            stack.append((TRAVERSE, (v, u, 0)))
            prev_node_stack[x].append(v)

    if state == UPDATE_DP:
        v, u, x = param
        prev_node_stack[x].pop()
        sz[u] += sz[v]
        prev_node[v] = prev_node_stack[x][-1]
        if prev_node[v] == 0:
"
"



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))


p=[0]*(n+2)
num=[0]*(n+3)

omomi=defaultdict(int)


nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            p[next]=now
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            x=now
            num[x]=1
            for y in root[x]:
                if y==p[x]:continue
                num[x]+=num[y]
            if x>1:
                c=col[x,p[x]]
                omomi[x,c]+=num[x]
                omomi[nextp[x],c]-=num[x]
            else:
                for {{completion}}:
                    omomi[x,c]+=num[x]
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)

ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)









","c in range(1,n+1)","y in root[x]:
                    if y==p[x]:continue
                    omomi[y,c]+=num[x]
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)

ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)









<|/ file ext=.py filename=ex2.py |>"
"




##########################



def tree_search(n,G,s,func1,func2,func3):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        if seen[now]==0 and func1!=0:func1(now)
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            if func2!=0:func2(now,next)
            search.append(next)
        else:
            if {{completion}}:func3(now)
            search.pop()

#############################



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))

def cnb(n):
    return n*(n-1)//2

p=[0]*(n+2)
num=[0]*(n+3)
dp=[defaultdict(int) for i in range(n+3)]
omomi=defaultdict(int)

def f2(x,y):
    p[y]=x

def f3(x):
    num[x]=1
    for y in root[x]:
        if y==p[x]:continue
        num[x]+=num[y]

    for y in root[x]:
        if y==p[x]:continue
        if len(dp[x])<len(dp[y]):
            res=dp[y]
            for ke in dp[x]:res[ke]+=dp[x][ke]
        else:
            res = dp[x]
            for ke in dp[y]: res[ke] += dp[y][ke]
        dp[x] = res
    if x>1:
        c=col[x,p[x]]
        omomi[x,c]=num[x]-dp[x][c]
        dp[x][c]=num[x]
    else:
        for c in range(1,n+1):
            omomi[1,c]=num[1]-dp[1][c]

tree_search(n,root,1,0,f2,f3)
nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)


ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)






",func3!=0,"func3!=0:func3(now)
            search.pop()

#############################



def tree_search2(n,G,s,func1,func2,func3):
    seen = [0] * (n + 1) #場合によっては外に出す
    ind = [0] * (n+1) ##
    search=[s]
    while search:
        now=search[-1]
        if seen[now]==0 and func1!=0:func1(now)
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind"
"




##########################



def tree_search(n,G,s,func1,func2,func3):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        if seen[now]==0 and func1!=0:func1(now)
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            if func2!=0:func2(now,next)
            search.append(next)
        else:
            if func3!=0:func3(now)
            search.pop()

#############################



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))

def cnb(n):
    return n*(n-1)//2

p=[0]*(n+2)
num=[0]*(n+3)
dp=[defaultdict(int) for i in range(n+3)]
omomi=defaultdict(int)

def f2(x,y):
    p[y]=x

def f3(x):
    num[x]=1
    for y in root[x]:
        if y==p[x]:continue
        num[x]+=num[y]

    for y in root[x]:
        if y==p[x]:continue
        if len(dp[x])<len(dp[y]):
            res=dp[y]
            for ke in dp[x]:res[ke]+=dp[x][ke]
        else:
            res = dp[x]
            for {{completion}}: res[ke] += dp[y][ke]
        dp[x] = res
    if x>1:
        c=col[x,p[x]]
        omomi[x,c]=num[x]-dp[x][c]
        dp[x][c]=num[x]
    else:
        for c in range(1,n+1):
            omomi[1,c]=num[1]-dp[1][c]

tree_search(n,root,1,0,f2,f3)
nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)


ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)






",ke in dp[y],"ke in dp[y]:res[ke]+=dp[y][ke]
        dp[x][y]=res[ke]
        dp[y][x]=res[ke]
    if x>1:
        c=col[x,p[x]]
        omomi[x,c]=num[x]-dp[x][c]
        dp[x][c]=num[x]
    else:
        for c in range(1,n+1):
            omomi[1,c]=num[1]-dp[1][c]

tree_search(n,root,1,f2,f3,0)
nextp=[10**10]*(n+2)
nextc=[1]*(n"
"import sys
input = sys.stdin.readline
N = int(input())
logN = (N - 2).bit_length()

door = []
for _ in range(N - 1):
    _, a, b, _ = map(int, input().split())
    door.append([a - 1, b - 1])

# door = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(N - 1)]

dist = [[[-1] * 4 for _ in range(logN)] for _ in range(N - 2)]

'''
0: 0->0
1: 0->1
2: 1->0
3: 1->1
'''

for i in range(N - 2):
    d1 = abs(i - door[i][1]) + abs(door[i][0] - i)
    dist[i][0][0] = abs(door[i][0] - door[i + 1][0]) + 1
    dist[i][0][3] = abs(door[i][1] - door[i + 1][1]) + 1
    dist[i][0][1] = min(
        abs(i + 1 - door[i + 1][1]) + abs(door[i][0] - (i + 1)) + 1,
        d1 + dist[i][0][3]
    )
    dist[i][0][2] = min(
        abs(door[i][1] - (i + 1)) + abs(i + 1 - door[i + 1][0]) + 1,
        d1 + dist[i][0][0]
    )

for j in range(1, logN):
    k = 1 << (j - 1)
    for i in range(N - 1 - (1 << j)):
        for fr in range(2):
            for to in range(2):
                dist[i][j][fr << 1 | to] = min(
                    dist[i][j - 1][fr << 1] + dist[i + k][j - 1][to],
                    dist[i][j - 1][fr << 1 | 1] + dist[i + k][j - 1][2 | to]
                )

Q = int(input())
for _ in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x) - 1, input().split())
    l1 = max(h1, w1)
    l2 = max(h2, w2)
    if l1 == l2:
        print(abs(h1 - h2) + abs(w1 - w2))
        continue
    if l1 > l2:
        l1, l2 = l2, l1
        h1, w1, h2, w2 = h2, w2, h1, w1
    now = l1
    l = l2 - l1 - 1
    d0 = abs(h1 - now) + abs(w1 - door[now][0])
    d1 = abs(h1 - door[now][1]) + abs(w1 - now)
    for i in range(logN - 1, -1, -1):
        if {{completion}}:
            d0, d1 = min(d0 + dist[now][i][0], d1 + dist[now][i][2]), min(d0 + dist[now][i][1], d1 + dist[now][i][3])
            now += 1 << i
    print(min(d0 + abs(now + 1 - h2) + abs(door[now][0] - w2), d1 + abs(door[now][1] - h2) + abs(now + 1 - w2)) + 1)",l >> i & 1,"now >= l:
            break
        if now & 1 << i:
            d0, d1 = min(d0 + dist[now][i][0], d1 + dist[now][i][2]), min(d0 + dist[now][i][1], d1 + dist[now][i][3])
            now -= 1 << i
        else:
            d0, d1 = min(d0 + dist[now][i][0], d1 + dist[now][i][2]), min(d0 + dist[now][i][1], d1 + dist[now][i][3])
            now += 1 << i
    print(min(d0 + abs(now + 1 - h2) + abs(door[now][0] - w2), d1 + abs(door[now"
"input = __import__('sys').stdin.readline


def manhattan(A, B, dA=None, dB=None):
    if dA is not None:
        A = list(A)
        A[0] += dA[0]
        A[1] += dA[1]
    if dB is not None:
        B = list(B)
        B[0] += dB[0]
        B[1] += dB[1]
    return abs(A[0] - B[0]) + abs(A[1] - B[1])


n = int(input())
a = []
for _ in range(n-1):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    a.append((
        (x1, y1),
        (x2, y2),
    ))
a.append((
    (a[-1][0][0] + 1, a[-1][0][1]),
    (a[-1][1][0], a[-1][1][1] + 1),
))

jump = [
    [
        (
            min(manhattan(a[i][0], a[i+1][0], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][0], dA=(0, 1))) + 1,
            min(manhattan(a[i][0], a[i+1][1], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][1], dA=(0, 1))) + 1,
            min(manhattan(a[i][1], a[i+1][0], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][0], dA=(1, 0))) + 1,
            min(manhattan(a[i][1], a[i+1][1], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][1], dA=(1, 0))) + 1,
        ) for i in range(n-1)
    ]
]


def merge(A, B):
    return (
        min(A[0] + B[0], A[1] + B[2]),
        min(A[0] + B[1], A[1] + B[3]),
        min(A[2] + B[0], A[3] + B[2]),
        min(A[2] + B[1], A[3] + B[3]),
    )

# print(jump[0])
for j in range(20):
    jump.append([
        merge(jump[j][i], jump[j][i + (1 << j)]) for i in range(len(jump[j]) - (1 << j))
    ])
    # print(jump[-1])


for _ in range(int(input())):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    m1, m2 = max(x1, y1), max(x2, y2)
    if m1 > m2:
        m1, m2 = m2, m1
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    
    if m1 == m2:
        print(manhattan((x1, y1), (x2, y2)))
        continue
    
    s = m1
    sz = m2 - m1 - 1
    dist = None
    for i in range(20):
        if (sz >> i) & 1 == 1:
            if {{completion}}:
                dist = jump[i][s]
            else:
                dist = merge(dist, jump[i][s])
            s += (1 << i)
    
    if m1 + 1 == m2:
        dist = (0, manhattan(a[m1][0], a[m1][1]), manhattan(a[m1][1], a[m1][0]), 0)
    # print('dist', dist, a[m1], a[m2-1])
    # print('>', manhattan((x1, y1), a[m1][0]), dist[0], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][0]), dist[1], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[2], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[3], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print([
    #     manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    # ])
    print(min(
        manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    ))",dist is None,"dist is None:
                dist = jump[m1][i]
            else:
                dist = merge(dist, jump[m1][i])
            s += (1 << i)
    
    for i in range(20):
        if (sz >> i) & 1 == 1:
            if dist is None:
                dist = jump[m2][i]
            else:
                dist = merge(dist, jump[m2][i])
            s += (1 << i)
    
    for i in range(20):
        if (sz >> i) & 1 == 1:
            if dist is None:
                dist = jump[i][m1]
            else:
                dist = merge(dist, jump[i][m1])
            s += (1 << i)
    
    for i in range(20):
        if (sz >> i) & 1 == 1:
"
"input = __import__('sys').stdin.readline


def manhattan(A, B, dA=None, dB=None):
    if dA is not None:
        A = list(A)
        A[0] += dA[0]
        A[1] += dA[1]
    if dB is not None:
        B = list(B)
        B[0] += dB[0]
        B[1] += dB[1]
    return abs(A[0] - B[0]) + abs(A[1] - B[1])


n = int(input())
a = []
for _ in range(n-1):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    a.append((
        (x1, y1),
        (x2, y2),
    ))
a.append((
    (a[-1][0][0] + 1, a[-1][0][1]),
    (a[-1][1][0], a[-1][1][1] + 1),
))

jump = [
    [
        (
            min(manhattan(a[i][0], a[i+1][0], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][0], dA=(0, 1))) + 1,
            min(manhattan(a[i][0], a[i+1][1], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][1], dA=(0, 1))) + 1,
            min(manhattan(a[i][1], a[i+1][0], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][0], dA=(1, 0))) + 1,
            min(manhattan(a[i][1], a[i+1][1], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][1], dA=(1, 0))) + 1,
        ) for i in range(n-1)
    ]
]


def merge(A, B):
    return (
        min(A[0] + B[0], A[1] + B[2]),
        min(A[0] + B[1], A[1] + B[3]),
        min(A[2] + B[0], A[3] + B[2]),
        min(A[2] + B[1], A[3] + B[3]),
    )

# print(jump[0])
for j in range(20):
    jump.append([
        merge(jump[j][i], jump[j][i + (1 << j)]) for i in range(len(jump[j]) - (1 << j))
    ])
    # print(jump[-1])


for _ in range(int(input())):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    m1, m2 = max(x1, y1), max(x2, y2)
    if m1 > m2:
        m1, m2 = m2, m1
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    
    if m1 == m2:
        print(manhattan((x1, y1), (x2, y2)))
        continue
    
    s = m1
    sz = m2 - m1 - 1
    dist = None
    for i in range(20):
        if {{completion}}:
            if dist is None:
                dist = jump[i][s]
            else:
                dist = merge(dist, jump[i][s])
            s += (1 << i)
    
    if m1 + 1 == m2:
        dist = (0, manhattan(a[m1][0], a[m1][1]), manhattan(a[m1][1], a[m1][0]), 0)
    # print('dist', dist, a[m1], a[m2-1])
    # print('>', manhattan((x1, y1), a[m1][0]), dist[0], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][0]), dist[1], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[2], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[3], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print([
    #     manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    # ])
    print(min(
        manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    ))",(sz >> i) & 1 == 1,"s < (1 << i):
            break
        if s & (1 << i):
            dist = jump[i][s]
            s -= 1 << i
    
    for i in range(20):
        if s & (1 << i):
            dist = merge(dist, jump[i][s])
            s -= 1 << i
    
    for i in range(20):
        if s & (1 << i):
            dist = merge(dist, jump[i][s])
            s -= 1 << i
    
    for i in range(20):
        if s & (1 << i):
            dist = merge(dist, jump[i][s])
            s -= 1 << i
    
    for i in range(20):
        if s & (1 << i):
            dist = merge(dist, jump[i][s])
            s -= 1 << i"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


def isMountain(ar):
    prefixInc = [False] * len(ar)
    prefixInc[0] = 1
    for i in range(1, len(ar)):
        prefixInc[i] = prefixInc[i - 1] and ar[i - 1] <= ar[i]

    suffixInc = [0] * len(ar)
    suffixInc[-1] = 1
    for i in range(len(ar) - 2, -1, -1):
        suffixInc[i] = suffixInc[i + 1] and ar[i] >= ar[i + 1]

    ans = prefixInc[-1] or suffixInc[0]
    for i in range(len(ar)):
        ans = ans or (prefixInc[i] and suffixInc[i])
    return ans

testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)
    print(""yes"" if isMountain(A) else ""no"")


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for {{completion}}:
        solve(tc + 1)
    assert not tokens",tc in range(testcaseCount),"tc in range(testcaseCount):
        solve(testcaseCount)
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        "
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    P = [getIntArray(2) for i in range(N)] + [[0, 0]]
    minX = abs(min(p[0] for p in P))
    maxX = abs(max(p[0] for p in P))
    minY = abs(min(p[1] for p in P))
    maxY = abs(max(p[1] for p in P))
    print(minX + minY + maxX + maxY << 1)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for {{completion}}:
        solve(tc + 1)
    assert not tokens",tc in range(testcaseCount),tc in testcaseCount
"a=[*map(int,[*open(0)][1].split())]
for k in 0,1:
	for i in range(19):
		z=1<<i
		for j in range(len(a)):
			if {{completion}}:a[j-k*z]^=a[j+k*z-z]
print(*reversed(a))
",j&z,"a[j]&z:
				a[j]^=a[j-k*z]
print(*reversed(a))
""""""
a=[*map(int,[*open(0)][1].split())]
for k in 0,1:
	for i in range(19):
		z=1<<i
		for j in range(len(a)):
			if a[j]&z:
				a[j]^=a[j-k*z]
print(*reversed(a))
""""""
a=[*map(int,[*open(0)][1].split())]
for k in 0,1:
	for i in range(19):
		z=1<<i
		for j in range(len(a)):
			if a[j]&z"
"a=[*map(int,[*open(0)][1].split())]
n=len(a)
for k in 0,1:
    for i in range(19):
        for j in range(n):
            l=j^1<<i
            if {{completion}}:
                a[j]^=a[l]
print(*reversed(a))
",k^(l<j)and l<n,l<n
"input()
n = int(input(), 2)
m = n
for {{completion}}:
    n = max(n, m | m >> i)
print(bin(n)[2:])",i in range(30),"_ in range(n):
    m = int(input(), 2)
for i in range(n):
    if m & 1 == 1:
        m |= 1 << i
    else:
        m &= ~(1 << i)
if m == n:
    print(bin(n)[2:])
else:
    print(bin(n)[2:], bin(m)[2:])
""""""
n = int(input())
m = n
for i in range(n):
    if m & 1 == 1:
        m |= 1 << i
    else:
        m &= ~(1 << i)
if m == n:
    print(bin(n)[2:])
else:
    print(bin(n)[2:], bin(m)[2:])
<|/ file ext=.py dstars=0 |>"
"n = int(input())
s=input()
b=int(s,2)
a=b;
mx=a|b
for i in range(0,7):
  a=a>>1
  m=a|b
  if {{completion}}:
    mx=m
st=format(mx ,""b"")
print(st)",m>mx,"m>mx:
    mx=m
st=format(mx ,""b"")
print(st)
<|/ file filename=P1.py |>
<| c |>
Welcome to Stack Overflow! You can [take the tour](http://stackoverflow.com/tour) first and learn [How to Ask a good question](http://stackoverflow.com/help/how-to-ask) and create a [Minimal, Complete, and Verifiable](http://stackoverflow.com/help/mcve) example. That makes it easier for us to help you.
<|/ c |>
<| c |>
Please don't post code as images. See [How do I ask and answer homework questions?](https://meta.stackoverflow.com/questions/334822/"
"n = input()
s = int(input(),2)

res = 0
for {{completion}}:
    res = max(res,(s | (s >> i)))
ans = bin(res)[2:]
print(ans)",i in range(100),"_ in range(n):
    i = random.randint(1,3)
    s ^= s
    if i == 1:
        s ^= 1
    if i == 2:
        s ^= 0
    if i == 3:
        s ^= 0
    if i == 4:
        s ^= 1
    if i == 5:
        s ^= 0
    if i == 6:
        s ^= 0
    if i == 7:
        s ^= 0
    if i == 8:
        s ^= 0
    if i == 9:
        s ^= 0
    if i == 10:
        s ^= 0
    if i == 11:
        s "
"input()
n=int(input(),2)
ans=0
for {{completion}}:
    ans=max(ans,n|(n>>i))
print(bin(ans)[2:])

","i in range(1,64)","_ in range(n):
    s=input()
    ans=max(ans,n|(n>>s))
print(bin(ans)[2:])

input()
n=int(input(),2)
ans=0
for i in range(n):
    s=input()
    for j in range(n):
        if j==i:
            continue
        ans=max(ans,n|(n>>s)|(n>>j))
print(bin(ans)[2:])

input()
n=int(input(),2)
ans=0
for i in range(n):
    s=input()
    for j in range(n):
        if j==i:
            continue
        ans=max(ans,n|(n>>s)"
"n = input()
s = int(input(), base=2)
t = s
for {{completion}}:
    t = max(t, s | s >> i)
print(""{0:b}"".format(t))","i in range(1,10)","_ in range(n):
    i = random.randint(1, 3)
    s = s ^ s
    if i == 1 and s == t:
        continue
    if i == 2 and s == t:
        continue
    if i == 3:
        break
    if s == t:
        continue
    if s >> i == t:
        continue
    if s >> i == t >> i:
        continue
    if s >> i == t >> i >> i:
        continue
    if s >> i == t >> i >> i >> i:
        continue
    if s >> i == t >> i >> i >> i >> i:
        continue
    if s >> i == t >> i >> i >> i >> i >> i:
        continue
    if s >> i == t >> i >> "
"n = int(input())
s = input().strip()

s1 = int('0b'+s,2)
res = s1

for {{completion}}:
    res = max(s1 | (s1 >> i), res)

print(bin(res)[2:])","i in range(1,8)","_ in range(n-1):
    s2 = int(bin(random.randint(0,2**n))[2:],2)
    res = max(s1 | (s1 >> i), res)
    s1 = s2

for _ in range(n-1):
    s2 = int(bin(random.randint(0,2**n))[2:],2)
    res = max(s1 | (s1 >> i), res)
    s1 = s2

for _ in range(n-1):
    s2 = int(bin(random.randint(0,2**n))[2:],2)
    res = max(s1 | (s1 >> i), res)
    s1 = s2

for _ in range(n-1):
    s2 = int(bin(random.randint(0,2**n))[2:],2)
    res = max(s1 | (s1 >> i), res)
    s"
"def random(st):
	n = 8
	st = int(st, 2)
	MAX = st
	for {{completion}}:
		MAX = max((st >> t) | st, MAX)

	return bin(MAX)[2:]


N = input()
b = input()
print(random(b))
",t in range(n),"t in range(n):
		MAX = (st >> t) | st
	return bin(MAX)[2:]

def random(st):
	n = 8
	st = int(st, 2)
	MAX = st
	for t in range(n):
		MAX = (st >> t) | st
	return bin(MAX)[2:]

def random(st):
	n = 8
	st = int(st, 2)
	MAX = st
	for t in range(n):
		MAX = (st >> t) | st
	return bin(MAX)[2:]

def random(st):
	n = 8
	st = int(st, 2)
	MAX = st
"
"# وده اقل حاجه ببايثون
input()
n=int(input(),2)
m=n
for {{completion}}:m=max(m,n|n>>i)
print(""{0:b}"".format(m))","i in range(1,100)","_ in range(n):
    s=input()
    s=list(s)
    i=0
    while i<len(s):
        if s[i]=='1':
            s[i]='0'
        else:
            s[i]='1'
        i+=1
    s="""".join(s)
    s=list(s)
    i=0
    while i<len(s):
        if s[i]=='1':
            s[i]='0'
        else:
            s[i]='1'
        i+=1
    s="""".join(s)
    s=list(s)
    i=0
    while i<len(s):
        if s[i]=='1':
            s[i]='0'
        else:
            s[i]='1'
        i+=1
    s="""".join(s)
    s=list("
"n = int(input())
a = int(input(), 2)
temp = a
mx = a|temp
for i in range(7):
    temp = temp >> 1
    m = a|temp
    if {{completion}}:
        mx = m

print(bin(mx).replace('0b', ''))
",mx < m,"m > mx:
        mx = m
print(bin(mx).replace('0b', ''))
""""""
<|/ file source=github ext=.py |>"
"import sys
import heapq
from collections import Counter
# sys.setrecursionlimit(10000)


def input_general():
    return sys.stdin.readline().rstrip('\r\n')


def input_num():
    return int(sys.stdin.readline().rstrip(""\r\n""))


def input_multi(x=int):
    return map(x, sys.stdin.readline().rstrip(""\r\n"").split())


def input_list(x=int):
    return list(input_multi(x))


def main():
    def mod_pow(p, a, e):
        base = a
        answer = 1

        while e:
            if {{completion}}:
                answer = (answer * base) % p

            base = (base * base) % p
            e >>= 1
        return answer

    n = input_num()
    hp = []
    pos = [[] for _ in range(300001)]
    for i in range(n):
        l, r = input_multi()
        pos[l].append((i, r + 1))

    P = 998244353
    two_inv = (P + 1) // 2

    loc = [-1] * 300001
    for i in range(300001):
        for (idx, r) in pos[i]:
            heapq.heappush(hp, (-idx, r))

        while hp and hp[0][1] <= i:
            heapq.heappop(hp)

        if hp:
            loc[i] = -hp[0][0]

    ctr = Counter(loc)
    max_loc = max(ctr.keys())

    curr = mod_pow(P, 2, n - 1)

    answer = (curr * (ctr[0] + ctr[1])) % P
    for i in range(2, max_loc + 1):
        curr = (curr * two_inv * 3) % P
        answer = (answer + curr * ctr[i]) % P

    print(answer)


if __name__ == ""__main__"":
    # cases = input_num()
    #
    # for _ in range(cases):
    main()
",e & 1,"e & 1:
                answer = (answer * base) % p
            if e >> 1:
                answer = (answer * base) % p
            base = (base * base) % p
            e >>= 1
        return answer

    n = input_num()
    hp = []
    pos = [[] for _ in range(300001)]
    for i in range(n):
        l, r = input_multi()
        pos[l].append((i, r + 1))

    P = 998244353
    two_inv = (P + 1) // 2

    loc = [-1] * 300001
    for i in range(300001):
        for (idx, r) in pos[i]:
            heapq.heappush(hp, (-idx, "
"import sys
input=sys.stdin.readline
from collections import defaultdict
from heapq import heappop,heappush

def solve():
    N=int(input())
    p=998244353

    # 2와 3의 거듭제곱 저장
    two=[1]
    for _ in range(N):
        two.append((two[-1]*2)%p)
    three=[1]
    for _ in range(N):
        three.append((three[-1]*3)%p)

    # 각 원소별로 마지막 출현 인덱스 저장
    def lazy(n,cur,start,end,left,right):
        if end<left or right<start:
            return
        elif left<=start and end<=right:
            st[cur]=n
        else:
            lazy(n,2*cur,start,(start+end)//2,left,right)
            lazy(n,2*cur+1,(start+end)//2+1,end,left,right)
    def update(cur,start,end):
        if start==end:
            last[start]=st[cur]
            return
        if 2*cur<1200000:
            if {{completion}}:
                st[2*cur]=st[cur]
            update(2*cur,start,(start+end)//2)
        if 2*cur+1<1200000:
            if st[2*cur+1]<st[cur]:
                st[2*cur+1]=st[cur]
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input().split())
        lazy(n,1,0,300000,a,b)
    update(1,0,300000)

    # last값을 기준으로 마지막 연산
    ans=0
    A=defaultdict(int)
    for l in last:
        if l!=0:
            A[l]+=1
    for l in A:
        ans=(ans+A[l]*(three[l-1]*two[N-l]))%p
    print(ans)
solve()",st[2*cur]<st[cur],"st[2*cur]<st[cur]:
                st[2*cur]=st[cur]
            update(2*cur,start,(start+end)//2)
        if 2*cur+1<1200000:
            if st[2*cur+1]<st[cur]:
                st[2*cur+1]=st[cur]
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input"
"import sys
input=sys.stdin.readline
from collections import defaultdict
from heapq import heappop,heappush

def solve():
    N=int(input())
    p=998244353

    # 2와 3의 거듭제곱 저장
    two=[1]
    for _ in range(N):
        two.append((two[-1]*2)%p)
    three=[1]
    for _ in range(N):
        three.append((three[-1]*3)%p)

    # 각 원소별로 마지막 출현 인덱스 저장
    def lazy(n,cur,start,end,left,right):
        if end<left or right<start:
            return
        elif left<=start and end<=right:
            st[cur]=n
        else:
            lazy(n,2*cur,start,(start+end)//2,left,right)
            lazy(n,2*cur+1,(start+end)//2+1,end,left,right)
    def update(cur,start,end):
        if start==end:
            last[start]=st[cur]
            return
        if 2*cur<1200000:
            if st[2*cur]<st[cur]:
                st[2*cur]=st[cur]
            update(2*cur,start,(start+end)//2)
        if 2*cur+1<1200000:
            if {{completion}}:
                st[2*cur+1]=st[cur]
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input().split())
        lazy(n,1,0,300000,a,b)
    update(1,0,300000)

    # last값을 기준으로 마지막 연산
    ans=0
    A=defaultdict(int)
    for l in last:
        if l!=0:
            A[l]+=1
    for l in A:
        ans=(ans+A[l]*(three[l-1]*two[N-l]))%p
    print(ans)
solve()",st[2*cur+1]<st[cur],"st[2*cur+1]>st[cur]:
                st[2*cur+1]=st[cur]
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input().split())
        lazy(n,1,0,300000,a,b)
    update(1,0,300000)

    ans=0
    A=defaultdict(int)
    for l in last:
        if l!=0:
            A[l]+"
"from collections import deque;I=input;R=lambda:map(int,I().split())
def f(x,pre):
  global flg;dp=[0]*(n+1)
  q=deque([(x,pre)]);R=[]
  while q:
    u,p=q.popleft()
    R.append((u))
    for v in g[u]:
      if {{completion}}:q.append((v,u))
  for u in R[::-1]:
    path=0;dp[u]+=1 if u in s else 0
    for v in g[u]:
      path+=(1 if dp[v] else 0);dp[u]+=dp[v]
    flg=flg and (path<=1 or path==2 and k==dp[u])
  return dp[x]

n=int(I());g=[[] for _ in range(n+1)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)
for _ in [0]*int(I()):
  k=int(I());flg=1;s=set(R());f(1,0)
  print(['NO','YES'][flg])",v!=p,"dp[v]!=pre:
        dp[v]=pre
        q"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
from collections import deque
n=I();adj=[[] for i in range(n)]
for i in range(n-1):
    p,q=M()
    adj[p-1].append(q-1)
    adj[q-1].append(p-1)
p=[-1]*n;d=[0]*n
q=deque([0]);v=[0]*n
while q:
    r=q.popleft()
    v[r]=1
    for j in adj[r]:
        if {{completion}}:
            q.append(j);d[j]=d[r]+1;p[j]=r
q=I()
for i in range(q):
    k=I()
    a=L();y=a[:]
    f=0;z=[]
    j=0;m=0;s=set()
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s1=set();x=0
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s and p[j]!=-1:
        s1.add(j);j=p[j]
    for t in range(len(z)-1,-1,-1):
        if z[t]==j:x=1
        if x==1:s1.add(z[t])
    for i in y:
        if i-1 not in s1:f=1;break
    print(""NO"" if f else ""YES"")",v[j]==0,"v[j]==1:
            q.append(j);d[j]=d[r]+1;p[j]=r
q=I()
for i in range(q):
    k=I()
    a=L();y=a[:]
    f=0;z=[]
    j=0;m=0;s=set()
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
from collections import deque
n=I();adj=[[] for i in range(n)]
for i in range(n-1):
    p,q=M()
    adj[p-1].append(q-1)
    adj[q-1].append(p-1)
p=[-1]*n;d=[0]*n
q=deque([0]);v=[0]*n
while q:
    r=q.popleft()
    v[r]=1
    for j in adj[r]:
        if v[j]==0:
            q.append(j);d[j]=d[r]+1;p[j]=r
q=I()
for i in range(q):
    k=I()
    a=L();y=a[:]
    f=0;z=[]
    j=0;m=0;s=set()
    for i in a:
        if {{completion}}:m=d[i-1];j=i-1
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s1=set();x=0
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s and p[j]!=-1:
        s1.add(j);j=p[j]
    for t in range(len(z)-1,-1,-1):
        if z[t]==j:x=1
        if x==1:s1.add(z[t])
    for i in y:
        if i-1 not in s1:f=1;break
    print(""NO"" if f else ""YES"")",d[i-1]>m,"d[i-1]>m:m=d[i-1];j=i-1
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s1=set();x=0
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s and p[j]!=-1:
        s1.add(j);j=p[j]
    for t in range(len(z)-1,-1,-1):
        if z[t]==j:x=1"
"def solve():
    n = int(input())
    g = [[] for _ in range(n)]

    for _ in range(n-1):
        u, v = [int(t) for t in input().split()]
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)

    q = int(input())
    for _ in range(q):
        input()
        S = [int(t)-1 for t in input().split()]

        in_S = [0] * n
        for v in S:
            in_S[v] = 1

        v = S[0]
        w = farthest(g, v, in_S)
        y = farthest(g, w, in_S)
        P = set(path(g, w, y))
        ans = ""YES"" if P.issuperset(S) else ""NO""

        print(ans)


def farthest(g, v, in_S):
    queue = [v]
    depth = [-1] * len(g)
    depth[v] = 0
    res = (0, v)
    for v in queue:
        if in_S[v]:
            res = max(res, (depth[v], v))
        for nei in g[v]:
            if {{completion}}:
                queue.append(nei)
                depth[nei] = depth[v] + 1
    return res[1]

def path(g, st, en):
    queue = [st]
    prev = [-1] * len(g)
    prev[st] = st
    for v in queue:
        for nei in g[v]:
            if prev[nei] == -1:
                queue.append(nei)
                prev[nei] = v

    res = [en]
    while prev[res[-1]] != res[-1]:
        res.append(prev[res[-1]])

    return res[::-1]


import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

solve()

os.write(1, stdout.getvalue())",depth[nei] == -1,"depth[nei] == depth[v] + 1:
                queue.append(nei)
                depth[nei] = depth[v] + 1
    return res[1]

def path(g, st, en):
    queue = [st]
    prev = [-1] * len(g)
    prev[st] = st
    for v in queue:
        for nei in g[v]:
            if prev[nei] == -1:
                queue.append(nei)
                prev[nei] = v

    res = [en]
    while prev[res[-1]] != res[-1]:
        res.append(prev[res[-1]])

    return res[::-1]


import sys, os, io
input = lambda: sys.stdin.readline"
"def solve():
    n = int(input())
    g = [[] for _ in range(n)]

    for _ in range(n-1):
        u, v = [int(t) for t in input().split()]
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)

    q = int(input())
    for _ in range(q):
        input()
        S = [int(t)-1 for t in input().split()]

        in_S = [0] * n
        for v in S:
            in_S[v] = 1

        v = S[0]
        w = farthest(g, v, in_S)
        y = farthest(g, w, in_S)
        P = set(path(g, w, y))
        ans = ""YES"" if P.issuperset(S) else ""NO""

        print(ans)


def farthest(g, v, in_S):
    queue = [v]
    depth = [-1] * len(g)
    depth[v] = 0
    res = (0, v)
    for v in queue:
        if in_S[v]:
            res = max(res, (depth[v], v))
        for nei in g[v]:
            if depth[nei] == -1:
                queue.append(nei)
                depth[nei] = depth[v] + 1
    return res[1]

def path(g, st, en):
    queue = [st]
    prev = [-1] * len(g)
    prev[st] = st
    for v in queue:
        for nei in g[v]:
            if {{completion}}:
                queue.append(nei)
                prev[nei] = v

    res = [en]
    while prev[res[-1]] != res[-1]:
        res.append(prev[res[-1]])

    return res[::-1]


import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

solve()

os.write(1, stdout.getvalue())",prev[nei] == -1,nei == en
"import sys
from array import array


class graph:
    def __init__(self, n):
        self.n, self.gdict = n, [array('i') for _ in range(n + 1)]

    def add_edge(self, node1, node2):
        self.gdict[node1].append(node2)
        self.gdict[node2].append(node1)

    def dfs(self, root):
        stk, ret = array('i', [root]), 0

        while stk:
            node = stk.pop()
            for ch in self.gdict[node]:
                if not vis[ch]:
                    vis[ch] = True

                    while {{completion}}:
                        vis[stk.pop()] = 0

                    ret |= mem[ch]
                    stk.append(ch)
        return ret


input = lambda: sys.stdin.buffer.readline().decode().strip()
n = int(input())
g = graph(n)

for _ in range(n - 1):
    u, v = map(int, input().split())
    g.add_edge(u, v)

for i in range(int(input())):
    k, a = int(input()), array('i', [int(x) for x in input().split()])
    vis = array('b', [False] * (n + 1))
    mem = array('b', [0] * (n + 1))
    vis[a[0]], paths = 1, 0

    for j in a:
        mem[j] = 1

    for j in g.gdict[a[0]]:
        vis[j] = 1
        paths += g.dfs(j) | mem[j]

    for j in a:
        if not vis[j]:
            paths = 3
            break

    print('yes' if paths < 3 else 'no')
",mem[ch] and stk,stk and mem[stk[-1]] == 
"from collections import deque
import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
    
    # build a tree with BFS
    par = [-1] * n
    depth = [0] * n
    q = deque([0])
    while q:
        u = q.popleft()
        for v in G[u]:
            if {{completion}}:
                par[v] = u
                depth[v] = depth[u] + 1
                q.append(v)

    # Path to LCA
    def build_path(u, v):
        path = []
        if depth[u] < depth[v]:
            u, v = v, u
        while depth[u] > depth[v]:
            path.append(u)
            u = par[u]
        while u != v:
            path.append(u)
            path.append(v)
            u, v = par[u], par[v]
        path.append(u)
        return path


    res = []
    q = int(input())
    for _ in range(q):
        k = int(input())
        P = [int(x) - 1 for x in input().split()]
        
        if k == 1:
            res.append(""YES"")
            continue
        
        P.sort(key=lambda u: depth[u])
        u = P.pop()
        v = P.pop()        
        path = build_path(u, v)
        
        while P and u == path[0] and v == path[-1]:
            u = v
            v = P.pop()
            path = build_path(u, v)

        ans = ""YES""
        for u in P:
            if u not in path:
                ans = ""NO""
                break
        res.append(ans)

    return res

res = solve()
print(""\n"".join(res))",v != par[u],par[v] == u
"from collections import deque
import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
    
    # build a tree with BFS
    par = [-1] * n
    depth = [0] * n
    q = deque([0])
    while q:
        u = q.popleft()
        for v in G[u]:
            if v != par[u]:
                par[v] = u
                depth[v] = depth[u] + 1
                q.append(v)

    # Path to LCA
    def build_path(u, v):
        path = []
        if depth[u] < depth[v]:
            u, v = v, u
        while depth[u] > depth[v]:
            path.append(u)
            u = par[u]
        while u != v:
            path.append(u)
            path.append(v)
            u, v = par[u], par[v]
        path.append(u)
        return path


    res = []
    q = int(input())
    for _ in range(q):
        k = int(input())
        P = [int(x) - 1 for x in input().split()]
        
        if k == 1:
            res.append(""YES"")
            continue
        
        P.sort(key=lambda u: depth[u])
        u = P.pop()
        v = P.pop()        
        path = build_path(u, v)
        
        while P and u == path[0] and v == path[-1]:
            u = v
            v = P.pop()
            path = build_path(u, v)

        ans = ""YES""
        for u in P:
            if {{completion}}:
                ans = ""NO""
                break
        res.append(ans)

    return res

res = solve()
print(""\n"".join(res))",u not in path,u != path[-1]
"input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1


n = int(input())
adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v = map(mapnode, input().split())
    adj[u].append(v)
    adj[v].append(u)

# dfs
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)]
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if {{completion}}:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for _ in range(19):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])

# print('depth', depth)
# print('jump', jump)

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    step = depth[u] - depth[v]
    for i in range(19):
        if (step >> i) & 1 == 1:
            u = jump[i][u]

    if u == v:
        return u
    
    # move up together
    for i in range(18, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# answer queries
for _ in range(int(input())):
    nk = int(input())
    
    nodes = list(sorted(map(mapnode, input().split()), key=lambda u: -depth[u]))
    mindepth = min(depth[u] for u in nodes)

    # check from lowest depth
    tocheck = [nodes[i] for i in range(1, nk) if nodes[i] != lca(nodes[0], nodes[i])]
    
    # print(subroot+1, [x+1 for x in tocheck], [x+1 for x in nodes])
    ok = len(tocheck) == 0 or all(lca(tocheck[0], u) == u for u in tocheck) and depth[lca(tocheck[0], nodes[0])] <= mindepth
    print('YES' if ok else 'NO')
",v != par,"depth[v] > depth[u] + 1:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for _ in range(19):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    step = depth[u] - depth[v]
    for i in range(19):
        if (step >> i) & 1 == 1:
            u = jump[i][u]

    if u == v:
        return u
    
    u, v = jump[0][u], jump[0][v]
    return u

for _ in range(int(input())):
    n"
"input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1


n = int(input())
adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v = map(mapnode, input().split())
    adj[u].append(v)
    adj[v].append(u)

# dfs
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)]
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for _ in range(19):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])

# print('depth', depth)
# print('jump', jump)

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    step = depth[u] - depth[v]
    for i in range(19):
        if {{completion}}:
            u = jump[i][u]

    if u == v:
        return u
    
    # move up together
    for i in range(18, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# answer queries
for _ in range(int(input())):
    nk = int(input())
    
    nodes = list(sorted(map(mapnode, input().split()), key=lambda u: -depth[u]))
    mindepth = min(depth[u] for u in nodes)

    # check from lowest depth
    tocheck = [nodes[i] for i in range(1, nk) if nodes[i] != lca(nodes[0], nodes[i])]
    
    # print(subroot+1, [x+1 for x in tocheck], [x+1 for x in nodes])
    ok = len(tocheck) == 0 or all(lca(tocheck[0], u) == u for u in tocheck) and depth[lca(tocheck[0], nodes[0])] <= mindepth
    print('YES' if ok else 'NO')
",(step >> i) & 1 == 1,"jump[i][u] == jump[i][v]:
            step += jump[i][u]
            u, v = v, u
            break
    
    if step == 0:
        return u
    
    for i in range(19):
        if jump[i][u] != jump[i][v] and step > 0:
            u, v = v, u
            step -= jump[i][u]
            break
    
    if step == 0:
        return u
    
    for i in range(19):
        if jump[i][u] != jump[i][v] and step < 0:
            u, v = v, u
            step += jump[i][u]
            break
    
    if step == 0:
        return u
    
    for i in range(19):
        if jump"
"from collections import defaultdict, deque, Counter
import sys
from decimal import *
from heapq import heapify, heappop, heappush
import math
import random
import string
from copy import deepcopy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce, lru_cache
from bisect import bisect_left, bisect_right

def input():
    return sys.stdin.readline().rstrip()
def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getListGraph():
    return list(map(lambda x:int(x) - 1, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]

mod = 10 ** 9 + 7
MOD = 998244353

# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')
inf = float('inf')
eps = 10 ** (-12)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

#############
# Main Code #
#############

# lca
class Doubling():
    def __init__(self, n, edges, root):
        self.n = n
        self.logn = n.bit_length()
        self.doubling = [[-1] * self.n for _ in range(self.logn)]
        self.depth = [-1] * N
        self.depth[root] = 0
        # bfs
        par = [-1] * N
        pos = deque([root])
        while len(pos) > 0:
            u = pos.popleft()
            for v in edges[u]:
                if {{completion}}:
                    self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)
        # doubling
        for i in range(self.n):
            self.doubling[0][i] = par[i]
        for i in range(1, self.logn):
            for j in range(self.n):
                if self.doubling[i - 1][j] == -1:
                    self.doubling[i][j] = -1
                else:
                    self.doubling[i][j] = self.doubling[i - 1][self.doubling[i - 1][j]]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):
            if (dv - du) >> i & 1:
                v = self.doubling[i][v]
        if u == v: return u

        for i in range(self.logn - 1, -1, -1):
            pu, pv = self.doubling[i][u], self.doubling[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.doubling[0][u]

    def upstream(self, s, t):
        if t == 0:
            return s
        now = s
        for k in range(self.logn):
            if t & (1 << k):
                now = self.doubling[k][now]
        return now

N = getN()
E = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = getNM()
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

D = Doubling(N, E, 0)
Q = getN()
for _ in range(Q):
    q_n = getN()
    V = sorted([[D.depth[p], p] for p in getListGraph()])
    p1 = V.pop()[1]
    flag = True
    while V:
        p2 = V.pop()[1]
        lca_p = D.lca(p1, p2)
        if lca_p != p2:
            while V:
                opt_p = V.pop()[1]
                # print(D.lca(p1, opt_p), (D.lca(p2, opt_p)))
                if not (opt_p == lca_p or ((D.lca(p1, opt_p) == opt_p) ^ (D.lca(p2, opt_p) == opt_p))):
                    flag = False

    print(""YES"" if flag else ""NO"")",self.depth[v] == -1,"par[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)
        self.depth[root] = -1
        self.depth = [-1] * N
        par = [-1] * N
        pos = deque([root])
        while len(pos) > 0:
            u = pos.popleft()
            for v in edges[u]:
                if par[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)
        self.depth[root] = -1
        self.depth = [-1] * N
        par = [-1] * N
        pos = deque([root])
        while len("
"from collections import defaultdict, deque, Counter
import sys
from decimal import *
from heapq import heapify, heappop, heappush
import math
import random
import string
from copy import deepcopy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce, lru_cache
from bisect import bisect_left, bisect_right

def input():
    return sys.stdin.readline().rstrip()
def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getListGraph():
    return list(map(lambda x:int(x) - 1, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]

mod = 10 ** 9 + 7
MOD = 998244353

# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')
inf = float('inf')
eps = 10 ** (-12)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

#############
# Main Code #
#############

# lca
class Doubling():
    def __init__(self, n, edges, root):
        self.n = n
        self.logn = n.bit_length()
        self.doubling = [[-1] * self.n for _ in range(self.logn)]
        self.depth = [-1] * N
        self.depth[root] = 0
        # bfs
        par = [-1] * N
        pos = deque([root])
        while len(pos) > 0:
            u = pos.popleft()
            for v in edges[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)
        # doubling
        for i in range(self.n):
            self.doubling[0][i] = par[i]
        for i in range(1, self.logn):
            for j in range(self.n):
                if self.doubling[i - 1][j] == -1:
                    self.doubling[i][j] = -1
                else:
                    self.doubling[i][j] = self.doubling[i - 1][self.doubling[i - 1][j]]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):
            if (dv - du) >> i & 1:
                v = self.doubling[i][v]
        if u == v: return u

        for i in range(self.logn - 1, -1, -1):
            pu, pv = self.doubling[i][u], self.doubling[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.doubling[0][u]

    def upstream(self, s, t):
        if t == 0:
            return s
        now = s
        for k in range(self.logn):
            if t & (1 << k):
                now = self.doubling[k][now]
        return now

N = getN()
E = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = getNM()
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

D = Doubling(N, E, 0)
Q = getN()
for _ in range(Q):
    q_n = getN()
    V = sorted([[D.depth[p], p] for p in getListGraph()])
    p1 = V.pop()[1]
    flag = True
    while V:
        p2 = V.pop()[1]
        lca_p = D.lca(p1, p2)
        if lca_p != p2:
            while V:
                opt_p = V.pop()[1]
                # print(D.lca(p1, opt_p), (D.lca(p2, opt_p)))
                if {{completion}}:
                    flag = False

    print(""YES"" if flag else ""NO"")","not (opt_p == lca_p or ((D.lca(p1, opt_p) == opt_p) ^ (D.lca(p2, opt_p) == opt_p)))","D.lca(p1, opt_p) == lca_p or D.lca(p2, opt_p) == lca_p:
                    break
                else:
                    V.append(opt_p)
            if V"
"from collections import deque;import math
import sys;I=sys.stdin.readline;R=lambda:map(lambda x:int(x)-1,input().split())
n=int(I());g=[[] for _ in range(n)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)

h=math.ceil(math.log2(n))
fa=[[-1]*(h+1) for _ in range(n)];dep=[0]*n
q=deque([0])
while q:
  u=q.popleft()
  for v in g[u]:
      if {{completion}}:fa[v][0]=u;dep[v]=dep[u]+1;q.append(v)
for i in range(1,h+1):
  for u in range(n):
    fa[u][i]=fa[fa[u][i-1]][i-1]
def lca(u,v):
  if dep[u]<dep[v]:u,v=v,u
  for i in range(h,-1,-1):
    if dep[v]+(1<<i)<=dep[u]:u=fa[u][i]
  if u==v:return u
  for i in range(h,-1,-1):
    if fa[u][i]!=fa[v][i]:u=fa[u][i];v=fa[v][i]
  return fa[u][0]

for _ in [0]*int(I()):
  k=int(I());p=[*R()];z='YES'
  if k<=2:print(z);continue
  p.sort(key=lambda u:dep[u])
  u=p.pop();v=p.pop();f=lca(u,v)
  while p and f==v:u=v;v=p.pop();f=lca(u,v)
  for x in p:
    if dep[x]<=dep[f] and x!=f or lca(u,x)!=x and lca(v,x)!=x:
      z='NO';break
  print(z)",v!=fa[u][0],"fa[u][v]==-1:fa[u][v]=u;fa[v][u]=u;dep[u]+=1;dep[v]+=1
      if dep[u]>dep[v]:q.append(v)
      if dep[u]==dep[v]:break
  if dep[u]==dep[v]:break
  fa[u][h]=fa[v][h]=-1
  q.append(u)
  while q:
    u=q.popleft()
    for v in g[u]:
      if fa[u][v]==-1:fa[u][v]=u;fa[v][u]=u;dep[u]+=1;dep[v"
"from collections import deque;import math
import sys;I=sys.stdin.readline;R=lambda:map(lambda x:int(x)-1,input().split())
n=int(I());g=[[] for _ in range(n)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)

h=math.ceil(math.log2(n))
fa=[[-1]*(h+1) for _ in range(n)];dep=[0]*n
q=deque([0])
while q:
  u=q.popleft()
  for v in g[u]:
      if v!=fa[u][0]:fa[v][0]=u;dep[v]=dep[u]+1;q.append(v)
for i in range(1,h+1):
  for u in range(n):
    fa[u][i]=fa[fa[u][i-1]][i-1]
def lca(u,v):
  if dep[u]<dep[v]:u,v=v,u
  for i in range(h,-1,-1):
    if {{completion}}:u=fa[u][i]
  if u==v:return u
  for i in range(h,-1,-1):
    if fa[u][i]!=fa[v][i]:u=fa[u][i];v=fa[v][i]
  return fa[u][0]

for _ in [0]*int(I()):
  k=int(I());p=[*R()];z='YES'
  if k<=2:print(z);continue
  p.sort(key=lambda u:dep[u])
  u=p.pop();v=p.pop();f=lca(u,v)
  while p and f==v:u=v;v=p.pop();f=lca(u,v)
  for x in p:
    if dep[x]<=dep[f] and x!=f or lca(u,x)!=x and lca(v,x)!=x:
      z='NO';break
  print(z)",dep[v]+(1<<i)<=dep[u],"fa[u][i]<fa[v][i]:u=fa[u][i];v=fa[v][i]
  return u
def dep(u,v):
  for i in range(h,-1,-1):
    if fa[u][i]<fa[v][i]:u=fa[u][i];v=fa[v][i]
  return dep[u]
def lca(u,v):
  if dep[u]<dep[v]:u,v=v,u
  for i in range(h,-1,-1):
    if fa[u][i]<fa[v][i]:u=fa[u][i];v=fa[v][i]
  return u
def dep(u,v):
  for i in range(h,-1,-1):
    if "
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def dfs(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl = s.pop()

        level[p] = lvl
        parent[p][0] = prev
        for i in child[p]:
            if(i == prev):continue

            s.append([i , p , lvl + 1])

def lca(u,v):

    if(level[u] > level[v]):u,v=v,u

    dist=level[v] - level[u]
    for i in range(20,-1,-1):
        if(dist >> i & 1):
            v=parent[v][i]

    if(u==v):return u
    for i in range(20,-1,-1):
        if(parent[u][i] != parent[v][i]):
            u=parent[u][i]
            v=parent[v][i]

    return parent[u][0]

for T in range(1):

    n = int(input())
    child = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u , v = inp()
        child[u].append(v)
        child[v].append(u)


    level = [0 for i in range(n + 1)]
    parent=[[-1 for i in range(21)] for j in range(n + 1)]
    dfs(1 , -1 , 1)

    for j in range(1 , 21):
        for i in range(1 , n + 1):
            if(parent[i][j - 1] == -1):continue
            
            parent[i][j] = parent[parent[i][j - 1]][j - 1]


    for q in range(int(input())):

        x = int(input())
        a = inp()

        maxval = 0
        for i in range(x):
            if(maxval < level[a[i]]):
                maxval = level[a[i]]
                left = a[i]


        maxval = 0
        for i in range(x):
            if(lca(a[i] , left) != a[i]):

                if{{completion}}:
                    maxval = level[a[i]]
                    right = a[i]

        if(maxval == 0):
            print('YES')
            continue


        ok = True
        Lca = lca(left , right)
        for i in range(x):
            if(a[i] == Lca):continue
            
            if(lca(Lca , a[i]) == a[i]):
                ok = False
                break

            if(lca(a[i] , left) != a[i] and lca(a[i] , right) != a[i]):
                ok = False
                break

        if(ok):print('YES')
        else:print('NO')

            
            
",(maxval < level[a[i]]),"(a[i] > maxval):
                    maxval = a[i]
                    right = a[i]

        if(maxval == 0):
            print('YES')
            continue


        ok = True
        Lca = lca(left , right)
        for i in range(x):
            if(a[i] == Lca):continue
            
            if(lca(Lca , a[i]) == a[i]):
                ok = False
                break

            if(lca(a[i] , left) != a[i] and lca(a[i] , right) != a[i]):
                ok = False
                break

        if(ok):print('YES')
        else:print('NO')

            
            
            
            
            
            
            
"
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def dfs(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl = s.pop()

        level[p] = lvl
        parent[p][0] = prev
        for i in child[p]:
            if{{completion}}:continue

            s.append([i , p , lvl + 1])

def lca(u,v):

    if(level[u] > level[v]):u,v=v,u

    dist=level[v] - level[u]
    for i in range(20,-1,-1):
        if(dist >> i & 1):
            v=parent[v][i]

    if(u==v):return u
    for i in range(20,-1,-1):
        if(parent[u][i] != parent[v][i]):
            u=parent[u][i]
            v=parent[v][i]

    return parent[u][0]

for T in range(1):

    n = int(input())
    child = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u , v = inp()
        child[u].append(v)
        child[v].append(u)


    level = [0 for i in range(n + 1)]
    parent=[[-1 for i in range(21)] for j in range(n + 1)]
    dfs(1 , -1 , 1)

    for j in range(1 , 21):
        for i in range(1 , n + 1):
            if(parent[i][j - 1] == -1):continue
            
            parent[i][j] = parent[parent[i][j - 1]][j - 1]


    for q in range(int(input())):

        x = int(input())
        a = inp()

        maxval = 0
        for i in range(x):
            if(maxval < level[a[i]]):
                maxval = level[a[i]]
                left = a[i]


        maxval = 0
        for i in range(x):
            if(lca(a[i] , left) != a[i]):

                if(maxval < level[a[i]]):
                    maxval = level[a[i]]
                    right = a[i]

        if(maxval == 0):
            print('YES')
            continue


        ok = True
        Lca = lca(left , right)
        for i in range(x):
            if(a[i] == Lca):continue
            
            if(lca(Lca , a[i]) == a[i]):
                ok = False
                break

            if(lca(a[i] , left) != a[i] and lca(a[i] , right) != a[i]):
                ok = False
                break

        if(ok):print('YES')
        else:print('NO')

            
            
",(i == prev),"(i == prev):continue
            
            s.append([i , p , lvl + 1])

def dfs2(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl = s.pop()

        level[p] = lvl
        parent[p][0] = prev
        for i in child[p]:
            if(i == prev):continue
            
            s.append([i , p , lvl + 1])

def dfs3(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl"
"import sys


class LCA:
    def __init__(self, g, root=0):
        self.g = g
        self.root = root
        n = len(g)
        self.logn = (n - 1).bit_length()
        self.depth = [None] * n
        self.parent = [[None] * self.logn for _ in range(n)]
        self._dfs()
        self._doubling()

    def _dfs(self):
        self.depth[self.root] = 0
        stack = [self.root]
        while stack:
            u = stack.pop()
            for v in self.g[u]:
                if {{completion}}:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[v][0] = u
                    stack.append(v)

    def _doubling(self):
        for i in range(self.logn - 1):
            for p in self.parent:
                if p[i] is not None:
                    p[i + 1] = self.parent[p[i]][i]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        d = self.depth[v] - self.depth[u]
        for i in range(d.bit_length()):
            if d >> i & 1:
                v = self.parent[v][i]
        if u == v:
            return u
        for i in reversed(range(self.logn)):
            if (pu := self.parent[u][i]) != (pv := self.parent[v][i]):
                u, v = pu, pv
        return self.parent[u][i]


def query(lca):
    k = int(sys.stdin.readline())
    p = sorted(
        (int(x) - 1 for x in sys.stdin.readline().split()),
        key=lca.depth.__getitem__,
        reverse=True,
    )
    branch = []
    top = p[0]
    for x in p[1:]:
        if lca.lca(top, x) == x:
            top = x
        else:
            branch.append(x)
    if not branch:
        return True
    if lca.lca(branch[0], p[0]) != lca.lca(branch[0], top):
        return False
    for i in range(1, len(branch)):
        if lca.lca(branch[i - 1], branch[i]) != branch[i]:
            return False
    return True


n = int(input())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = (int(x) - 1 for x in sys.stdin.readline().split())
    g[u].append(v)
    g[v].append(u)
lca = LCA(g)
for _ in range(int(input())):
    print(""YES"" if query(lca) else ""NO"")
",self.depth[v] is None,v not in self.depth
"import sys


class LCA:
    def __init__(self, g, root=0):
        self.g = g
        self.root = root
        n = len(g)
        self.logn = (n - 1).bit_length()
        self.depth = [None] * n
        self.parent = [[None] * self.logn for _ in range(n)]
        self._dfs()
        self._doubling()

    def _dfs(self):
        self.depth[self.root] = 0
        stack = [self.root]
        while stack:
            u = stack.pop()
            for v in self.g[u]:
                if self.depth[v] is None:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[v][0] = u
                    stack.append(v)

    def _doubling(self):
        for i in range(self.logn - 1):
            for p in self.parent:
                if {{completion}}:
                    p[i + 1] = self.parent[p[i]][i]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        d = self.depth[v] - self.depth[u]
        for i in range(d.bit_length()):
            if d >> i & 1:
                v = self.parent[v][i]
        if u == v:
            return u
        for i in reversed(range(self.logn)):
            if (pu := self.parent[u][i]) != (pv := self.parent[v][i]):
                u, v = pu, pv
        return self.parent[u][i]


def query(lca):
    k = int(sys.stdin.readline())
    p = sorted(
        (int(x) - 1 for x in sys.stdin.readline().split()),
        key=lca.depth.__getitem__,
        reverse=True,
    )
    branch = []
    top = p[0]
    for x in p[1:]:
        if lca.lca(top, x) == x:
            top = x
        else:
            branch.append(x)
    if not branch:
        return True
    if lca.lca(branch[0], p[0]) != lca.lca(branch[0], top):
        return False
    for i in range(1, len(branch)):
        if lca.lca(branch[i - 1], branch[i]) != branch[i]:
            return False
    return True


n = int(input())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = (int(x) - 1 for x in sys.stdin.readline().split())
    g[u].append(v)
    g[v].append(u)
lca = LCA(g)
for _ in range(int(input())):
    print(""YES"" if query(lca) else ""NO"")
",p[i] is not None,"p[i] is not None:
                    p[i + 1] = self.parent[p[i]][i]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        d = self.depth[v] - self.depth[u]
        for i in range(d.bit_length()):
            if d >> i & 1:
                v = self.parent[v][i]
        if u == v:
            return u
        for i in reversed(range(self.logn)):
            if (pu := self.parent[u][i]) != (pv := self.parent[v][i]):
                u, v = pu, pv
        return self.parent[u][i]


def query(lca):
    k = int(sys.stdin.readline())
"
"from collections import Counter
for _ in range(int(input())):
    n=int(input());
    l=list(map(int, input().split()));c = Counter(l);
    if {{completion}}:
        print(-1); continue
    print(*[i if i!=0 and l[i]==l[i-1] else i+c[l[i]] for i in range(n)])",any(x == 1 for x in c.values()),n<2 or n>10^5 or sum(l)<10^9 or any(c[i]>1 for i in range(n))
"import collections
import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    data = dict(collections.Counter(map(int, input().split())))

    if min(list(data.values())) > 1:
        last = 1
        for i in data.keys():
            print(last + data[i] - 1, end=' ')
            for {{completion}}:
                print(j, end=' ')
            last = last + data[i]
        print()
    else:
        print(-1)
","j in range(last, last + data[i] - 1)","j in data.keys():
                if i != j and data[i] <= data[j] and data[i] > last"
"for t in range(int(input())):
    n=int(input())
    x=list(map(int,input().split()))
    g={}
    if n==1:
        print(-1)
    else:


        for i in range(n-1):
            if not((x[i]==x[i+1] or x[i]==x[i-1]) and ( x[-1]==x[-2])):
                print(-1)
                break
            g[x[i]]=[]


        else:
            for i in range(n):
                g[x[i]].append(i+1)
            for i,j in g.items():
                for {{completion}}:
                    print(j[q-1],end=' ')
            print()
            
        
        ",q in range(len(j)),"q in j:
                    if q==i+1:
                        print(i,end=' ')
                        break
                else:
                    print(i,end=' ')
            print()
            
        
        
for t in range(int(input())):
    n=int(input())
    x=list(map(int,input().split()))
    g={}
    if n==1:
        print(-1)
    else:


        for i in range(n-1):
            if not((x[i]==x[i+1] or x[i]==x[i-1]) and ( x[-1]==x[-2])):
                print(-1)
                break
            g[x[i]]=[]


        else:
            for i in range(n):
                g[x[i]].append(i+1)
            for i,j in "
"t = int(input())
for i in range(t):
    n = int(input())
    s = [int(x) for x in input().split(' ')]
    s.append('A')
    f = 0
    p = s[0]
    c = 0
    for x in range(n+1):
        if s[x] == p:
            s[x] = str(x)
            c+=1
        else:
            if {{completion}}:
                s = -1
                break
            else:
                s[f] = str(x)
                f = x
                p = s[x]
                c = 1
    if s != -1:
        s.pop()
        print(' '.join(s))
    else:
        print(s)
",c == 1,"c==1:
                s.append(str(x))
                f = x
                p = s[x]
                c = 0
            elif c>1:
                s[f] = str(x)
                f = x
                p = s[x]
                c = 1
    if s != -1:
        s.pop()
        print(' '.join(s))
    else:
        print(s)
""""""
<|/ a dscore=0 |>
<| a tags=python,algorithm |>
<code>
t = int(input())
for i in range(t):
    n = int(input())
    s = [int(x) for x in input().split(' ')]
    s.append('A')
    f = 0
    p = s[0]
    c = 0
    for x in range(n+1):
        if "
"import sys
input=sys.stdin.readline
for _ in range(int(input())):
    n=int(input())
    x=tuple(map(int,input().split()))
    if n==1:
        print(-1)
        continue
    ans=[-1]*n
    extra=[]
    visited=[False]*n
    for i in range(n-1,-1,-1):
        if i!=0 and x[i]==x[i-1]:
            ans[i]=i
            visited[i-1]=True
            if not visited[i]:
                extra.append(i+1)
        else:
            if {{completion}}:
                ans[i]=extra.pop()
            else:
                print(-1)
                break
    else:
        print(*ans)
",extra,"visited[i] and i!=n-1:
                ans[i]=extra.pop()
            else:
                print(-1)
                break
    else:
        print(*ans)
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
import sys
input=sys.stdin.readline
for _ in range(int(input())):
    n=int(input())
    x=tuple(map(int,input().split()))
    if n==1:
        print(-1)
        continue
    ans=[-1]*n
    extra=[]
    visited=[False]*n
    for i in range(n-1,-1,-1):
        if i!=0 and x[i]==x[i-1]:
            an"
"from sys import stdin
input = stdin.readline

I = lambda : list(map(int, input().split()))

def solve(N,A):
    dic = {}
    
    for i in range(N):
        if {{completion}}:
            dic[A[i]] = []
        dic[A[i]].append(i)

    ans = [0]*N
    for k in dic.keys():
        l = dic[k]
        if len(l) == 1:
            return [-1]
        for i in range(len(l)):
            ans[l[i]] = l[(i-1)%len(l)] + 1
    return ans
    
T = int(input())

for _ in range(T):
    N = int(input())
    A = I()
    print(*solve(N,A))",A[i] not in dic,"A[i] not in dic:
            dic[A[i]] = [i]
        elif dic[A[i]] == [i]:
            dic[A[i]].append(i)
        elif dic[A[i]] != [i] and dic[A[i]][-1] < i:
            dic[A[i]].append(i)
        elif dic[A[i]] != [i] and dic[A[i]][-1] > i:
            dic[A[i]].append(i)
        elif dic[A[i]] == [i] and dic[A[i]][-1] == i:
            dic[A[i]].append(i)
        elif dic[A[i]] == [i] and dic[A[i]][-1] != i:
            dic[A[i]].append("
"from sys import stdin
input = stdin.readline

I = lambda : list(map(int, input().split()))

def solve(N,A):
    dic = {}
    
    for i in range(N):
        if A[i] not in dic:
            dic[A[i]] = []
        dic[A[i]].append(i)

    ans = [0]*N
    for k in dic.keys():
        l = dic[k]
        if {{completion}}:
            return [-1]
        for i in range(len(l)):
            ans[l[i]] = l[(i-1)%len(l)] + 1
    return ans
    
T = int(input())

for _ in range(T):
    N = int(input())
    A = I()
    print(*solve(N,A))",len(l) == 1,l[-1] != N
"for _ in range(int(input())):
    n = int(input())
    arr = list(map(int,input().split()))
    freq = {}
    for i in arr:
        if(i in freq): freq[i] += 1
        else: freq[i] = 1
    for i in freq:
        if(freq[i] == 1): #not in pairs
            print(-1);break
    else:
        ans2 = []
        for i in freq:
            res = []
            res.append(freq[i]+len(ans2))
            for {{completion}}:
                res.append(j+len(ans2))
            ans2.extend(res)
        print(*ans2)","j in range(1,freq[i])",j in arr
"from bisect import bisect_left

cases = int(input())
for run in range(cases):
    n = int(input())
    shoes = input().split()
    for x in range(len(shoes)):
        shoes[x] = int(shoes[x])
    
    perm = []
    i = 0

    while i < len(shoes) and perm != [-1]:
        p = bisect_left(shoes,shoes[i]+1)-1
        if {{completion}}:
            perm = [-1]
        else:
            perm.append(p+1)
            perm += list(range(i+1,p+1))
            i = p+1
            
    print("" "".join([str(int) for int in perm]))
                
                
            
",p == i,"p == -1 or shoes[p] != shoes[i]:
            perm = -1
            break
        elif p == len(shoes)-1 or shoes[p+1] != shoes[i+1]"
"import sys
sys.setrecursionlimit(300000)

import faulthandler
faulthandler.enable()

n, k = map(int, input().split())
MOD = 10**9 + 7

fact = [1 for i in range(n+1)]
for i in range(2, n+1):
	fact[i] = i*fact[i-1] % MOD

inv_fact = [1 for i in range(n+1)]
inv_fact[-1] = pow(fact[-1], MOD-2, MOD)
for i in range(1, n):
	inv_fact[n-i] = (n-i+1)*inv_fact[n-i+1] % MOD

def comb(a, b):
	if a < b:
		return 0
	return fact[a]*inv_fact[b]*inv_fact[a-b] % MOD

edges = [[] for i in range(n)]
for _ in range(n-1):
	x, y = map(lambda a: int(a)-1, input().split())
	edges[x].append(y)
	edges[y].append(x)

ends = [[] for i in range(n)]

visited = [0 for i in range(n)]
totals = [1 for i in range(n)]
dfs_stack = [0]

while len(dfs_stack) > 0:
	node = dfs_stack[-1]

	if visited[node] == 1:
		visited[node] = 2

		for next_node in edges[node]:
			if visited[next_node] == 2:
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])

		ends[node].append(n-totals[node])
		dfs_stack.pop()
	else:
		visited[node] = 1

		for next_node in edges[node]:
			if {{completion}}:
				dfs_stack.append(next_node)

z = n*n * comb(n, k) % MOD
node_v = [0 for i in range(n)]

for i in range(n):
	node_v[i] = sum(comb(e, k) for e in ends[i]) % MOD

	for e in ends[i]:
		z = (z - e*e * (comb(n-e, k) + comb(e, k) - node_v[i])) % MOD

print(z)",visited[next_node] == 0,"visited[next_node] == 1:
				dfs_stack.append(next_node)

		dfs_stack.pop()

for node in visited:
	if visited[node] == 2:
		totals[node] += totals[node]
		ends[node].append(totals[node])

		dfs_stack.append(node)

for node in visited:
	if visited[node] == 1:
		totals[node] += totals[node]
		ends[node].append(totals[node])

		dfs_stack.append(node)

while len(dfs_stack) > 0:
	node = dfs_stack[-1]

	if visited[node] == 1:
		visited[node] = 2

		for "
"import sys
sys.setrecursionlimit(300000)

import faulthandler
faulthandler.enable()

n, k = map(int, input().split())
MOD = 10**9 + 7

fact = [1 for i in range(n+1)]
for i in range(2, n+1):
	fact[i] = i*fact[i-1] % MOD

inv_fact = [1 for i in range(n+1)]
inv_fact[-1] = pow(fact[-1], MOD-2, MOD)
for i in range(1, n):
	inv_fact[n-i] = (n-i+1)*inv_fact[n-i+1] % MOD

def comb(a, b):
	if a < b:
		return 0
	return fact[a]*inv_fact[b]*inv_fact[a-b] % MOD

edges = [[] for i in range(n)]
for _ in range(n-1):
	x, y = map(lambda a: int(a)-1, input().split())
	edges[x].append(y)
	edges[y].append(x)

ends = [[] for i in range(n)]

visited = [0 for i in range(n)]
totals = [1 for i in range(n)]
dfs_stack = [0]

while len(dfs_stack) > 0:
	node = dfs_stack[-1]

	if visited[node] == 1:
		visited[node] = 2

		for next_node in edges[node]:
			if {{completion}}:
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])

		ends[node].append(n-totals[node])
		dfs_stack.pop()
	else:
		visited[node] = 1

		for next_node in edges[node]:
			if visited[next_node] == 0:
				dfs_stack.append(next_node)

z = n*n * comb(n, k) % MOD
node_v = [0 for i in range(n)]

for i in range(n):
	node_v[i] = sum(comb(e, k) for e in ends[i]) % MOD

	for e in ends[i]:
		z = (z - e*e * (comb(n-e, k) + comb(e, k) - node_v[i])) % MOD

print(z)",visited[next_node] == 2,"visited[next_node] == 0 and totals[next_node] < n:
				totals[next_node] += 1
				ends[next_node].append(totals[next_node])
				dfs_stack.append(next_node)
				
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])

				totals[next_node] += 1
				ends[next_node].append(totals[next_node])
				dfs_stack.append(next_node)
				
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])
				dfs_stack.append(next_node)
				
				totals["
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 10 ** 9 + 7

n, k = I()

binomk = [0] * k
binomk.append(1)
for i in range(k + 1, n + 1):
	binomk.append(binomk[-1] * i * pow(i - k, M - 2, M) % M)
neighbors = [[] for i in range(n)]
for i in range(n - 1):
	a, b = I()
	a -= 1
	b -= 1
	neighbors[a].append(b)
	neighbors[b].append(a)
parents = [None] + [-1] * (n - 1)
children = [[] for i in range(n)]
layer = [0]
while layer:
	newlayer = []
	for guy in layer:
		for boi in neighbors[guy]:
			if {{completion}}:
				children[guy].append(boi)
				parents[boi] = guy
				newlayer.append(boi)
	layer = newlayer
size = [0] * n
q = []
for i in range(n):
	if len(children[i]) == 0:
		q.append(i)
qind = 0
left = [len(children[i]) for i in range(n)]
while qind < len(q):
	v = q[qind]
	tot = 1
	for guy in children[v]:
		tot += size[guy]
	size[v] = tot
	if parents[v] is None:
		break
	left[parents[v]] -= 1
	if left[parents[v]] == 0:
		q.append(parents[v])
	qind += 1

answer = 0
for i in range(n):
	things = []
	for guy in children[i]:
		things.append(size[guy])
	if i != 0:
		things.append(n - 1 - sum(things))
	bins = [binomk[i] for i in things]
	ss = sum(bins) % M
	for guy in things:
		answer = (answer + (n - guy) * guy * binomk[n - guy]) % M
		answer = (answer - (n - guy) * guy * (ss - binomk[guy])) % M
	answer = (answer + n * binomk[n]) % M
	answer = (answer - ss * n) % M
print(answer)
",boi != parents[guy],boi not in layer
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 10 ** 9 + 7

n, k = I()

binomk = [0] * k
binomk.append(1)
for i in range(k + 1, n + 1):
	binomk.append(binomk[-1] * i * pow(i - k, M - 2, M) % M)
neighbors = [[] for i in range(n)]
for i in range(n - 1):
	a, b = I()
	a -= 1
	b -= 1
	neighbors[a].append(b)
	neighbors[b].append(a)
parents = [None] + [-1] * (n - 1)
children = [[] for i in range(n)]
layer = [0]
while layer:
	newlayer = []
	for guy in layer:
		for {{completion}}:
			if boi != parents[guy]:
				children[guy].append(boi)
				parents[boi] = guy
				newlayer.append(boi)
	layer = newlayer
size = [0] * n
q = []
for i in range(n):
	if len(children[i]) == 0:
		q.append(i)
qind = 0
left = [len(children[i]) for i in range(n)]
while qind < len(q):
	v = q[qind]
	tot = 1
	for guy in children[v]:
		tot += size[guy]
	size[v] = tot
	if parents[v] is None:
		break
	left[parents[v]] -= 1
	if left[parents[v]] == 0:
		q.append(parents[v])
	qind += 1

answer = 0
for i in range(n):
	things = []
	for guy in children[i]:
		things.append(size[guy])
	if i != 0:
		things.append(n - 1 - sum(things))
	bins = [binomk[i] for i in things]
	ss = sum(bins) % M
	for guy in things:
		answer = (answer + (n - guy) * guy * binomk[n - guy]) % M
		answer = (answer - (n - guy) * guy * (ss - binomk[guy])) % M
	answer = (answer + n * binomk[n]) % M
	answer = (answer - ss * n) % M
print(answer)
",boi in neighbors[guy],"boi in neighbors[guy]:
			if boi != parents[guy]:
				children[guy].append(boi)
				parents[boi] = guy
				newlayer.append(boi)
	layer = newlayer
size = [0] * n
q = []
for i in range(n):
	if len(children[i]) == 0:
		q.append(i)
qind = 0
left = [len(children[i]) for i in range(n)]
while qind < len(q):
	v = q[qind]
	tot = 1
	for guy in children[v]:
		tot += size[guy]
	size[v] = tot
	if parents[v] is None:"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    if N % 2 == 0:
        a1 = [A[i] for i in range(0, N, 2)]
        a2 = [A[i] for i in range(1, N, 2)]

        i1, i2 = a1.index(min(a1)), a2.index(min(a2))
        m1 = min(a1) * len(a1) + i1
        m2 = min(a2) * len(a2) + i2

        print(""Mike"" if m1 > m2 else ""Joe"")
    else:
        print(""Mike"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for {{completion}}:
        solve(tc + 1)
    assert not tokens",tc in range(testcaseCount),"tc in range(1, testcaseCount + 1):
        if tc % 2 == 0:
            solve(testcase)
        else:
            solve(tc)
        
    if tc % 2 == 0:
        solve(tc)
    else:
        solve(tc + 1)
    
    if tc % 2 == 0:
        solve(tc)
    else:
        solve(tc + 1)
    
    if tc % 2 == 0:
        solve(tc)
    else:
        solve(tc + 1)
    
    if tc % 2 == 0:
        solve(tc)
    else:
        solve(tc + 1)
    
    if tc % 2 == 0:
        solve"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if {{completion}}: continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i == 0 and j == 0,A[i][j] == -1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if {{completion}}: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i,"A[i][j] == 0: continue
            if A[i - 1][j] == 0: continue
            if A[i][j - 1] == 0: continue
            if A[i - 1][j - 1] == 0: continue
            if A[i - 1][j] > 0: B[i][j] |= B[i - 1][j]
            if A[i][j] > 0: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] |= B[i][j - 1]
            if "
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for _ in range(N)]

    if N < M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if {{completion}}: continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i == 0 and j == 0,"A[i][j] > 0: B[i][j] |= 1 << get(A[i][j])
            else: B[i][j] |= 1 << (N + M - 1 - j)
            if i == N - 1 and j == M - 1: B[i][j] |= 1 << get(0)
            if j == M - 1: B[i][j] |= 1 << get(0)
            if i == N - 1: B[i][j] |= 1 << get(0)
            if i == 0: B[i][j] |= 1 << get(0)
            if j == 0: B[i][j] |= 1 << get(0)
            if i == 0 and j == 0: B[i][j] |= 1 << get(0)
            if i == 0 and j == M - 1: B[i][j] |= 1 << get(0)
            if "
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for _ in range(N)]

    if N < M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if {{completion}}: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i,"i == 0 and j == M - 1: continue
            if i == N - 1 and j == M - 1: continue
            if i == N - 1 and j == 0: continue
            if A[i][j] > 0: B[i][j] |= 1 << get(A[i][j])
            else: B[i][j] |= 1 << get(A[i][j]) * -1
            if j"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    if N > M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if {{completion}}: continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i == 0 and j == 0,A[i][j] == -1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    if N > M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if {{completion}}: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i,"i == 0 and j == M - 1: continue
            if i == N - 1 and j == M - 1: continue
            if i == N - 1 and j == 0: continue
            if A[i][j] > 0: B[i][j] |= 1 << get(A[i][j])
            else: B[i][j] |= 1 << (get(A[i][j]) - A[i][j])
            if j"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    X = Y = 0
    for i in range(N):
        for j in range(M):
            if {{completion}}:
                X, Y = i, j

    height = max(N - X, X + 1)
    width = max(M - Y, Y + 1)
    print(height * width)

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",A[i][j] > A[X][Y],"A[i][j] > A[X][Y]:
                A[X][Y], A[i][j] = A[i][j], A[X][Y]
                X, Y = i, j
            elif A[i][j] < A[X][Y]:
                A[X][Y], A[i][j] = A[i][j], A[X][Y]
                X, Y = i, j
            elif A[i][j] == A[X][Y]:
                A[X][Y], A[i][j] = A[i][j], A[X][Y]
                X, Y = i, j
            elif A[i][j] == A[X][Y] and A[i][j] > A[X][Y]:
                "
"import sys


def _input_iter():
    for line in sys.stdin:
        for part in line.strip().split(' '):
            stripped = part.strip()
            if {{completion}}:
                yield stripped


def read_int():
    return int(next(stream))


def read_str():
    return next(stream)


def get_ans(a, b):
    if len(a) < len(b):
        return False
    if len(a) == len(b):
        return a == b

    if len(b) == 1:
        return b in a

    if a[-len(b) + 1:] != b[1:]:
        return False

    return b[0] in a[:len(a) - len(b) + 1]


def run():
    read_int(), read_int()
    a, b = read_str(), read_str()
    print('YES' if get_ans(a, b) else 'NO')


stream = _input_iter()


def main():
    t = read_int()
    for _ in range(t):
        run()


if __name__ == '__main__':
    main()
",stripped,"stripped:
                yield stripped


def read_int():
    return int(next(stream))


def read_str():
    return next(stream)


def get_ans(a, b):
    if len(a) < len(b):
        return False
    if len(a) == len(b):
        return a == b

    if len(b) == 1:
        return b in a

    if a[-len(b) + 1:] != b[1:]:
        return False

    return b[0] in a[:len(a) - len(b) + 1]


def run():
    read_int(), read_int()
    a, b = read_str(), read_str()
    print('YES' if get_ans(a, b) else 'NO')


stream = _input_iter()


def main():
    t = read_"
"R=lambda:map(int,input().split());G=range;t,=R()
for {{completion}}:
  n,m=R();s=[sum(i*v for i,v in enumerate(R()))for _ in G(n)]
  mx=max(s);print(s.index(mx)+1,mx-min(s))",_ in G(t),"_ in range(t):
  n,m=R();s=[sum(i*v for i,v in enumerate(R()))for _ in G(n)]
  mx=max(s);print(s.index(mx)+1,mx-min(s))
  
R=lambda:map(int,input().split());G=range;t=R()
for _ in range(t):
  n,m=R();s=[sum(i*v for i,v in enumerate(R()))for _ in G(n)]
  mx=max(s);print(s.index(mx)+1,mx-min(s))
  
R=lambda:map(int,input().split());G=range;t=R()
for _ in range(t):
  n,m="
"for _ in range(int(input())):
	n, m = map(int, input().split())

	vals = []
	for _ in range(n):
		count = 0
		for {{completion}}:
			count += a*b
		vals.append(count)


	c = vals.index(max(vals))
	print(c + 1, vals[c] - vals[c-1])","a, b in enumerate(map(int, input().split()))","_ in range(m):
			a, b = map(int, input().split())
			if a != 0 and b != 0 and a != b and a != b and b != a:
				count += 1
		vals.append(count)

	c = vals.index(max(vals))
	print(c + 1, vals[c] - vals[c-1])
<|/ file ext=.py |>"
"case=int(input())
for i in range(case):
  n,m = (int(v) for v in input().split())
  tmp=0
  for j in range(n):
    list1 = [int(v) for v in input().split()]
    value = 0
    for k in range(m):
      value += list1[k]*(k+1)
    if j==0:
      tmp = value
    else:
      if value > tmp:
        print(str(j+1)+"" ""+str(value-tmp))
      elif {{completion}}:
        print(""1 ""+str(tmp-value))
        tmp = value
      else:
        pass",value < tmp,value < tmp
"input = __import__('sys').stdin.readline


def solve():
    n, m = map(int, input().split())

    mx = (0, -1)
    mn = (10**18, -1)
    for i in range(n):
        current, total = 0, 0
        for {{completion}}:
            current += x
            total += current
        
        mx = max(mx, (total, i))
        mn = min(mn, (total, i))
    
    print(mn[1]+1, mx[0] - mn[0])


for _ in range(int(input())):
    solve()","x in map(int, input().split())","x in range(m):
            if x % 2 == 0:
                current += x
                total += current
            else:
                current -= x
                total -= current
        
        mx = max(mx, (total, i))
        mn = min(mn, (total, i))
    
    print(mn[1]+1, mx[0] - mn[0])


for _ in range(int(input())):
    solve()
    
<|/ file ext=.py |>"
"import sys 
input= sys.stdin.readline

rn=lambda: [*map(int,input().split())]

for _ in range(*rn()):
    n,m=rn()
    b=[]
    mm=0
    for i in range(0,n):
        a=sum([*map(lambda x,y:int(x)*y,input().split(),range(1,m+1))])
        b.append(a)
        if {{completion}}:
            mm=i
    print(mm+1,b[mm]-b[mm-1])",a>b[mm],mm==0 or a>b[mm-1]
"for t in range(int(input())):
    N, M = map(int, input().split())
    minV = int(1e20)
    maxV = -1
    ret = 0
    for index in range(N):
        mlist = list(map(int, input().split()))
        cur = sum([index*val for index, val in enumerate(mlist)])
        
        minV = min(minV, cur)
        if {{completion}}:
            ret = index+1
        maxV = max(maxV, cur)
    print(f""{ret} {maxV-minV}"")",maxV < cur,cur == minV
"import sys
input = sys.stdin.readline
s = input().strip()
l = len(s)
d, p = [], [0]
d.append([1 if s[0] == chr(x+97)  else 0 for x in range(26)])
for idx, i in enumerate(s):
    if {{completion}}: continue
    x = ord(i) - 97
    d.append(d[p[idx-1]][:])
    d[idx][x] = idx+1
    p.append(d[p[idx-1]][x])
for i in range(10): p.append(0); d.append([])
for i in range(int(input())):
    for idx, t in enumerate(input().strip()):
        x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]
    print(*p[l:l+idx+1])",idx == 0,"i == '': continue
    x = ord(i) - 97
    d.append(d[p[idx-1]][:])
    d[idx][x] = idx+1
    p.append(d[p[idx-1]][x])
for i in range(10): p.append(0); d.append([])
for i in range(int(input())):
    for idx, t in enumerate(input().strip()):
        x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]
    print(*p[l:l+idx+1])
<|/ a tags=string,python,algorithm "
"import sys
input = sys.stdin.readline
s = input().strip()
l = len(s)
d, p = [], [0]
d.append([1 if s[0] == chr(x+97)  else 0 for x in range(26)])
for idx, i in enumerate(s):
    if idx == 0: continue
    x = ord(i) - 97
    d.append(d[p[idx-1]][:])
    d[idx][x] = idx+1
    p.append(d[p[idx-1]][x])
for i in range(10): p.append(0); d.append([])
for i in range(int(input())):
    for {{completion}}:
        x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]
    print(*p[l:l+idx+1])","idx, t in enumerate(input().strip())","idx, t in enumerate(input().strip().lower()):
        if idx == 0: continue
        if t not in 'abcdefghijklmnopqrstuvwxyz': continue
        if t not in d: continue
        if d[idx][ord(t)-97] == 0: continue
        d[idx][ord(t)-97] = d[idx][ord(t)-97] + 1
    for idx, t in enumerate(input().strip().lower()):
        if idx == 0: continue
        if t not in 'abcdefghijklmnopqrstuvwxyz': continue
        if t not in d: continue
        if d[idx][ord(t)-97] == 0: continue
        d[idx][ord(t)-97"
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif {{completion}}:
            print(2)
        elif l == 2:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
",l == 3,"l == 3:
            print(2)
        elif l == 2:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif l == 3:
            print(2)
        elif l == 2:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]"
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif l == 3:
            print(2)
        elif {{completion}}:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
",l == 2,"l == 2:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif l == 3:
            print(2)
        elif l == 2:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:"
"import sys

from itertools import permutations, combinations

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

    
def solve(n, a, b):
    ps = [((list(range(n))), (list(range(n))))]
    res = (1<<30) - 1

    for k in range(30, -1, -1):
        next_ps = []
        for (pa, pb) in ps:

            a0, a1, b0, b1 = [], [], [], []
            for pai in pa:
                if {{completion}}: a0.append(pai) 
                else: a1.append(pai)
            for pbi in pb:
                if b[pbi] & (1<<k) == 0: b0.append(pbi) 
                else: b1.append(pbi)

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))

        ps = next_ps if int(res & (1<<k)) != 0 else ps       

    return res
    #return rec(a, b, max_order-1)


for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    print(solve(n, a, b))
",a[pai] & (1<<k) == 0,"a[pai] & (1<<k) == 0: a0.append(pai) 
                else: a1.append(pai)
            for pbi in pb:
                if b[pbi] & (1<<k) == 0: b0.append(pbi) 
                else: b1.append(pbi)

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))"
"import sys

from itertools import permutations, combinations

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

    
def solve(n, a, b):
    ps = [((list(range(n))), (list(range(n))))]
    res = (1<<30) - 1

    for k in range(30, -1, -1):
        next_ps = []
        for (pa, pb) in ps:

            a0, a1, b0, b1 = [], [], [], []
            for pai in pa:
                if a[pai] & (1<<k) == 0: a0.append(pai) 
                else: a1.append(pai)
            for pbi in pb:
                if {{completion}}: b0.append(pbi) 
                else: b1.append(pbi)

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))

        ps = next_ps if int(res & (1<<k)) != 0 else ps       

    return res
    #return rec(a, b, max_order-1)


for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    print(solve(n, a, b))
",b[pbi] & (1<<k) == 0,"b[pbi] & (1<<k) == 0: b0.append(pbi) 
                else: b1.append(pbi)

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))

        ps = next_ps if int(res & (1<<k)) != 0 else ps       

    return res
    #return rec(a, b, max_order-1)


for i in range(1, len(ls)"
"import sys
from math import ceil

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def at_least(L, x):
    for i in range(len(L)):
        if L[i] >= x:
            return i
    return len(L)-1

def at_most(L, x):
    for i in range(len(L)-1, -1, -1):
        if L[i] <= x:
            return i
    return 0

def solve(n, a, b):
    dmin, dmax = [-1]*n, [-1]*n
    imin, imax = 0, n-1
    for i in range(n):
        
        while b[imin] < a[i]:
            imin += 1

        dmin[i] = b[imin] - a[i]
        dmax[n-1-i] = b[imax] - a[n-1-i]
        
        if i < n-1:
            if {{completion}}:
                imax = n-i-2

    return dmin, dmax

for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    dmin, dmax = solve(n, a, b)
    print(*dmin)
    print(*dmax)",b[n-i-2] < a[n-i-1],"dmin[i] > dmin[i+1]:
                imax = i
            else:
                imax = i+1
        else:
            if dmax[i] < dmax[i-1]"
"import sys
from math import ceil

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def at_least(L, x):
    for i in range(len(L)):
        if L[i] >= x:
            return i
    return len(L)-1

def at_most(L, x):
    for i in range(len(L)-1, -1, -1):
        if L[i] <= x:
            return i
    return 0

def solve(n, a, b):
    dmin, dmax = [-1]*n, [-1]*n
    imin, imax = 0, n-1
    for i in range(n):
        
        while {{completion}}:
            imin += 1

        dmin[i] = b[imin] - a[i]
        dmax[n-1-i] = b[imax] - a[n-1-i]
        
        if i < n-1:
            if b[n-i-2] < a[n-i-1]:
                imax = n-i-2

    return dmin, dmax

for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    dmin, dmax = solve(n, a, b)
    print(*dmin)
    print(*dmax)",b[imin] < a[i],"b[imin] <= a[i]:
            imin += 1
        
        while b[imax] >= a[n-1-i]:
            imax -= 1
        
        if b[imin] < a[i]:
            imin += 1
        if b[imax] > a[n-1-i]:
            imax -= 1
        
        dmin[i] = b[imin] - a[i]
        dmax[n-1-i] = b[imax] - a[n-1-i]
        
        if i < n-1:
            if b[n-i-2] < a[n-i-1]:
                imax = n-i-2

    return dmin, dmax

for i in range(1, len(ls)-1, 3):"
"import sys

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if {{completion}}:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def ins(u, mn, mx):
    return u[0] >= mn[0] and u[1] >= mn[1] and u[0] <= mx[0] and u[1] <= mx[1]

def clmp(x, n):
    if x < 0: return 0
    if x >= n: return n-1
    return x

def clp(u, n, m):
    return (clmp(u[0], n), clmp(u[1], m)) 

def d(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def solve(n, m, sx, sy, d):
    if d ==0: return n+m-2
    smin = clp((sx-d, sy-d), n, m)
    smax = clp((sx+d, sy+d), n, m)
    if abs(smax[0]-smin[0]) >= n-1 or abs(smax[1]-smin[1]) >= m-1: return -1
    if ins((0, 0), smin, smax) or ins((n-1, m-1), smin, smax) : return -1
    return n+m-2

for l in ls[1:]:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve(n, m, sx-1, sy-1, d))",len(lst) > 0,"lst != '':
        ls.append(lst)

for l in ls:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve(n, m, sx-1, sy-1, d))

for l in ls:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve(n, m, sx, sy-1, d))

for l in ls:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve(n, m, sx-1, sy, d))

for l in ls:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve"
"_,(*a,),*r=(map(int,s.split())for s in open(0))
b=[[0],[0]]
for x in b:
 for {{completion}}:x+=x[-1]+max(0,u-v),
 max=min
for s,t in r:l=b[s>t];print(l[t]-l[s])","u,v in zip([0]+a,a)","u,v in zip(a,x):
  x[-1]"
"n,m=map(int,input().split())
c=[int(i) for i in input().split()]
f=[0]*n
g=[0]*n
for i in range(1,n):
	f[i]=f[i-1]+max(0,c[i-1]-c[i])
	g[-i-1]=g[-i]+max(0,c[-i]-c[-i-1])
for i in range(m):
	x,y=map(int,input().split())
	if {{completion}}:
		print(f[y-1]-f[x-1])
	else:
		print(g[y-1]-g[x-1])",x<y,"x>y:
		print(f[y-1]-f[x-1])
	elif x<y:
		print(g[y-1]-g[x-1])
	else:
		print(g[y-1]-g[x-1])
		
""""""
n,m=map(int,input().split())
c=[int(i) for i in input().split()]
f=[0]*n
g=[0]*n
for i in range(1,n):
	f[i]=f[i-1]+max(0,c[i-1]-c[i])
	g[-i-1]=g[-i]+max(0,c[-i]-c[-i-1])
for i in range(m):
	x,y=map(int,input().split())
	if x>y:
		print(f"
"R=lambda:map(int,input().split())
n,m=R()
*a,=R()
b=[[0],[0]]
f=max
for x in b:
 for {{completion}}:x+=x[-1]+f(0,u-v),
 f=min
for _ in[0]*m:s,t=R();l=b[s>t];print(l[t]-l[s])","u,v in zip([0]+a,a)","u in a:
  x+=x[-1]+f(0,u-v),
 f=min
for _ in[0]*m:s,t=R();l=b[s>t];print(l[t]-l[s])
<|/ q tags=python-3.x,python |>
<| c |>
Please post the code in the question itself.
<|/ c |>
<| c |>
Please post the code in the question itself.
<|/ c |>
<| c |>
Please post the code in the question itself.
<|/ c |>
<| c |>
Please post the code in the question itself.
<|/ c |>
<|"
"n,m=map(int,input().split())
world=['x']+list(map(int,input().split()))
L1=[0]
L2=[0]
for i in range(1,n):
    L1.append(L1[i-1]+max(world[i]-world[i+1],0))
    L2.append(L2[i-1]+max(world[i+1]-world[i],0))
for i in range(m):
    s,t=map(int,input().split())
    if {{completion}}:
        print(L1[t-1]-L1[s-1])
    else:
        print(L2[s-1]-L2[t-1])",s<t,s<t
"n,m=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
ltr,rtl=[0],[0]
for i in range(1,n):
    ltr.append(max(0,a[i-1]-a[i])+ltr[-1])
    rtl.append(max(0,a[i]-a[i-1])+rtl[-1])
for i in range(m):
    s,t=[int(x) for x in input().split()]
    if {{completion}}:
        print(ltr[t-1]-ltr[s-1])
    else:
        print(rtl[s-1]-rtl[t-1])
        ",s<=t,s<t
"(n,m),(*a,),*r=(map(int,s.split())for s in open(0))
b=[[0],[0]]
for x in b:
 for {{completion}}:x+=x[-1]+max(0,u-v),
 max=min
for s,t in r:l=b[s>t];print(l[t]-l[s])","u,v in zip([0]+a,a)","u,v in zip(x[:-1],x[1:]):
  x[-1]+=max(0,u-v),
 max=min
for s,t in r:l=b[s>t];print(l[t]-l[s])
<|/ q |>
<| c |>
Please add your code.
<|/ c |>
<| c |>
Please don't post code in comments. Edit your question instead.
<|/ c |>
<| c |>
Please don't post code in comments. Edit your question instead.
<|/ c |>
<| c |>
Please don't post code in comments. Edit your question instead.
<|/ c |>
<|"
"n, m = map(int, input().split())
a = list(map(int, input().split()))
inc = [0]
dec = [0]
for i in range(n-1):
    inc.append(inc[i] + max(0, a[i]-a[i+1]))
    dec.append(dec[i] + max(0, a[i+1] - a[i]))
    
for i in range(m):
    x, y = map(int, input().split())
    #print(x, y)
    #ans = 0
    if {{completion}}:
        ans = inc[y-1] - inc[x-1]
    else:
        ans = dec[x-1] - dec[y-1]
    print(ans)
",x < y,inc[x-1] > dec[y-1]
"R=lambda:map(int,input().split())
n,m=R()
*a,=R()
b=[[0],[0]]
for x in b:
 for {{completion}}:x+=x[-1]+max(0,u-v),
 a=a[::-1]
b[1]=[0]+b[1][::-1]
for _ in[0]*m:s,t=R();l=b[s>t];print(abs(l[s]-l[t]))","u,v in zip([0]+a,a)","_ in x:
  u=b[-1][-1]
  v=a[-1]
  b[-1]"
"n, m = map(int, input().split());a = list(map(int, input().split()));l = [0] + [max(0, a[i] - a[i + 1]) for i in range(n - 1)];r = [0] + [max(0, a[i] - a[i - 1]) for i in range(1, n)]
for {{completion}}: l[i + 1] += l[i];r[i + 1] += r[i]
for _ in range(m): s, t = map(int, input().split());print(l[t - 1] - l[s - 1]) if(s < t) else print(r[s - 1] - r[t - 1])",i in range(n - 1),"_ in range(m): s, t = map(int, input().split());print(l[t - 1] - l[s - 1]) if(s < t) else print(r[s - 1] - r[t - 1])
'''
<|/ a dscore=0 |>
<| c |>
Thanks for your answer. Can you please explain me the code you wrote? I am not able to understand it.
<|/ c |>
<| c |>
I added the explanation to the answer. Hope it helps.
<|/ c |>
<| c |>
Thanks for your answer. Can you please explain me the code you wrote? I am "
"n, m = map(int, input().split());a = list(map(int, input().split()));l = [0] + [max(0, a[i] - a[i + 1]) for i in range(n - 1)];r = [0] + [max(0, a[i] - a[i - 1]) for i in range(1, n)]
for i in range(n - 1): l[i + 1] += l[i];r[i + 1] += r[i]
for {{completion}}: s, t = map(int, input().split());print(l[t - 1] - l[s - 1]) if(s < t) else print(r[s - 1] - r[t - 1])",_ in range(m),"_ in range(m):
    s, t = map(int, input().split())
    print(l[t - 1] - l[s - 1])
    if(s < t): print(0)
    else: print(r[s - 1] - r[t - 1])
<|/ a dscore=0 |>
<| c |>
Thanks for your answer. Can you please explain how you got the answer for the above question?
<|/ c |>
<| c |>
I added the code to the answer
<|/ c |>
<| c |>
Thanks for your answer. Can you please explain how you got the answer for the above question?
<|/ c |>
"
"n,m=(map(int,input().split()))
l=list(map(int,input().split()))

f=[0]*n
b=[0]*n
d=0
for j in range(1,n):
    d=d+max(0,l[j-1]-l[j])
    f[j]=d
l=l[::-1]
d=0
for k in range(1,n):
    d=d+max(0,l[k-1]-l[k])
    b[k]=d
b=b[::-1]
for i in range(m):
    s,t=(map(int,input().split()))
    if {{completion}}:
        print(f[t-1]-f[s-1])
    else:
        print(b[t-1]-b[s-1])",s<t,s<t
"import sys, collections, math, itertools
input = lambda: sys.stdin.readline().strip()
ints = lambda: list(map(int, input().split()))
Int = lambda: int(input())
n, m = ints()
a = ints()
s = int(m ** .5 + 1)
maxs = [max(a[i:i + s]) for i in range(0, m, s)]
for i in range(Int()):
    ys, xs, yf, xf, k = ints()
    yes = (xs - xf) % k == 0 and (ys - yf) % k == 0
    if {{completion}}:
        print('no')
        continue
    mi, ma = min(xs, xf), max(xs, xf)
    high = max([0] + a[mi:min(ma, (mi // s + 1) * s)] + a[max(mi, ma // s * s):ma])
    for j in range(min(xs, xf) // s + 1, max(xs, xf) // s):
        high = max(high, maxs[j])
    if high < ys:
        print('yes')
        continue
    print('yes' if ((high - ys) // k + 1) * k + ys <= n else 'no')",not yes,"yes:
        print('yes')
        continue
    if ys > yf or xs > xf or ys < 0 or xs < 0 or k > 10 ** 9:
        print('no')
        continue
    if ys == yf and xs == xf:
        print('yes')
        continue
    if ys == yf and xs > xf:
        print('yes')
        continue
    if ys > yf:
        print('yes')
        continue
    if ys < yf:
        print('no')
        continue
    if xs == xf:
        print('yes')
        continue
    if xs > xf:
        print('no')
        continue
    if xs < xf:
        print('no"
"import math
import sys
input = sys.stdin.buffer.readline

y, x_ = input().split()
block = [int(x) for x in input().split()]
 
list2 = [[0] *20 for i in range( len(block))]
for a in range(len(block)):
    list2[a][0] = block[a]
    
z, x = 0, 1
while (1 << x) <= len(block):
    z = 0
    while (z + (1 << x) - 1) < len(block):
        list2[z][x] = (max(list2[z][x - 1], list2[z + (1 << (x - 1))][x - 1]))
        z += 1
    x += 1
    
 
for i in range(int(input())):
    s = [int(x) for x in input().split()]
    if abs(s[0] - s[2]) % s[-1] != 0 or abs(s[1] - s[3]) % s[-1] != 0:
        print(""NO"")
    else:
        smaller = min(s[1], s[3])
        bigger = max(s[1], s[3])
        k = 0
        while {{completion}}:
            k += 1
        highest = max(list2[smaller - 1][k], list2[bigger - (1 << k)][k])
        if highest < s[-1] * ((int(y) - s[0]) // s[-1]) + s[0]:
            print(""YES"")
        else:
            print(""NO"")",(1 << (k + 1)) <= bigger - smaller + 1,"k < len(list2[smaller - 1]) and list2[smaller - 1][k] == list2[bigger - (1 << k)][k]:
            k += 1
        while k < len(list2[bigger - (1 << k)][k]):
            list2[bigger - (1 << k)][k] = list2[bigger - (1 << k)][k] + 1
            k += 1
        while k < len(list2[bigger - (1 << k)][k]):
            list2[bigger - (1 << k)][k] = list2[bigger - (1 << k)][k] - 1
            k += 1
        while k < len(list2[bigger - (1 << k)][k]):
            list"
"import math
import sys
input = sys.stdin.buffer.readline

y, x_ = input().split()
block = [int(x) for x in input().split()]
 
list2 = [[0] *20 for i in range( len(block))]
for a in range(len(block)):
    list2[a][0] = block[a]
    
z, x = 0, 1
while (1 << x) <= len(block):
    z = 0
    while (z + (1 << x) - 1) < len(block):
        list2[z][x] = (max(list2[z][x - 1], list2[z + (1 << (x - 1))][x - 1]))
        z += 1
    x += 1
    
 
for i in range(int(input())):
    s = [int(x) for x in input().split()]
    if abs(s[0] - s[2]) % s[-1] != 0 or abs(s[1] - s[3]) % s[-1] != 0:
        print(""NO"")
    else:
        smaller = min(s[1], s[3])
        bigger = max(s[1], s[3])
        k = 0
        while (1 << (k + 1)) <= bigger - smaller + 1:
            k += 1
        highest = max(list2[smaller - 1][k], list2[bigger - (1 << k)][k])
        if {{completion}}:
            print(""YES"")
        else:
            print(""NO"")",highest < s[-1] * ((int(y) - s[0]) // s[-1]) + s[0],"highest == list2[bigger - 1][k]:
            print(""NO"")
        elif highest == list2[bigger - (1 << k)][k]:
            print(""YES"")
        else:
            print(""NO"")
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 "
"from sys import stdin, stdout
from math import floor, ceil, log
input, print = stdin.readline, stdout.write

def main():
  n, m = map(int, input().split())
  arr = [0] + [int(x) for x in input().split()]
  st = construct(arr, m)
  for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if {{completion}}:
      print(""NO\n"")
      continue
    if (x1 <= arr[y1] or x2 <= arr[y2]):
      print(""NO\n"")
      continue
    max_x = ((n-x1)//k)*k + x1 
    if (max_x <= getMax(st, m, min(y1, y2), max(y1, y2))):
      print(""NO\n"")
      continue
    print(""YES\n"")

def construct(arr, n):
  x = ceil(log(n, 2))
  max_size = 2 * pow(2, x) - 1 
  st = [0]*max_size
  construct2(arr, 0, n-1, st, 0)
  return st
  
def construct2(arr, ss, se, st, si):
  if (ss == se):
    st[si] = arr[ss]
    return arr[ss]
  mid = getMid(ss, se)
  st[si] = max(construct2(arr, ss, mid, st, si * 2 + 1), construct2(arr, mid + 1, se, st, si * 2 + 2))
  return st[si]

def getMid(s, e):
  return s + (e - s) // 2

def getMax(st, n, l, r):
  return MaxUtil(st, 0, n - 1, l, r, 0)

def MaxUtil(st, ss, se, l, r, node):
  if (l <= ss and r >= se):
    return st[node]
  if (se < l or ss > r):
    return -1
  mid = getMid(ss, se)
  return max(MaxUtil(st, ss, mid, l, r, 2 * node + 1), MaxUtil(st, mid + 1, se, l, r, 2 * node + 2))
  
main()",((y2 - y1) % k != 0 or (x2 - x1) % k != 0),"x1 > n or x2 > n or y1 > m or y2 > m or k > 10**9:
      print(""NO\n"")
      continue
    if (x1 <= arr[y1] or x2 <= arr[y2]):
      print(""NO\n"")
      continue
    max_x = ((n-x1)//k)*k + x1 
    if (max_x <= getMax(st, m, min(y1, y2), max(y1, y2))):
      print(""NO\n"")
      continue
    print(""YES\n"")

def construct(arr, n):
  x = ceil(log(n, 2))
  max_size = 2 * pow(2, x) - 1 
  st = [0]*max_size
"
"from sys import stdin, stdout
from math import floor, ceil, log
input, print = stdin.readline, stdout.write

def main():
  n, m = map(int, input().split())
  arr = [0] + [int(x) for x in input().split()]
  st = construct(arr, m)
  for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if ((y2 - y1) % k != 0 or (x2 - x1) % k != 0):
      print(""NO\n"")
      continue
    if (x1 <= arr[y1] or x2 <= arr[y2]):
      print(""NO\n"")
      continue
    max_x = ((n-x1)//k)*k + x1 
    if {{completion}}:
      print(""NO\n"")
      continue
    print(""YES\n"")

def construct(arr, n):
  x = ceil(log(n, 2))
  max_size = 2 * pow(2, x) - 1 
  st = [0]*max_size
  construct2(arr, 0, n-1, st, 0)
  return st
  
def construct2(arr, ss, se, st, si):
  if (ss == se):
    st[si] = arr[ss]
    return arr[ss]
  mid = getMid(ss, se)
  st[si] = max(construct2(arr, ss, mid, st, si * 2 + 1), construct2(arr, mid + 1, se, st, si * 2 + 2))
  return st[si]

def getMid(s, e):
  return s + (e - s) // 2

def getMax(st, n, l, r):
  return MaxUtil(st, 0, n - 1, l, r, 0)

def MaxUtil(st, ss, se, l, r, node):
  if (l <= ss and r >= se):
    return st[node]
  if (se < l or ss > r):
    return -1
  mid = getMid(ss, se)
  return max(MaxUtil(st, ss, mid, l, r, 2 * node + 1), MaxUtil(st, mid + 1, se, l, r, 2 * node + 2))
  
main()","(max_x <= getMax(st, m, min(y1, y2), max(y1, y2)))","max_x >= arr[y2]:
      print(""NO\n"")
      continue
    max_y = ((m-y1)//k)*k + y1 
    if max_y >= arr[y2]"
"import sys
from array import array

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
debug = lambda *x: print(*x, file=sys.stderr)
out = []


class sparse_table:
    def __init__(self, n, a, default=0, func=max):
        self.n, self.lg = n, 20
        self.func = func
        self.table = [array('i', [default] * n) for _ in range(self.lg)]
        self.table[0] = a
        self.preprocess()

    def preprocess(self):
        for j in range(1, self.lg):
            i = 0
            while {{completion}}:
                ix = i + (1 << (j - 1))
                self.table[j][i] = self.func(self.table[j - 1][i], self.table[j - 1][ix])
                i += 1

    def quary(self, l, r):
        '''[l,r]'''
        l1 = (r - l + 1).bit_length() - 1
        r1 = r - (1 << l1) + 1
        return self.func(self.table[l1][l], self.table[l1][r1])


n, m = inp(int)
a = array('i', inp(int))
mem = sparse_table(m, a)

for _ in range(int(input())):
    xs, ys, xf, yf, k = inp(int)
    div, mod = divmod(n - xs, k)
    xma = n - mod
    qur = mem.quary(min(ys, yf) - 1, max(ys, yf) - 1)

    if qur >= xma or abs(xma - xf) % k or abs(ys - yf) % k:
        out.append('no')
    else:
        out.append('yes')

print('\n'.join(out))
",i + (1 << j) - 1 < self.n,"i < self.n and j > 1:
                j -= 1
                i += 1
            self.table[j][i - 1] = self.table[j][i - 1] + 1

    def query(self, xs, ys, xf, yf):
        '''[xs,ys,xf,yf]'''
        xma = n - xs
        qur = self.quary(min(ys, yf) - 1, max(ys, yf) - 1)
        if qur >= xma or abs(xma - xf) % self.n or abs(ys - yf) % self.n:
            return 'no'
        else:
            return 'yes'

    def quary(self, l, r):
        '''[l,r]'''
        l1 = (r - l + 1)."
"from sys import setrecursionlimit, stdin
readline = stdin.readline

# def I(): return int(readline())
# def ST(): return readline()[:-1]
# def LI(): return list(map(int, readline().split()))

def solve():
    N, m = map(int, readline().split())
    A = [0] + list(map(int, readline().split()))
    n = len(A)
    num = 1 << (n - 1).bit_length()
    tree = [0] * 2 * num
    for i in range(n):
        tree[num + i] = A[i] 
    for i in range(num - 1, 0, -1):
        tree[i] = max(tree[2 * i], tree[2 * i + 1])

    def query(l, r):
        ret = 0
        l += num
        r += num
        while l < r:
            if {{completion}}:
                ret = max(ret, tree[l])
                l += 1
            if r & 1:
                ret = max(ret, tree[r - 1])
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, gy + 1) < top: print(""YES"")
        else: print(""NO"")

solve()",l & 1,"l & 1:
                ret = max(ret, tree[l])
                l += 1
            if r & 1:
                ret = max(ret, tree[r - 1])
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, "
"from sys import setrecursionlimit, stdin
readline = stdin.readline

# def I(): return int(readline())
# def ST(): return readline()[:-1]
# def LI(): return list(map(int, readline().split()))

def solve():
    N, m = map(int, readline().split())
    A = [0] + list(map(int, readline().split()))
    n = len(A)
    num = 1 << (n - 1).bit_length()
    tree = [0] * 2 * num
    for i in range(n):
        tree[num + i] = A[i] 
    for i in range(num - 1, 0, -1):
        tree[i] = max(tree[2 * i], tree[2 * i + 1])

    def query(l, r):
        ret = 0
        l += num
        r += num
        while l < r:
            if l & 1:
                ret = max(ret, tree[l])
                l += 1
            if {{completion}}:
                ret = max(ret, tree[r - 1])
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, gy + 1) < top: print(""YES"")
        else: print(""NO"")

solve()",r & 1,"r & 1:
                ret = max(ret, tree[r])
                r -= 1
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, gy + 1) < top: print(""YES"")
        else: print(""NO"")

"
"input = __import__('sys').stdin.readline


log2s = [0, 0]
for i in range(2, 200005):
    log2s.append(log2s[i // 2] + 1)


n, m = map(int, input().split())
sparse = [[0] + list(map(int, input().split()))]
for j in range(20):
    sparse.append([max(sparse[j][min(i + (1 << j), m)], sparse[j][i]) for i in range(m+1)])

def getmax(L, R):
    j = log2s[R - L + 1]
    return max(sparse[j][R - (1 << j) + 1], sparse[j][L])

for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if {{completion}}:
        print('NO')
        continue
    
    # i * k + x1 <= n
    i = (n - x1) // k
    h = i * k + x1
    while h > n:
        h -= k
    print('YES' if getmax(min(y1, y2), max(y1, y2)) < h else 'NO')
",(x1 - x2) % k != 0 or (y1 - y2) % k != 0,"x1 == x2 and y1 == y2:
        print('YES')
        continue
    if x1 > n or y1 > m or x2 > n or y2 > m or k < 1 or k > 10 ** 9:
        print('NO')
        continue
    if getmax(min(y1, y2), max(y1, y2)) < k * k:
        print('NO')
        continue
    if getmax(min(y1, y2), max(y1, y2)) < k * k + k * k + k * k + k * k + k * k + k * k + k * k + k * k + k * k + k * k + k * k + k * "
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

n,m=M();a=L();q=I()

t=[0]*(2*m)
# a is the array of initial values
def build(t,n,a):
    for i in range(n):t[i+n]=a[i]
    for i in range(n-1,0,-1):t[i]=max(t[i<<1],t[(i<<1)|1])

# change value at position p to v
def modify(t,n,p,v):
    p+=n
    t[p]=v
    while p>1:
        t[p>>1]=max(t[p],t[p^1])
        p>>=1

# find the combined value of range [l,r)
def query(t,n,l,r):
    resl=resr=0
    l+=n;r+=n
    while l<r:
        if {{completion}}:resl=max(resl,t[l]);l+=1
        if (r&1):r-=1;resr=max(t[r],resr)
        l>>=1;r>>=1
    return max(resl,resr)

build(t,m,a)

for i in range(q):
    xs,ys,xf,yf,k=M()
    if abs(xs-xf)%k or abs(ys-yf)%k:print(""NO"");continue
    p=query(t,m,min(ys,yf)-1,max(ys,yf))
    z=min(xs,xf)+((n-min(xs,xf))//k)*k
    if z<=p:print(""NO"")
    else:print(""YES"")",(l&1),"t[l]<t[r]:l+=1
        elif t[l]>t[r]:r-=1
        else:modify(t,n,l,t[l])
        l+=n;r+=n
        while l<r:
            if t[l]<t[r]:l+=1
            elif t[l]>t[r]:r-=1
            else:modify(t,n,l,t[l])
            l+=n;r+=n
        if l==r:modify(t,n,l,t[l])
        l+=n;r+=n
        while l<r:
            if t[l]<t[r]:l+=1
            elif t[l]>t[r]:r-=1
            else:modif"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

n,m=M();a=L();q=I()

t=[0]*(2*m)
# a is the array of initial values
def build(t,n,a):
    for i in range(n):t[i+n]=a[i]
    for i in range(n-1,0,-1):t[i]=max(t[i<<1],t[(i<<1)|1])

# change value at position p to v
def modify(t,n,p,v):
    p+=n
    t[p]=v
    while p>1:
        t[p>>1]=max(t[p],t[p^1])
        p>>=1

# find the combined value of range [l,r)
def query(t,n,l,r):
    resl=resr=0
    l+=n;r+=n
    while l<r:
        if (l&1):resl=max(resl,t[l]);l+=1
        if {{completion}}:r-=1;resr=max(t[r],resr)
        l>>=1;r>>=1
    return max(resl,resr)

build(t,m,a)

for i in range(q):
    xs,ys,xf,yf,k=M()
    if abs(xs-xf)%k or abs(ys-yf)%k:print(""NO"");continue
    p=query(t,m,min(ys,yf)-1,max(ys,yf))
    z=min(xs,xf)+((n-min(xs,xf))//k)*k
    if z<=p:print(""NO"")
    else:print(""YES"")",(r&1),"(r&1):resr=max(resr,t[r]);r+=1
        if l==r:modify(t,n,l,t[l])
        l&=~(r&1)
        r&=~(l&1)
    if l<r:modify(t,n,l,t[l])
    return max(resl,resr)

def query(t,n,l,r):
    resl=resr=0
    l+=n;r+=n
    while l<r:
        if (l&1):resl=max(resl,t[l]);l+=1
        if (r&1):resr=max(resr,t[r]);r+=1
        if l==r:modify("
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            self.s.add(el)

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])


        #print('merging', i, j, list(D[i]), list(D[j]))
        if any(x in D[i] for x in D[j]):
            r += 1
            D[i].s.clear()
            break
        else:
            for {{completion}}:
                D[i].add(x ^ A[i])

        #assert 0 not in D[i]

    #print(i, A[i], adj[i], list(D[i]))

print(r)
",x in D[j],"x in D[j]:
                D[i].add(x)
                D[j].add(x)
                if x not in D[i]:
                    D[i].update(x)
                    D[j].update(x)
                    break

            #print('merging', i, j, list(D[i]), list(D[j]))
            if any(x in D[i] for x in D[j]):
                r += 1
                D[i].s.clear()
                break
            else:
                D[i].add(x ^ A[i])
                D[j].add(x ^ A[i])
                if x not in D[i]:
                    D[i].update(x)
                    D[j].update(x)
                    break

                #print('merging', i, j, list(D"
"import sys 
from types import GeneratorType
from collections import defaultdict

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if {{completion}}:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

input = lambda: sys.stdin.readline().rstrip()

def solve():

    N = int(input())
    A = [int(x) for x in input().split()]

    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = [int(x) - 1 for x in input().split()]
        G[x].append(y)
        G[y].append(x)
    
    
    B = [0] * N
    vals = defaultdict(set)
    res = [0]

    @bootstrap
    def fill_dfs(v, p):
        B[v] = A[v]
        if p != -1:
            B[v] ^= B[p]
        for u in G[v]:
            if u != p:
                yield fill_dfs(u, v)
        yield
                
    
    @bootstrap
    def calc_dfs(v, p):
        zero = False
        vals[v].add(B[v])
        for u in G[v]:
            if u != p:
                yield calc_dfs(u, v)
                if len(vals[v]) < len(vals[u]):
                    vals[v], vals[u] = vals[u], vals[v]
                for x in vals[u]:
                    zero |= (x ^ A[v]) in vals[v]
                for x in vals[u]:
                    vals[v].add(x)
                vals[u].clear()
        if zero:
            res[0] += 1
            vals[v].clear()
        yield

    fill_dfs(0, -1)
    calc_dfs(0, -1)

    return res[0]

print(solve())",not stack,stack
"import sys 
from types import GeneratorType
from collections import defaultdict

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if {{completion}}:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

input = lambda: sys.stdin.readline().rstrip()

def solve():

    N = int(input())
    A = [int(x) for x in input().split()]

    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = [int(x) - 1 for x in input().split()]
        G[x].append(y)
        G[y].append(x)
    
    
    B = [0] * N
    vals = defaultdict(set)
    res = [0]

    @bootstrap
    def fill_dfs(v, p):
        B[v] = A[v]
        if p != -1:
            B[v] ^= B[p]
        for u in G[v]:
            if u != p:
                yield fill_dfs(u, v)
        yield
                
    
    @bootstrap
    def calc_dfs(v, p):
        zero = False
        vals[v].add(B[v])
        for u in G[v]:
            if u != p:
                yield calc_dfs(u, v)
                if len(vals[v]) < len(vals[u]):
                    vals[v], vals[u] = vals[u], vals[v]
                for x in vals[u]:
                    zero |= (x ^ A[v]) in vals[v]
                for x in vals[u]:
                    vals[v].add(x)
                vals[u].clear()
        if zero:
            res[0] += 1
            vals[v].clear()
        yield

    fill_dfs(0, -1)
    calc_dfs(0, -1)

    return res[0]

print(solve())",type(to) is GeneratorType,stack
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            self.s.add(el)

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])

        l = list(D[j])
        for x in l:
            if x in D[i]:
                r += 1
                D[i].s.clear()
                break
        else:
            for {{completion}}:
                D[i].add(x ^ A[i])

            continue

        break

    #print(i, A[i], adj[i], list(D[i]))

print(r)
",x in l,"x in D[i]:
                D[i].add(x)
                D[j].add(x)
                r += 1
                break

        if len(D[i]) < len(D[j]):
            for x in D[j]:
                D[i].add(x)
                r += 1
                break

        if len(D[i]) > len(D[j]):
            for x in D[i]:
                D[j].add(x)
                r += 1
                break

        if len(D[i]) == len(D[j]):
            for x in D[i]:
                D[i].add(x)
                D[j].add(x)
                r += 1
                break

        if len(D[i]) == len(D[j]) and len(D[i]) > len(D[j]):
            for x in D"
"import collections

def caminho(parent, sala):
  resp = []
  while sala is not None:
    resp.append(sala)
    sala = parent[sala]
  return list(reversed(resp))

def solve(grafo, total, inicio):
  if len(grafo[inicio]) < 2:
    return
  globalParent = collections.defaultdict(lambda: None)
  for sala1 in grafo[inicio]:
    currentParent = collections.defaultdict(lambda: None)
    currentParent[sala1] = inicio
    
    fila = collections.deque()
    fila.append(sala1)

    while len(fila) > 0:
      y = fila.popleft()
      for x in grafo[y]:
        if {{completion}}:
          currentParent[x] = y
          fila.append(x)

    for x in currentParent:
      if x in globalParent:
        #Deu bom
        return (caminho(globalParent, x), caminho(currentParent, x))
        
    for x,y in currentParent.items():
      globalParent[x] = y
      
    

n, m, s = map(int, input().split())
g = collections.defaultdict(list)
for i in range(m):
  x,y = map(int, input().split())
  g[x].append(y)

paths = solve(g,n,s)

if paths is None:
  print(""Impossible"")
else:
  print(""Possible"")
  for i in paths:
    print(len(i))
    print("" "".join(map(str,i)))",x != inicio and currentParent[x] is None,x not in currentParent
"import collections

def caminho(parent, sala):
  resp = []
  while sala is not None:
    resp.append(sala)
    sala = parent[sala]
  return list(reversed(resp))

def solve(grafo, total, inicio):
  if len(grafo[inicio]) < 2:
    return
  globalParent = collections.defaultdict(lambda: None)
  for sala1 in grafo[inicio]:
    currentParent = collections.defaultdict(lambda: None)
    currentParent[sala1] = inicio
    
    fila = collections.deque()
    fila.append(sala1)

    while len(fila) > 0:
      y = fila.popleft()
      for {{completion}}:
        if x != inicio and currentParent[x] is None:
          currentParent[x] = y
          fila.append(x)

    for x in currentParent:
      if x in globalParent:
        #Deu bom
        return (caminho(globalParent, x), caminho(currentParent, x))
        
    for x,y in currentParent.items():
      globalParent[x] = y
      
    

n, m, s = map(int, input().split())
g = collections.defaultdict(list)
for i in range(m):
  x,y = map(int, input().split())
  g[x].append(y)

paths = solve(g,n,s)

if paths is None:
  print(""Impossible"")
else:
  print(""Possible"")
  for i in paths:
    print(len(i))
    print("" "".join(map(str,i)))",x in grafo[y],"x in grafo[y]:
        if x not in currentParent"
"n, m, s = [int(x) for x in input().split()]
labyrinth = {x: set() for x in range(1, n+1)}
for _ in range(m):
    pt1, pt2 = [int(x) for x in input().split()]
    labyrinth[pt1].add(pt2)
d_father = {}
for pt in labyrinth[s]:
    d_father[pt] = s
if len(d_father) < 2: print('Impossible')
else:
    for pt in labyrinth[s]:
        visited = {pt, s}
        to_visit = {pt}
        while to_visit:
            new_visit = set()
            for origin in to_visit:
                for new_pt in labyrinth[origin]:
                    if new_pt not in visited:
                        if new_pt in d_father:
                            path1 = [new_pt]
                            path2 = [new_pt, origin]
                            while {{completion}}:
                                path1.append(d_father[path1[-1]])
                            while path2[-1] in d_father:
                                path2.append(d_father[path2[-1]])
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue
                break
            else:
                to_visit = new_visit
                continue
            break
        else: continue
        break
    else: print('Impossible')",path1[-1] in d_father,"path1[-1] in d_father:
                                path1.append(d_father[path1[-1]])
                            while path2[-1] in d_father:
                                path2.append(d_father[path2[-1]])
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue"
"n, m, s = [int(x) for x in input().split()]
labyrinth = {x: set() for x in range(1, n+1)}
for _ in range(m):
    pt1, pt2 = [int(x) for x in input().split()]
    labyrinth[pt1].add(pt2)
d_father = {}
for pt in labyrinth[s]:
    d_father[pt] = s
if len(d_father) < 2: print('Impossible')
else:
    for pt in labyrinth[s]:
        visited = {pt, s}
        to_visit = {pt}
        while to_visit:
            new_visit = set()
            for origin in to_visit:
                for new_pt in labyrinth[origin]:
                    if new_pt not in visited:
                        if new_pt in d_father:
                            path1 = [new_pt]
                            path2 = [new_pt, origin]
                            while path1[-1] in d_father:
                                path1.append(d_father[path1[-1]])
                            while {{completion}}:
                                path2.append(d_father[path2[-1]])
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue
                break
            else:
                to_visit = new_visit
                continue
            break
        else: continue
        break
    else: print('Impossible')",path2[-1] in d_father,"path2[-1] in d_father:
                                path2.append(d_father[path2[-1]])
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue
                break
            else:
                to_visit = new_visit
                continue
            break
        else: continue
        break
    else: "
"import re
import sys
exit=sys.exit
from bisect import *
from collections import *
ddict=defaultdict
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
rb=lambda:list(map(int,rl()))
rfs=lambda:rln().split()
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rl=lambda:rln().rstrip('\n')
rln=sys.stdin.readline
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'
########################################################################

n,m,s=ris()
adj=[[] for _ in range(n+1)]
for _ in range(m):
  u,v=ris()
  adj[u].append(v)

vis=[{} for _ in range(n+1)]
for i in adj[s]:
  stk=[i]
  vis[s][i]=0
  vis[i][i]=s
  while stk:
    u=stk.pop()
    if 1<len(vis[u]):
      print('Possible')
      for j in vis[u]:
        x,path=u,[]
        while {{completion}}:
          path.append(x)
          x=vis[x][j]
        print(len(path))
        print(*reversed(path))
      exit()
    for v in adj[u]:
      if i in vis[v] or v==s:
        continue
      stk.append(v)
      vis[v][i]=u
  
print('Impossible')
",j in vis[x],"x!=j and vis[x].get(j,0)!=0:
          path.append(x)
          x=vis[x][j]
        print(len(path))
        print(*reversed(path))
      exit()
    for v in adj[u]:
      if i in vis[v] or v==s:
        continue
      stk.append(v)
      vis[v][i]=u

print('Impossible')
exit()

########################################################################

n,m,s=ris()
adj=[[] for _ in range(n+1)]
for _ in range(m):
  u,v=ris()
  adj[u].append(v)

vis=[{} for _ in range(n+1)]
for i in adj[s]:
  st"
"def DFS(start):
    nodes=set()
    stack=[start]
    while stack:
        parent=stack.pop()
        if(not visited[parent]):
            nodes.add(parent)
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                else:
                    if {{completion}}:
                        return child
        else:
            if parent not in nodes and parent != s:
                return parent
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path=[]
    while node!=-1:
        path.append(node)
        node=parent_list[node]
    path.reverse()
    return path
n,m,s=map(int,input().split())
s-=1
graph=[[] for _ in range(n)]
for _ in range(m):
    a,b=map(int,input().split())
    a-=1
    b-=1
    graph[a].append(b)
visited=[False]*n
visited[s]=True
for child in graph[s]:
    end=DFS(child)
    if end!=-1:
        visited = [False] * n
        parent_list=[-1]*n
        visited[s]=True
        ans=[]
        for child in graph[s]:
            if DFS_get_path(child):
                ans.append([s]+get_path(end))
            if len(ans)==2:
                break
        print(""Possible"")
        for i in ans:
            print(len(i))
            print(*[j+1 for j in i])
        break
else:
    print(""Impossible"")

# 3 3 1
# 1 2
# 2 1
# 1 3",child not in nodes and child!=s,"child in nodes:
                        return child
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path=[]
    while node!=-1:
        path.append(node)
        node=parent_list[node]
    path.reverse()
    return path
n,m,"
"def DFS(start):
    nodes=set()
    stack=[start]
    while stack:
        parent=stack.pop()
        if(not visited[parent]):
            nodes.add(parent)
            visited[parent]=True
            for child in graph[parent]:
                if {{completion}}:
                    stack.append(child)
                else:
                    if child not in nodes and child!=s:
                        return child
        else:
            if parent not in nodes and parent != s:
                return parent
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path=[]
    while node!=-1:
        path.append(node)
        node=parent_list[node]
    path.reverse()
    return path
n,m,s=map(int,input().split())
s-=1
graph=[[] for _ in range(n)]
for _ in range(m):
    a,b=map(int,input().split())
    a-=1
    b-=1
    graph[a].append(b)
visited=[False]*n
visited[s]=True
for child in graph[s]:
    end=DFS(child)
    if end!=-1:
        visited = [False] * n
        parent_list=[-1]*n
        visited[s]=True
        ans=[]
        for child in graph[s]:
            if DFS_get_path(child):
                ans.append([s]+get_path(end))
            if len(ans)==2:
                break
        print(""Possible"")
        for i in ans:
            print(len(i))
            print(*[j+1 for j in i])
        break
else:
    print(""Impossible"")

# 3 3 1
# 1 2
# 2 1
# 1 3",(not visited[child]),"child==end:
                    return child
                elif child not in nodes and child!=s:
                    stack.append(child)
                else:
                    if child not in nodes and child!=s:
                        return child
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path"
"l=[[*map(int,input().split())] for i in range(3)]
l=sorted(l,key=lambda x:x[1])
ans=[]
ans.append([l[0][0],l[0][1],l[0][0],l[1][1]])
l[0]=[l[0][0],l[1][1]]
if (l[1][0]<l[0][0] and l[2][0]>l[0][0]) or (l[1][0]>l[0][0] and l[2][0]<l[0][0]):
    ans.append([*l[0],l[1][0],l[0][1]])
    ans.append([*l[0],l[2][0],l[0][1]])
    ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])
else:
    if {{completion}}:leng=max(l[1][0],l[2][0])
    else:leng=min(l[1][0],l[2][0])
    ans.append([*l[0],leng,l[0][1]])
    ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])
print(len(ans))
for i in ans:
    print(*i)
","max(l[1][0],l[2][0])>l[0][0]","l[1][0]<l[2][0]:
        leng=max(l[1][1],l[2][1])
    elif l[1][0]>l[2][0]:
        leng=min(l[1][1],l[2][1])
    elif l[1][0]==l[2][0]:
        leng=max(l[1][1],l[2][1])
        ans.append([*l[0],l[1][0],l[0][1]])
        ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])
    elif l[2][0]<l[1][0]:
        leng=max(l[1][1],l[2][1])
        ans.append([*l[0],l[1][0],l[0][1]])
        an"
"'''
题意：将n个人安排到二叉树中，每两人之间通过最短路径d[i,j]通信，消息数量c[i,j]通过矩阵给出，
要求构造的二叉树满足：任意节点u的左子树中节点序号<u、右子树…>，且所有的节点对之间的c[i,j]*d[i,j]的总和最小。

区间dp，对于f[l,r]，枚举根节点k，得到最大值时记住区间[l,r]的根节点k，
最后先序遍历为每个节点指定根节点。
'''
R,G=lambda:map(int,input().split()),range;n,=R();Fa=[0]*n;N=n+1
A=lambda:[[0]*N for _ in G(N)];S,Rt,f=A(),A(),A()
for i in G(n):
  r=[*R()]
  for j in G(n):S[i+1][j+1]=r[j]+S[i][j+1]+S[i+1][j]-S[i][j]
rec=lambda i,x:S[x][x]-S[x][i]-S[i][x]+S[i][i]
for c in G(1,N):
  for l in G(N-c):
    r=l+c;f[l][l+c]=float('inf')
    for k in G(l,r):
      C=f[l][k]+S[k][n]-S[l][n]-rec(l,k)+f[k+1][r]+S[r][n]-S[k+1][n]-rec(k+1,r)
      if {{completion}}:f[l][r]=C;Rt[l][r]=k
def F(l,r,fa):
  if l==r:return
  mid=Rt[l][r];Fa[mid]=fa+1;F(l,mid,mid);F(mid+1,r,mid)
F(0,n,-1);print(*Fa)",C<f[l][r],"C<f[l][r]:f[l][r]=C;Rt[l][r]=k
print(*Fa)
'''
时间复杂度：$O(n^2)$
空间复杂度：$O(n^2)$
'''
'''
题意：将n个人安排到二叉树中，每两人之间通过最短路径d[i,j]通信，消息数量c[i,j]通过矩阵给出，
要求构造的二叉树满足："
"n = int(input().strip())

S = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    for j, c in enumerate(map(int, input().strip().split())):
        S[i][j] = c

for i in range(n):
    for j in range(n):
        if i > 0 and j > 0:
            S[i][j] += S[i][j-1] + S[i-1][j] - S[i-1][j-1]
        elif i > 0:
            S[i][j] += S[i-1][j]
        elif {{completion}}:
            S[i][j] += S[i][j-1]


def acc(i1, i2, j1, j2):
    if i1 >= i2 or j1 >= j2:
        return 0
    a = S[i2-1][j2-1]
    b = S[i2-1][j1-1] if j1 > 0 else 0
    c = S[i1-1][j2-1] if i1 > 0 else 0
    d = S[i1-1][j1-1] if i1 > 0 and j1 > 0 else 0
    return a - b - c + d

M = [[-1 for i in range(n)] for j in range(n)]
P = [[-1 for i in range(n)] for j in range(n)]
def solve(b, e):
    if e - b == 1:
        M[b][e-1] = 0
        return 0
    if e - b == 0:
        return 0
    if M[b][e-1] != -1:
        return M[b][e-1]
    M[b][e-1] = 1e18
    for i in range(b, e):
        s = solve(b, i) + solve(i+1, e)
        s += acc(0, b, b, i) + acc(b, i, i, n) + acc(0, i+1, i+1, e) + acc(i+1, e, e, n)
        if s < M[b][e-1]:
            M[b][e-1] = s
            P[b][e-1] = i
    return M[b][e-1]
solve(0, n)
sol = ["""" for _ in range(n)]
def label(b, e, p):
    if e - b == 1:
        sol[b] = str(p)
        return
    elif e - b == 0:
        return
    i = P[b][e-1]
    sol[i] = str(p)
    label(b, i, i+1)
    label(i+1, e, i+1)
label(0, n, 0)
print("" "".join(sol))
",j > 0,"j > 0:
            S[i][j] += S[i][j-1]
        else:
            S[i][j] += S[i][j-1]
for i in range(n):
    for j in range(n):
        if i > 0 and j > 0:
            S[i][j] += S[i][j-1] + S[i-1][j] - S[i-1][j-1]
        elif i > 0:
            S[i][j] += S[i-1][j]
        elif j > 0:
            S[i][j] += S[i][j-1]
        else:
            S[i][j] += S[i][j-1]
for i in range(n):
    for j in range(n):
        if i > 0 and j > 0:
            S[i][j] += S[i][j-1] + S[i-1][j] - S[i-1][j-1]
        elif i > 0:
            S[i][j] += S[i-1][j]
        elif "
"n=int(input())
c=[]
for _ in range(n):
    c.append(tuple(map(int,input().split())))
prefix_sum=[[0]*(n+1) for _ in range(n+1)]
for i in range(1,n+1):
    temp=0
    for j in range(1,n+1):
        temp+=c[i-1][j-1]
        prefix_sum[i][j]+=prefix_sum[i-1][j]+temp
def get_rectangel_sum(x1,y1,x2,y2):
    return prefix_sum[x2+1][y2+1]-prefix_sum[x1][y2+1]-prefix_sum[x2+1][y1]+prefix_sum[x1][y1]
def cost(x,y):
    if x>y:
        return 0
    a=get_rectangel_sum(x,0,y,x-1) if x!=0 else 0
    b=get_rectangel_sum(x,y+1,y,n-1) if y!=n-1 else 0
    return a+b
dp=[[float(""INF"")]*n for _ in range(n)]
best_root_for_range=[[-1]*n for _ in range(n)]
for i in range(n):
    dp[i][i]=0
    best_root_for_range[i][i]=i
def get_dp_cost(x,y):
    return dp[x][y] if x<=y else 0
for length in range(1,n):
    # actual length is length+1
    for i in range(n-length):
        j=i+length
        for root in range(i,j+1):
            temp=cost(i,root-1)+cost(root+1,j)+get_dp_cost(i,root-1)+get_dp_cost(root+1,j)
            if {{completion}}:
                dp[i][j]=temp
                best_root_for_range[i][j]=root
ans=[-1]*n
def assign_ans(ansecstor,x,y):
    if x>y:
        return
    root=best_root_for_range[x][y]
    ans[root]=ansecstor
    assign_ans(root,x,root-1)
    assign_ans(root,root+1,y)
assign_ans(-1,0,n-1)
print(*[i+1 for i in ans])

# 3
# 0 1 2
# 1 0 3
# 2 3 0

# 4
# 0 1 2 3
# 1 0 5 7
# 2 5 0 4
# 3 7 4 0

# 6
# 0 100 20 37 14 73
# 100 0 17 13 20 2
# 20 17 0 1093 900 1
# 37 13 1093 0 2 4
# 14 20 900 2 0 1
# 73 2 1 4 1 0",temp<dp[i][j],"temp<dp[i][j]:
                dp[i][j]=temp
                best_root_for_range[i][j]=root
ans=[-1]*n
def assign_ans(ansecstor,x,y):
    if x>y:
        return
    root=best_root_for_range[x][y]
    ans[root]=ansecstor
    assign_ans(root,x,root-1)
    assign_ans(root,root+1,y)
assign_ans(-1,0,n-1)
print(*[i+1 for i in ans])

#2
n=int(input())
c=[]
for _ in range(n):
    c.append(tuple(map(int,input().split())))
prefix_sum=[[0]*(n"
"n,s=open(0)
for {{completion}}:print(min(-int(x)%2**i-i+15for i in range(16)))",x in s.split(),"x in range(n):
    s=s+int(x)%2**15-i+15
"
"n = int(input())
mod = 1 << 15
for x in map(int, input().split()):
    res = 16
    for a in range(15):
        for b in range(15):
            if {{completion}}:
                res = min(res, a + b)
    print(res)
",(x + a) * (1 << b) % mod == 0,a < b
"n, s = open(0)
for {{completion}}:
    print(min(15-i+-x % 2**i for i in range(16)))
","x in map(int, s.split())","x in range(n):
    s += x
    s += (x % 2**16) * 2**16
    s += (x % 2**8) * 2**8
    s += (x % 2**4) * 2**4
    s += (x % 2**2) * 2**2
    s += (x % 2**1) * 2**1
    s += (x % 2**0) * 2**0
print(s)
<|/ file source=github dstars=1 |>"
"n,s=open(0)
for {{completion}}:print(min(-x%2**i-i+15for i in range(16)))","x in map(int,s.split())","x in range(n):
    s=s+x%2**15-i+15for i in range(16)
print(s)

</text>
<cell>
n,s=input().split()
n=int(n)
s=int(s)
for x in range(n):
    s=s+x%2**15-i+15for i in range(16)
print(s)
</cell>
<text>
Solution using Python:

</text>
<cell>
n,s=input().split()
n=int(n)
s=int(s)
for x in range(n):
    s=s+x%2**15-i+15for i in range(16)
print(s)
</cell>
<text>
Solution using Python:

</text>
<cell>
n,s="
"n,s=open(0)
for {{completion}}:print(min(15-i+-x%2**i for i in range(16)))","x in map(int,s.split())","x in range(n):
  s=s+x%2**16
  print(min(15-i+-x%2**i for i in range(16)))

</text>
<cell>
n,s=open(0)
for x in range(n):
  s=s+x%2**16
  print(min(15-i+-x%2**i for i in range(16)))
</cell>
<text>
Solution 2

</text>
<cell>
n,s=open(0)
for x in range(n):
  s=s+x%2**16
  print(min(15-i+-x%2**i for i in range(16)))
</cell>
<text>
Solution 3

</text>
<cell>
n,s=open(0)
for "
"n,s=open(0)
for {{completion}}:print(min(-int(x)%2**i-i+15for i in range(16)))",x in s.split(),"x in range(n):
    s=s+2**x%32768
print(s)
<|/ q dscore=0 |>
<| c |>
What have you tried so far?
<|/ c |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Welcome to Stack Overflow! It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far, example "
"for test in range(int(input())):
    n = int(input())
    h = [int(i) for i in input().split()]
    res = 2 << 69

    for req in range(max(h), max(h)+3):
        hm = req
        d = 0
        c = 0
        for {{completion}}:
            d += req-i
            c += (req-i) & 1
        res = min(res, max((d//3)*2+d % 3, c*2-1))

    print(res)
",i in h,"i,hi in enumerate(h):
            if hi < req:
                d += req-i
                c += (req-i) & 1
            else:
                hm = min(hm, hi)
                d += hi - hm
                c += (hi - hm) & 1
        res = min(res, max((d//3)*2+d % 3, c*2-1))

    print(res)
""""""
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
for test in range(int(input())):
    n = int(input())
    h = [int(i) for i in input().split()]
    res = 2 << 69

    for req in range(max(h), max("
"from bisect import bisect

t = int(input().strip())

def solve(o, t):
    if {{completion}}:
        d = (t - o) // 3 + ((t - o) % 3 == 2)
        o, t = o + 2 * d, t - d
    return (o + (t > o)) * 2 - (o > t)


out = []
for _ in range(t):
    n = int(input().strip())
    h = list(map(int, input().strip().split()))
    mx = max(h)
    o, t, e = 0, 0, 0
    for x in h:
        e += (mx - x + 1) % 2
        o += (mx - x) % 2
        t += (mx - x) // 2
    out.append(str(min(solve(o, t), solve(e, t + o))))


print(""\n"".join(out))
",t - o > 1,t > o
"from bisect import bisect

t = int(input().strip())

def solve(o, t):
    if t - o > 1:
        d = (t - o) // 3 + ((t - o) % 3 == 2)
        o, t = o + 2 * d, t - d
    return (o + (t > o)) * 2 - (o > t)


out = []
for _ in range(t):
    n = int(input().strip())
    h = list(map(int, input().strip().split()))
    mx = max(h)
    o, t, e = 0, 0, 0
    for {{completion}}:
        e += (mx - x + 1) % 2
        o += (mx - x) % 2
        t += (mx - x) // 2
    out.append(str(min(solve(o, t), solve(e, t + o))))


print(""\n"".join(out))
",x in h,"x in h:
        e += (mx - x + 1) % 2
        o += (mx - x) % 2
        t += (mx - x) // 2
    out.append(str(min(solve(o, t), solve(e, t + o))))


print(""\n"".join(out))
""""""
<|/ file source=github |>"
"def solve(target,r):
 k=len(r)
 ones=twos=0
 for {{completion}}:
  ones+=(target-r[i])%2
  twos+=(target-r[i])//2
 if ones>twos:return 2*ones-1
 return (ones+twos*2)//3*2+(ones+twos*2)%3
for _ in [0]*int(input()):
 input();r=[*map(int,input().split())]
 print(min(solve(max(r),r),solve(max(r)+1,r)))",i in range(k),"i in range((k+1)//2):
  ones+=(target-r[i])%2
  twos+=(target-r[i])//2
 if ones>twos:return 2*ones-1
 return (ones+twos*2)//3*2+(ones+twos*2)%3
for _ in [0]*int(input()):
 input();r=[*map(int,input().split())]
 print(min(solve(max(r),r),solve(max(r)+1,r)))
'''
</cell>
<cell>
'''
Solution 2
'''
def solve(target,r):
 k=len(r)
 ones="
"for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().strip().split()))
    l.sort()
    a=l.count(l[-1])
    odd,even=0,0
    for i in l:
        if {{completion}}:
            even+=1
        else:
            odd+=1
    su=sum(l[:n-a])
    needed=l[-1]*(n-a)-su
    if l[-1]%2==0:
        p1,p2=odd,even
    else:
        p1,p2=even,odd
    ans=max(2*(needed//3)+needed%3,2*p1-1)
    needed+=n
    ans2=max(2*(needed//3)+needed%3,2*p2-1)
    print(min(ans,ans2))",i%2==0,"i%2==1:
            even+=1
        else:
            odd+=1
    su=sum(l[:n-a])
    needed=l[-1]*(n-a)-su
    if l[-1]%2==0:
        p1,p2=odd,even
    else:
        p1,p2=even,odd
    ans=max(2*(needed//3)+needed%3,2*p1-1)
    needed+=n
    ans2=max(2*(needed//3)+needed%3,2*p2-1)
    print(min(ans,ans2))
<|/ a dscore=0 |>
<| a tags=python,python-3.x "
"def solve(m,a):
    ev=od=0
    for {{completion}}:
        ev += (m-i)//2; od += (m-i)%2
    if(od>=ev):
        return od*2-(od!=ev)
    ev = (ev-od)*2
    return od*2 + ev//3*2 + ev%3

I = lambda: map(int,input().split())
t,=I()
for _ in [1]*t:
    n, = I()
    b = [*I()]
    mx = max(b)
    print(min(solve(mx,b),solve(mx+1,b)))",i in a,"i,x in enumerate(a):
        if(x>m):
            break
        ev += (m-x)//2
        od += (m-x)%2
    if(od>=ev):
        return od*2-(od!=ev)
    ev = (ev-od)*2
    return od*2 + ev//3*2 + ev%3

def solve(m,a):
    ev=od=0
    for i,x in enumerate(a):
        if(x>m):
            break
        ev += (m-i)//2
        od += (m-i)%2
    if(od>=ev):
        return od*2-(od!=ev)
    ev = ("
"# by the authority of GOD     author: Kritarth Sharma #
import sys
from collections import defaultdict,deque,Counter
from bisect import bisect_left
import math
input=sys.stdin.readline
def inp():
    l=list(map(int,input().split()))
    return l

for _ in range(int(input())):
        n,=inp()
        l=inp()
        m=max(l)
        a=float('inf')
        for i in range(m,m+2):
            x=0
            y=0
            for {{completion}}:
                x+=(i-l[j])//2
                y+=(i-l[j])%2
            a=min(a,max( 2*y -1, ((2*x+y)//3)*2 +((2*x+y)%3) ))
        print(a)",j in range(n),"j in l:
                if i==j"
"inp = lambda : list(map(int,input().split()))
for _ in range(int(input())):
    n = int(input())
    t = inp()
    c = 0
    m = max(t)
    def mm(m):
        n1 = n2 = 0
        tot =0
        for {{completion}}:
            n1+= (m-i)%2
            n2+= (m-i)//2
        return (n1*2-1) if n2<n1 else ((n2*2+n1)//3*2+(n2*2+n1)%3)    

    print(min(mm(m),mm(m+1)))",i in t,"i,h in enumerate(t):
            tot+=h
            if tot==m:
                c += 1
                tot = 0
            if tot%2==1:
                n1 += 1
            if tot%2==0:
                n2 += 1
            if tot==m:
                break
        return (n1*2-1) if n2<n1 else ((n2*2+n1)//3*2+(n2*2+n1)%3)
    print(min(mm(m),mm(m+1)))
<|/ a tags=python-3.x,python |>
<| a dscore=0 |>
<code>
inp = lambda : list(map(int,input().split()))
for _ in range(int(input())):
"
"for ii in range(int(input())):
	n=int(input())
	a = list(map(int, input().split()))
	m=max(a)
	ans=float(""inf"")
	for jj in range(m,m+4):
		x,y=0,0
		for {{completion}}:
			x+=(jj-kk)%2
			y+=(jj-kk)//2
		ans=min(max(((x+y*2)//3*2)+(x+y*2)%3,x*2-1),ans)
	print(ans)",kk in a,"kk in range(1,n+1):
			x+=(jj-kk)%2
			y+=(jj-kk)//2
		ans=min(max(((x+y*2)//3*2)+(x+y*2)%3,x*2-1),ans)
	print(ans)
<|/ q tags=python-3.x,python |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please read [ask] and [mcve]
<|/ c |>
<| c |>
I have added the code I have written so far.
<|/ c |>
<| c |>"
"n,k = map(int, input().split())
bb = list(map(int, input().split()))
ans = 0
sofar = 0
sumprog = 0
timeq = []
for ib,b in enumerate(bb[::-1]):
    kk = min(k, n-ib)
    time = (max(0,b-sofar)+kk-1)//kk
    ans += time
    timeq.append(time)
    sumprog += time
    if {{completion}}:
        sumprog -= timeq[ib-k]
    sofar += kk*time
    sofar -= sumprog
    # print(time, sofar, timeq, sumprog)
print(ans)
",ib >= k,"timeq[ib]>0:
        sumprog -= timeq[ib]
    for k in range(ib,ib,-1):
        time = (max(0,bb[ib]-sofar)+k-1)//k
        ans += time
        timeq.append(time)
        sumprog += time
        if timeq[ib-k]>0:
            sumprog -= timeq[ib-k]
    for k in range(ib,ib,-1):
        time = (max(0,bb[ib]-sofar)+k-1)//k
        ans += time
        timeq.append(time)
        sumprog += time
        if timeq[ib-"
"I = lambda: [int(x) for x in input().split()]
n, k = I()
B, d = I() + [0]*k, [0] * (n + k)

s = total = 0
for i in range(n-1, -1, -1):
    B[i] -= total
    if {{completion}}:
        dd = min(k, i + 1)
        d[i] = (B[i] + dd - 1)//dd
    s += d[i] - d[i + k]
    total += d[i] * dd - s
    
print(sum(d))",B[i] > 0,"B[i] < 0:
        B[i] = 0
    if B[i] > k:
        B[i] = k
    
    for j in range(i + 1, n + 1):
        B[j] -= B[i]
        if B[j] < 0:
            B[j] = 0
    
    d[i] = 0
    for j in range(i + 1, n + 1):
        d[i] += B[j] - B[i]
    
    for j in range(i + 1, n + 1):
        d[i] += d[j]
    
    for j in range(i + 1, n + 1):
        B[j] -= d[j]
    
    for j in range(i + 1, n + 1):
        B[j] -= B[i]
    
    for j in range(i + 1, n + 1):
        B[j] -= d[j]
    
"
"#!/usr/bin/env PyPy3

from collections import Counter, defaultdict, deque
import itertools
import re
import math
from functools import reduce
import operator
import bisect
import heapq
import functools
mod=10**9+7

import sys
input=sys.stdin.readline
n,k=map(int,input().split())
b=list(map(int,input().split()))
ans = 0
dec = 0
cnt = [0] * n
tmp = 0
for i in range(k-1,n)[::-1]:
    tmp -= cnt[i]
    dec -= tmp
    #print(tmp,dec)
    if b[i] > dec:
        #print(b[i]-dec)
        x = -(-(b[i]-dec) // k)
        ans += x
        if {{completion}}:
            cnt[i-k-1] = x
        dec += x * k
        tmp += x
    #print(ans)
    #tmp -= cnt[i]
#print(cnt)
ma = 0
for i in range(k-1)[::-1]:
    tmp -= cnt[i]
    dec -= tmp
    ma = max(ma,-(-(b[i]-dec) // (i+1)))

print(ans+ma)",i - k - 1 >= 0,"i > 0:
            cnt[i-1] = x
        if i < k-1:
            cnt[i+k-1] = x
        dec += x * k
        tmp += x
    else:
        x = -(-(b[i]-dec) // k)
        ans += x
        if i > 0:
            cnt[i-1] = x
        if i < k-1:
            cnt[i+k-1] = x
        dec += x * k
        tmp += x
    #print(ans)
    #tmp -= cnt[i]
#print(cnt)
ma = 0
for i in range(k-1)[::-1]:
    tmp -= cnt[i]
    dec -= tmp
    ma = max(ma,-(-(b[i]-dec) // (i+1)))"
"n, k = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]

dd = [0]*(len(a)+5)

add = 0
diff = 0
moves = 0
for key, i in reversed([*enumerate(a)]):
    add += diff
    i += add
    diff += dd[-1]
    dd.pop()
    if {{completion}}:
        K = min(k, key+1)
        dd[-K] -= (i+K-1)//K
        diff += (i+K-1)//K
        moves += (i+K-1)//K
        add -= K*((i+K-1)//K)
print(moves)
",i > 0,"i==k:
        moves += 1
        break
    if i==k-1:
        moves += 2
        break
    if i==k+1:
        moves += 3
        break
    if i==k+2:
        moves += 4
        break
    if i==k+3:
        moves += 5
        break
    if i==k+4:
        moves += 6
        break
    if i==k+5:
        moves += 7
        break
    if i==k+6:
        moves += 8
        break
    if i==k+7:
        moves += 9
        break
    if i==k+8:
"
"""""""
take element as ""the tail"" will use more less operations,

use variables s,cnt and closed,
to avoid the inner iteration(update neighbor k elements every time),
complexity is O(n).
""""""
row=lambda:map(int,input().split())
n,k=row()
a=list(row())
closed=[0]*n
s=cnt=res=0
for i in range(n-1,-1,-1):
    # print(i,a[i],'s,cnt:',s,cnt,'closed:',closed)
    s-=cnt
    cnt-=closed[i]
    a[i]-=s
    if {{completion}}:
        continue
    th=min(i+1,k)
    need=(a[i]+th-1)//th#equals ceil()
    s+=need*th
    cnt+=need
    res+=need
    if i>=th:
        closed[i-th]+=need
print(res)",a[i]<=0,"a[i]<0:
        a[i]+=k
    if a[i]>k:
        a[i]-=k
    if a[i]<0:
        a[i]+=k
    if a[i]>k:
        a[i]-=k
    if a[i]<0:
        a[i]+=k
    if a[i]>k:
        a[i]-=k
    if a[i]<0:
        a[i]+=k
    if a[i]>k:
        a[i]-=k
    if a[i]<0:
        a[i]+=k
    if a[i]>k:
        a[i]-=k
    if a[i]<0:
        a[i]+=k
    if a[i]>k:
        a[i]-=k
    if a[i]<"
"""""""
take element as ""the tail"" will use more less operations,

use variables s,cnt and closed,
to avoid the inner iteration(update neighbor k elements every time),
complexity is O(n).
""""""
row=lambda:map(int,input().split())
n,k=row()
a=list(row())
closed=[0]*n
s=cnt=res=0
for i in range(n-1,-1,-1):
    # print(i,a[i],'s,cnt:',s,cnt,'closed:',closed)
    s-=cnt
    cnt-=closed[i]
    a[i]-=s
    if a[i]<=0:
        continue
    th=min(i+1,k)
    need=(a[i]+th-1)//th#equals ceil()
    s+=need*th
    cnt+=need
    res+=need
    if {{completion}}:
        closed[i-th]+=need
print(res)",i>=th,cnt==0 and i<
"import math     
n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))
ans = res = tot = minus = 0
pre = []
prefix = []
for i in range(n)[::-1]:
    if {{completion}}:
        minus += k * pre[-1] - prefix[-1]
    nums[i] -= minus
    cur = max(0, math.ceil(nums[i] / k))
    ans += (cur if i >= k else 0)
    pre.append(cur if i >= k else 0)
    tot += (cur if i >= k else 0)
    if len(pre) > k:
        tot -= pre[- k - 1]
    prefix.append(tot)
for i in range(k):
    res = max(res, math.ceil(nums[i] / (i + 1)))
print(ans + res)  ",i < n - 1,"nums[i] >= k:
        tot += k * pre[-1] - prefix[-1]
        nums[i] -= k
        cur = max(0, math.ceil(nums[i] / k))
        ans += (cur if i >= k else 0)
        pre.append(cur if i >= k else 0)
        tot += (cur if i >= k else 0)
        if len(pre) > k:
            tot -= pre[- k - 1]
        prefix.append(tot)
    else:
        tot += k * pre[-1] - prefix[-1]
        nums[i] -= k
        cur = max(0, math.ceil(nums[i] / k))
        ans += (cur if i >= k else 0)
        pre.append(cur if i >= k else "
"import math     
n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))
ans = res = tot = minus = 0
pre = []
prefix = []
for i in range(n)[::-1]:
    if i < n - 1:
        minus += k * pre[-1] - prefix[-1]
    nums[i] -= minus
    cur = max(0, math.ceil(nums[i] / k))
    ans += (cur if i >= k else 0)
    pre.append(cur if i >= k else 0)
    tot += (cur if i >= k else 0)
    if {{completion}}:
        tot -= pre[- k - 1]
    prefix.append(tot)
for i in range(k):
    res = max(res, math.ceil(nums[i] / (i + 1)))
print(ans + res)  ",len(pre) > k,"i >= k - 1:
        tot -= pre[- k - 1]
    prefix.append(tot)
for i in range(k):
    res = max(res, math.ceil(nums[i] / (i + 1)))
print(ans + res)  
<|/ a dscore=0 |>
<| a tags=arrays,algorithm,python |>
<code>
import math     
n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))
ans = res = tot = minus = 0
pre = []
prefix = []
for i in range(n)[::-1]:
    if i < n - 1:
        minus += k * pre[-1] - prefix[-1]
    nums[i] -= minus
    cur = max(0, math."
"I=lambda:[*map(int,input().split())]
def F(g,i):s=g//i;b=g%i;return b*(s+1)**2+(i-b)*s**2
def f(g,c):
	if c>g**2//2:return 0,g**2
	s=0;b=g
	while b-s>1:
		m=(b+s)//2
		if {{completion}}:s=m
		else:b=m
	return s,F(g,b)
n,=I()
a=[0]+I()
m,=I()
G=[a[i+1]-a[i]for i in range(n)]
s=2
b=1<<59
while b-s>1:
	C=0;M=(b+s)//2
	for g in G:a,c=f(g,M);C+=c
	if C>m:b=M
	else:s=M
A=C=0
for g in G:a,c=f(g,b);A+=a;C+=c
print(A+max(0,(C-m-1)//s+1))","F(g,m)-F(g,m+1)>=c","c<F(g,m):
			s=m
		else:b=m
	return s,F(g,b)
def I():return map(int, input().split())
def F(g,i):s=g//i;b=g%i;return b*(s+1)**2+(i-b)*s**2
def f(g,c):
	if c>g**2//2:return 0,g**2
	s=0;b=g
	while b-s>1:
		m=(b+s)//2
		if c<F(g,m):
			s=m
		else:b=m
	return s,F(g,b)
def I():return map(int, input().split())
"
"from collections import Counter
n, a, m = int(input()), [*map(int, input().split())], int(input())
def energy(l, t):
    x,y = divmod(l, t+1)
    return x*x*(t+1-y)+(x+1)*(x+1)*y
def getdiff(l, diff):
    lo, hi = 0, l
    while lo < hi:
        mid = lo + hi >> 1
        if {{completion}}: hi = mid
        else: lo = mid + 1
    return lo, energy(l, lo)
def getsum(d, c=0): a1,a2 = zip(*[getdiff(i, d) for i,_ in a]); return (0 if c else sum(a1[i]*x for i, (_, x) in enumerate(a)), sum(a2[i]*x for i, (_, x) in enumerate(a)))
a = [0] + a
a = Counter([a[i+1]-a[i] for i in range(n)]).items()
lo, hi = 1, m
while lo < hi:
    mid = lo + hi >> 1
    if getsum(mid, 1)[1] > m: hi = mid
    else: lo = mid + 1
lo-=1
a1, a2 = getsum(lo)
print(a1-(m-a2)//lo if lo else a1)","energy(l, mid) - energy(l, mid+1) < diff","getsum(mid, diff)[1] > diff"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

def ff(gap, ints): 
	sml = gap // ints
	bigcount = gap % ints
	return bigcount * (sml + 1) ** 2 + (ints - bigcount) * sml ** 2

def f(gap, c):
	if c > gap ** 2 // 2:
		return 0, gap ** 2
	sml = 0
	big = gap
	while big - sml > 1:
		mid = (big + sml) // 2
		a = ff(gap, mid)
		b = ff(gap, mid + 1)
		if {{completion}}:
			sml = mid
		else:
			big = mid
	return sml, ff(gap, big)

n, = I()
a = I()
m, = I()
gaps = [a[0]]
for i in range(n - 1):
	gaps.append(a[i + 1] - a[i])

sml = 2
big = 1 << 59 + 2
while big - sml > 1:
	cost = 0
	mid = (big + sml) // 2
	for g in gaps:
		a, c = f(g, mid)
		cost += c
	if cost > m:
		big = mid
	else:
		sml = mid
abig = 0
cbig = 0
for g in gaps:
	a, c = f(g, big)
	abig += a
	cbig += c

print(abig + max(0, (cbig - m - 1) // sml + 1))",a - b >= c,"a > b:
			sml = mid
		else:
			big = mid
	return sml, ff(gap, big)

n, = I()
a = I()
m, = I()
gaps = [a[0]]
for i in range(n - 1):
	gaps.append(a[i + 1] - a[i])

sml = 2
big = 1 << 59 + 2
while big - sml > 1:
	cost = 0
	mid = (big + sml) // 2
	for g in gaps:
		a, c = f(g, mid)
		cost += c
	if cost > m:
		big = mid
	else:
		sml = mid
abig = 0
cbig"
"from functools import cache
from math import inf
from itertools import accumulate

def solve(A, m):
    n = len(A)
    A.reverse()

    @cache
    def dp(i, val, balance):
        if abs(balance) > m:
            return inf
        if {{completion}}:
            return inf
        if i == n:
            return 0 if balance == 0 else inf

        curr = A[i] + balance
        take = abs(curr - val) + dp(i + 1, val, curr - val)
        skip = dp(i, val + 1, balance)
        return min(take, skip)

    return dp(0, 0, 0)


n, m = map(int, input().split())
A = list(map(int, input().split()))
print(solve(A, m))
",(n - i) * val > m,"i == n:
            return 0 if balance == 0 else inf

        curr = A[i] + balance
        take = abs(curr - val) + dp(i, val + 1, curr - val)
        skip = dp(i, val + 1, balance)
        return min(take, skip)

    return dp(0, 0, 0)


n, m = map(int, input().split())
A = list(map(int, input().split()))
print(solve(A, m))
""""""

""""""
from functools import cache
from math import inf
from itertools import accumulate

def solve(A, m):
    n = len(A)
    A.reverse()

    @cache
    def dp(i, val, balance):
        if abs(balance) > m:
            return inf
        if i == "
"from functools import cache
from math import inf
from itertools import accumulate

def solve(A, m):
    n = len(A)
    A.reverse()

    @cache
    def dp(i, val, balance):
        if abs(balance) > m:
            return inf
        if (n - i) * val > m:
            return inf
        if {{completion}}:
            return 0 if balance == 0 else inf

        curr = A[i] + balance
        take = abs(curr - val) + dp(i + 1, val, curr - val)
        skip = dp(i, val + 1, balance)
        return min(take, skip)

    return dp(0, 0, 0)


n, m = map(int, input().split())
A = list(map(int, input().split()))
print(solve(A, m))
",i == n,"i == 0 and balance == 0:
            return 0 if balance == 0 else inf
        if i == n - 1 and balance == 0:
            return 0 if balance == 0 else inf
        if i == n - 1 and balance > 0:
            return 0 if balance == 0 else inf
        if i == 0 and balance < 0:
            return 0 if balance == 0 else inf
        if i == 0 and balance > 0:
            return 0 if balance == 0 else inf
        if i == 0 and balance < 0:
            return 0 if balance == 0 else inf
        if i == n - 1 and balance < 0:
            return 0 if balance == 0 else inf
        if i == n - 1 and balance > 0:
            return 0 if balance == 0 else inf
        if i == n - 1 and balance < 0:
            return 0 if balance == 0 else inf
        if i == n - 1 and balance == 0:
"
"from itertools import accumulate
I=lambda:map(int,input().split())
n,m=I()
a,inf=[*I()],float('inf')
pre=[0]+[*accumulate(a)]

dp=[[inf]*(m+1) for _ in range(m+1)]
dp[m][0]=0
for i in range(n):
  cur=[[inf]*(m+1) for _ in range(m+1)]
  for lst in reversed(range(m+1)):
    for sums in range(m+1):
      if {{completion}}:
        dp[lst][sums]=min(dp[lst][sums],dp[lst+1][sums])
      if sums+lst<=m:
        cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))
  dp,cur=cur,dp
print(min(dp[lst][m] for lst in range(m+1)))",lst<m,sums>lst
"from itertools import accumulate
I=lambda:map(int,input().split())
n,m=I()
a,inf=[*I()],float('inf')
pre=[0]+[*accumulate(a)]

dp=[[inf]*(m+1) for _ in range(m+1)]
dp[m][0]=0
for i in range(n):
  cur=[[inf]*(m+1) for _ in range(m+1)]
  for lst in reversed(range(m+1)):
    for sums in range(m+1):
      if lst<m:
        dp[lst][sums]=min(dp[lst][sums],dp[lst+1][sums])
      if {{completion}}:
        cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))
  dp,cur=cur,dp
print(min(dp[lst][m] for lst in range(m+1)))",sums+lst<=m,sums<lst
"n,m=map(int,input().split())
a=list(map(int,input().split()))[::-1]

id=[]
for i in range(n):
  for _ in range(a[i]):
    id.append(i)

inf=10**5
dp=[[inf]*(m+1) for i in range(m+1)]
dp[0][0]=0
for i in range(n):
  cost=[]
  for j in id:
    cost.append(abs(i-j))
  cum=[0]
  tmp=0
  for j in cost:
    tmp+=j
    cum.append(tmp)
  
  dp_new=[[inf]*(m+1) for i in range(m+1)]
  for j in range(m+1):
    mx=(m-j)//(n-i)
    for k in range(mx+1):
      if dp[j][k]==inf:continue
      #print(i,j,k,mx)
      for {{completion}}:
        #print(l)
        c=cum[l+j]-cum[j]
        dp_new[j+l][l]=min(dp_new[j+l][l],dp[j][k]+c)
  dp=dp_new
print(min(dp[-1]))","l in range(k,mx+1)","l in range(j+1,k+1):
        #print(l,j)
        if l==j:
          continue
        if l<j:
          #print(l,j)
          dp[j][l]=min(dp[j][l],dp[j][k]+cum[l+j])
        else:
          #print(l,j)
          dp[j][l]=min(dp[j][l],dp[j][k]+cum[l+j])
      #print(j,k)
      for l in range(j+1,k+1):
        #print(l,j)
        if l==j:
          continue
        if l<j:
          #print(l,j)
          dp_new[j"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, K = map(int, getIntArray(2))
    A = getIntArray(N)

    s = [set() for i in range(3005)]
    for i in range(N):
        for k in range(1, K + 1):
            s[A[i] // k].add(i)

    ans = 999999999999999999999999999999999999999999999999999999999999999999999
    r = 0
    freq = {}
    for l in range(len(s)):
        while len(freq) < N and r < len(s):
            for v in s[r]:
                if {{completion}}: freq[v] = 0
                freq[v] += 1
            r += 1
        if len(freq) < N: break
        ans = min(ans, r - l - 1)
        for v in s[l]:
            if freq[v] == 1: del freq[v]
            else: freq[v] -= 1
    print(ans)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",v not in freq,"freq.has_key(v): continue
                if freq.has_key(v) and freq[v] == 0: continue
                if freq.has_key(v) and freq[v] > freq[v - 1]"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, K = map(int, getIntArray(2))
    A = getIntArray(N)

    s = [set() for i in range(3005)]
    for i in range(N):
        for k in range(1, K + 1):
            s[A[i] // k].add(i)

    ans = 999999999999999999999999999999999999999999999999999999999999999999999
    r = 0
    freq = {}
    for l in range(len(s)):
        while len(freq) < N and r < len(s):
            for {{completion}}:
                if v not in freq: freq[v] = 0
                freq[v] += 1
            r += 1
        if len(freq) < N: break
        ans = min(ans, r - l - 1)
        for v in s[l]:
            if freq[v] == 1: del freq[v]
            else: freq[v] -= 1
    print(ans)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",v in s[r],"v in s[r]:
                if v not in freq: freq[v] = 0
                freq[v] += 1
            r += 1
        if len(freq) < N: break
        ans = min(ans, r - l - 1)
        for v in s[l]:
            if freq[v] == 1: del freq[v]
            else: freq[v] -= 1
    print(ans)


testcase = False
def solve(testcase = 1):
    N, K = map(int, getIntArray(2))
    A = getIntArray(N)

    s = [set() for i in range(3005)]
    for i in range(N):
        for k in range(1, K + 1):
            s[A[i] // k].add(i)

    ans = "
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    map = {}
    for i in range(N):
        if A[i] not in map: map[A[i]] = []
        map[A[i]].append(i)

    for color in range(1, N + 1):
        if color not in map:
            print(0, end=' ')
            continue
        ar = map[color]
        oddCount = evenCount = 0
        for i in ar:
            if {{completion}}:
                evenCount = max(evenCount, oddCount + 1)
            else:
                oddCount = max(oddCount, evenCount + 1)
        print(max(oddCount, evenCount), end=' ')
    print()


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i % 2 == 0,"i % 2 == 1:
                oddCount = max(oddCount, evenCount + 1)
            elif i % 2 == 0:
                evenCount = max(evenCount, oddCount + 1)
            else:
                oddCount = max(oddCount, evenCount + 1)
        print(max(oddCount, evenCount), end=' ')
    print()


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens


testcase = True
def solve(testcase = 1):
    N = "
"n, d = map(int, input().split())
p = sorted(map(int, input().split()), reverse=True)
ans = 0
for num in p:
    if {{completion}}:
        n -= d // num + 1
        ans += 1
    else:
        break
print(ans)
",n >= d // num + 1,"num > d:
        ans += 1
    elif num < -d:
        ans += 1
    elif num == -d:
        ans += 1
    elif num == d:
        ans += 1
    elif num == -d:
        ans += 1
    elif num == d:
        ans += 1
    elif num == -d:
        ans += 1
    elif num == d:
        ans += 1
    elif num == -d:
        ans += 1
    elif num == d:
        ans += 1
    elif num == -d:
        ans += 1
    elif num == d:
        ans += 1
    elif num == -d:
        ans += 1
    elif num == d:
"
"def solve():
    n, d = [int(i) for i in input().split(' ')]
    power = [int(i) for i in input().split(' ')]
    
    power.sort()

    used = 0
    w = 0
    for i in range(len(power)-1, -1, -1):
        min_players = -(d // -power[i])
        p = power[i] * min_players
        if(p > d):
            used += min_players
        elif{{completion}}:
            used += min_players + 1

        if(used > n):
            break

        w += 1

    print(w)

solve()",(p == d),"(p == d):
            used += min_players
        else:
            used += min_players + 1

        if(used > n):
            break

        w += 1

    print(w)

solve()
<|/ file source=github |>"
"import math
enemy_power=int(input().split()[1])
team=[int(i) for i in input().split()]
team.sort()
days=0
while len(team)>0:
    num=enemy_power//team[-1]+1
    if {{completion}}:
        break;
    else:
        del team[-1]
        del team[0:num-1]
        days+=1
print(days)",len(team)<num,"num>len(team):
        num=len(team)
    if num<len(team):
        team+=[0]*(num-len(team))
    if sum(team)>enemy_power:
        team=[0]*(len(team)+1)
        team[-1]=enemy_power
        team[0:len(team)-1]=team[0:len(team)-1]+team[-1]
        days+=1
    elif sum(team)<enemy_power:
        team=[0]*(len(team)+1)
        team[-1]=enemy_power
        team[0:len(team)-1]=team[0:len(team)-1]+team[-1]
        days"
"import sys,math
n,team=map(int,sys.stdin.readline().split())
arr=sorted(map(int,sys.stdin.readline().split()),reverse=True)
# print(arr)
all=n+1
count=0
for i in range(n):
    sub=int(math.floor(team/arr[i])+1)
    all-=sub
    if {{completion}}:
        count+=1
    else:break
print(count)",all>0,"all>0:
        team-=sub*arr[i]
        count+=1
    else:break
print(count)
<|/ file dstars=0 source=github |>"
"def solve():
    n,d=map(int,input().split())
    a=sorted([*map(int,input().split())])[::-1]
    i,j,r=0,len(a),0
    while i<j:
        x=a[i]
        while x<=d:
            j-=1
            if {{completion}}:
                x+=a[i]
            else:
                return r
        else:
            r+=1
            i+=1
    return r
print(solve())
",i<j,"j==0:
                r+=1
                break
            elif x<"
"from sys import stdin,stdout
def ans():
    n,d=map(int,stdin.readline().strip().split())
    p=list(map(int,stdin.readline().strip().split()))
    temp=int(n)
    ans=0
    for x in sorted(p,reverse=True):
        if {{completion}}:
            temp-=((d//x)+1)
            ans+=1
    print(ans)     
    
if __name__=='__main__':
    ans()
",temp>=((d//x)+1),"temp>d:
            break
        if temp%x==0:
            ans+=1
            temp//=x
        else:
            ans+=1
            temp-=((d//x)+1)
            ans+=1
    print(ans)
    
if __name__=='__main__':
    ans()
'''
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"d = int(input().split("" "")[1])
p = sorted(map(int, input().split("" "")))
c = 0
l = 0
r = len(p) - 1

s = p[r]

while r > l:
    while {{completion}}:
        s += p[r]
        l += 1
    if l > r:
        break
    r -= 1
    s = p[r]
    c += 1

if p[0] > d:
    c += 1

print(c)
",s <= d,"c < l and p[r] > s:
        s += p[r]
        c += 1
    while c < r and p[r] < s:
        s += p[r]
        c += 1
    while c < l and p[r] < s:
        s += p[r]
        c += 1
    while c < r and p[r] > s:
        s += p[r]
        c += 1
    if l > r:
        break
    l += 1
    s = p[r]
    c += 1

while r > l:
    while c < l and p[r] > s:
        s += p[r]
        l += 1
    while c < r"
"import sys
input=sys.stdin.readline

from heapq import heappush,heappop,heapify 
from collections import defaultdict
 
def main():
	n,m=map(int,input().split())
	gf=defaultdict(list)
	gb=defaultdict(list)
	for _ in range(m):
		u,v,w=map(int,input().split())
		gf[u].append((v,w))
		gb[v].append((u,w))
	dis=[float('inf')]*(n+1)
	dis[1]=0
	h=[]
	heapify(h)
	heappush(h,(0,1))
	while h:
		cd,cn=heappop(h)
		if dis[cn]==cd:
			for nn,nw in gf[cn]:
				if {{completion}}:
					dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	res=[float('inf')]*(n+1)
	res[1]=0
	h=[]
	for i in range(1,n+1):
		if dis[i]!=float('inf'):
			res[i]=dis[i]
			h.append((dis[i],i))
	heapify(h)
	while h:
		cd,cn=heappop(h)
		if res[cn]==cd:
			for nn,nw in gb[cn]:
				if cd+nw<res[nn]:
					res[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	for i in range(1,len(res)):
		if res[i]==float('inf'):res[i]=-1
	print(*res[2:])

main()",cd+nw<dis[nn],"cd+nw<dis[nn]:
					dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	dis=[float('inf')]*(n+1)
	dis[1]=0
	h=[]
	for i in range(1,n+1):
		if dis[i]!=float('inf'):
			dis[i]=float('inf')
			h.append((dis[i],i))
	heapify(h)
	while h:
		cd,cn=heappop(h)
		if dis[cn]==cd:
			for nn,nw in gb[cn]:
				if cd+nw<dis[nn]:
					di"
"import sys
input=sys.stdin.readline

from heapq import heappush,heappop,heapify 
from collections import defaultdict
 
def main():
	n,m=map(int,input().split())
	gf=defaultdict(list)
	gb=defaultdict(list)
	for _ in range(m):
		u,v,w=map(int,input().split())
		gf[u].append((v,w))
		gb[v].append((u,w))
	dis=[float('inf')]*(n+1)
	dis[1]=0
	h=[]
	heapify(h)
	heappush(h,(0,1))
	while h:
		cd,cn=heappop(h)
		if dis[cn]==cd:
			for nn,nw in gf[cn]:
				if cd+nw<dis[nn]:
					dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	res=[float('inf')]*(n+1)
	res[1]=0
	h=[]
	for i in range(1,n+1):
		if dis[i]!=float('inf'):
			res[i]=dis[i]
			h.append((dis[i],i))
	heapify(h)
	while h:
		cd,cn=heappop(h)
		if res[cn]==cd:
			for nn,nw in gb[cn]:
				if {{completion}}:
					res[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	for i in range(1,len(res)):
		if res[i]==float('inf'):res[i]=-1
	print(*res[2:])

main()",cd+nw<res[nn],"cd+nw<res[nn]:
					res[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	for i in range(1,len(res)):
		if res[i]==float('inf'):res[i]=-1
	print(*res[2:])

main()
'''
import sys
input=sys.stdin.readline

from heapq import heappush,heappop,heapify 
from collections import defaultdict
 
def main():
	n,m=map(int,input().split())
	gf=defaultdict(list)
	gb=defaultdict(list)
	for _ in range(m):
		u,v,w=map(int,input().split())
		gf[u"
"def ev(x):
    k = 0
    while x%2 == 0:
        x//=2
        k+=1
    return x+k
p,q = [int(i) for i in input().split()]
t,s,sum = 1,1,0
while True:
    ss = s + (t+1)//2
    if ss > p:
        m = (p-s+1)
        sum += m*t
        break
    sum += t*((t+1)//2)
    s = ss
    t += 1
mx = t-2*m+1
print(sum)
mul,ded,turn = 0,0,0
t -= 0 if mx==turn else 1
for i in range(q):
    x = int(input())
    if x == 1:
        print(1)
        continue
    while True:
        if {{completion}}:
            print(ev(x-ded)+mul)
            break
        ded += (t+1)//2
        turn+=1
        mul += 1
        t -= 0 if mx==turn else 1",x-ded <= t,x>ded
"def ev(x):
    k = 0
    while x%2 == 0:
        x//=2
        k+=1
    return x+k
p,q = [int(i) for i in input().split()]
t = 1
s = 1
sum = 0
while True:
    ss = s + (t+1)//2
    if ss > p:
        m = (p-s+1)
        sum += m*t
        break
    sum += t*((t+1)//2)
    s = ss
    t += 1
mx = t-2*m+1
print(sum)
tt = t
mul = 0
ded = 0
turn = 0
tt -= 0 if mx==turn else 1
for i in range(q):
    x = int(input())
    if x == 1:
        print(1)
        continue
    while True:
        #print(""A:"",turn,tt,x-ded)
        if {{completion}}:
            print(ev(x-ded)+mul)
            break
        #print(""WUT"")
        if tt < 0:
            print(ev(x-ded)+mul)
            break
        ded += (tt+1)//2
        turn+=1
        mul += 1
        tt -= 0 if mx==turn else 1",x-ded <= tt,tt
"import sys

#sys.stdin = open(""C:\\Users\\asawe\\Documents\\input.txt"",""r"")

mx = 3 * (10 ** 5) + 10
mod = 998244353

fact = [1]
inv_fact = [1]


def modpow(a, b, m):
    res = 1
    x = a
    y = b

    while (y > 0):
        if {{completion}}:
            res = (res * x) % m
        y = y >> 1
        x = ((x % m) * (x % m)) % m

    return (res % m + m) % m

def inverse(a, m):
    u,v = 0,1
    while a != 0:
        t = m // a
        m -= t * a
        a, m = m, a
        u -= t * v
        u, v = v, u
    return u

for i in range(1, mx):
    fact.append((fact[-1] * i) % mod)
    inv_fact.append(inverse(fact[-1], mod)%mod)

def P(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[n - k]) % mod

def C(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[k] * inv_fact[n - k]) % mod

n,m = map(int,sys.stdin.readline().split())
a = list(map(int,sys.stdin.readline().split()))
s = sum(a)

psum = [0] * n
for i in range(n-1):
    psum[i] = psum[i-1] + a[i]
di = {}
for i in psum:
    di[i] = 0
count = 0
for i in psum:
    if i + s/2 in di:
        count+=1
v = n - 2 * count
ans = 0
for i in range(count+1):
    ans = (ans + C(count,i) * P(m,count-i) * modpow(m-count+i,v,mod) * modpow(P(m-count+i,2),i,mod)) % mod
print(ans)
",(y & 1),"y & 1 == 1:
            res = (res * x) % m
        x = x * (x % m) 
        y >>= 1
        if y & 1 == 1:
            res = (res * x) % m
        x = x * (x % m) 
        y >>= 1
        if y & 1 == 1:
            res = (res * x) % m
        x = x * (x % m) 
        y >>= 1
        if y & 1 == 1:
            res = (res * x) % m
        x = x * (x % m) 
        y >>= 1
        if y & 1 == 1:
            res = (res * x) % m
        x = x * (x % m) 
"
"import sys

#sys.stdin = open(""C:\\Users\\asawe\\Documents\\input.txt"",""r"")

mx = 3 * (10 ** 5) + 10
mod = 998244353

fact = [1]
inv_fact = [1]


def modpow(a, b, m):
    res = 1
    x = a
    y = b

    while {{completion}}:
        if (y & 1):
            res = (res * x) % m
        y = y >> 1
        x = ((x % m) * (x % m)) % m

    return (res % m + m) % m

def inverse(a, m):
    u,v = 0,1
    while a != 0:
        t = m // a
        m -= t * a
        a, m = m, a
        u -= t * v
        u, v = v, u
    return u

for i in range(1, mx):
    fact.append((fact[-1] * i) % mod)
    inv_fact.append(inverse(fact[-1], mod)%mod)

def P(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[n - k]) % mod

def C(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[k] * inv_fact[n - k]) % mod

n,m = map(int,sys.stdin.readline().split())
a = list(map(int,sys.stdin.readline().split()))
s = sum(a)

psum = [0] * n
for i in range(n-1):
    psum[i] = psum[i-1] + a[i]
di = {}
for i in psum:
    di[i] = 0
count = 0
for i in psum:
    if i + s/2 in di:
        count+=1
v = n - 2 * count
ans = 0
for i in range(count+1):
    ans = (ans + C(count,i) * P(m,count-i) * modpow(m-count+i,v,mod) * modpow(P(m-count+i,2),i,mod)) % mod
print(ans)
",(y > 0),"y != 0:
        if y & 1:
            res = (res * x) % m
        y = y >> 1
        x = ((x % m) * (x % m)) % m

    return (res % m + m) % m

def modpow2(x, y, m):
    res = 1
    x = y
    y = x

    while y != 0:
        if y & 1:
            res = (res * x) % m
        y = y >> 1
        x = ((x % m) * (x % m)) % m

    return (res % m + m) % m

def modpow3(x, y, m):
    res = 1
    x = y
    y = x

    while y != 0:
        if y & 1:
            res = (re"
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if {{completion}}:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      anss+=ans
print(anss%pmod)",n%2,"n&1:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
def bpow(a,n,p):
    res = 1
    while n:
        if n&1:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
def bpow(a,n,p):
    res = 1
    while n:
        if n&1:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
def bpow(a,"
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if {{completion}}:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      ans%=pmod
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      ans%=pmod
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      ans%=pmod
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      ans%=pmod
      anss+=ans
print(anss%pmod)",n%2,"n&1:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
def bpow2(a,n,p):
    res = 1
    while n:
        if n&1:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
def bpow3(a,n,p):
    res = 1
    while n:
        if n&1:
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
def b"
"def solve(a, b):
    inf = 2 * 10 ** 6
    d, n = inf, len(b)

    for i in range(n):
        if {{completion}}:
            d = min(d, a[i] - b[i])

    # b[i] > a[i]
    if d < 0:
        print(""NO"")
        return
    # All elements of b are 0s
    if d == inf:
        print(""YES"")
        return

    for i in range(n):
        if a[i] - b[i] > d:
            print(""NO"")
            return
        if b[i] > 0 and a[i] - b[i] < d:
            print(""NO"")
            return
    # all a[i] - b[i] == d
    print(""YES"")

def main():
    from sys import stdin
    from itertools import islice

    tkns = map(int, stdin.read().split())
    t = next(tkns)

    for T in range(t):
        n = next(tkns)
        a, b = list(islice(tkns, n)), list(islice(tkns, n))

        solve(a, b)

main()
",b[i] > 0,"a[i] < b[i]:
            d = min(d,a[i] - b[i])
        elif a[i] > b[i]:
            d = min(d, b[i] - a[i])
        else:
            d = min(d, a[i] - b[i])

    for i in range(n):
        if a[i] < b[i]:
            d = min(d,a[i] - b[i])
        elif a[i] > b[i]:
            d = min(d, b[i] - a[i])
        else:
            d = min(d, a[i] - b[i])

    for i in range(n):
        if a[i] < b[i]:
            d = min(d,a[i] - b[i])
        elif a[i] > b[i]:
            d = min(d, b[i] - a[i])
        else:
"
"def solve(a, b):
    inf = 2 * 10 ** 6
    d, n = inf, len(b)

    for i in range(n):
        if b[i] > 0:
            d = min(d, a[i] - b[i])

    # b[i] > a[i]
    if d < 0:
        print(""NO"")
        return
    # All elements of b are 0s
    if d == inf:
        print(""YES"")
        return

    for i in range(n):
        if {{completion}}:
            print(""NO"")
            return
        if b[i] > 0 and a[i] - b[i] < d:
            print(""NO"")
            return
    # all a[i] - b[i] == d
    print(""YES"")

def main():
    from sys import stdin
    from itertools import islice

    tkns = map(int, stdin.read().split())
    t = next(tkns)

    for T in range(t):
        n = next(tkns)
        a, b = list(islice(tkns, n)), list(islice(tkns, n))

        solve(a, b)

main()
",a[i] - b[i] > d,"b[i] == 0 and a[i] > 0:
            d = min(d, a[i] - b[i])
        if b[i] < 0 and a[i] > b[i]:
            d = min(d, a[i] - b[i])
        if b[i] < 0 and a[i] < b[i]:
            d = min(d, a[i] - b[i])
        if b[i] > 0 and a[i] < b[i]:
            d = min(d, a[i] - b[i])
        if b[i] > 0 and a[i] > b[i]:
            d = min(d, a[i] - b[i])
        if b[i] < 0 and a[i] < b[i]:
            d = min(d, a[i] - b[i])
        if b[i] < 0 and a[i] > b[i]:
            d = "
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  a = list(map(int, inp(n)))
  s = list(inp1())
  d = {}
  ok = True
  for i in range(n):
    if a[i] not in d:
      d[a[i]] = s[i]
    elif {{completion}}:
      ok = not ok
      break
  print(""YES"" if ok else ""NO"")

",d[a[i]] != s[i],"d[a[i]] != s[i]:
      ok = False
      break
    else:
      d[a[i]] = s[i]
  if ok"
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  c = inp1()
  s = inp1()
  ret = 0
  l = []
  last = ''
  for i in range(n):
    cur = s[i]
    if cur == last:
      continue
    if cur == c:
      last = cur
      l.append((c, i))
    elif {{completion}}:
      last = cur
      l.append(('g', i))
  first_g = -1
  for i in range(len(l)):
    if l[i][0] == 'g' and first_g != -1:
      continue
    elif l[i][0] == 'g' and first_g == -1:
      first_g = l[i][1]
    elif i == len(l) - 1:
      ret = max(ret, n - l[i][1] + first_g)
    else:
      ret = max(ret, l[i + 1][1] - l[i][1])
  print(ret)
",cur == 'g',"cur == 'g':
      last = cur
      l.append((c, i))
    elif i == n - 1:
      ret = max(ret, n - l[i][1] + l[i][0])
    else:
      ret = max(ret, l[i + 1][0] - l[i][0])
  print(ret)
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
"
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  c = inp1()
  s = inp1()
  ret = 0
  l = []
  last = ''
  for i in range(n):
    cur = s[i]
    if cur == last:
      continue
    if cur == c:
      last = cur
      l.append((c, i))
    elif cur == 'g':
      last = cur
      l.append(('g', i))
  first_g = -1
  for i in range(len(l)):
    if l[i][0] == 'g' and first_g != -1:
      continue
    elif {{completion}}:
      first_g = l[i][1]
    elif i == len(l) - 1:
      ret = max(ret, n - l[i][1] + first_g)
    else:
      ret = max(ret, l[i + 1][1] - l[i][1])
  print(ret)
",l[i][0] == 'g' and first_g == -1,"i == 0 and l[i][0] == 'g':
      first_g = l[i][1]
    elif i == len(l) - 1 and l[i][0] == 'g':
      ret = max(ret, n - l[i][1] + first_g)
    elif l[i][0] == 'g' and l[i + 1][0] == 'g':
      ret = max(ret, l[i][1] - l[i + 1][1])
    elif l[i][0] == 'g' and l[i + 1][0] != 'g':
      ret = max(ret, l[i][1] - l[i + 1][1])
    elif l[i][0] != 'g' and l[i + 1][0] == 'g':
      ret = max(ret, l[i][1] - l[i + 1][1])
    elif l[i][0] != 'g' and l[i + 1][0] != 'g':
      ret = max(ret, l"
"from itertools import islice
from sys import stdin

data = iter([int(x) for x in stdin.read().split()[1:]])

res = []
while True:
    try:
        n = next(data)
    except StopIteration:
        break
    q = next(data)
    counts = [0, 0]
    sums = [0, 0]
    for v in islice(data, n):
        counts[v % 2] += 1
        sums[v % 2] += v
    for _ in range(q):
        mod = next(data)
        x = next(data)
        to_add = counts[mod] * x
        if {{completion}}:
            counts[1 - mod] += counts[mod]
            sums[1 - mod] += sums[mod] + to_add
            counts[mod] = sums[mod] = 0
        else:
            sums[mod] += to_add
        res.append(sum(sums))

print('\n'.join(str(x) for x in res))",x % 2,mod > mod
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  q = inp1()
  a = inp(n)
  tx = [inp(2) for _ in range(q)]
  odd = 0
  even = 0
  for i in a:
    if i % 2 == 0:
      even +=1
    else:
      odd +=1
  ret = sum(a)
  for i in tx:
    if i[0] == 0:
      ret += even * i[1]
      if i[1] % 2 != 0:
        odd = n
        even = 0
    else:
      ret += odd * i[1]
      if {{completion}}:
        even = n
        odd = 0
    print(ret)
",i[1] % 2 != 0,"i[1] % 2 != 0:
        even = n
        odd = 0
  print(ret)
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  "
"for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    prefix = suffix = 0
    for i in range(n - 1):
        if {{completion}}:
            prefix += d
        else:
            suffix -= d
    print(abs(a[0] - prefix) + prefix + suffix)
",(d := a[i] - a[i + 1]) > 0,"a[i] < a[i + 1]:
            prefix += a[i + 1]
        else:
            suffix -= a[i + 1]
    for _ in range(n - 1):
        prefix += a[0]
    for _ in range(n - 1):
        suffix -= a[n-1]
    for _ in range(n - 1):
        prefix += a[0]
    for _ in range(n - 1):
        suffix -= a[n-1]
    for _ in range(n - 1):
        prefix += a[0]
    for _ in range(n - 1):
        suffix -= a[n-1]
    for _ in range(n - 1):
        prefix += a[0]
    for _ in range(n - 1):
        suffix -= a[n-1]
    for _ in range(n - 1):
        prefix += a[0]
    for _ in range(n - 1):"
"for line in [*open(0)][2::2]:
  tot = 0
  list = line.split(' ')
  list2 = [0] + list
  minv = int(list[0])
  for val in range(len(list)-1):
    diff = int(list2[val+1]) - int(list[val+1])
    if {{completion}}:
      tot += diff
      minv -= diff
  print(tot-minv+abs(minv)+int(list[len(list)-1]))",(diff >= 0),"diff > minv:
      minv = diff
    if diff < minv:
      minv = diff
    if diff == minv:
      minv += diff
      tot += diff
      minv -= diff
  print(tot-minv+abs(minv)+int(list[len(list)-1]))
<|/ a dscore=0 |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
I added the explanation to the answer.
<|/ c |>
<| a tags=python |>
<code>
for line in [*open(0)]["
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();d=[a[0]]
    for i in range(1,n):d.append(a[i]-a[i-1])
    for i in range(1,n):
        if {{completion}}:d[0]+=d[i]
    print(sum(abs(i) for i in d))",d[i]<=0,"d[i]<0:d[i]=d[i]+mod1
    for i in range(1,n):
        if d[i]<0:d[i]=d[i]-mod1
    for i in range(1,n):
        if d[i]<0:d[i]=d[i]+mod2
    for i in range(1,n):
        if d[i]<0:d[i]=d[i]-mod2
    for i in range(1,n):
        if d[i]<0:d[i]=d[i]+mod2
    for i in range(1,n):
        if d[i]<0:d[i]=d[i]-mod2
    for i in range(1,n):
        if d[i]<0:d[i]=d[i]-mod2
    for i in range(1,n):
        if d[i]"
"for _ in range(int(input())):
    input()
    a = [int(x) for x in input().split()]
    prefix_value = a[0]
    suffix_value = 0
    steps = 0
    for x, y in zip(a, a[1:]):
        if x > y:
            steps += x - y
            prefix_value = y - suffix_value
        elif {{completion}}:
            steps += y - x
            suffix_value += y - x
    print(steps + abs(prefix_value))
",y > x,"x < y:
            steps += y - x
            suffix_value += y - x
    print(steps + abs(prefix_value))
<|/ a tags=python,algorithm |>
<| c |>
Thank you so much! It was really helpful.
<|/ c |>
<| a dscore=0 |>
<code>
for _ in range(int(input())):
    input()
    a = [int(x) for x in input().split()]
    prefix_value = a[0]
    suffix_value = 0
    steps = 0
    for x, y in zip(a, a[1:]):
        if x > y:
            steps += x - y
            prefix_value = y - suffix_value
        elif "
"from sys import stdin
a = int(stdin.readline())

for t in range(0,a):
    b = int(stdin.readline())
    c = stdin.readline().split()
    count = 0
    current = int(c[0])
    for u in range(0,b-1):
        if int(c[u+1])>int(c[u]):
            count+=(int(c[u+1])-int(c[u]))

        elif {{completion}}:
            count+=(int(c[u]) - int(c[u+1]))
            current = current - (int(c[u]) - int(c[u+1]))
        


    print(abs(current)+count)",int(c[u+1]) < int(c[u]),"int(c[u+1])<int(c[u]):
            count+=(int(c[u])-int(c[u+1]))
            current = current - (int(c[u])-int(c[u+1]))
        else:
            count+=(int(c[u])-int(c[u+1]))
            current = current - (int(c[u])-int(c[u+1]))
    
    for u in range(0,b-1):
        if int(c[u+1])>int(c[u]):
            count+=(int(c[u+1])-int(c[u]))

        elif int(c[u+1])<int(c[u]):
            count+=(int(c[u"
"t = int(input())
 
for _ in range(t):
	n = int(input())
	A = list(map(int,input().split()))
	res,r = 0,0
	for i in range(n-1):
		x = A[i+1]-A[i]
		if {{completion}}:  
			r+=x
		res+=abs(x)
	res+=abs(r-A[n-1])
	print(res) ",x>0,"x>0:
			r+=x
		res+=abs(x)
	res+=abs(r-A[n-1])
	print(res) 
<|/ file filename=LittleLeon.py ext=.py |>
#Python program to find minimum number of actions to dry and water the soil.
t = int(input())
 
for _ in range(t):
	n = int(input())
	A = list(map(int,input().split()))
	res,r = 0,0
	for i in range(n-1):
		x = A[i+1]-A[i]
		if x>0:
			r+=x
		res+=abs(x)
	res+=abs(r-A[n"
"def solve():
    n = int(input())
    a = [int(i) for i in input().split()]
    dl, dr = 0, 0
    for i in range(1, n):
        if {{completion}}:
            dr += (a[i]-dr)-(a[0]-dl)
        else:
            dl += (a[0]-dl)-(a[i]-dr)
    return dl+dr+abs(a[0]-dl)

for _ in range(int(input())):
    print(solve())",a[i]-dr >= a[0]-dl,"i%2 == 0:
            dr += (a[i]-dr)-(a[0]-dl)
        else:
            dl += (a[0]-dl)-(a[i]-dr)
    return dl+dr+abs(a[0]-dl)

for _ in range(int(input())):
    print(solve())

'''
def solve():
    n = int(input())
    a = [int(i) for i in input().split()]
    dl, dr = 0, 0
    for i in range(1, n):
        if i%2 == 0:
            dr += (a[i]-dr)-(a[0]-dl)
        else:
            dl += (a[0]-dl)-(a[i]-dr)"
"v = int(input())

while v > 0:
    n = int(input())
    arr = input().split()
    ori = int(arr[0])
    temp = 0
    ans = 0
    x = 1
    while x < n:
        nex = int(arr[x])
        ans += abs(nex - ori)
        if {{completion}}:
            temp += abs(nex - ori)
        ori = nex
        x += 1
    ans += abs(int(arr[0]) - temp)
    print(ans)
    v -= 1",nex - ori < 0,nex > ori
"import sys

T = int(sys.stdin.readline())
for t in range(T):
    n = int(sys.stdin.readline())
    a = [int(x) for x in sys.stdin.readline().strip().split(' ')]
    l, r = 0, 0
    for i in range(len(a) - 1):
        x, y = a[i], a[i+1]
        if x > y:
            l += x - y
        elif {{completion}}:
            r += y - x
    print(abs(a[-1]-r)+l+r)

# 4
# 3
# -2 -2 -2
# 3
# 10 4 7
# 4
# 4 -4 4 -4
# 5
# 1 -2 3 -4 5
",x < y,"x < y:
            r += y - x
    print(abs(a[-1]-l+r))

T = int(sys.stdin.readline())
for t in range(T):
    n = int(sys.stdin.readline())
    a = [int(x) for x in sys.stdin.readline().strip().split(' ')]
    l, r = 0, 0
    for i in range(len(a) - 1):
        x, y = a[i], a[i+1]
        if x > y:
            l += x - y
        elif x < y:
            r += y - x
    print(abs(a[-1]-l+r))

T = int(sys.stdin.readline())
for t in range(T):
    n = int(sys.stdin.readline())
    a = [int(x) for x in sys.stdin.readline"
"
# 1 0 0 1 0 0
# 0 1 0 0 0 1
# 1 1 1 2 2 2
# 0 1 1 1 1 2
# swap two same number is useless
# each time we swap i and i+1, only prefix of i is changed, either increased by 1 or decreased by 1

# same argument as of inversion, each time inversion can only increased by 1 or decreased by 1
# so in one step we can always move a prefix closer to the expected by 1
# Let s = sum(diff(prefix[a] - prefix[a'])) , we can always achive this in minimum time

# prefix + (0, 1) | (1,0)
# we would like to make every prefix of a is same as a' (with a' is fixed)

# when we swap pair (0,1) in two row, say we are at column j, then the prefix of one row decreased by 1 and the other is increased by 1 form the column j

# 1 1 1 0 0 0
# 0 0 0 1 1 1
# i

# Now let's construct array diff of two row
# Reprahsed of the problem
# In one step, we can either
# 1. increase / decrease any diff by 1
# 2. at a certain column, increase diff of either by 1 and decrease the other by 1  till the last column

# Analysis
# Go from the start since we have increamnt suffix operation
# If both element is same sign ,then add their abs since suffix operation not reduce their diff but also increase the total number of operatons, if on suffix operatons help the rest move closer to the target then we can just apply from the i+1 position to get the same result and take 1 less move
# If there are of different sign
# k = min(abs(row1[i]]), abs(row2[i])) normaly we would take k to make one ddiff move to zeros, but now with suffix opertions, we also move the other closer to 0 by k, so we are have free k more free operations, if this suffix make the rest worst then just apply k reverse suffix operation on i+1 to cancel the efffect so this algorithm always move to a better answer

n = int(input())

a, b, x, y = [list(map(int, input().split())) for _ in range(4)]
s0 = s1 = ans = 0
for m, n, p, q in zip(a, b, x, y):
    s0 += m
    s0 -= p
    s1 += n
    s1 -= q
    while s0 > 0 and s1 < 0:
        ans += 1
        s0 -= 1
        s1 += 1
    while {{completion}}:
        ans += 1
        s0 += 1
        s1 -= 1
    ans += abs(s0) + abs(s1)
print(-1 if s1 or s0 else ans)  # finally but prefix must be 0
",s0 < 0 and s1 > 0,"s0 < 0 and s1 > 0:
        ans += 1
        s0 += 1
        s1 -= 1
    while s0 < 0 and s1 < 0:
        ans += 1
        s0 += 1
        s1 += 1
    while s0 > 0 and s1 > 0:
        ans += 1
        s0 -= 1
        s1 -= 1
    while s0 > 0 and s1 < 0:
        ans += 1
        s0 -= 1
        s1 += 1
    while s0 < 0 and s1 > 0:
        ans += 1
        s0 += 1
        s1 -= 1
    while s0 < 0 and s1 < 0:
        ans += 1
        s0 += 1
        s1 += 1
    while s0 > 0 and s1 "
"n=int(input())
s=input()[::2],input()[::2]
t=input()[::2],input()[::2]

d=[0,0]
total=0
for y in range(n):
    for x in 0,1:
        d[x]+=(s[x][y]==""1"")-(t[x][y]==""1"")
    if d[0]>0 and d[1]<0:
        total+=1
        d[0]-=1
        d[1]+=1
    elif {{completion}}:
        total+=1
        d[0]+=1
        d[1]-=1
    total+=abs(d[0])+abs(d[1])
print(total if d==[0,0] else -1)",d[0]<0 and d[1]>0,"d[0]<0 and d[1]>0:
        total+=1
        d[0]+=1
        d[1]-=1
    elif d[0]>0 and d[1]>0:
        total+=1
        d[0]-=1
        d[1]+=1
    elif d[0]<0 and d[1]<0:
        total+=1
        d[0]+=1
        d[1]+=1
print(total if d==[0,0] else -1)
<|/ a dscore=0 |>
<| a tags=python,python-3.x |>
<code>
n=int(input())
s=input()[::2],input()[::2]
t=input()[::2],input()[::2]

d=[0,0]
total"
"def solve():
    # Size of the matrices.
    n = int(input())
    # Data matrix (the first two rows correspond to the original matrix
    # and the last two to the target matrix).
    matrix = []

    # Read the input data.
    for _ in range(4):
        matrix.append([int(data) for data in input().split()])

    top = 0  # Difference between the prefixes of the first rows of the matrices.
    bottom = 0  # Difference between the prefixes of the second rows of the matrices.
    total = 0  # Total cost of the operations.

    for i in range(n):
        top += (matrix[0][i] - matrix[2][i])  # Update the first prefix.
        bottom += (matrix[1][i] - matrix[3][i])  # Update the second prefix.

        # If the prefix differences have different signs, swap the exceeding one
        # in the positive row to the negative, spending an operation on it.
        if bottom < 0 and 0 < top:
            top -= 1
            bottom += 1
            total += 1
        elif {{completion}}:
            top += 1
            bottom -= 1
            total += 1

        # Update the total cost with the cost of fixing this prefix, since the last fix.
        total += abs(top) + abs(bottom)

    # The condition top + bottom == 0 is equivalent to top == 0 && bottom == 0, because top and
    # bottom always have the same sign or at least one is zero.
    # Therefore, if top + bottom != 0, then top != 0 or bottom != 0.
    # This mean the matrices have different amount of one, so the problem is unsolvable.
    if top + bottom != 0:
        return -1

    # Otherwise, the problem has a solution, and it's the total calculated cost.
    return total


print(solve())
",top < 0 and 0 < bottom,"bottom > 0 and 0 < top:
            top += 1
            bottom -= 1
            total += 1
        elif bottom < 0 and 0 < bottom:
            top -= 1
            bottom += 1
            total += 1
        elif bottom > 0 and 0 < bottom"
"import math

lines = [*open(0)]
sizes = lines[1].split(' ')

tot, running = 0, 0
minval = 0

for lock in sizes:
    tot += int(lock)
    running += 1
    minval = max(minval, tot/running)

for mintime in lines[3:]:
  if {{completion}}:
    print(""-1"")
  else:
    print(math.ceil(tot/int(mintime)))",(int(mintime) < minval),int(mintime) < minval
"I=input;n=int(I());p=m=0
for {{completion}}:
  p+=int(v);m=max(m,(p+i)//(i+1))
for _ in [0]*int(I()):
  t=int(I());print([-1,(p+t-1)//t][t>=m])","i,v in enumerate(I().split())","_ in [0]*int(I()):
  v=int(I());i+=1;if v>p+i:
    p+=int(v);m=max(m,(p+i)//(i+1))
for _ in [0]*int(I()):
  t=int(I());print([-1,(p+t-1)//t][t>=m])
<|/ q tags=python-3.x,python |>
<| c |>
Please don't post images of code. Post the code as text in the question.
<|/ c |>
<| c |>
Please don't post images of code. Post the code as text in the question.
<|/ c |>
<| c "
"I=input;n=int(I());p=m=0
for i,v in enumerate(I().split()):
  p+=int(v);m=max(m,(p+i)//(i+1))
for {{completion}}:
  t=int(I());print([-1,(p+t-1)//t][t>=m])",_ in [0]*int(I()),"q in I().split():
  t=int(I());print([-1,(p+t-1)//t][t>=m])
<|/ a dscore=0 |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| a dscore=0 |>
<code>
I=input;n=int(I());p=m=0
"
"import math as ma

r = range
R = lambda: int(input())
num_of_locks = R()
vols_arr = list(map(int, input().split("" "")))
sum_of_vols = 0
avg_vols = []
for _ in r(len(vols_arr)): sum_of_vols += vols_arr[_]; avg_vols += ma.ceil(sum_of_vols/(_ + 1)),
max_avg_vols = max(avg_vols)
for _ in r(R()):
    liters = R(); answer = ma.ceil(sum_of_vols/liters)
    if {{completion}}:
        answer = -1
    print(answer)",max_avg_vols > liters,"answer == max_avg_vols:
        answer = 1
    elif answer == max_avg_vols - 1:
        answer = 2
    elif answer == max_avg_vols - 2:
        answer = 3
    elif answer == max_avg_vols - 3:
        answer = 4
    elif answer == max_avg_vols - 4:
        answer = 5
    elif answer == max_avg_vols - 5:
        answer = 6
    elif answer == max_avg_vols - 6:
        answer = 7
    elif answer == max_avg_vols - 7:
        answer = 8
    elif answer == max_avg_vols - 8:
        answer = 9
    elif answer == max_avg_vols - 9:
        answer = 10
"
"n = int(input())
a = list(map(int, input().split()))
maxi = tot = 0
for i, j in enumerate(a, 1):
    tot += j
    maxi = max(maxi, (tot+i-1) // i)

q = int(input())
for _ in range(q):
    k = int(input())
    if {{completion}}:
        print(-1)
    else:
        # open x pipe
        # time = ceil(sum / x) => x increased => time decrease
        # => sum <= x * time -> x >= sum / time -> x = ceil(sum / time) (looking for x min)
        print((tot + k - 1) // k)
",k < maxi,"k > maxi:
        print(-1)
    else:
        tot = 0
        for i in range(k):
            tot += a[i]
            if tot > maxi:
                tot -= maxi
                maxi = max(maxi, (tot + i - 1) // i)
        print(maxi)
</code>
<|/ a tags=algorithm,python,math |>
<| a tags=algorithm,python,math |>
<code>
n = int(input())
a = list(map(int, input().split()))
maxi = tot = 0
for i, j in enumerate(a, 1):
    tot += j
    maxi = max(maxi, (tot+i-1) // i)

q = int(input())
"
"from sys import stdin, stderr


def debug(*args, **kwargs):
    print(*args, file=stderr, **kwargs)


_, volumes, _, *queries = stdin.readlines()
volumes = map(int, volumes.split())
queries = map(int, queries)

s = t_min = 0
for i, v in enumerate(volumes, 1):
    s += v
    div, mod = divmod(s, i)
    t_min = max(t_min, div + (mod != 0))

res = []
for q in map(int, queries):
    if {{completion}}:
        ans = -1
    else:
        div, mod = divmod(s, q)
        ans = div + (mod != 0)
    res.append(ans)

print('\n'.join(str(x) for x in res))
",q < t_min,t_min == q
"import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for {{completion}}:
    m=max((v[i]-1)//(i+1)+1,m)
for _ in range(int(input())):
    t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)
",i in range(n),"_ in range(int(input())):
    q = input()
    t = int(input())
    if q == str(q):
        print(-1)
        break
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for i in range(n):
    m=max((v[i]-1)//(i+1)+1,m)
for {{completion}}:
    t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)
",_ in range(int(input())),"_ in range(q):
    t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)
'''
import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for i in range(n):
    m=max((v[i]-1)//(i+1)+1,m)
for _ in range(q):
    t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)
'''
import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for i in range(n):
    m=max((v[i]-1)//(i+1)+1,m)"
"number = int(input())
V = [int(i) for i in input().split()]
time,total = 0,0
for i in range(number):
    total += V[i]
    time = max(time,(total+i)//(i+1))
    pass
for q in range(int(input())):
    t = int(input())
    if{{completion}}: print(-1)
    else: print((total+t-1)//t)
    pass",(t<time),"((total+t-1)//t < time): print(-1)
    else: print((total+t-1)//t)
    pass
for q in range(int(input())):
    t = int(input())
    if((total+t-1)//t < time): print(-1)
    else: print((total+t-1)//t)
    pass
for q in range(int(input())):
    t = int(input())
    if((total+t-1)//t < time"
"from math import ceil
r = range;i = lambda: int(input());s = lambda: input().split()
for _ in r(1):
    n = i();v = list(map(int,s()))
    dp = [];sum = 0;max = 0
    for _ in r(n):
        sum += v[_];val = ceil(sum/(_+1))
        dp += val, #comma --> tuple element
        if{{completion}}: max = val
    for _ in r(i()): t = i();print(ceil(sum/t)) if(max <= t) else print(-1)",(val > max),"((val > max) and (dp[-1] == dp[-2])):
            max = val
    for _ in r(i()): t = i();print(ceil(sum/t)) if(max <= t) else print(-1)
for _ in r(1):
    n = i();v = list(map(int,s()))
    dp = [];sum = 0;max = 0
    for _ in r(n):
        sum += v[_];val = ceil(sum/(_+1))
        dp += val, #comma --> tuple element
        if((val > max) and (dp[-1] == dp[-2])):
            max = val
    for _ in r(i()): t = i();print(ceil(sum/t)) if(max "
"#from math import ceil, floor, gcd, log
#import heapq as hq
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft

import sys
input = sys.stdin.readline
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#def insr():
#    s = input()
#    return(list(s[:len(s) - 1]))
#def invr():
#    return(map(int,input().split()))
####################################################
#1) inp — For taking integer inputs.
#2) inlt — For taking List inputs.
#3) insr — For taking string inputs. Returns a List of Characters.
#4) invr — For taking space seperated integer variable inputs.
####################################################
def swp(x1,x2):
    tmp=a[x1[0]][x1[1]]
    a[x1[0]][x1[1]]=a[x2[0]][x2[1]]
    a[x2[0]][x2[1]]=tmp
def fnei(xlst):
    tmpl=[xlst]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def fnei2(xlst):
    tmpl=[]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def chkb(x,y):
    if a[x][y]==1:return False
    for i in fnei2([x,y]):
        if a[x][y]>a[i[0]][i[1]]:
            return False
    else:
        return True
#######################
t=1
#t = int(input())
for tc in range(t):
    n,m = map(int, input().split())
#    n=inp()
#    a=inlt()
#    s=insr()
#    occ=dict();
#    for i in range(n):occ[i]=[]
#    for i in range(n):
#        occ[i].append(inlt())
    a=[]
    for i in range(n):
        a.append(inlt())

    b=[]
    for i in range(n):
        for j in range(m):
            if chkb(i,j):b.append([i,j])
    if len(b)==0:print(0);continue
    if len(b)>2:print(2);continue
    cter=0
    bnei=fnei(b[0])
    for j in bnei:
        for i1 in range(n):
            for i2 in range(m):
                i=[i1,i2]
                if i==b[0]:continue
#                print(a,a[i[0]][i[1]],a[j[0]][j[1]])
                swp(i,j)
                flag=1
                for k in fnei(i)+fnei(j):
                    if chkb(k[0],k[1]):flag=0;break
                if len(b)>1:
                    for k2 in range(1,len(b)):
                        if {{completion}}:flag=0;break
                swp(i,j)
#                print(a,i,j)
                if flag:cter+=1;#print('success',i,j)
    if cter==0: # all single move efforts failed
        print(2)
    else:
        print(1,cter)
    
#print(*a2,sep=' ')
#print("" "".join(str(i) for i in a2))
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i] #sum[:ax]=psa[x]
","chkb(b[k2][0],b[k2][1])","chkb(k[0],k[1]) and chkb(k[0],k[2]):flag=0;break
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;#print('success',i,j)
                if flag:cter+=1;"
"#from math import ceil, floor, gcd, log
#import heapq as hq
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft

import sys
input = sys.stdin.readline
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#def insr():
#    s = input()
#    return(list(s[:len(s) - 1]))
#def invr():
#    return(map(int,input().split()))
####################################################
#1) inp — For taking integer inputs.
#2) inlt — For taking List inputs.
#3) insr — For taking string inputs. Returns a List of Characters.
#4) invr — For taking space seperated integer variable inputs.
####################################################
def swp(x1,x2):
    tmp=a[x1[0]][x1[1]]
    a[x1[0]][x1[1]]=a[x2[0]][x2[1]]
    a[x2[0]][x2[1]]=tmp
def fnei(xlst):
    tmpl=[xlst]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def fnei2(xlst):
    tmpl=[]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def chkb(x,y):
    if a[x][y]==1:return False
    for i in fnei2([x,y]):
        if a[x][y]>a[i[0]][i[1]]:
            return False
    else:
        return True
#######################
t=1
#t = int(input())
for tc in range(t):
    n,m = map(int, input().split())
#    n=inp()
#    a=inlt()
#    s=insr()
#    occ=dict();
#    for i in range(n):occ[i]=[]
#    for i in range(n):
#        occ[i].append(inlt())
    a=[]
    for i in range(n):
        a.append(inlt())

    b=[]
    for i in range(n):
        for j in range(m):
            if chkb(i,j):b.append([i,j])
    if len(b)==0:print(0);continue
    if len(b)>2:print(2);continue
    cter=0
    bnei=fnei(b[0])
    for j in bnei:
        for i1 in range(n):
            for i2 in range(m):
                i=[i1,i2]
                if i==b[0]:continue
#                print(a,a[i[0]][i[1]],a[j[0]][j[1]])
                swp(i,j)
                flag=1
                for k in fnei(i)+fnei(j):
                    if {{completion}}:flag=0;break
                if len(b)>1:
                    for k2 in range(1,len(b)):
                        if chkb(b[k2][0],b[k2][1]):flag=0;break
                swp(i,j)
#                print(a,i,j)
                if flag:cter+=1;#print('success',i,j)
    if cter==0: # all single move efforts failed
        print(2)
    else:
        print(1,cter)
    
#print(*a2,sep=' ')
#print("" "".join(str(i) for i in a2))
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i] #sum[:ax]=psa[x]
","chkb(k[0],k[1])","a[k[0]][k[1]]==a[i[0]][i[1]]:flag=0;break
                if len(b)>1:
                    for k2 in range(1,len(b)):
                        if chkb(b[k2][0],b[k2][1]):flag=0;break
                swp(i,j)
#                print(a,i,j)
                if flag:cter+=1;#print('success',i,j)
    if cter==0: #all single move efforts failed
        print(0)
    else:
        print(1,cter)
    
#print(*a,sep=' ')
#print("" "".join(str(i) for i in a))
#prefixsum a=[a1...an] #psa=[0]*(n+1)"
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


from itertools import chain

def near(r, c, itself = False):
    if itself:
        yield (r, c)
    if 0 < r:
        yield (r - 1, c)
    if r + 1 < n:
        yield (r + 1, c)
    if 0 < c:
        yield (r, c - 1)
    if c + 1 < m:
        yield (r, c + 1)
#    R = []
#    if itself:
#        R.append((r, c))
#    if 0 < r:
#        R.append((r - 1, c))
#    if r + 1 < n:
#        R.append((r + 1, c))
#    if 0 < c:
#        R.append((r, c - 1))
#    if c + 1 < m:
#        R.append((r, c + 1))

#    return R

def ok(x, y):
    v = A[x][y]
    if v == 1:
        return True

    return any(A[r][c] < v for r, c in near(x, y))


def swapAndCheck(r1, c1, r2, c2):
    if (r1 , c1) != (r2, c2):
        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        flag = ok(r1, c1) and ok(r2, c2) and all(ok(r, c) for r, c in chain(near(r1, c1), near(r2, c2), H[1:]))

        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        return flag

    return False


n, m = map(int, input().split())

A = []
for _ in range(n):
    A.append(list(map(int, input().split())))


H = list({(r, c) for r in range(n) for c in range(m) if not ok(r, c)})

if not H:
    print(""0"")
elif len(H) > 2:
    print(""2"")
else:
    r1, c1 = H[0]
    w = 0

    for r, c in near(r1, c1, True):
        for x in range(n):
            for y in range(m):
                if {{completion}}:
                    w += 1
        
    if w != 0:
        print(""1 {}"".format(w))
    else:
        print(""2"")

","(r1 != x or c1 != y) and swapAndCheck(r, c, x, y)","A[x][y] == A[r][c]:
                    w += 1
                    break
            if w != 0:
                break
        if w != 0:
            break
    else:
        print(""1 {}"".format(w))
        
    r2, c2 = H[-1]
    w = 0

    for r, c in near(r2, c2, True):
        for x in range(n):
            for y in range(m):
                if A[x][y] == A[r][c]:
                    w += 1
                    break
            if w != 0:
                break
        if w != 0:
            break
    else:
        print(""1 {}"".format(w))
        
    for r in range(n):
        for c in range(m):
            if A[r][c] == A[r1][c"
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


from itertools import chain

def near(r, c, itself = False):
    if itself:
        yield (r, c)
    if 0 < r:
        yield (r - 1, c)
    if r + 1 < n:
        yield (r + 1, c)
    if 0 < c:
        yield (r, c - 1)
    if c + 1 < m:
        yield (r, c + 1)
#    R = []
#    if itself:
#        R.append((r, c))
#    if 0 < r:
#        R.append((r - 1, c))
#    if r + 1 < n:
#        R.append((r + 1, c))
#    if 0 < c:
#        R.append((r, c - 1))
#    if c + 1 < m:
#        R.append((r, c + 1))

#    return R

def ok(x, y):
    v = A[x][y]
    if v == 1:
        return True

    return any(A[r][c] < v for r, c in near(x, y))


def swapAndCheck(r1, c1, r2, c2):
    if (r1 , c1) != (r2, c2):
        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        flag = ok(r1, c1) and ok(r2, c2) and all(ok(r, c) for r, c in chain(near(r1, c1), near(r2, c2), H[1:]))

        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        return flag

    return False


n, m = map(int, input().split())

A = []
for _ in range(n):
    A.append(list(map(int, input().split())))


H = list({(r, c) for r in range(n) for c in range(m) if not ok(r, c)})

if not H:
    print(""0"")
elif len(H) > 2:
    print(""2"")
else:
    r1, c1 = H[0]
    w = 0

    for r, c in near(r1, c1, True):
        for x in range(n):
            for {{completion}}:
                if (r1 != x or c1 != y) and swapAndCheck(r, c, x, y):
                    w += 1
        
    if w != 0:
        print(""1 {}"".format(w))
    else:
        print(""2"")

",y in range(m),"y in range(m):
                if A[x][y] == r and A[x][y] == c:
                    continue
                elif A[x][y] == r + 1 and A[x][y] == c + 1:
                    continue
                elif A[x][y] == r - 1 and A[x][y] == c - 1:
                    continue
                elif A[x][y] == r + 1 and A[x][y] == c + 1:
                    continue
                elif A[x][y] == r - 1 and A[x][y] == c - 1:
                    continue
                elif A[x][y] == r + 1 and A[x][y] == c + 1:
                    continue
                elif A[x][y] == r - 1 and A[x]["
"import os
import sys
from io import BytesIO, IOBase

#_str = str
#str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n, m = list(map(int, input().strip().split(' ')))
    g = [list(map(int, input().strip().split(' '))) for _ in range(n)]
    bfs = set()
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    def check(x, y):
        if g[x][y] == 1:
            return True
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and g[x][y] > g[nx][ny]:
                return True
        return False

    def check5(x, y):
        if not check(x, y):
            return False
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and not check(nx, ny):
                return False
        return True

    bad = list()
    for x in range(n):
        for y in range(m):
            if g[x][y] == 1:
                continue
            if not check(x, y):
                bad.append([x, y])
    if not bad:
        print(0)
    elif len(bad) > 5:
        print(2)
    else:
        candidate = [bad[0]]
        for i in range(4):
            nx, ny = bad[0][0] + dx[i], bad[0][1] + dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                candidate.append([nx, ny])
        res = 0
        for cx, cy in candidate:
            for x in range(n):
                for y in range(m):
                    if x == bad[0][0] and y == bad[0][1]:
                        continue
                    if cx == x and cy == y:
                        continue
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
                    flag = True
                    for bx, by in bad:
                        if {{completion}}:
                            flag = False
                            break
                    if flag and check5(x, y) and check5(cx, cy):
                        res += 1
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
        if res == 0:
            print(2)
        else:
            print(1, res)


    return

main()","not check(bx, by)",bx == cx and by == cy
"import os
import sys
from io import BytesIO, IOBase

#_str = str
#str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n, m = list(map(int, input().strip().split(' ')))
    g = [list(map(int, input().strip().split(' '))) for _ in range(n)]
    bfs = set()
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    def check(x, y):
        if g[x][y] == 1:
            return True
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and g[x][y] > g[nx][ny]:
                return True
        return False

    def check5(x, y):
        if not check(x, y):
            return False
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and not check(nx, ny):
                return False
        return True

    bad = list()
    for x in range(n):
        for y in range(m):
            if g[x][y] == 1:
                continue
            if not check(x, y):
                bad.append([x, y])
    if not bad:
        print(0)
    elif len(bad) > 5:
        print(2)
    else:
        candidate = [bad[0]]
        for i in range(4):
            nx, ny = bad[0][0] + dx[i], bad[0][1] + dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                candidate.append([nx, ny])
        res = 0
        for cx, cy in candidate:
            for x in range(n):
                for y in range(m):
                    if x == bad[0][0] and y == bad[0][1]:
                        continue
                    if cx == x and cy == y:
                        continue
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
                    flag = True
                    for {{completion}}:
                        if not check(bx, by):
                            flag = False
                            break
                    if flag and check5(x, y) and check5(cx, cy):
                        res += 1
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
        if res == 0:
            print(2)
        else:
            print(1, res)


    return

main()","bx, by in bad","bx, by in bad"
"from collections import Counter
import heapq
for _ in range(int(input())):
    _ = input()
    l = input().split()
    cnt = Counter(l)
    x = list(cnt.values())
    x.append(1)
    
    
    hp = []
    x.sort()
    for i, n in enumerate(x):
        if {{completion}}:
            heapq.heappush(hp, -(n-i-1))
    
    cnt = 0
    while hp and cnt + hp[0] < 0:
        n = heapq.heappop(hp)
        heapq.heappush(hp, n+1)
        cnt += 1
    print(len(x)+cnt)",n-i-1 > 0,"n > 0:
            heapq.heappush(hp, -(n-i-1))
    
    cnt = 0
    while hp and cnt + hp[0] < 0:
        n = heapq.heappop(hp)
        heapq.heappush(hp, n+1)
        cnt += 1
    print(len(x)+cnt)
<|/ file filename=tree.py |>"
"t = int(input())

for i in range(t):
    n = int(input())
    p = [int(value) for value in input().split()]
    
    tree = [0] * n
	
    for i in range(len(p)):
	    tree[p[i] - 1] += 1
	    
    tree = sorted(tree)
    resposta = 0
    r = n
	
    while resposta <= r:
        s = 0
        c = 1
        m = (resposta + r) // 2
        neg1 = -1
        
        for i in range(n + neg1, neg1, neg1):
            if {{completion}}:
                break
            
            aux = tree[i] + s - m
            c += max(0, aux)
            s += 1
        
        if m - s >= c:
            r = m - 1
        
        else:
            resposta = m + 1
    
    print(resposta)",tree[i] == 0,"tree[i] <= 0 and tree[i] > neg1:
                neg1 = i
                break
            
        for i in range(neg1, n + neg1, neg1):
            if tree[i] <= 0 and tree[i] > neg1:
                neg1 = i
                break
            
        for i in range(neg1, n + neg1, neg1):
            if tree[i] <= 0 and tree[i] > neg1:
                neg1 = i
                break
            
        for i in range(neg1, n + neg1, neg1):
            if tree[i] <= 0 and tree[i] > neg1:
                neg1 = i
                break
            
        for i in range(neg1, n + neg1, neg1):
            if tree[i] <= 0 and tree[i] > neg1:
                neg"
"from heapq import *

for _ in range(int(input())):
    n = int(input())
    pp = list(map(int, input().split()))
    sibs = [[] for _ in range(n+1)]
    for i,p in enumerate(pp, 2):
        sibs[p].append(i)
    child_infected = [False] * (n+1)
    isibs = sorted(range(1, n+1), key=lambda x:len(sibs[x]), reverse=True)
    remain = n
    to_spread = []
    for turn, isib in enumerate(isibs):
        children = sibs[isib]
        while {{completion}}:
            heappop(to_spread)
        remain -= len(to_spread)
        child_infected[isib] = True
        heappush(to_spread, (len(children)+turn, isib))
        remain -= 1
        if remain <= 0:
            break
    print(turn+1)
",to_spread and to_spread[0][0] <= turn,"len(children) > 0:
            child = heappop(children)
            if child_infected[child]:
                continue
            child_infected[child] = True
            heappush(to_spread, (len(children)+turn, child))
            remain -= 1
            if remain <= 0:
                break
    print(turn+1)
<|/ file ext=.py |>
<| c |>
Please don't post images of text. Post the text itself.
<|/ c |>
<| c |>
I edited the question and added the code as well.
<|/ c |>
<| c |>
I edited the question and added the code as well."
"from heapq import *

for _ in range(int(input())):
    n = int(input())
    pp = list(map(int, input().split()))
    sibs = [[] for _ in range(n+1)]
    for i,p in enumerate(pp, 2):
        sibs[p].append(i)
    child_infected = [False] * (n+1)
    isibs = sorted(range(1, n+1), key=lambda x:len(sibs[x]), reverse=True)
    remain = n
    to_spread = []
    for turn, isib in enumerate(isibs):
        children = sibs[isib]
        while to_spread and to_spread[0][0] <= turn:
            heappop(to_spread)
        remain -= len(to_spread)
        child_infected[isib] = True
        heappush(to_spread, (len(children)+turn, isib))
        remain -= 1
        if {{completion}}:
            break
    print(turn+1)
",remain <= 0,"remain == 0:
            break
    for turn, child in enumerate(children):
        if child_infected[child]:
            continue
        child_infected[child] = True
        heappush(to_spread, (len(children)+turn, child))
        remain -= 1
        if remain == 0:
            break
    to_spread = []
    for turn, isib in enumerate(isibs):
        children = sibs[isib]
        while to_spread and to_spread[0][0] <= turn:
            heappop(to_spread)
        remain -= len(to_spread)
        child_infected[isib] = True
        heappush(to_spread"
"from sys import stdin, stdout
from collections import defaultdict

t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    parents = [int(x) for x in stdin.readline().split()]
    counts = defaultdict(int)
    counts[0] = 1
    for i in parents:
        counts[i] += 1

    lives = [counts[i] for i in counts]
    lives.sort(reverse=True)

    for i in range(len(lives)):
        lives[i] -= len(lives)-i

    answer = len(lives)

    while max(lives) > 0:
        current_max = -1
        max_index = -1
        for i in range(len(lives)):
            lives[i] -= 1
            if {{completion}}:
                current_max = lives[i]
                max_index = i
        lives[max_index] -= 1
        answer += 1

    stdout.write(""{}\n"".format(answer))
",lives[i] > current_max,"lives[i] > 0:
                if current_max < lives[i]:
                    current_max = lives[i]
                    max_index = i
            elif lives[i] == 0:
                if current_max > lives[i]:
                    current_max = lives[i]
                    max_index = i
            elif lives[i] == current_max:
                if current_max < lives[i]:
                    current_max = lives[i]
                    max_index = i
            elif lives[i] < current_max:
                if current_max < lives[i]:
                    current_max = lives[i]
                    max_index = i
            elif lives[i] < current_max and lives[i] != current_max:
                if current_max < lives[i]:
                    current_max = lives[i]
                    max_"
"for _ in [0] * int(input()):
    n = int(input())
    a = list(map(int, input().split()))
    c = [0] * n + [1]
    for i in a:
        c[i - 1] += 1
    c = sorted(c, reverse=True)
    ans = sum(i > 0 for i in c)
    for i, j in enumerate(c):
        if j > 0:
            c[i] = i + j - ans
    c = sorted([i for i in c if i > 0], reverse=True)
    while c:
        ans += 1
        for i, j in enumerate(c):
            if {{completion}}:
                c[i] = j - 1 - (i == 0)
        c = sorted([i for i in c if i > 0], reverse=True)
    print(ans)
",j > 0,"j > 0 and i != ans - 1 and i != ans + 1 and i != ans - 1 and i != ans + 1:
                c[i] = j - 1 - (i == ans - 1 or i == ans + 1)
        c = sorted([i for i in c if i > 0], reverse=True)
    print(ans)
<|/ a dscore=0 |>"
"inf=10**18
dxy=[(0,1), (1,0), (-1, 0), (0, -1)]
mod=10**9+7
MOD=998244353
from collections import Counter

def solve():
    n = int(input())
    p = [int(i)-1 for i in input().split()]
    c = Counter(p)

    ans = len(c.values())+1
    adi = []
    for i, n in enumerate(sorted(c.values(), reverse=True)):
        if n+i-ans>0:
            adi.append(n+i-ans)
    if adi:
        adi.sort(reverse=True)
        cnt = 0
        #bi search
        r = max(adi)+1
        l = 0
        def is_ok(x):
            d = 0
            for {{completion}}:
                d += max(0, i-x)
            return d-x<=0

        while r-l>1:
            mid = (r+l)//2
            if is_ok(mid):r = mid 
            else: l = mid
        ans += r
    return ans


def main():
    T = int(input())
    for _ in range(T):
        print(solve())


main()",i in adi,"i,d in dxy"
"inf=10**18
dxy=[(0,1), (1,0), (-1, 0), (0, -1)]
mod=10**9+7
MOD=998244353
from collections import Counter

def solve():
    n = int(input())
    p = [int(i)-1 for i in input().split()]
    c = Counter(p)

    ans = len(c.values())+1
    adi = []
    for i, n in enumerate(sorted(c.values(), reverse=True)):
        if n+i-ans>0:
            adi.append(n+i-ans)
    if adi:
        adi.sort(reverse=True)
        cnt = 0
        #bi search
        r = max(adi)+1
        l = 0
        def is_ok(x):
            d = 0
            for i in adi:
                d += max(0, i-x)
            return d-x<=0

        while r-l>1:
            mid = (r+l)//2
            if {{completion}}:r = mid 
            else: l = mid
        ans += r
    return ans


def main():
    T = int(input())
    for _ in range(T):
        print(solve())


main()",is_ok(mid),"is_ok(mid):
                l = mid
            else:
                r = mid
        ans += r
    return ans

def solve():
    n = int(input())
    p = [int(i)-1 for i in input().split()]
    c = Counter(p)

    ans = len(c.values())+1
    adi = []
    for i, n in enumerate(sorted(c.values(), reverse=True)):
        if n+i-ans>0:
            adi.append(n+i-ans)
    if adi:
        adi.sort(reverse=True)
        cnt = 0
        #bi search
        r = max(adi)+1
        l = 0
        def is_ok(x):
            d = 0
            for i in adi:
                d += "
"from heapq import heappop, heappush

t = int(input())
const = 1 << 18

for T in range(t):
    n = int(input())
    arr = [int(x) for x in input().split("" "")]

    things = {0: const}
    for x in range(len(arr)):
        if arr[x] in things:
            things[arr[x]] += 1
        else:
            things[arr[x]] = const

    laze = []
    for x in things:
        heappush(laze, -things[x])

    time = 0
    while len(laze) > 0:

        f = -laze[0]

        if f <= time:
            heappop(laze)
            continue
        elif f >= const:
            f -= const
            f += time + 1
            heappop(laze)

            if {{completion}}:
                heappush(laze, -f)
        else:
            f -= 1
            heappop(laze)

            if f > time:
                heappush(laze, -f)
        time += 1
    print(time)
",f > time,"f > time:
                heappush(laze, -f)
        else:
            f -= 1
            heappop(laze)

            if f > time:
                heappush(laze, -f)
        time += 1
    print(time)
""""""
<|/ a dscore=0 |>"
"from heapq import heappop, heappush

t = int(input())
const = 1 << 18

for T in range(t):
    n = int(input())
    arr = [int(x) for x in input().split("" "")]

    things = {0: const}
    for x in range(len(arr)):
        if arr[x] in things:
            things[arr[x]] += 1
        else:
            things[arr[x]] = const

    laze = []
    for x in things:
        heappush(laze, -things[x])

    time = 0
    while len(laze) > 0:

        f = -laze[0]

        if f <= time:
            heappop(laze)
            continue
        elif f >= const:
            f -= const
            f += time + 1
            heappop(laze)

            if f > time:
                heappush(laze, -f)
        else:
            f -= 1
            heappop(laze)

            if {{completion}}:
                heappush(laze, -f)
        time += 1
    print(time)
",f > time,"f > time:
                heappush(laze, -f)
        time += 1
    print(time)
""""""
<|/ file dstars=0 |>"
"from collections import defaultdict

counter = defaultdict(int)

def solve(a):
    for ai in a:
        counter[ai] += 1
    count = list(counter.values())
    num_level = len(count)
    count.sort()

    for i in range(num_level):
        count[i] = max(count[i] - i - 2, 0)
    
    L = 0; R = max(count)

    if R == 0:
        return num_level + 1

    def check(k):
        b = count.copy()
        for {{completion}}:
            b[i] = max(b[i] - k, 0)
        if sum(b) <= k:
            return True
        return False

    while R - L > 1:
        mid = (R + L) // 2
        if(check(mid)):
            R = mid
        else:
            L = mid

    return num_level + 1 + R

for a in [*open(0)][2::2]:
    counter.clear()
    res = solve(a.split())
    print(res)",i in range(len(b)),"a in b:
            b[a] = max(b[a] - k, 0)
        if sum(b) <= k:
            return True
        return False

    while R - L > 1:
        mid = (R + L) // 2
        if(check(mid)):
            R = mid
        else:
            L = mid

    return num_level + 1 + R

for a in [*open(0)][2::2]:
    counter.clear()
    res = solve(a.split())
    print(res)
<|/ file dstars=0 source=github |>"
"from collections import defaultdict

counter = defaultdict(int)

def solve(a):
    for ai in a:
        counter[ai] += 1
    count = list(counter.values())
    num_level = len(count)
    count.sort()

    for i in range(num_level):
        count[i] = max(count[i] - i - 2, 0)
    
    L = 0; R = max(count)

    if R == 0:
        return num_level + 1

    def check(k):
        b = count.copy()
        for i in range(len(b)):
            b[i] = max(b[i] - k, 0)
        if {{completion}}:
            return True
        return False

    while R - L > 1:
        mid = (R + L) // 2
        if(check(mid)):
            R = mid
        else:
            L = mid

    return num_level + 1 + R

for a in [*open(0)][2::2]:
    counter.clear()
    res = solve(a.split())
    print(res)",sum(b) <= k,"b == count:
            return True
        if b < count"
"from collections import Counter
for _ in range(int(input())):
    n = int(input())
    m = max(Counter(input().split()).values())
    ans = n-m
    while {{completion}}:
        ans += 1
        m *= 2
    print(ans)
",m<n,"m % 2 == 0:
        m //= 2
    while m > 0:
        ans -= 1
        m //= 2
    while m % 2 == 0:
        m //= 2
    while m > 0:
        ans += 1
        m //= 2
    while m % 2 == 0:
        m //= 2
    while m > 0:
        ans -= 1
        m //= 2
    while m % 2 == 0:
        m //= 2
    while m > 0:
        ans += 1
        m //= 2
    while m % 2 == 0:
        m //= 2
    while m > 0:
        ans -= 1
        m "
"from collections import*
for a in[*open(0)][2::2]:
 n=len(a:=a.split());m=max(Counter(a).values());r=0
 while {{completion}}:r+=min(m,n-m)+1;m*=2
 print(r)",m<n,"m>1:
  r+=m
  m//=2;m*=2
 print(r)
<|/ q tags=python,algorithm |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
from collections import*
for a in[*open(0)][2::2]:
 n=len(a:=a.split());m=max(Counter(a).values());r=0
"
"import math

for t in range(int(input())):
    n=int(input())
    L=input().split()
    count={}
    for {{completion}}:
        try:
            count[i]+=1
        except:
            count[i]=1
    m=max(list(count.values()))
    print(int(n-m + math.ceil(math.log(n/m,2))))",i in L,"x in L:
        count[x]=count[x]+1 if x in count else 1
    count[0]=1
    for i in range(1,n):
        if count[i]==1:
            continue
        if count[i]>1:
            count[i]-=1
            continue
        if count[i]==1:
            count[i]+=1
            continue
        if count[i]>1:
            count[i]-=1
            count[i]+=1
            continue
        if count[i]==1:
            count[i]+=1
            count[i]+=1
            continue
        if count[i]>1:
            count[i]-=1
            count[i]+=1
            count[i]+=1
            continue
        if count[i]==1:
            count"
"if True:
    from collections import Counter
    t = int(input())
    for {{completion}}:
        n = int(input())
        d = Counter(input().split()).most_common(1)[0][1]
        print([i for i in range(18) if (2**i)*d >= n][0]+n-d)",_ in range(t),"_ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        d = Counter(input().split()).most_common(1)[0][1]
        print([i for i in range(18) if (2**i)*d >= n][0]+n-d)
if False:
    from collections import Counter
    t = int(input())
    for _ in range(t):
        n = int(input())
        d = Counter(input().split()).most_common(1)[0][1]
        print([i for i in range(18) if (2**i)*d >= n][0]+n-d)
if True:
    from collections import Counter
    t = int(input())
    for _ in range(t):
        n = int(input())
        d = Counter(input().split()).most_common(1)[0][1]
        print([i for i in range("
"from sys import stdin
t = int(stdin.readline())
while t>0:
     t -= 1
     n = int(stdin.readline())
     a = sorted(list(map(int,stdin.readline().split())))
     M = 1
     temp = 1
     for i in range(1,n):
          if {{completion}}:
               temp = 1
          else:
               temp += 1
          M = max(M,temp)
     ind = 0
     temp = M
     while temp<n:
          ind += 1
          temp *= 2
     print(n-M+ind)
",a[i]>a[i-1],a[i]!=a[i-1]
"for i in range(int(input())):
	n=int(input())
	a=input().split()
	from collections import Counter

	e,bb=Counter(a).most_common(1)[0]
	c=n-bb
	while {{completion}}:
		c+=1
		bb*=2
	print(c)",bb<n,"bb>0:
		bb-=1
		e+=1
	print(c)
	
for i in range(int(input())):
	n=int(input())
	a=input().split()
	bb=n
	c=0
	while bb>0:
		bb-=1
		c+=1
	print(c)
	
for i in range(int(input())):
	n=int(input())
	a=input().split()
	bb=n
	c=0
	while bb>0:
		bb-=1
		c+=1
	print(c)
	
for i in range(int(input())):
	n=int(input())
	"
"from collections import Counter

for li in[*open(0)][2::2]:
    n=len(li:=li.split());
    m = max(Counter(li).values())
    ans =n-m
    while{{completion}}:
        ans+=1
        
        m=2*m
    print(ans)",(m<n),"(m>1):
        ans+=1
        m=2*m
    print(ans)
<|/ file dstars=0 source=github |>"
"from collections import Counter
def solve():
    n = int(input())
    freq = max(Counter(input().split()).values())
    left = n -  freq
    ans=0
    while{{completion}}:
        ans += 1+min(left,freq)
        left = left - min(left,freq)
        freq=2*freq
            
    print(ans)

while(True):
    try:
        test = int(input())
    except EOFError:
        break
    for i in range (test):
        solve()
",(left),"(freq>0):
        ans += 1+min(left,freq)
        left = left - min(left,freq)
        freq=2*freq
            
    print(ans)

while(True):
    try:
        test = int(input())
    except EOFError:
        break
    for i in range (test):
        solve()
'''
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"from collections import Counter
def solve():
    n = int(input())
    freq = max(Counter(input().split()).values())
    left = n -  freq
    ans=0
    while(left):
        ans += 1+min(left,freq)
        left = left - min(left,freq)
        freq=2*freq
            
    print(ans)

while(True):
    try:
        test = int(input())
    except EOFError:
        break
    for {{completion}}:
        solve()
",i in range (test),"_ in range(test):
        solve()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"from sys import stdin, stdout
from collections import Counter
for _ in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())
    b = a =  max(Counter(stdin.readline().split()).items(), key = lambda x:x[1])[1]
    ans = n - a
    while {{completion}}:
        a = a + a
        ans += 1
    stdout.write(f""{str(ans)}\n"")
",a < n,"a < n:
        a.append(0)
    while a < n:
        a[a - n] = a[a - n] + a[a - n]
        ans += 1
    while a < n:
        a[a - n] = a[a - n] + a[a - n]
        ans += 1
    while a < n:
        a[a - n] = a[a - n] + a[a - n]
        ans += 1
    while a < n:
        a[a - n] = a[a - n] + a[a - n]
        ans += 1
    while a < n:
        a[a - n] = a[a - n] + a[a - n]
        ans += 1
    while a < n:
        a[a - n"
"N=int(input())
for _ in range(N):
    n = int(input())
    list_num = input().split(' ')

    d = dict()
    for num in list_num:
        if {{completion}}:
            d[num] = d[num] + 1
        else:
            d[num] = 1
    max_num = max(d.values())

    now = max_num
    ans = 0
    copy = 0
    while now < n:
        if copy > 0:
            ans += 1
            copy -= 1
            now += 1

        else:
            ans += 1
            copy = now
    
    print (ans)
",num in d,"num in d:
            d[num] = d[num] + 1
        else:
            d[num] = 1
    max_num = max(d.values())

    now = max_num
    ans = 0
    copy = 0
    while now < n:
        if copy > 0:
            ans += 1
            copy -= 1
            now += 1

        else:
            ans += 1
            copy = now
    
    print (ans)
""""""
<|/ a dscore=0 |>
<| a |>
<code>
N=int(input())
for _ in range(N):
    n = int(input())
    list_num = input().split(' ')

    d = dict()
    for num in list_num:
        if num in d:"
"N=int(input())
for _ in range(N):
    n = int(input())
    list_num = input().split(' ')

    d = dict()
    for num in list_num:
        if num in d:
            d[num] = d[num] + 1
        else:
            d[num] = 1
    max_num = max(d.values())

    now = max_num
    ans = 0
    copy = 0
    while now < n:
        if {{completion}}:
            ans += 1
            copy -= 1
            now += 1

        else:
            ans += 1
            copy = now
    
    print (ans)
",copy > 0,"now in d:
            ans += 1
            copy += 1
            now += 1
            
        elif now == copy"
"t=int(input())
for i in range (t):
    n = int(input())
    m=n//4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif {{completion}}:
        print(m,2*m,m,1,end=' ')
    elif n%4==2:
        print(2*m-1,2*m+1,1,1,end=' ')
    else:
        print(2,4*m-2,2,1,end=' ')
    print(sep='')    ",n%4==1,"n%4==1:
        print(2*m,2*m+1,2*m+1,1,end=' ')
    elif n%4==3:
        print(2*m-1,2*m+1,1,1,end=' ')
    elif n%4==2:
        print(2*m-1,2*m+1,1,1,end=' ')
    else:
        print(2,4*m-2,2,1,end=' ')
    print(sep='')    
print(sep='')
t=int(input())
for i in range (t):
    n = int(input())
    m=n//4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif n%4==1:
        print(2*m,2*m+1,2*m+"
"t=int(input())
for i in range (t):
    n = int(input())
    m=n//4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif n%4==1:
        print(m,2*m,m,1,end=' ')
    elif {{completion}}:
        print(2*m-1,2*m+1,1,1,end=' ')
    else:
        print(2,4*m-2,2,1,end=' ')
    print(sep='')    ",n%4==2,"n%4==2:
        print(2*m,m,2,2,end=' ')
    elif n%4==3:
        print(m,2*m-1,1,1,end=' ')
    else:
        print(2,4*m,2,2,1,end=' ')
    print(sep='')
    m=m+4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif n%4==1:
        print(m,2*m,m,1,end=' ')
    elif n%4==2:
        print(2*m,m,2,2,end=' ')
    elif n%4==3:
        print(m,2*m-1,1,1,end=' ')
    else:
        print(2,4*m,2,2,1,end=' ')
    print(sep='')
    m"
"for _ in range(int(input())):
    n = int(input())

    if n == 4:
        a = b = c = d = 1

    elif n == 5:
        a = c = d = 1
        b = 2

    elif n == 6:
        a = c = d = 1
        b = 3

    elif {{completion}}:
        c = d = b = 2
        a = n-6

    elif n%4 == 1:
        d = 1
        c = 2
        a = 2
        b = n-5

    elif n%4 == 2:
        d = 1
        c = 1
        a = (n-2)//2 - 1
        b = (n-2)//2 + 1

    else:
        d = 1
        c = 2
        b = 2
        a = n-5

    print(a, b, c, d)",n%4 == 0,"n == 7:
        a = c = d = 2
        b = 2

    elif n == 8:
        a = c = d = 2
        b = 3

    elif n == 9:
        a = c = d = 2
        b = 3

    elif n == 10:
        a = c = d = 2
        b = 3

    elif n == 11:
        a = c = d = 2
        b = 3

    elif n == 12:
        a = c = d = 2
        b = 3

    elif n == 13:
        a = c = d = 2
        b = 3

    elif n == 14:
        a = c = d = 2
        b = 3

    elif n == 15:
        a = c = d = 2
        b = 3

    elif n == 16:
        a = c = d = 2
        b = 3

    elif n == 17:"
"for _ in range(int(input())):
    n = int(input())

    if n == 4:
        a = b = c = d = 1

    elif n == 5:
        a = c = d = 1
        b = 2

    elif n == 6:
        a = c = d = 1
        b = 3

    elif n%4 == 0:
        c = d = b = 2
        a = n-6

    elif {{completion}}:
        d = 1
        c = 2
        a = 2
        b = n-5

    elif n%4 == 2:
        d = 1
        c = 1
        a = (n-2)//2 - 1
        b = (n-2)//2 + 1

    else:
        d = 1
        c = 2
        b = 2
        a = n-5

    print(a, b, c, d)",n%4 == 1,"n%4 == 1:
        c = d = a = 1
        b = n-6

    elif n%4 == 3:
        c = d = a = 1
        b = 2

    elif n%4 == 4:
        c = d = a = 1
        b = 3

    elif n%4 == 5"
"t = int(input())
for _ in range(t):
    n = int(input())
    ans = []
    if n == 5:
        ans = [1, 2, 1, 1]
    elif {{completion}}:
        ans = [n // 4] * 4
    elif n % 2 == 0:
        ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]
    else:
        a, c, d = 2, 2, 1
        b = n - a - c - d
        ans = [a, b, c, d]
    print(' '.join([str(a) for a in ans]))
",n % 4 == 0,"n % 4 == 0:
        ans = [n // 4, n // 2, n // 2, n // 2]
    elif n % 4 == 1:
        ans = [n // 4, n // 2, n // 2, n // 2]
    elif n % 4 == 2:
        ans = [n // 4, n // 2, n // 2, n // 2]
    elif n % 4 == 3:
        ans = [n // 4, n // 2, n // 2, n // 2]
    elif n % 4 == 4:
        ans = [n // 4, n // 2, n // 2, n // 2]
    elif n % 2 == 0:
        ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]
    else:"
"t = int(input())
for _ in range(t):
    n = int(input())
    ans = []
    if n == 5:
        ans = [1, 2, 1, 1]
    elif n % 4 == 0:
        ans = [n // 4] * 4
    elif {{completion}}:
        ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]
    else:
        a, c, d = 2, 2, 1
        b = n - a - c - d
        ans = [a, b, c, d]
    print(' '.join([str(a) for a in ans]))
",n % 2 == 0,"n % 4 == 1:
        ans = [n // 4, n // 4, n // 4, n // 4]
    elif n % 4 == 2:
        ans = [n // 4, n // 4, n // 4, n // 4]
    elif n % 4 == 3:
        ans = [n // 4, n // 4, n // 4, n // 4]
    elif n % 4 == 4:
        ans = [n // 4, n // 4, n // 4, n // 4]
    elif n % 4 == 5:
        ans = [n // 4, n // 4, n // 4, n // 4]
    elif n % 4 == 6:
        ans = [n // 4, n // 4, n // 4, n // 4]"
"for _ in range(int(input())):
    a=int(input())
    if a%4==0:
        print(a//4,a//4,a//4,a//4)
    else:
        if a%2==1:
            a1=(a-1)
            if a1%3==0:
                print(a1//3,a1//3,a1//3,1)
            elif a1%4!=0:
                a1=a-2
                print(a1//2,a1//2+1,1,1)
            elif {{completion}}:
                print(a1//4,a1//2,a1//4,1)
        else:
            a1=a-2
            print(a1//2-1,a1//2+1,1,1)
        
    ",a1%4==0,"a1%4==0 and a1%3!=0:
                print(a1//4,a1//4,a1//4,1)
            else:
                a1=a-2
                print(a1//2-1,a1//2+1,1,1)
        elif a%2==0:
            a1=(a-1)
            if a1%4==0:
                print(a1//4,a1//4,a1//4,1)
            elif a1%4!=0:
                a1=a-2
                print(a1//2,a1//2+1,1,1)
            elif a1%4==0 and a1%3!=0:
                print(a1//4,a1//4,a1//4,1)
            else:
"
"t = int(input())
for test in range(t):
    a = []
    while len(a) != 8:
        s = input()
        if (len(s) == 8):
            a.append(s)
 
    x = 0
    y = 0
 
    for i in range(1, 7):
        for j in range(1, 7):
            if {{completion}}:
                x = i
                y = j
    print(x + 1, y + 1)
 
    
 
    
",(a[i][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j-1] == '#'),"a[x][y] == '#':
                a[x][y] = '.'
            if a[x][y] == '.':
                a[x][y] = '#'
            if a[x][y] == '#' and a[x-1][y] == '#' and a[x+1][y] == '#' and a[x][y-1] == '#' and a[x][y+1] == '#':
                a[x][y] = '#'
            if a[x][y] == '#' and a[x-1][y] == '#' and a[x+1][y] == '#' and a[x][y-1] == '#' and a[x][y+1] == '#' and a[x-1][y-1] == '#' and a"
"import sys
n = int(input())
a = [int(x)-1 for x in sys.stdin.readline().split()]
depth = [1]*n
best = [0]*n
for i in range(n-1, -1, -1):
    best[i] = max(best[i], depth[i])
    if {{completion}}:
        parent = a[i-1]
        depth[parent] = max(depth[parent], 1 + depth[i])
        best[parent] += best[i]
print(best[0])
",i != 0,"a[i] != i+1:
        depth[a[i]] = 1 + depth[i]
        best[a[i]] += best[i]
for i in range(n-1, -1, -1):
    if a[i] != i+1:
        depth[a[i]] = 1 + depth[i]
        best[a[i]] += best[i]
for i in range(n-1, -1, -1):
    if a[i] != i+1 and depth[a[i]] > depth[i]:
        depth[a[i]] = depth[i]
        best[a[i]] += best[i]
for i in range(n-1, -1, -1):
    if a[i] != i+1 and depth[a[i]] > depth[i]:
        depth[a[i]] = depth[i]
        best[a[i]] += best[i]
for i in range(n-1, -1, -1):
    if a[i] "
"mod = 998244353


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    P = [0, 0] + list(map(int, input().split()))

    child = [[] for _ in range(N + 1)]
    for v in range(2, N+1):
        p = P[v]
        child[p].append(v)

    dp = [0] * (N + 1)
    dp2 = [0] * (N + 1)
    for v in range(N, 0, -1):
        if not child[v]:
            dp2[v] = 1
            dp[v] = 1
        else:
            S = 0
            D = 0
            for {{completion}}:
                S += dp[c]
                D = max(D, dp2[c])
            dp2[v] = D + 1
            dp[v] = max(S, D + 1)
    print(dp[1])
    #print(dp, dp2)


if __name__ == '__main__':
    main()
",c in child[v],"c in child[v]:
                S += dp[c]
                D = max(D, dp2[c])
            dp2[v] = D + 1
            dp[v] = max(S, D + 1)
    print(dp[1])
    #print(dp, dp2)


if __name__ == '__main__':
    main()
""""""
mod = 998244353


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    P = [0, 0] + list(map(int, input().split()))

    child = [[] for _ in range(N + 1)]
    for v in range(2, N+1):
        p = P[v]
        child[p].append(v)

    dp = [0] * (N + 1)
    dp2 = [0]"
"n=int(input())
a=[-1]+[int(o)-1 for o in input().split()]
f=[0]*n
dp=[0]*n
for {{completion}}:
  f[a[i]]=max(f[i]+1,f[a[i]])
for i in range(n-1,0,-1):
  dp[i]=max(dp[i],f[i]+1)
  dp[a[i]]+=dp[i]
print(max(dp[0],f[0]+1))","i in range(n-1,0,-1)","j in range(1,n):
  f[j]=max(f[j-1]+1,f[j])
for i in range(1,n):
  dp[i]=max(dp[i-1]+1,f[i])
for i in range(n-1,0,-1):
  dp[i]=max(dp[i],f[i]+1)
print(max(dp[0],f[0]+1))
<|/ a dscore=0 |>
<| c |>
Please don't post only code as answer, but also provide an explanation what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>"
"n=int(input())
a=[-1]+[int(o)-1 for o in input().split()]
f=[0]*n
dp=[0]*n
for i in range(n-1,0,-1):
  f[a[i]]=max(f[i]+1,f[a[i]])
for {{completion}}:
  dp[i]=max(dp[i],f[i]+1)
  dp[a[i]]+=dp[i]
print(max(dp[0],f[0]+1))","i in range(n-1,0,-1)","j in range(1,n):
  dp[j]=max(dp[j],dp[j-1])
for i in range(n-1,0,-1):
  dp[i]=max(dp[i],f[i]+1)
print(max(dp[0],f[0]+1))
<|/ a dscore=0 |>
<| a tags=dynamic-programming,algorithm,python,dynamic-programming |>
<code>
n=int(input())
a=[-1]+[int(o)-1 for o in input().split()]
f=[0]*n
dp=[0]*n
for i in range(n-1,0,-1):
  f[a[i]]=max(f[i]+1,f[a[i]])
for j in range(1,n):
  dp"
"I,G=input,range;n=int(I());p=[-1,0]+[*map(int,I().split())];h=[1]*(n+1);F=[0]*(n+1)
for {{completion}}:h[p[i]]=max(h[i]+1,h[p[i]])
for i in G(n,0,-1):F[i]=max(F[i],h[i]);F[p[i]]+=F[i]
print(F[1])","i in G(n,1,-1)","i,j in zip(p,G(n,0,-1)):h[i]=max(h[i],j);h[p[i]]+=h[i]
for i in G(n,0,-1):F[i]=max(F[i],h[i]);F[p[i]]+=F[i]
print(F[1])
""""""
import math
def PakChanek(n):
    s=[]
    for i in range(1,n+1):
        s.append(i)
    s=sorted(s)
    s=s+[i for i in s if i>1]
    s=sorted(s)
    s=s+[i for i in s if i<n]
    s=sorted(s)
    s=s+[i for i in s if i>1]
    s=sorted(s)
    s=s+["
"I,G=input,range;n=int(I());p=[-1,0]+[*map(int,I().split())];h=[1]*(n+1);F=[0]*(n+1)
for i in G(n,1,-1):h[p[i]]=max(h[i]+1,h[p[i]])
for {{completion}}:F[i]=max(F[i],h[i]);F[p[i]]+=F[i]
print(F[1])","i in G(n,0,-1)","i,j in enumerate(F):j+=h[i]
for i,j in enumerate(F):F[i]=max(F[i],j)
for i,j in enumerate(F):F[i]=max(F[i],h[i])
print(F[1])

Time:

The time complexity is $O(n^2)$, where $n$ is the number of cards.

Space:

The space complexity is $O(n)$, where $n$ is the number of cards.

Stable:

The algorithm is stable.

Remarks:

The input data set is non-decreasing.

The output data set is non-decreasing.

The algorithm is stable."
"n = int(input())
a = [*map(lambda x:int(x)-1,input().split())]
edge = [[] for _ in range(n)]
for i,p in enumerate(a,1): edge[p] += i,

dp = [[1,0] for _ in range(n)]
for r in range(n-1,-1,-1):
    for {{completion}}: 
        k = max(dp[v])
        dp[r][1] += k
        dp[r][0] = max(dp[r][0],dp[v][0]+1)
print(max(dp[0]))",v in edge[r],"v in edge[r]:
        if dp[r][1] < dp[v][1]"
"from sys import stdin, stdout
from collections import defaultdict
N = 998244353

n = int(stdin.readline())
a = [int(x)-1 for x in stdin.readline().split()]

count = [0]*n
row_values = [0]*n

for i in range(n):
    row_values[count[a[i]]] += 1
    count[a[i]] += 1

row_values_pref = [row_values[0]]
for i in range(1,n):
    row_values_pref.append(row_values_pref[-1]+row_values[i])

dp = [[0]*(n+1) for bar in range(n+1)]

for i in range(1,row_values[0]+1):
    dp[i][i] = 1

for i in range(1,n):
    for total in range(n-1,0,-1):
        current = 0
        for last in range(total//i, 0, -1):
            current += dp[total][last]
            current %= N
            dp[total][last] = 0

            if {{completion}}:
                dp[total+last][last] += current
                dp[total+last][last] %= N

answer = 0
for i in range(1,n+1):
    answer += dp[n][i]
    answer %= N

stdout.write(str(answer)+'\n')
","last <= min(row_values_pref[i]-total, n-total)","current == row_values_pref[last]:
                dp[total][last] += current
                dp[total][last] %= N
            elif current > row_values_pref[last]:
                dp[total][last] += current
                dp[total][last] %= N

        for last in range(total//i, 0, -1):
            current += dp[total][last]
            current %= N
            dp[total][last] = 0

            if current == row_values_pref[last]:
                dp[total][last] += current
                dp[total][last] %= N
            elif current > row_values_pref[last]:
                "
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1

M = 998244353


def solve():
    n = getInt()
    a = list(getList())
    cnt = [0] * n
    for i in a:
        cnt[i-1] += 1

    lim = [0] * (n+1)

    col = 0  # the number of remaining columns, initial col = number of distinct element
    f = [0] * (n+1)  # frequent of the height of columns
    for i, j in enumerate(cnt):
        col += j > 0
        f[j] += 1

    for i in range(1, n+1):
        lim[i] = lim[i-1] + col
        col -= f[i]
    dp = [[0] * (n+1) for _ in range(n+1)]

    dp[0][0] = 1
    for x in range(n, 0, -1):
        # dp[i][j] used elements + size of multiset
        for j in range(n):
            # transition
            # x * j <= n
            # i+x <= lim[j+1]
            if j * x > n:
                break
            for i in range(n-x+1):
                if {{completion}}:
                    dp[i+x][j+1] += dp[i][j]
                    dp[i+x][j+1] %= M
    print(sum(dp[n]) % M)


for _ in range(t):
    solve()
",i + x <= lim[j+1],i + x * j > lim[j+1]
"g=10**9+7
v=[1]+[0]*40001
for i in range(1,40001):
 if str(i)==str(i)[::-1]:
  for {{completion}}:v[j]=v[j]%g+v[j-i]
for n in[*open(0)][1:]:print(v[int(n)]%g)","j in range(i,40001)","j in range(1,40001):
   if j>=i:
    v[j]=v[j]%g+v[j-i]
for n in[*open(0)][1:]:print(v[int(n)]%g)
<|/ q tags=python,python-3.x |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
I have added the code I have tried
<|/ c |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
I have added the code I have tried
<|/ c |>
"
"p=[]
for i in range(1,40004):
  s=str(i)
  if s==s[::-1]:
    p+=[i]
n=40004
d=[0]*(n+1)
for pj in p:
  d[0] = 1
  for i in range(1,n+1):
    if {{completion}}:
      d[i]+=d[i-pj]
    d[i]=d[i]%int(1e9+7)
for _ in range(int(input())):
  print(d[int(input())])
        
  
    
      
",pj<=i,"pj==p[i-pj]:
      d[i]+=1
    else:
      d[i]=0
for i in range(1,n+1):
  if d[i]!=0:
    for pj in p:
      if d[i]>d[i-pj]:
        d[i]=d[i-pj]
        break
    else:
      d[i]=d[i]%int(1e9+7)
for _ in range(int(input())):
  print(d[int(input())])
        
  
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      "
"n = int(input())


def getList():
    return map(int, input().split())


def getInt():
    return int(input())


N = 4 * 10 ** 4 + 10
M = 10 ** 9 + 7
dp = [0] * N

for i in range(1, N):
    if str(i) == str(i)[::-1]:
        dp[i] += 1
        for {{completion}}:
            dp[j] += dp[j-i]
            dp[j] %= M


def solve():
    n = getInt()
    print(dp[n])


for _ in range(n):
    solve()
","j in range(i, N)",j in dp
"from sys import stdin,stdout
input = lambda : stdin.readline().rstrip()
print =lambda x : stdout.write(str(x))

dp = [0 for _ in range(40002)]
dp[0] = 1
for i in range(1, 40001):
    if str(i) == str(i)[::-1]:
        for {{completion}}:
            dp[j] = (dp[j]+dp[j-i])%int(1e9+7)
for _ in range(int(input())):
    print(f""{dp[int(input())]}\n"")

","j in range(i, 40001)",j in dp
"R=range
m=40001
d=10**9+7
p=[]
for i in R(1,m):
    n=str(i)
    if {{completion}}:p+=[i]
a=[1]+[0]*m
for i in p:
    for j in R(i,m):
        a[j]+=a[j-i];a[j]%=d
for n in[*open(0)][1:]:print(a[int(n)])",n==n[::-1],"n==n[::-1]:p.append(i)
    if n!=n[::-1]"
"R=range
m=40001
d=10**9+7
p=[]
for i in R(1,m):
    n=str(i)
    if n==n[::-1]:p+=[i]
a=[1]+[0]*m
for i in p:
    for {{completion}}:
        a[j]+=a[j-i];a[j]%=d
for n in[*open(0)][1:]:print(a[int(n)])","j in R(i,m)","j in R(1,m):
        if a[j]>i:break
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue
    for j in R(1,m):
        if a[j]>i:continue"
"import sys
input  = sys.stdin.readline
s = []
c = [1]
for y in range(1,40005):
    if str(y) == (str(y))[::-1]:
        s.append(y)
    c.append(0)


for i in s:
    for j in range(1,40005):
        if {{completion}}:
            c[j] += (c[j - i]) % ((10 ** 9) + 7) 
            
a = int(input())
 
for y in range(a):
    b = int(input())
    print(c[b] % ((10 ** 9) + 7))
",j >= i,i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j and i != j
"d=[0]*40001
d[0]=1
for x in range(1,40001):
    if str(x)==str(x)[::-1]:
        for {{completion}}:
            d[i]=(d[i]+d[i-x])%(10**9+7)
for _ in range(int(input())):
    print(d[int(input())])
","i in range(x,40001)","y in range(1,40001):
            if y!=x and str(y)==str(y)[::-1]:
                d[x]=d[x]+d[y]
for _ in range(int(input())):
    print(d[int(input())])
""""""
<|/ q dscore=0 |>
<| c |>
Please post the code you've tried so far.
<|/ c |>
<| c |>
I added the code I tried
<|/ c |>
<| a |>
<code>
d=[0]*40001
d[0]=1
for x in range(1,40001):
    if str(x)==str(x)[::-1]:
        for y in range(1,40001):"
"size = int(4e4)+1
ps=[]
i=1
while (i<size):
    if str(i) == str(i)[::-1]:
        ps.append(i)
    i+=1
 
pm = [0]*size
pm[0]=1
for p in ps:
    i=0
    while (i<size):
        if {{completion}}:
            break
        pm[i+p]+=pm[i]
        pm[i+p]%=int(1e9)+7
        i+=1
 
T = int(input())
for _ in range(T):
    n = int(input())
    print(pm[n])
",i+p >= size,"pm[i]!=0:
            i+=1
            continue
        if i==p:
            i+=1
            continue
        if i==p+1:
            i+=1
            continue
        if i==p-1:
            i+=1
            continue
        if i==p+2:
            i+=1
            continue
        if i==p-2:
            i+=1
            continue
        if i==p+3:
            i+=1
            continue
        if i==p-3:
            i+=1
            continue
        if i==p+4:
            i+=1
            continue
        if i==p-4:
            i+=1
            continue
        if i==p+"
"for {{completion}}:
    s = input()
    c = len(set(s))
    print(""Yes"" if all(len(set(s[i::c])) == 1 for i in range(c)) else ""No"")
",_ in range(int(input())),"_ in range(int(input())):
    s = input()
    c = len(set(s))
    print(""Yes"" if all(len(set(s[i::c])) == 1 for i in range(c)) else ""No"")
<|/ a |>
<| a tags=string,python,algorithm |>
<code>
for _ in range(int(input())):
    s = input()
    c = len(set(s))
    print(""Yes"" if all(len(set(s[i::c])) == 1 for i in range(c)) else ""No"")
</code>
<|/ a dscore=0 |>
<| c |>
Please add some explanation to your answer.
<|/ c |>
<| a tags=string,python,algorithm |>
<code>
for _ in range(int("
"import sys
input = sys.stdin.readline

n = int(input())
for _ in range(n):
    s = input()[:-1]
    a = len(s)
    b = len(set(s))
    if b == 1 or a == b:
        print('YES')
    else:
        for i in range(1, a):
            if s[i] in s[:i]:
                w = (s[:i]*a)[:a]
                if {{completion}}:
                    print(""YES"")
                else:
                    print(""NO"")
                break",s == w,"w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + s[:i]
                if w in s:
                    w = s[:i] + "
"t = int(input())
while (t > 0):
    t -= 1
    s = str(input())
    var = set(s)
    ans = ""YES""
    for i in range(len(s)-len(var)+1):
        if {{completion}}:
            ans = ""NO""
            break
    print(ans)",len(set(s[i:i+len(var)])) != len(var),"var.issubset(set(s[:i]+s[i+1:])):
            ans = ""NO""
            break
    for i in range(len(s)-len(var)+1):
        if var.issubset(set(s[:i]+s[i+1:])) and var.issubset(set(s[i+1:])):
            ans = ""NO""
            break
    for i in range(len(s)-len(var)+1):
        if var.issubset(set(s[:i]+s[i+1:])) and var.issubset(set(s[i+1:])):
            ans = ""NO""
            break
    for i in range(len(s)-len(var)+1):
        if var.issubset(set(s[:i]+s[i+1:])) and var.is"
"def solve(s):
    st=set(s)
    a=len(st)
    f=1
    for i in range(len(s)):
        if {{completion}}:
            f=0
    if not f:
        return ""NO""
    else:
        return ""YES""
    
    
    
for i in range(int(input())):
    s=input()
    print(solve(s))",s[i]!=s[i%a]  ,"s[i] in st:
            f=f*st[s[i]]
        else:
            f=0
        if f>1:
            f=1
        else:
            f=0
        if f==1:
            break
    if f==1:
        return ""NO""
    else:
        return ""YES""
    
for i in range(int(input())):
    s=input()
    print(solve(s))
'''
def solve(s):
    st=set(s)
    a=len(st)
    f=1
    for i in range(len(s)):
        if s[i] in st:
            f=f*st[s[i]]
        else:
            f=0
        if f>1:
            f=1
        else:
            f=0
        if "
"for _ in range(int(input())):
    n=input()
    s=len(set(n))
    for i in range(len(n)-s):
        if {{completion}}:print(""NO"");break
    else:print(""YES"")",n[i]!=n[i+s],"n[i:i+s]==n:break
    else:print(""NO"")
    for _ in range(int(input())):
        n=input()
        s=len(set(n))
        for i in range(len(n)-s):
            if n[i:i+s]==n:break
        else:print(""NO"")
    for _ in range(int(input())):
        n=input()
        s=len(set(n))
        for i in range(len(n)-s):
            if n[i:i+s]==n:break
        else:print(""NO"")
    for _ in range(int(input())):
        n=input()
        s=len(set(n))
        for i in range(len(n)-s):
            if n[i:i+s]==n:break
        else:print(""NO"")
    for _ in range(int(input"
"for i in range(int(input())):
    count={}
    str = input()
    for char in str:
        count[char] = 0
    res = True
    for i in range(len(str) - len(count.keys())):
        if {{completion}}:
            res = False
    print(""YES"" if res else ""NO"")
",(str[i]!=str[i + len(count.keys())]),"str[i:i+len(count.keys())] in count.keys():
            count[str[i:i+len(count.keys())]] += 1
        else:
            res = False
    for k in count.keys():
        if count[k] > 1:
            res = False
    if res:
        print(""YES"")
    else:
        print(""NO"")
<|/ a |>
<| a tags=string,python,algorithm |>
<code>
def isBalanced(s):
    count = {}
    for c in s:
        if c in count:
            count[c] += 1
        else:
            count[c] = 1
    res = True
    for k in count.keys():
        if count[k] > 1:
            res = False
    return res

for i in range(int(input())):
    "
"t = int(input())
while(t):
    s = input()
    d = len(set(s))
    for i in range(d, len(s)):
        if{{completion}}:
            print(""No"")
            break
    else:
        print(""Yes"")
    t -= 1",(s[i] != s[i - d]),"(i-len(s)+1 >= d):
            break
        u = s[i-d:i]
        v = s[i+1:i+1+d]
        if(u == v):
            print(""Yes"")
            break
        if(u != v):
            print(""No"")
            break
    else:
        print(""Yes"")
    t -= 1
<|/ file filename=perfectly_balanced.py |>"
"n = int(input())
for i in range(n):
  str1 = input()
  set_char = set(str1)
  req = len(set_char)
  prev = dict()
  truth = True
  ind = 0
  for i1 in str1:
    if{{completion}}:
      truth = False
      break
    prev[i1] = ind
    ind += 1
  print(truth and 'YES' or 'NO')",( i1 in prev and ind - prev[i1] != req),"(i1 in prev):
      if(abs(req - prev[i1]) > 1):
        truth = False
        break
    prev[i1] = ind
    ind += 1
  if(truth):
    print('YES')
  else:
    print('NO')
<|/ a tags=string,python,algorithm |>
<| a dscore=0 |>
<code>
n = int(input())
for i in range(n):
  str1 = input()
  set_char = set(str1)
  req = len(set_char)
  prev = dict()
  truth = True
  ind = 0
  for i1 in str1:
    if(i1 in prev):
      if(abs(req - prev[i1]) > 1):"
"for {{completion}}:
    string=tuple(input().strip())
    k=len(set(string))
    print(""NO"" if any([string[i]!=string[i%k] for i in range (len(string))]) else ""YES"")
",_ in range(int(input())),"test in range (int(input())):
    string=tuple(input().strip())
    k=len(set(string))
    print(""NO"" if any([string[i]!=string[i%k] for i in range (len(string))]) else ""YES"")
<|/ q dscore=0 |>
<| c |>
Please [edit] your question to include a [mcve]. Your code is not complete and is not properly indented. Also please take some time to read [ask] and [what's on-topic](/help/on-topic) again and [edit] your question accordingly.
<|/ c |>
<| c |>
Please [edit] "
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  alph = ""abcdefghijklmnopqrstuvwxyz""
  a = list(map(lambda c: alph.index(c) + 1, inp1()))
  l = len(a)
  s = sum(a)

  if l % 2 == 0:
    print(f""Alice {s}"")
  elif l == 1:
    print(f""Bob {s}"")
  else:
    o1 = sum(a[1:]) - a[0]
    o2 = sum(a[:l-1]) - a[-1]
    if {{completion}}:
      print(f""Alice {o1}"")
    else:
      print(f""Alice {o2}"")
",o1 > o2,"o1 > o2:
      print(f""Bob {s}"")
    elif o1 < o2:
      print(f""Alice {s}"")
    else:
      print(f""Alice {s}"")
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  "
"MOD = 998244353

def modmul(x, y, c = 0):
    return (x * y + c) % MOD

def inv(x):
    return pow(x, MOD - 2, MOD)

MAX = 10 ** 6

fact = [1]
for {{completion}}:
    fact.append(modmul(i, fact[i-1]))

invfact = [1] * (MAX)
invfact[MAX - 1] = inv(fact[MAX - 1])
for i in range(MAX - 2, -1, -1):
    invfact[i] = modmul(i + 1, invfact[i+1])

def comb(x, y):
    return modmul(fact[x], modmul(invfact[y], invfact[x - y]))
    
def invcomb(x, y):
    return modmul(invfact[x], modmul(fact[y], fact[x - y]))
    
def invs(x):
    return modmul(fact[x - 1], invfact[x])

n = int(input())

out = [0] * n

for i in range((n + 1) // 2):
    base = fact[n - 1]
    frac = modmul(comb(n//2, i), invcomb(n - 1, i))
    
    out[i] = modmul(base, frac)

rem = 0   
for i in range(n - 1, -1, -1):
    oldrem = rem
    rem += modmul(out[i], invs(i))
    out[i] -= oldrem
    
    rem %= MOD
    out[i] %= MOD
    
print(' '.join(map(str,out)))","i in range(1, MAX)","k in range(2, MAX):
    fact.append(fact[k - 1] * k)
    
for i in range(MAX - 2, -1, -1):
    fact[i] = fact[i] * i
    
for i in range(MAX - 2, -1, -1):
    if i == MAX - 1:
        fact[i] = fact[i] * i
        continue
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
    fact[i] = fact[i] * i
"
"MOD = 998244353

def modmul(x, y, c = 0):
    return (x * y + c) % MOD

def inv(x):
    return pow(x, MOD - 2, MOD)

MAX = 10 ** 6

fact = [1]
for i in range(1, MAX):
    fact.append(modmul(i, fact[i-1]))

invfact = [1] * (MAX)
invfact[MAX - 1] = inv(fact[MAX - 1])
for {{completion}}:
    invfact[i] = modmul(i + 1, invfact[i+1])

def comb(x, y):
    return modmul(fact[x], modmul(invfact[y], invfact[x - y]))
    
def invcomb(x, y):
    return modmul(invfact[x], modmul(fact[y], fact[x - y]))
    
def invs(x):
    return modmul(fact[x - 1], invfact[x])

n = int(input())

out = [0] * n

for i in range((n + 1) // 2):
    base = fact[n - 1]
    frac = modmul(comb(n//2, i), invcomb(n - 1, i))
    
    out[i] = modmul(base, frac)

rem = 0   
for i in range(n - 1, -1, -1):
    oldrem = rem
    rem += modmul(out[i], invs(i))
    out[i] -= oldrem
    
    rem %= MOD
    out[i] %= MOD
    
print(' '.join(map(str,out)))","i in range(MAX - 2, -1, -1)","i = MAX - 2, -1, -1"
"import sys

# https://codeforces.com/contest/1701/problem/F

MAXN = 200000


class SegmentTree:
    def __init__(self):
        self.lazy = []
        self.v0 = []
        self.v1 = []
        self.v2 = []
        self.active = []

        for _ in range(4 * MAXN + 1):
            self.lazy.append(0)
            self.v0.append(1)
            self.v1.append(0)
            self.v2.append(0)
            self.active.append(True)

        self._init_active(1, 1, MAXN)

    def _init_active(self, x, l, r):
        if l == r:
            self.active[x] = False
        else:
            m = (l + r) // 2
            self._init_active(x * 2, l, m)
            self._init_active(x * 2 + 1, m + 1, r)
            self._reclac(x)

    def _reclac(self, x):
        self.v0[x] = 0
        self.v1[x] = 0
        self.v2[x] = 0

        if self.active[x * 2]:
            self.v0[x] += self.v0[x * 2]
            self.v1[x] += self.v1[x * 2]
            self.v2[x] += self.v2[x * 2]

        if self.active[x * 2 + 1]:
            self.v0[x] += self.v0[x * 2 + 1]
            self.v1[x] += self.v1[x * 2 + 1]
            self.v2[x] += self.v2[x * 2 + 1]

    def _push(self, x, l, r):
        la = self.lazy[x]

        if la == 0:
            return

        if l != r:
            self.v2[x * 2] = self.v2[x * 2] + 2 * la * self.v1[x * 2] + la * la * self.v0[x * 2]
            self.v1[x * 2] += la * self.v0[x * 2]

            self.v2[x * 2 + 1] = self.v2[x * 2 + 1] + 2 * la * self.v1[x * 2 + 1] + la * la * self.v0[x * 2 + 1]
            self.v1[x * 2 + 1] += la * self.v0[x * 2 + 1]

            self.lazy[x * 2] += la
            self.lazy[x * 2 + 1] += la

        self.lazy[x] = 0

    def update(self, x, l, r, a, b, up: bool):
        if r < a or b < l:
            return

        if a <= l and r <= b:
            if {{completion}}:
                self.v2[x] = self.v2[x] + 2 * self.v1[x] + self.v0[x]
                self.v1[x] += self.v0[x]

                self.lazy[x] += 1
            else:
                self.v2[x] = self.v2[x] - 2 * self.v1[x] + self.v0[x]
                self.v1[x] -= self.v0[x]

                self.lazy[x] -= 1
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.update(x * 2, l, m, a, b, up)
        self.update(x * 2 + 1, m + 1, r, a, b, up)

        self._reclac(x)

    def set_state(self, x, l, r, pos, up: bool):
        if pos < l or r < pos:
            return

        if l == r:
            self.active[x] = up
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.set_state(x * 2, l, m, pos, up)
        self.set_state(x * 2 + 1, m + 1, r, pos, up)

        self._reclac(x)


def solve():
    q, d = map(int, input().split())
    points = map(int, sys.stdin.readline().split())

    tree = SegmentTree()

    check = [0] * (MAXN + 1)
    ans = []
    for point in points:
        if check[point]:
            check[point] = 0
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, False)
            tree.set_state(1, 1, MAXN, point, False)
        else:
            check[point] = 1
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, True)
            tree.set_state(1, 1, MAXN, point, True)

        v1 = tree.v1[1]
        v2 = tree.v2[1]
        ans.append((v2 - v1) // 2)

    print('\n'.join(map(str, ans)))


if __name__ == '__main__':
    solve()",up,up
"import sys

# https://codeforces.com/contest/1701/problem/F

MAXN = 200000


class SegmentTree:
    def __init__(self):
        self.lazy = []
        self.v0 = []
        self.v1 = []
        self.v2 = []
        self.active = []

        for {{completion}}:
            self.lazy.append(0)
            self.v0.append(1)
            self.v1.append(0)
            self.v2.append(0)
            self.active.append(True)

        self._init_active(1, 1, MAXN)

    def _init_active(self, x, l, r):
        if l == r:
            self.active[x] = False
        else:
            m = (l + r) // 2
            self._init_active(x * 2, l, m)
            self._init_active(x * 2 + 1, m + 1, r)
            self._reclac(x)

    def _reclac(self, x):
        self.v0[x] = 0
        self.v1[x] = 0
        self.v2[x] = 0

        if self.active[x * 2]:
            self.v0[x] += self.v0[x * 2]
            self.v1[x] += self.v1[x * 2]
            self.v2[x] += self.v2[x * 2]

        if self.active[x * 2 + 1]:
            self.v0[x] += self.v0[x * 2 + 1]
            self.v1[x] += self.v1[x * 2 + 1]
            self.v2[x] += self.v2[x * 2 + 1]

    def _push(self, x, l, r):
        la = self.lazy[x]

        if la == 0:
            return

        if l != r:
            self.v2[x * 2] = self.v2[x * 2] + 2 * la * self.v1[x * 2] + la * la * self.v0[x * 2]
            self.v1[x * 2] += la * self.v0[x * 2]

            self.v2[x * 2 + 1] = self.v2[x * 2 + 1] + 2 * la * self.v1[x * 2 + 1] + la * la * self.v0[x * 2 + 1]
            self.v1[x * 2 + 1] += la * self.v0[x * 2 + 1]

            self.lazy[x * 2] += la
            self.lazy[x * 2 + 1] += la

        self.lazy[x] = 0

    def update(self, x, l, r, a, b, up: bool):
        if r < a or b < l:
            return

        if a <= l and r <= b:
            if up:
                self.v2[x] = self.v2[x] + 2 * self.v1[x] + self.v0[x]
                self.v1[x] += self.v0[x]

                self.lazy[x] += 1
            else:
                self.v2[x] = self.v2[x] - 2 * self.v1[x] + self.v0[x]
                self.v1[x] -= self.v0[x]

                self.lazy[x] -= 1
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.update(x * 2, l, m, a, b, up)
        self.update(x * 2 + 1, m + 1, r, a, b, up)

        self._reclac(x)

    def set_state(self, x, l, r, pos, up: bool):
        if pos < l or r < pos:
            return

        if l == r:
            self.active[x] = up
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.set_state(x * 2, l, m, pos, up)
        self.set_state(x * 2 + 1, m + 1, r, pos, up)

        self._reclac(x)


def solve():
    q, d = map(int, input().split())
    points = map(int, sys.stdin.readline().split())

    tree = SegmentTree()

    check = [0] * (MAXN + 1)
    ans = []
    for point in points:
        if check[point]:
            check[point] = 0
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, False)
            tree.set_state(1, 1, MAXN, point, False)
        else:
            check[point] = 1
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, True)
            tree.set_state(1, 1, MAXN, point, True)

        v1 = tree.v1[1]
        v2 = tree.v2[1]
        ans.append((v2 - v1) // 2)

    print('\n'.join(map(str, ans)))


if __name__ == '__main__':
    solve()",_ in range(4 * MAXN + 1),"x in range(MAXN):
            self.lazy.append(0)
            self.v0.append(1)
            self.v1.append(0)
            self.v2.append(0)
            self.active.append(True)

        self._init_active(1, 1, MAXN)

    def _init_active(self, x, l, r):
        if l == r:
            self.active[x] = False
        else:
            m = (l + r) // 2
            self._init_active(x * 2, l, m)
            self._init_active(x * 2 + 1, m + 1, r)
            self._reclac(x)

    def _reclac(self, x):
        self.v0[x] = 0
        self.v1[x] = 0
        self.v2[x] = 0

        if self.active[x * 2]:
            self.v0[x] += self.v0[x * "
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class LazySegmentTree():
    def __init__(self, n, op, e, mapping, composition, id):
        self.n = n
        self.op = op
        self.e = e
        self.mapping = mapping
        self.composition = composition
        self.id = id
        self.log = (n - 1).bit_length()
        self.size = 1 << self.log
        self.data = [e] * (2 * self.size)
        self.lazy = [id] * self.size

    def update(self, k):
        self.data[k] = self.op(self.data[2 * k], self.data[2 * k + 1])

    def all_apply(self, k, f):
        self.data[k] = self.mapping(f, self.data[k])
        if k < self.size:
            self.lazy[k] = self.composition(f, self.lazy[k])

    def push(self, k):
        self.all_apply(2 * k, self.lazy[k])
        self.all_apply(2 * k + 1, self.lazy[k])
        self.lazy[k] = self.id

    def build(self, arr):
        # assert len(arr) == self.n
        for i, a in enumerate(arr):
            self.data[self.size + i] = a
        for i in range(self.size - 1, 0, -1):
            self.update(i)

    def set(self, p, x):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = x
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def get(self, p):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        return self.data[p]

    def prod(self, l, r):
        # assert 0 <= l <= r <= self.n
        if l == r: return self.e
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push(r >> i)
        sml = smr = self.e
        while l < r:
            if l & 1:
                sml = self.op(sml, self.data[l])
                l += 1
            if r & 1:
                r -= 1
                smr = self.op(self.data[r], smr)
            l >>= 1
            r >>= 1
        return self.op(sml, smr)

    def all_prod(self):
        return self.data[1]

    def apply(self, p, f):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = self.mapping(f, self.data[p])
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def range_apply(self, l, r, f):
        # assert 0 <= l <= r <= self.n
        if l == r: return
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if {{completion}}: self.push((r - 1) >> i)
        l2 = l
        r2 = r
        while l < r:
            if l & 1:
                self.all_apply(l, f)
                l += 1
            if r & 1:
                r -= 1
                self.all_apply(r, f)
            l >>= 1
            r >>= 1
        l = l2
        r = r2
        for i in range(1, self.log + 1):
            if ((l >> i) << i) != l: self.update(l >> i)
            if ((r >> i) << i) != r: self.update((r - 1) >> i)




n = 2*10**5+1
q, d = map(int, input().split())
arr = list(map(int, input().split()))
v = [0]*n

def op(x, y):
    return [x[0]+y[0], x[1]+y[1], x[2]+y[2], x[3]]

def mapping(k, x):
    return [x[0], k*x[0]+x[1], k*k*x[0]+2*k*x[1]+x[2], x[3]+k]

def composition(f, g):
    return f+g

e = [0, 0, 0, 0]
id = 0

st = LazySegmentTree(n, op, e, mapping, composition, id)
st.build([[0, 0, 0, 0] for i in range(n)])
for x in arr:
    v[x] ^= 1
    m = st.get(x)[3]
    if v[x]:
        st.range_apply(x+1, min(x+d+1, n), 1)
        st.set(x, [1, m, m*m, m])
    else:
        st.range_apply(x+1, min(x+d+1, n), -1)
        st.set(x, [0, 0, 0, m])
    a = st.all_prod()
    print((a[2]-a[1])//2)

",((r >> i) << i) != r,"((r >> i) << i) != r: self.push(r >> i)
        l2 = l
        r2 = r
        while l < r:
            if l & 1:
                self.apply(l, f)
                l += 1
            if r & 1:
                r -= 1
                self.apply(r, f)
            l >>= 1
            r >>= 1
        l = l2
        r = r2
        for i in range(1, self.log + 1):
            if ((l >> i) << i) != l: self.update(l >> i)
            if ((r >> i) << i) != r: self.update((r - 1) >> i)

    def range_range_apply(self, l, r, f, g):
        assert 0 <= l <= r <= self.n
"
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class LazySegmentTree():
    def __init__(self, n, op, e, mapping, composition, id):
        self.n = n
        self.op = op
        self.e = e
        self.mapping = mapping
        self.composition = composition
        self.id = id
        self.log = (n - 1).bit_length()
        self.size = 1 << self.log
        self.data = [e] * (2 * self.size)
        self.lazy = [id] * self.size

    def update(self, k):
        self.data[k] = self.op(self.data[2 * k], self.data[2 * k + 1])

    def all_apply(self, k, f):
        self.data[k] = self.mapping(f, self.data[k])
        if k < self.size:
            self.lazy[k] = self.composition(f, self.lazy[k])

    def push(self, k):
        self.all_apply(2 * k, self.lazy[k])
        self.all_apply(2 * k + 1, self.lazy[k])
        self.lazy[k] = self.id

    def build(self, arr):
        # assert len(arr) == self.n
        for i, a in enumerate(arr):
            self.data[self.size + i] = a
        for i in range(self.size - 1, 0, -1):
            self.update(i)

    def set(self, p, x):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = x
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def get(self, p):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        return self.data[p]

    def prod(self, l, r):
        # assert 0 <= l <= r <= self.n
        if l == r: return self.e
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push(r >> i)
        sml = smr = self.e
        while l < r:
            if l & 1:
                sml = self.op(sml, self.data[l])
                l += 1
            if r & 1:
                r -= 1
                smr = self.op(self.data[r], smr)
            l >>= 1
            r >>= 1
        return self.op(sml, smr)

    def all_prod(self):
        return self.data[1]

    def apply(self, p, f):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = self.mapping(f, self.data[p])
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def range_apply(self, l, r, f):
        # assert 0 <= l <= r <= self.n
        if l == r: return
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push((r - 1) >> i)
        l2 = l
        r2 = r
        while l < r:
            if {{completion}}:
                self.all_apply(l, f)
                l += 1
            if r & 1:
                r -= 1
                self.all_apply(r, f)
            l >>= 1
            r >>= 1
        l = l2
        r = r2
        for i in range(1, self.log + 1):
            if ((l >> i) << i) != l: self.update(l >> i)
            if ((r >> i) << i) != r: self.update((r - 1) >> i)




n = 2*10**5+1
q, d = map(int, input().split())
arr = list(map(int, input().split()))
v = [0]*n

def op(x, y):
    return [x[0]+y[0], x[1]+y[1], x[2]+y[2], x[3]]

def mapping(k, x):
    return [x[0], k*x[0]+x[1], k*k*x[0]+2*k*x[1]+x[2], x[3]+k]

def composition(f, g):
    return f+g

e = [0, 0, 0, 0]
id = 0

st = LazySegmentTree(n, op, e, mapping, composition, id)
st.build([[0, 0, 0, 0] for i in range(n)])
for x in arr:
    v[x] ^= 1
    m = st.get(x)[3]
    if v[x]:
        st.range_apply(x+1, min(x+d+1, n), 1)
        st.set(x, [1, m, m*m, m])
    else:
        st.range_apply(x+1, min(x+d+1, n), -1)
        st.set(x, [0, 0, 0, m])
    a = st.all_prod()
    print((a[2]-a[1])//2)

",l & 1,"l & 1:
                l2 = self.op(l2, self.data[l])
                l += 1
            if r & 1:
                r2 -= 1
                self.op(r2, self.data[r])
            l >>= 1
            r >>= 1
        self.push(l2)
        self.push(r2)
        while l < r:
            if l & 1:
                l2 = self.op(l2, self.data[l])
                l += 1
            if r & 1:
                r2 -= 1
                self.op(r2, self.data[r])
            l >>= 1
            r >>= 1
        self.push(l2)
        self.push(r2)

    def range_push(self, l, r):
        if l "
"n,k = map(int,input().split())
ns = set()
for {{completion}}:
    s = tuple(int(v) for v in input().split())
    ns.add(s)
arr = [[tuple((6-v1[i]-v2[i])%3 for i in range(k)) in ns for v1 in ns] for v2 in ns]
ans = 0
for i in range(n):
    s = sum(arr[i])-2
    ans += s*s//8
print(ans)",_ in range(n),"_ in range(n):
    s = tuple(int(v) for v in input().split())
    ns.add(s)
arr = [[tuple((6-v1[i]-v2[i])%3 for i in range(k)) in ns for v1 in ns] for v2 in ns]
ans = 0
for i in range(n):
    s = sum(arr[i])-2
    ans += s*s//8
print(ans)
<|/ q dscore=0 |>
<| c |>
Please read [ask] and [MCVE].  What have you tried so far?
<|/ c |>
<| c |>
Please [edit] your question to show [what you have tried so far](http://whathaveyoutri"
"n,k = map(int,input().split())
ns = set()
for _ in range(n):
    s = tuple(int(v) for v in input().split())
    ns.add(s)
arr = [[tuple((6-v1[i]-v2[i])%3 for i in range(k)) in ns for v1 in ns] for v2 in ns]
ans = 0
for {{completion}}:
    s = sum(arr[i])-2
    ans += s*s//8
print(ans)",i in range(n),"_ in range(n//8):
    ans += sum(arr[0])-2
    ans += sum(arr[1])-2
    ans += sum(arr[2])-2
for i in range(n//8):
    ans += sum(arr[i+1])-2
    ans += sum(arr[i+2])-2
for i in range(n//8):
    ans += sum(arr[i+3])-2
for i in range(n//8):
    ans += sum(arr[i+4])-2
for i in range(n//8):
    ans += sum(arr[i+5])-2
for i in range(n//8):
    ans += sum(arr[i+6])-2
for i in range(n//8):
    ans += sum(arr[i+7])-2"
"from sys import stdin

def missing(c1, c2):
    c3 = []
    for i in range(len(c1)):
        if c1[i] == c2[i]:
            c3.append(c1[i])
        else:
            c3.append(next(iter({""0"", ""1"", ""2""}.difference({c1[i], c2[i]}))))

    return """".join(c3)

def solve():
    n, k = map(int, stdin.readline().split())
    cards = [stdin.readline().strip().replace("" "", """") for i in range(n)]
    
    off1 = {c:0 for c in cards}

    for i in range(n):
        for j in range(i+1, n):
            m = missing(cards[i], cards[j])
            if {{completion}}:
                off1[m] += 1

    print(sum(i*(i-1)//2 for i in off1.values()))

solve()",m in off1,"m != """":
                off1[m] += 1
            elif m == """" and off1[cards[i]] > off1[cards[j]]"
"ndfeagbb, dfeagbbk = map(int, input().split())
cards = [tuple(map(int, input().split())) for _ in range(ndfeagbb)]
cards_lookup, counter = {card: i for i, card in enumerate(cards)}, [0] * (ndfeagbb + 1)
for i in range(len(cards) - 1):
    for {{completion}}:
        counter[cards_lookup.get(tuple(x if x == y else ((x + 1) ^ (y + 1)) - 1 for x, y in zip(cards[i], cards[j])), -1)] += 1
print(sum(x * (x - 1) // 2 for x in counter[:-1]))
","j in range(i + 1, len(cards))","j in range(i + 1, len(cards)):
        if cards_lookup.get(tuple(x if x == y else ((x + 1) ^ (y + 1)) - 1 for x, y in zip(cards[i], cards[j])), -1) != -1:
            counter[cards_lookup.get(tuple(x if x == y else ((x + 1) ^ (y + 1)) - 1 for x, y in zip(cards[i], cards[j]))] += 1
print(sum(x * (x - 1) // 2 for x in counter[:-1]))
<|/ q dscore=0 |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have tried so far.
"
"from sys import stdin, stdout

n, k = [int(x) for x in stdin.readline().split()]
cards = set()
for i in range(n):
    cards.add(tuple([int(x) for x in stdin.readline().split()]))

answer = 0
for card in cards:
    yes_v = 0
    for v in cards:
        w = []
        for {{completion}}:
            w.append((3-card[i]-v[i])%3)
        if tuple(w) in cards:
            yes_v += 1

    yes_v = (yes_v-1)//2
    answer += (yes_v * (yes_v-1))//2

stdout.write(str(answer)+'\n')
",i in range(k),"i,x in enumerate(card):
            if x==v[i]:
                w.append(x)
            else:
                w.append((3-card[i]-v[i])%3)
        if tuple(w) in cards:
            yes_v += 1

    yes_v = (yes_v-1)//2
    answer += (yes_v * (yes_v-1))//2

stdout.write(str(answer)+'\n')
""""""
<|/ q tags=python,python-3.x |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
I added the code I tried
<|/ c |>"
"from sys import stdin, stdout

n, k = [int(x) for x in stdin.readline().split()]
cards = set()
for i in range(n):
    cards.add(tuple([int(x) for x in stdin.readline().split()]))

answer = 0
for card in cards:
    yes_v = 0
    for v in cards:
        w = []
        for i in range(k):
            w.append((3-card[i]-v[i])%3)
        if {{completion}}:
            yes_v += 1

    yes_v = (yes_v-1)//2
    answer += (yes_v * (yes_v-1))//2

stdout.write(str(answer)+'\n')
",tuple(w) in cards,"w == [0, 0, 0]"
"import sys; R = sys.stdin.readline
n,k = map(int,R().split())
deck = [tuple(map(int,R().split())) for _ in range(n)]
dic = {}
for i in range(n): dic[deck[i]] = i
res = [0]*n
for p in range(n-2):
    for q in range(p+1,n-1):
        last = [0]*k
        for {{completion}}:
            last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
        last = tuple(last)
        if last in dic and dic[last]>q:
            res[p] += 1; res[q] += 1; res[dic[last]] += 1
print(sum((s*(s-1))//2 for s in res))",j in range(k),"j in range (k): last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
        last = tuple(last)
        if last in dic and dic[last]>q:
            res[p] += 1; res[q] += 1; res[dic[last]] += 1
print(sum((s*(s-1))//2 for s in res))
<|/ q tags=python,algorithm |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Please post the code you have tried so far.
"
"import sys; R = sys.stdin.readline
n,k = map(int,R().split())
deck = [tuple(map(int,R().split())) for _ in range(n)]
dic = {}
for i in range(n): dic[deck[i]] = i
res = [0]*n
for p in range(n-2):
    for q in range(p+1,n-1):
        last = [0]*k
        for j in range(k):
            last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
        last = tuple(last)
        if {{completion}}:
            res[p] += 1; res[q] += 1; res[dic[last]] += 1
print(sum((s*(s-1))//2 for s in res))",last in dic and dic[last]>q,"last in dic:
            res[p] += 1; res[q] += 1; res[dic[last]] += 1
print(sum((s*(s-1))//2 for s in res))
<|/ a dscore=0 |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
I added the explanation
<|/ c |>
<| a dscore=0 |>
<code>
import sys; R = sys.stdin.readline
n,k = map(int,R().split())
deck = [tuple(map(int,R().split())) for _ in range(n)]
dic = {}
for i in range("
"
n,k=map(int,input().split())
a=[]
d={}
for i in range(n):
    a+=[''.join(input().split())]
    d[a[-1]]=0


def cal(s,t):
    res=""""
    for {{completion}}:
        res+=str((9-int(s[i])-int(t[i]))%3)
    return res



for i in range(n):
    for j in range(i):
        try:
            d[cal(a[i],a[j])]+=1
        except:
            pass

ans=0
for y in d.values():
    ans+=(y*(y-1))//2
print(ans)

",i in range(k),"i,j in zip(s,t):
        res+=str(int(i)-int(j))
    return res

def cal2(s,t):
    res=""""
    for i in range(9):
        if int(s[i])>int(t[i]):
            res+=str((int(s[i])-int(t[i]))%3)
        elif int(s[i])<int(t[i]):
            res+=str((9-int(s[i])-int(t[i]))%3)
    return res

def cal3(s,t):
    res=""""
    for i in range(9):
        if int(s[i])>int(t[i]):
            res+=str((int(s[i])-int(t[i]))%3)
        elif int(s[i])<int(t"
"
n,k=map(int,input().split())
a=[]
d={}
for i in range(n):
    a+=[''.join(input().split())]
    d[a[-1]]=0


def cal(s,t):
    res=""""
    for i in range(k):
        res+=str((9-int(s[i])-int(t[i]))%3)
    return res



for i in range(n):
    for {{completion}}:
        try:
            d[cal(a[i],a[j])]+=1
        except:
            pass

ans=0
for y in d.values():
    ans+=(y*(y-1))//2
print(ans)

",j in range(i),"j in range(i+1,n):
        if a[j]==a[i]:
            continue
        if cal(a[i],a[j])==a[j]:
            d[a[j]]+=1
        else:
            d[cal(a[i],a[j])]+=1
for j in range(n):
    if a[j] in d:
        d[a[j]]+=1
    else:
        d[cal(a[i],a[j])]+=1
for j in range(n):
    if a[j] in d:
        d[a[j]]+=1
    else:
        d[cal(a[i],a[j])]+=1
for j in range(n):
    if a[j] in d:
        d[a[j]]+=1
    else:
        d[cal(a[i],a[j])]+=1
for "
"n, k = [int(i) for i in input().split()]
a = []
for _ in range(n):
    a.append(tuple([int(i) for i in input().split()]))
a = tuple(a)
sus = set(a)

cs = [0 for i in range(n)]
for i in range(n):
    p = a[i]
    for j in set(range(n)) - set(tuple([i])):
        q = a[j]
        r = []
        for o in range(k):
            if {{completion}}:
                r.append(p[o])
            else:
                r.append(3-p[o]-q[o])
        if tuple(r) in sus:
            cs[i] += 1
            cs[j] += 1
cs = [i//4 for i in cs]
cs = [(i*(i-1))//2 for i in cs]
print(sum(cs))",p[o] == q[o],"p[o]==q[o] and p[o]>q[o]:
                r.append(p[o])
            elif p[o]>q[o]:
                r.append(3-p[o]-q[o])
            elif p[o]<q[o]:
                r.append(3-p[o]-q[o])
            else:
                r.append(3-p[o]-q[o])
        if tuple(r) in sus:
            cs[i] += 1
            cs[j] += 1
cs = [i//4 for i in cs]
cs = [(i*(i-1))//2 for i in cs]
print(sum(cs))
<|/ q dscore=0 |>
<| c |>
Please "
"for {{completion}}:
    n = input()
    a = sorted(map(int, input().split()))
    print(a[-1] + a[-2] - a[0] - a[1])",_ in range(int(input())),"_ in range(int(input())):
    n = int(input())
    a = sorted(map(int, input().split()))
    print(a[-1] + a[-2] - a[0] - a[1])
<|/ q dscore=0 |>
<| c |>
What is your question?
<|/ c |>
<| c |>
Please add your question to the post, not as a comment.
<|/ c |>
<| c |>
Please [edit] your question and add your question to the post. Comments are for asking clarifications or requests for clarifications.
<|/ c |>
<| c |>
Please read [ask] and [mc"
"for {{completion}}:a,b,*_,c,d=sorted(map(int,s.split()));print(c+d-a-b)",s in[*open(0)][2::2],"_ in range(int(input())):
    n=int(input())
    a=list(map(int,input().split()))
    l=7
    r=8
    s=""""
    for i in range(l-1,r+1):
        s=s+str(a[i])+"",""
    s=s[:-1]
    s=s+str(a[l])+"",""
    s=s[:-1]
    s=s+str(a[r])+"",""
    s=s[:-1]
    s=s+str(a[r+1])+"",""
    s=s[:-1]
    s=s+str(a[r+2])+"",""
    s=s[:-1]
    s=s+str(a[n])+"",""
    s=s[:-1]
    s=s+"
"for {{completion}}:input();a,b,*_,c,d=sorted(map(int,input().split()));print(c+d-a-b)",t in range(int(input())),"_ in range(int(input())):
    n=int(input())
    arr=list(map(int,input().split()))
    arr.sort()
    ans=max(arr[0],arr[1])
    for i in range(2,n):
        ans=max(ans,max(arr[i],arr[i-1]))
        ans=max(ans,max(arr[i],arr[i+2]))
        ans=max(ans,max(arr[i-1],arr[i+2]))
    print(ans)
<|/ a dscore=0 |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your "
"for {{completion}}:p,q,*_,r,s=sorted(map(int,sdr.split()));print(r+s-p-q)",sdr in[*open(0)][2::2],"_ in range(int(input())):
    sdr=input()
    p,q,*_,r,s=sorted(map(int,sdr.split()))
    print(max(r+1,s+1) - min(p,q) + max(p,q) - min(p,q))

'''
<|/ a dscore=0 |>
<| c |>
Thanks for your answer. Can you please explain me the code you wrote?
<|/ c |>
<| c |>
I have added the explanation to the answer
<|/ c |>
<| c |>
Thanks for your answer. Can you please explain me the code you wro"
"for {{completion}}:
    input()
    a, b, *_, c, d = sorted(map(int, input().split()))
    print(c+d-a-b)
    ",_ in range(int(input())),"_ in range(int(input())):
    n, *a = sorted(map(int, input().split()))
    l = r = 0
    while l < r:
        mid = (l+r) // 2
        if a[mid] > a[mid+1]:
            l = mid+1
        else:
            r = mid
    print(max(max(a[l], a[r]), min(a[l], a[r])) - min(a[l], a[r]) + max(a[l+1:r]) - min(a[l+1:r]))

for _ in range(int(input())):
    n, *a = sorted(map(int, input().split()))
    l = r = 0
    while l < r:
        mid"
"for {{completion}}:
    input()
    a = sorted(map(int, input().split()))
    print(a[-1] + a[-2] - a[0] - a[1])
",_ in range(int(input())),"_ in range(int(input())):
    n = int(input())
    a = sorted(map(int, input().split()))
    l = 7
    r = 8
    beauty = max(a[l], a[r]) - min(a[l], a[r]) + max(a[l+1:r]) - min(a[l+1:r])
    print(beauty)
<|/ q tags=python-3.x,python |>
<| c |>
What is the question?
<|/ c |>
<| c |>
Please [edit] your question and add the question to the body of the question. Don't post it as a comment. Also, please format your code properly.
<|/ c "
"import sys
import math
import heapq
import itertools
import bisect
import random
from decimal import *
from collections import deque
input=sys.stdin.readline

def extended_gcd(a,b):
    x0,x1,y0,y1=1,0,0,1
    while b!=0:
        n,a,b=a//b,b,a%b
        x0,x1=x1,x0-n*x1
        y0,y1=y1,y0-n*y1
    return x0,y0

n=int(input())
arr=[]
ans=0
for i in range(n):
    a,b=map(int,input().split())
    ans+=a
    arr.append(b-a)
arr.sort(reverse=True)
s=[0]
for i in range(n):
    s.append(s[-1]+arr[i])
mp=s.index(max(s))

m=int(input())
for _ in range(m):
    a,b=map(int,input().split())
    k=math.gcd(a,b)
    if n%(math.gcd(a,b))==0:
        a1,b1=a//k,b//k
        x,y=extended_gcd(a1,b1)
        x,y=x*(n//k),y*(n//k)
        mod=math.lcm(a,b)
        p=(y*b)%mod
        if p>n:
            print(-1)
        else:
            p1=(mp//mod)*mod+p
            line=[p1,p1-mod,p1+mod]
            ma=-10**18
            for i in line:
                if {{completion}}:
                    ma=max(ma,s[i])
            print(ma+ans)
            
            
            
    else:
        print(-1)
        
        
            






        
",0<=i<=n,"i>=0:
                    heapq.heappush(s,i)
                elif i<0:
                    heapq.heappop(s,i)
                if i>"
"input = __import__('sys').stdin.readline


MOD = 998244353


d, n, m = map(int, input().split())
lamps = list(sorted(map(int, input().split()))) # n
points = list(sorted(map(int, input().split()))) # m

# 1. O(m^2) to find all interesting points (sould be around m^2 points)
positions = [x for x in points]
positions.append(0)
positions.append(d)
for i in range(m):
    for j in range(i+1, m):
        mid = (points[i] + points[j]) // 2
        positions.append(mid)
        positions.append(mid+1)
positions = list(sorted(set(positions)))
posmap = {x: i for i, x in enumerate(positions)}

# print('points', points)
# print('positions', positions)

# 2. O(nm) to precompute QueryL and QueryR
i = 0
queryL = []
for p in points:
    queries = [0] * len(positions)
    while positions[i] < p:
        i += 1

    j = i    
    q = 1
    for x in lamps:
        if x <= p:
            continue
        while x > positions[j]:
            queries[j] = q
            j += 1
        q = q * (x - p) % MOD
    
    while j < len(positions):
        queries[j] = q
        j += 1
    
    queryL.append(queries)
    # print('L p:', p, queries)

i = len(positions)-1
queryR = []
for p in points[::-1]:
    queries = [0] * len(positions)
    while positions[i] > p:
        i -= 1

    j = i
    q = 1
    for x in lamps[::-1]:
        if x > p:
            continue
        while x < positions[j]:
            queries[j] = q
            j -= 1
        q = q * (p - x) % MOD
    while j >= 0:
        queries[j] = q
        j -= 1
    
    queryR.append(queries)
    # print('R p:', p, queries)

queryR = queryR[::-1]
# print('queryL', queryL)
# print('queryR', queryR)

# 3. O(m*2^m) to convert all mask to product of QueryL & QueryR and calculate the inclusion-exclusion & accumulate its SumQueryL[L..R] SumQueryR[L..R] values
querySums = [[[0]*len(positions) for _ in range(len(points))] for _ in range(2)]
current_ans = 0
for mask in range(1, 1 << m):
    keys = []
    prev_idx = -1
    popcnt = 0
    q = 1
    for i in range(m):
        if (mask >> i) & 1:
            p = points[i]
            if {{completion}}:
                keys.append((1, i, 0))
                q = q * queryR[i][0] % MOD
            else:
                prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD
            
            prev_idx = i
            popcnt += 1
    
    keys.append((0, prev_idx, len(positions)-1))
    q = q * queryL[prev_idx][-1] % MOD
    if popcnt & 1:
        current_ans = (current_ans - q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] - q) % MOD
    else:
        current_ans = (current_ans + q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD
    
    # print('mask', ('{:0' + str(m) + 'b}').format(mask), q, keys)

for j in range(m):
    for k in range(len(positions) -2, -1, -1):
        querySums[0][j][k] = (querySums[0][j][k] + querySums[0][j][k+1]) % MOD
    for k in range(1, len(positions)):
        querySums[1][j][k] = (querySums[1][j][k] + querySums[1][j][k-1]) % MOD

# 4. for each query, update the total ans by affected SumQueryL and SumQueryR (those with L <= x <= R)
current_ans += pow(d+1, n+1, MOD)
current_ans %= MOD

_ = int(input())
for x in map(int, input().split()):
    ans = current_ans

    for i in range(len(positions)):
        if positions[i] >= x:
            pos = i
            break

    for j in range(m):
        if points[j] < x:
            total = querySums[0][j][pos]
            ans -= total
            ans += total * (x - points[j]) % MOD
            ans %= MOD
    
    for i in range(len(positions)-1, -1, -1):
        if positions[i] <= x:
            pos = i
            break
    
    for j in range(m):
        if x <= points[j]:
            total = querySums[1][j][pos]
            ans -= total
            ans += total * (points[j] - x) % MOD
            ans %= MOD

    print(ans)
",prev_idx == -1,"prev_idx == -1:
                keys.append((0, i, 0))
                q = q * queryL[i][0] % MOD
            else:
                prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD
            
            prev_idx = i
            popcnt += 1
    
    keys.append((0, prev_idx, len(positions)-1))
    q = q"
"input = __import__('sys').stdin.readline


MOD = 998244353


d, n, m = map(int, input().split())
lamps = list(sorted(map(int, input().split()))) # n
points = list(sorted(map(int, input().split()))) # m

# 1. O(m^2) to find all interesting points (sould be around m^2 points)
positions = [x for x in points]
positions.append(0)
positions.append(d)
for i in range(m):
    for j in range(i+1, m):
        mid = (points[i] + points[j]) // 2
        positions.append(mid)
        positions.append(mid+1)
positions = list(sorted(set(positions)))
posmap = {x: i for i, x in enumerate(positions)}

# print('points', points)
# print('positions', positions)

# 2. O(nm) to precompute QueryL and QueryR
i = 0
queryL = []
for p in points:
    queries = [0] * len(positions)
    while positions[i] < p:
        i += 1

    j = i    
    q = 1
    for x in lamps:
        if x <= p:
            continue
        while x > positions[j]:
            queries[j] = q
            j += 1
        q = q * (x - p) % MOD
    
    while j < len(positions):
        queries[j] = q
        j += 1
    
    queryL.append(queries)
    # print('L p:', p, queries)

i = len(positions)-1
queryR = []
for p in points[::-1]:
    queries = [0] * len(positions)
    while positions[i] > p:
        i -= 1

    j = i
    q = 1
    for x in lamps[::-1]:
        if x > p:
            continue
        while x < positions[j]:
            queries[j] = q
            j -= 1
        q = q * (p - x) % MOD
    while j >= 0:
        queries[j] = q
        j -= 1
    
    queryR.append(queries)
    # print('R p:', p, queries)

queryR = queryR[::-1]
# print('queryL', queryL)
# print('queryR', queryR)

# 3. O(m*2^m) to convert all mask to product of QueryL & QueryR and calculate the inclusion-exclusion & accumulate its SumQueryL[L..R] SumQueryR[L..R] values
querySums = [[[0]*len(positions) for _ in range(len(points))] for _ in range(2)]
current_ans = 0
for mask in range(1, 1 << m):
    keys = []
    prev_idx = -1
    popcnt = 0
    q = 1
    for i in range(m):
        if (mask >> i) & 1:
            p = points[i]
            if prev_idx == -1:
                keys.append((1, i, 0))
                q = q * queryR[i][0] % MOD
            else:
                prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD
            
            prev_idx = i
            popcnt += 1
    
    keys.append((0, prev_idx, len(positions)-1))
    q = q * queryL[prev_idx][-1] % MOD
    if popcnt & 1:
        current_ans = (current_ans - q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] - q) % MOD
    else:
        current_ans = (current_ans + q) % MOD
        for {{completion}}:
            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD
    
    # print('mask', ('{:0' + str(m) + 'b}').format(mask), q, keys)

for j in range(m):
    for k in range(len(positions) -2, -1, -1):
        querySums[0][j][k] = (querySums[0][j][k] + querySums[0][j][k+1]) % MOD
    for k in range(1, len(positions)):
        querySums[1][j][k] = (querySums[1][j][k] + querySums[1][j][k-1]) % MOD

# 4. for each query, update the total ans by affected SumQueryL and SumQueryR (those with L <= x <= R)
current_ans += pow(d+1, n+1, MOD)
current_ans %= MOD

_ = int(input())
for x in map(int, input().split()):
    ans = current_ans

    for i in range(len(positions)):
        if positions[i] >= x:
            pos = i
            break

    for j in range(m):
        if points[j] < x:
            total = querySums[0][j][pos]
            ans -= total
            ans += total * (x - points[j]) % MOD
            ans %= MOD
    
    for i in range(len(positions)-1, -1, -1):
        if positions[i] <= x:
            pos = i
            break
    
    for j in range(m):
        if x <= points[j]:
            total = querySums[1][j][pos]
            ans -= total
            ans += total * (points[j] - x) % MOD
            ans %= MOD

    print(ans)
","i, j, k in keys","(i, j, k) in keys:
            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"import sys
input=sys.stdin.readline
R=lambda:map(int,input().split())
n,m=R();r,c,tr,tc=[0]*(n+1),[0]*(n+1),[0]*(n+1),[0]*(n+1)
def A(t,i,v):
  while i<=n:t[i]+=v;i+=i&(-i)
def Q(t,i):
  s=0
  while i:s+=t[i];i-=i&(-i)
  return s
for _ in range(m):
  v=[*R()];op,x,y=v[:3]
  if op==1:
    r[x]+=1;c[y]+=1
    if r[x]==1:A(tr,x,1)
    if c[y]==1:A(tc,y,1)
  elif op==2:
    r[x]-=1;c[y]-=1
    if {{completion}}:A(tr,x,-1)
    if c[y]==0:A(tc,y,-1)
  else:
    x1,y1=v[3:]
    print('Yes' if Q(tr,x1)-Q(tr,x-1)==x1-x+1 or Q(tc,y1)-Q(tc,y-1)==y1-y+1 else 'No')",r[x]==0,"r[x]==1:A(tr,x,-1)
    if c[y]==1:A(tc,y,-1)
  elif op==3:
    x1,y1,x2,y2=v[3:]
    print('Yes' if Q(tr,x1)-Q(tr,x2)==x1-x2 or Q(tc,y1)-Q(tc,y2)==y1-y2 else 'No')
  elif op==4:
    x1,y1,x2,y2=v[3:]
    print('Yes' if Q(tr,x1)-Q(tr,x2)==x1-x2 or Q(tc,y1)-Q(tc,y2)==y1-y"
"class BIT:
  def __init__(self, n, element):
    self.num = n
    self.ele = element
    self.data = [self.ele] * (self.num + 1)
  
  def calc(self, x, y):
    return x + y
 
  def update(self, idx, x):
    while idx <= self.num:
      self.data[idx] = self.calc(self.data[idx], x)
      idx += idx & -idx
  
  def sum(self, idx):
    res = self.ele
    while idx > 0:
      res = self.calc(res, self.data[idx])
      idx -= idx & -idx
    return res
  
  def prod(self, l, r):
    return self.sum(r) - self.sum(l-1)

import sys
input = sys.stdin.readline
n, q = map(int, input().split())
cntb, cntv = [0] * n, [0] * n
bitb = BIT(n, 0)
bitv = BIT(n, 0)
for _ in range(q):
  query = list(map(int, input().split()))
  if query[0] == 1:
    x, y = query[1], query[2]
    if cntb[x-1] == 0:
      bitb.update(x, 1)
    cntb[x-1] += 1
    if cntv[y-1] == 0:
      bitv.update(y, 1)
    cntv[y-1] += 1
  elif query[0] == 2:
    x, y = query[1], query[2]
    cntb[x-1] -= 1
    cntv[y-1] -= 1
    if {{completion}}:
      bitb.update(x, -1)
    if cntv[y-1] == 0:
      bitv.update(y, -1)
  else:
    flg = bitb.prod(query[1], query[3]) == query[3] - query[1] + 1 or bitv.prod(query[2], query[4]) == query[4] - query[2] + 1
    print(""Yes"" if flg else ""No"")",cntb[x-1] == 0,"cntb[x-1] == 0:
      bitb.update(x, -1)
    if cntv[y-1] == 0:
      bitv.update(y, -1)
  elif query[0] == 3:
    x, y = query[1], query[2]
    flg = bitb.prod(query[1], query[3]) == query[3] - query[1] + 1 or bitv.prod(query[2], query[4]) == query[4] - query[2] + 1
    print(""Yes"" if flg else ""No"")
  elif query[0] == 4:
    x, y = query[1], query[2]
    flg = bitb.prod(query[1], query[3]) == query[3] - query[1] + 1 or bitv.prod(query[2], query[4]) == query[4] - query[2] + 1
    print(""Yes"" if fl"
"import sys

def solve():
	inp = sys.stdin.readline
	n, q = map(int, inp().split())
	r = [0] * n
	c = [0] * n
	rc = [0] * n
	cc = [0] * n
	for i in range(q):
		ii = iter(map(int, inp().split()))
		t = next(ii)
		if t <= 2:
			x, y = ii
			vv = 1 if t == 1 else -1
			x -= 1
			w = int(rc[x] > 0)
			rc[x] += vv
			v = int(rc[x] > 0) - w
			while x < n:
				r[x] += v
				x = (x | (x + 1))
			x = y - 1
			w = int(cc[x] > 0)
			cc[x] += vv
			v = int(cc[x] > 0) - w
			while x < n:
				c[x] += v
				x = (x | (x + 1))
		else:
			x1, y1, x2, y2 = ii
			v = 0
			x = x2 - 1
			while {{completion}}:
				v += r[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while x >= 0:
				v -= r[x]
				x = (x & (x + 1)) - 1
			if v == x2 - x1 + 1:
				print('Yes')
				continue
			v = 0
			x = y2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = y1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
				print('No')


def main():
	solve()


if __name__ == '__main__':
	main()
",x >= 0,"x >= 0:
				v += r[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while x >= 0:
				v -= r[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
				continue
			v = 0
			x = y2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = y1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
"
"import sys

def solve():
	inp = sys.stdin.readline
	n, q = map(int, inp().split())
	r = [0] * n
	c = [0] * n
	rc = [0] * n
	cc = [0] * n
	for i in range(q):
		ii = iter(map(int, inp().split()))
		t = next(ii)
		if t <= 2:
			x, y = ii
			vv = 1 if t == 1 else -1
			x -= 1
			w = int(rc[x] > 0)
			rc[x] += vv
			v = int(rc[x] > 0) - w
			while x < n:
				r[x] += v
				x = (x | (x + 1))
			x = y - 1
			w = int(cc[x] > 0)
			cc[x] += vv
			v = int(cc[x] > 0) - w
			while x < n:
				c[x] += v
				x = (x | (x + 1))
		else:
			x1, y1, x2, y2 = ii
			v = 0
			x = x2 - 1
			while x >= 0:
				v += r[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while x >= 0:
				v -= r[x]
				x = (x & (x + 1)) - 1
			if {{completion}}:
				print('Yes')
				continue
			v = 0
			x = y2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = y1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
				print('No')


def main():
	solve()


if __name__ == '__main__':
	main()
",v == x2 - x1 + 1,"v == y2 - y1 + 1:
				print('Yes')
			else:
				print('No')
			v = 0
			x = x2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
				print('No')
			v = 0
			x = x2 - 1
			while x >= 0:
				v += rc[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while "
"import math
from collections import defaultdict, deque, Counter
from sys import stdin
inf = int(1e18)
input = stdin.readline

#fenwick Tree
#D V ARAVIND

def add(ft, i, v):
    while i < len(ft):
        ft[i] += v
        i += i&(-i)

def get(ft, i):
    s = 0
    while (i > 0):
        s = s + ft[i]
        i = i - (i &(-i))
    return(s)



for _ in range (1):
    n,q = map(int, input().split())
    ftr = [0 for i in range (n+1)]
    ftc = [0 for i in range (n+1)]
    visr = [0 for i in range (n+1)]
    visc = [0 for i in range (n+1)]
    for _ in range (q):
        a = [int(i) for i in input().split()]
        if a[0] == 1:
            if visr[a[1]] == 0:
                add(ftr, a[1], 1)
            visr[a[1]] += 1
            if visc[a[2]] == 0:
                add(ftc, a[2], 1)
            visc[a[2]] += 1
        elif a[0] == 2:
            if {{completion}}:
                add(ftr, a[1], -1)
            visr[a[1]] -= 1
            if visc[a[2]] == 1:
                add(ftc, a[2], -1)
            visc[a[2]] -= 1
        else:
            sr = get(ftr, a[3]) - get(ftr, a[1]-1)
            sc = get(ftc, a[4]) - get(ftc, a[2]-1)
            if (sr == a[3] - a[1] + 1) or (sc == a[4]-a[2]+1):
                print(""YES"")
            else:
                print(""NO"")",visr[a[1]] == 1,"visr[a[1]] == 0:
                add(ftr, a[1], -1)
            visr[a[1]] -= 1
            if visc[a[2]] == 0:
                add(ftc, a[2], -1)
            visc[a[2]] -= 1
        elif a[0] == 3:
            if visr[a[1]] == 0 and visc[a[2]] == 0:
                print(""NO"")
            else:
                print(""YES"")
        elif a[0] == 4:
            if visr[a[1]] == 0 and visc[a[2]] == 0:
                print(""NO"")
            else:
                print(""YES"")
        elif a[0] == 5:
            if visr[a[1]] == 0 and visc[a[2]] == 0:
                print(""NO"")
"
"import math
from collections import defaultdict, deque, Counter
from sys import stdin
inf = int(1e18)
input = stdin.readline

#fenwick Tree
#D V ARAVIND

def add(ft, i, v):
    while i < len(ft):
        ft[i] += v
        i += i&(-i)

def get(ft, i):
    s = 0
    while (i > 0):
        s = s + ft[i]
        i = i - (i &(-i))
    return(s)



for _ in range (1):
    n,q = map(int, input().split())
    ftr = [0 for i in range (n+1)]
    ftc = [0 for i in range (n+1)]
    visr = [0 for i in range (n+1)]
    visc = [0 for i in range (n+1)]
    for _ in range (q):
        a = [int(i) for i in input().split()]
        if a[0] == 1:
            if visr[a[1]] == 0:
                add(ftr, a[1], 1)
            visr[a[1]] += 1
            if visc[a[2]] == 0:
                add(ftc, a[2], 1)
            visc[a[2]] += 1
        elif a[0] == 2:
            if visr[a[1]] == 1:
                add(ftr, a[1], -1)
            visr[a[1]] -= 1
            if visc[a[2]] == 1:
                add(ftc, a[2], -1)
            visc[a[2]] -= 1
        else:
            sr = get(ftr, a[3]) - get(ftr, a[1]-1)
            sc = get(ftc, a[4]) - get(ftc, a[2]-1)
            if {{completion}}:
                print(""YES"")
            else:
                print(""NO"")",(sr == a[3] - a[1] + 1) or (sc == a[4]-a[2]+1),"sr == 0 and sc == 0:
                print(""NO"")
            elif sr == 0 and sc > 0:
                print(""NO"")
            elif sr > 0 and sc == 0:
                print(""NO"")
            elif sr > 0 and sc > 0:
                print(""YES"")
            else:
                print(""NO"")
    for _ in range (q):
        a = [int(i) for i in input().split()]
        if a[0] == 1:
            if visr[a[1]] == 0:
                add(ftr, a[1], 1)
            visr[a[1]] += 1
            if visc[a[2]] == 0:
                add(ftc, a[2], 1)
            visc[a[2]] += 1
        elif a[0] == 2:
            if visr[a[1]] == 1:"
"import sys
def update(ind, val, tree, n):
    while ind <= n:
        tree[ind] += val
        ind += (ind & -ind)

def read(ind, tree):
    ans = 0
    while(ind > 0):
        ans += tree[ind]
        ind -= (ind & -ind)
    return ans

def query(l, r, tree):
    return read(r, tree) - read(l-1, tree)

n, q = map(int, sys.stdin.readline().split())
row = [0] * (n+1)
col = [0] * (n+1)
rtree = [0] * (n+1)
ctree = [0] * (n+1)
for i in range(q):
    inp = list(map(int, sys.stdin.readline().split()))
    t = inp[0]
    if t == 1:
        x = inp[1]
        y = inp[2]
        row[x] += 1
        col[y] += 1
        if row[x] == 1:
            update(x, 1, rtree, n)
        if col[y] == 1:
            update(y, 1, ctree, n)
    elif t == 2:
        x = inp[1]
        y = inp[2]
        row[x] -= 1
        col[y] -= 1
        if {{completion}}:
            update(x, -1, rtree, n)
        if col[y] == 0:
            update(y, -1, ctree, n)
    else:
        x1 = inp[1]
        y1 = inp[2]
        x2 = inp[3]
        y2 = inp[4]
        flag1 = True
        flag2 = True;
        if query(x1, x2, rtree) < x2 - x1 + 1:
            flag1 = False
        if query(y1, y2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")",row[x] == 0,"row[x] == -1:
            update(x, -1, rtree, n)
        if col[y] == -1:
            update(y, -1, ctree, n)
    elif t == 3:
        x1 = inp[1]
        y1 = inp[2]
        x2 = inp[3]
        y2 = inp[4]
        flag1 = True
        flag2 = True;
        if query(x1, x2, rtree) < x2 - x1 + 1:
            flag1 = False
        if query(y1, y2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")
    elif t == 4:
        x1 = inp[1]"
"import sys
def update(ind, val, tree, n):
    while ind <= n:
        tree[ind] += val
        ind += (ind & -ind)

def read(ind, tree):
    ans = 0
    while(ind > 0):
        ans += tree[ind]
        ind -= (ind & -ind)
    return ans

def query(l, r, tree):
    return read(r, tree) - read(l-1, tree)

n, q = map(int, sys.stdin.readline().split())
row = [0] * (n+1)
col = [0] * (n+1)
rtree = [0] * (n+1)
ctree = [0] * (n+1)
for i in range(q):
    inp = list(map(int, sys.stdin.readline().split()))
    t = inp[0]
    if t == 1:
        x = inp[1]
        y = inp[2]
        row[x] += 1
        col[y] += 1
        if row[x] == 1:
            update(x, 1, rtree, n)
        if col[y] == 1:
            update(y, 1, ctree, n)
    elif t == 2:
        x = inp[1]
        y = inp[2]
        row[x] -= 1
        col[y] -= 1
        if row[x] == 0:
            update(x, -1, rtree, n)
        if col[y] == 0:
            update(y, -1, ctree, n)
    else:
        x1 = inp[1]
        y1 = inp[2]
        x2 = inp[3]
        y2 = inp[4]
        flag1 = True
        flag2 = True;
        if {{completion}}:
            flag1 = False
        if query(y1, y2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")","query(x1, x2, rtree) < x2 - x1 + 1","query(x1, y1, rtree) < x2 - x1 + 1:
            flag1 = False
        if query(y1, y1, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")
        if query(x1, x2, rtree) < x2 - x1 + 1:
            flag1 = False
        if query(y1, x2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")
        if query(x2, x2, rtree) < x2 - x1 + 1:
            flag1 = False"
"import bisect
import collections
import heapq
import io
import math
import os
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
Mod = 1000000007

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

# for _ in range(int(_input())):
for _ in range(1):
    n, q = map(int, _input().split())
    a = [0] * (n + 1)
    b = [0] * (n + 1)
    x = [0] * (n + 1)
    y = [0] * (n + 1)
    for _ in range(q):
        o = list(map(int, _input().split()))
        if o[0] == 1:
            _, u, v = o
            a[u] += 1
            if a[u] == 1:
                while u <= n:
                    x[u] += 1
                    u += u & -u
            b[v] += 1
            if b[v] == 1:
                while v <= n:
                    y[v] += 1
                    v += v & -v
        elif o[0] == 2:
            _, u, v = o
            a[u] -= 1
            if a[u] == 0:
                while {{completion}}:
                    x[u] -= 1
                    u += u & -u
            b[v] -= 1
            if b[v] == 0:
                while v <= n:
                    y[v] -= 1
                    v += v & -v
        else:
            _, u1, v1, u2, v2 = o
            c = 0
            u = u2
            while u > 0:
                c += x[u]
                u -= u & -u
            u = u1 - 1
            while u > 0:
                c -= x[u]
                u -= u & -u
            d = 0
            v = v2
            while v > 0:
                d += y[v]
                v -= v & -v
            v = v1 - 1
            while v > 0:
                d -= y[v]
                v -= v & -v
            print('Yes' if c >= u2 - u1 + 1 or d >= v2 - v1 + 1 else 'No')",u <= n,"u <= n:
                    x[u] -= 1
                    u += u & -u
            b[v] -= 1
            if b[v] == 0:
                while v <= n:
                    y[v] -= 1
                    v += v & -v
        elif o[0] == 3:
            _, u1, v1, u2, v2 = o
            a[u1] += 1
            if a[u1] == 1:
                while u1 <= n:
                    x[u1] += 1
                    u1 += u1 & -u1
            b[v1] += 1
            if b[v1] == 1:
                while v1 <= n:
                    y[v1] += 1
                    v1 += v1 & -v1
            "
"f = open(0)
def R(): return map(int, next(f).split())


n, q = R()
d = {}
i = v = r = 0
for x in R():
    r += x
    i += 1
    d[i] = x
while q:
    q -= 1
    t, *x = R()
    if {{completion}}:
        i, x = x
        r += x - d.get(i, v)
        d[i] = x
    else:
        d = {}
        v, = x
        r = v * n
    print(r)
",t & 1,"t == 1:
        i, x = x
        r += x - d.get(i, v)
        d[i] = x
    elif t == 2:
        v = x[0]
    elif t == 3:
        v, = x
    elif t == 4:
        v, = x
    elif t == 5:
        v, = x
    elif t == 6:
        v, = x
    elif t == 7:
        v, = x
    elif t == 8:
        v, = x
    elif t == 9:
        v, = x
    elif t == 10:
        v, = x
    elif t == 11:
        v, = x
    elif t == 12:
        v, = x
    elif t == 13:
        v, = x
    elif t == "
"inp = [list(map(int, l.split())) for l in open(0).read().splitlines()]
n, q = inp[0]
a = inp[1]
last = 0
step = [-1] * n
laststep = -2
tot = sum(a)
 
for i, b in enumerate(inp[2:]):
    if b[0] == 1:
        if {{completion}}:
            tot += b[2] - a[b[1]-1] 
            a[b[1]-1] = b[2]
        else:
            tot += b[2] - last
            a[b[1]-1] = b[2]
        step[b[1]-1] = i
        print(tot)
    else:
        tot = b[1] * n
        last = b[1]
        laststep = i
        print(tot)",step[b[1]-1] > laststep,b[1] > last
"from collections import defaultdict
import sys
input = sys.stdin.readline
n, q = map(int, input().split())
t = dict(enumerate(map(int, input().split())))
ans = sum(t.values())
for i in range(q):
    p = list(map(int, input().split()))
    if {{completion}}:
        k = p[1]
        ans = n*p[1]
        t = defaultdict(lambda:k)
    else :
        ans += p[2] - t[p[1] - 1]
        t[p[1] - 1] = p[2]
    print(ans)",p[0] == 2,p[1]-1 in t 
"n,q = map(int, input().split(' '))
array = list(map(int, input().split(' ')))
d = {i:item for i,item in enumerate(array, start=1)}
tot = sum(array)
default = None
for _ in range(q):
    t, *a = map(int, input().split(' '))
    if t==1:
        i, x = a
        tot += (x-d.get(i, default))
        d[i] = x
    elif {{completion}}:
        default, = a
        tot = default*n
        d = {}
    print(tot)
",t==2,"t==2:
        tot += a[0]
    else:
        print(""Wrong input"")
if default is None:
    for a in d.values():
        if a is None:
            default = a
        else:
            default = None
if default is not None:
    for a in d.values():
        if a is None:
            default = a
            break
        else:
            default = None
if default is None:
    for a in d.values():
        if a is None:
            default = a
            break
        else:
            default = None
if default is None:
    for a in d.values():
        if a is None:
            default = a
            break
        else:
            default = None
if default is None:
    for a in d.values():
        if a is None:
"
"f=open(0)
s=lambda:map(int,next(f).split())
n,tst=s()
arr={}
i=g=ans=0
for x in s():ans+=x;i+=1;arr[i]=x
while tst:
    tst-=1;t,*x=s()
    if {{completion}}:i,x=x;ans+=x-arr.get(i,g);arr[i]=x
    else:arr={};g,=x;ans=g*n
    print(ans)
  ",t&1,"t==1:
        i,x=x
        ans+=x-arr.get(i,g);arr[i]=x
    elif t==2:
        g,=x
        ans+=g*n
    elif t==3:
        i,x=x
        ans+=x-arr.get(i,g);arr[i]=x
    elif t==4:
        i,x=x
        ans+=x-arr.get(i,g);arr[i]=x
    elif t==5:
        i,x=x
        ans+=x-arr.get(i,g);arr[i]=x
    elif t==6:
        i,x=x
        ans+=x-arr.get(i,"
"n, q = list(map(int, input().split()))

a = list(map(int, input().split()))
x, c, s, b = 0, 0, sum(a), [1]*(n)

for i in range(q):
    k = list(map(int, input().split()))
    if k[0]==1:
        j = k[1]-1
        if {{completion}}:
            s = s-a[j]+k[2]
        else:
            s = s-x+k[2]
            b[j] = c+1
        a[j] = k[2]
        print(s)
    else:
        c = c+1
        x = k[1]
        s = n*x
        print(s)
            
    
        ",b[j]>c,"j<0:
            j=j+n
        if j>=n:
            j=j-n
        if j<0:
            j=0
        if j>=n:
            j=n-1
        a[j] = k[2]
        print(s)
    elif k[0]==2:
        j = k[1]-1
        if j<0:
            j=j+n
        if j>=n:
            j=j-n
        if j<0:
            j=0
        if j>=n:
            j=n-1
        if a[j]==k[2]"
"f=open(0)        

n,q=map(int,next(f).split())
a = list(map(int,next(f).split()))
c = [-1]*n
X = 0
S = sum(a)
lst=-2

for idx in range(q):
    req = list(map(int,next(f).split()))

    if {{completion}}:
        i = req[1]-1
        x = req[2]
        current = X if c[i]<lst else a[i]
        S += x - current
        a[i] = x
        c[i] = idx

    else:
        X = req[1]
        S = X * n
        lst = idx

    print(S)




                

            

            
            
            
            
                
        
        
        

",(req[0] == 1),"req[0]==1:
        i = req[1]-1
        x = req[2]
        current = X if c[i]<lst else a[i]
        S += x - current
        a[i] = x
        c[i] = idx

    elif req[0]==2:
        X = req[1]
        S = X * n
        lst = idx

    else:
        X = req[1]
        S = X * n
        lst = idx

    print(S)




                

            

            
            
            
            
                
        
        
        

        
        
        
        
        
        
        
        
        
        
        
        
"
"import sys, math
input = sys.stdin.readline

n, q = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
d = {}
for i in range(n):
    d[i + 1] = a[i]   
type2 = 0
for i in range(q):
    t = [int(x) for x in input().split()]
    if {{completion}}:
        d[t[1]] = t[2]
    else:
        d.clear()
        type2 = t[1]
    print(type2*(n - len(d)) + sum(d.values()))",t[0] == 1,"t[0] == 1:
        d[t[1]] = t[2]
    elif t[0] == 2:
        d[t[1]] = t[2]
    else:
        d.clear()
        type2 = t[1]
    print(type2*(n - len(d)) + sum(d.values()))
'''
<|/ a |>
<| c |>
I appreciate your efforts but this question was asked in an online coding competition and I was not allowed to use any built-in functions. I did try the above code but it didn't work.
<|/ c |>
<| c |>
I see. Thanks for letting me know. I'll keep this in mind for future questions.
<|/ "
"import sys

input = sys.stdin.readline


def solve():
    n, m, k = map(int, input().split())
    arr = list(map(int, input().split()))
    graph = [[] for _ in range(n)]
    for i in range(m):
        u, v = map(int, input().split())
        graph[u-1].append(v-1)

    lo, hi = min(arr), max(arr)+1
    while lo < hi:
        mid = lo + (hi-lo)//2
        dp = [0]*n
        degree = [0]*n
        cnt = 0
        for i in range(n):
            if arr[i] > mid:
                continue
            cnt += 1
            for nei in graph[i]:
                if arr[nei] > mid:
                    continue
                degree[nei] += 1

        stack = []
        nums = 0
        for i in range(n):
            if degree[i] == 0 and arr[i] <= mid:
                stack.append(i)
                nums += 1

        while stack:
            curr = stack.pop()
            for nei in graph[curr]:
                if arr[nei] > mid:
                    continue
                degree[nei] -= 1
                if {{completion}}:
                    stack.append(nei)
                    dp[nei] = max(dp[nei], dp[curr] + 1)
                    nums += 1

        if nums != cnt or max(dp) >= k-1:
            hi = mid
        else:
            lo = mid + 1

    if lo == max(arr) + 1:
        return -1
    else:
        return lo


print(solve())",degree[nei] == 0,degree[nei] == 0 and arr[nei] <= mid
"import sys
from array import array
from collections import deque

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
debug = lambda *x: print(*x, file=sys.stderr)
out = array('i')


class graph:
    def __init__(self, n):
        self.n = n
        self.gdict = [array('i') for _ in range(n + 1)]
        self.deg = array('i', [0] * (n + 1))

    def add_uniedge(self, node1, node2):
        self.gdict[node1].append(node2)
        self.deg[node2] += 1

    def kahn(self):
        # enqueue all node with 0 in degree
        que, cnt = deque([(i, 0) for i in range(1, self.n + 1) if not self.deg[i]]), 0
        ret = 0

        while que:
            s, lev = que.popleft()
            ret = max(ret, lev)

            for i in self.gdict[s]:
                self.deg[i] -= 1
                if {{completion}}:
                    que.append((i, lev + 1))

            cnt += 1
        return cnt != valids or ret >= k - 1


n, m, k = inp(int)
a = array('i', [0] + inp(int))
g = graph(n)

for i in range(m):
    u, v = inp(int)
    g.add_uniedge(u, v)

be, en, ans = min(a[1:]), 10 ** 9, -1
orgdeg = g.deg[:]

while be <= en:
    md, valids = (be + en) >> 1, n
    for i in range(1, n + 1):
        if a[i] > md:
            valids -= 1
            g.deg[i] = 10 ** 6

            for j in g.gdict[i]:
                g.deg[j] -= 1

    if g.kahn():
        en, ans = md - 1, md
    else:
        be = md + 1

    g.deg = orgdeg[:]

print(ans)
",a[i] <= md and not self.deg[i],"i == lev:
                    que.append((i, lev + 1))

            cnt += 1
        return cnt != 0 or ret >= k - 1


n, m, k = inp(int)
a = array('i', [0] + inp(int))
g = graph(n)

for i in range(m):
    u, v = inp(int)
    g.add_uniedge(u, v)

be, en, ans = min(a[1:]), 10 ** 9, -1
orgdeg = g.deg[:]

while be <= en:
    md, valids = (be + en) >> 1, n
    for i in range(1, n + 1):
        if a[i] > md:
            valids -= 1
            g.deg[i] = 10 ** 6

            for j in g.g"
"from sys import stdin, stdout


n, m, k = [int(x) for x in stdin.readline().split()]
a = [int(x) for x in stdin.readline().split()]
edges = {i:[] for i in range(n)}
for bar in range(m):
    u, v = [int(x)-1 for x in stdin.readline().split()]
    edges[u].append(v)

a_copy = list(set(a))
a_copy.sort()

def check(bound):
    heights = [0]*n
    expanded = [0]*n
    parents = [-1]*n
    for root in range(n):
        if a[root] <= bound and heights[root] == 0:
            stack = [root]

            while len(stack) > 0:
                if heights[stack[-1]] > 0:
                    v = stack.pop()
                    expanded[v] = 2
                    if parents[v] != -1:
                        heights[parents[v]] = max(heights[parents[v]], 1 + heights[v])
                        if heights[parents[v]] >= k:
                            return True
                else:
                    v = stack[-1]
                    heights[v] = 1
                    if heights[v] >= k:
                        return True
                    expanded[v] = 1
                    for w in edges[v]:
                        if a[w] <= bound:
                            if {{completion}}:
                                return True

                            if heights[w] > 0:
                                heights[v] = max(heights[v], 1 + heights[w])
                                if heights[v] >= k:
                                    return True

                            else:
                                parents[w] = v
                                stack.append(w)

    return False

if not check(a_copy[-1]):
    stdout.write('-1\n')

else:
    upper = len(a_copy)-1
    lower = -1
    while upper - lower > 1:
        candidate = (upper+lower)//2
        if check(a_copy[candidate]):
            upper = candidate
        else:
            lower = candidate

    stdout.write(str(a_copy[upper])+'\n')
",expanded[w] == 1,"expanded[w] == 1:
                                expanded[w] = 2
                                stack.append(w)
                            else:
                                expanded[w] = 1
                                stack.append(w)
                        elif expanded[w] == 2:
                            expanded[w] = 1
                            stack.append(w)
                        else:
                            if expanded[w] == 2:
                                expanded[w] = 1
                                stack.append(w)
                            else:
                                parents[w] = v
                                stack.append(w)

    return False

if not check(a_copy[-1]):
    stdout.write('-1\n')

else:
    upper = len(a_copy)-1
    lower = -1
    while upper - lower > 1:
        candidate = (upper+lower)//2"
"import sys
input = sys.stdin.readline
n, m, k = list(map(int,input().split()))
arr = list(map(int,input().split()))

adj = [list() for _ in range(n)]
for i in range(m):
    u, v = list(map(int,input().split()))
    adj[u-1].append(v-1)
    
def dfs(u, vis, val, dist, group):
    
    vis[u] = True
    group[u] = 1
    for v in adj[u]:
        if arr[v] <= val :
            if group[v]:
                dist[u] = 10**18
                return True
            if not vis[v]:
                dfs(v, vis, val, dist, group)
                group[v] = 0
            dist[u] = max(dist[u], dist[v] + 1)
        if dist[u] >= k :
            return True
                

def ok(val):
    if k == 1:return True
    vis = [False] * n
    dist = [1] * n
    group = [0] * n
    for i in range(n):
        if arr[i] <= val and not vis[i]:
            stk = [i]
            while stk:
                u = stk.pop()
                if vis[u]:
                    for v in adj[u]:
                        if arr[v] <= val :
                            dist[u] = max(dist[u], dist[v] + 1)
                            if {{completion}}:
                                return True
                            group[v] = 0
                    group[u] = 0
                    continue
                stk.append(u)
                group[u] = 1
                vis[u] = True
                for v in adj[u]:
                    if group[v]:
                        return True
                    if arr[v] <= val :
                        if not vis[v]:
                            stk.append(v)
            group[i] = 0
    return False
            


sor = sorted(arr)
l = 0
r = n - 1
while l <= r :
    mid = (l + r) // 2
    if ok(sor[mid]):
        r = mid - 1
    else:
        l = mid + 1
if l == n:
    print(-1)
else:
    print(sor[l]) ",dist[u] >= k ,dist[u] >= k 
"import sys
input = sys.stdin.readline
n, m, k = list(map(int,input().split()))
arr = list(map(int,input().split()))

adj = [list() for _ in range(n)]
for i in range(m):
    u, v = list(map(int,input().split()))
    adj[u-1].append(v-1)
    
def dfs(u, vis, val, dist, group):
    
    vis[u] = True
    group[u] = 1
    for v in adj[u]:
        if arr[v] <= val :
            if group[v]:
                dist[u] = 10**18
                return True
            if not vis[v]:
                dfs(v, vis, val, dist, group)
                group[v] = 0
            dist[u] = max(dist[u], dist[v] + 1)
        if dist[u] >= k :
            return True
                

def ok(val):
    if k == 1:return True
    vis = [False] * n
    dist = [1] * n
    group = [0] * n
    for i in range(n):
        if arr[i] <= val and not vis[i]:
            stk = [i]
            while stk:
                u = stk.pop()
                if vis[u]:
                    for v in adj[u]:
                        if {{completion}}:
                            dist[u] = max(dist[u], dist[v] + 1)
                            if dist[u] >= k :
                                return True
                            group[v] = 0
                    group[u] = 0
                    continue
                stk.append(u)
                group[u] = 1
                vis[u] = True
                for v in adj[u]:
                    if group[v]:
                        return True
                    if arr[v] <= val :
                        if not vis[v]:
                            stk.append(v)
            group[i] = 0
    return False
            


sor = sorted(arr)
l = 0
r = n - 1
while l <= r :
    mid = (l + r) // 2
    if ok(sor[mid]):
        r = mid - 1
    else:
        l = mid + 1
if l == n:
    print(-1)
else:
    print(sor[l]) ",arr[v] <= val ,arr[v] <= val 
"test = int(input())

for i in range(test):
    ans = ""B""
    cnt =0
    while cnt < 8 :
        t = input()
        if t.strip() != '':
            cnt +=1
            if {{completion}}:
                ans = ""R""

    print(ans)            
    

    
        
    
    
    ","t == ""RRRRRRRR""","t[0] == 'R':
                ans = ""R""
            elif t[0] == 'B':
                ans = ""B""
            else:
                ans = ""B""
        else:
            cnt +=1
            if t[0] == 'R':
                ans = ""R""
            elif t[0] == 'B':
                ans = ""B""
            else:
                ans = ""B""
    print(ans)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"t=int(input())
for p in range(t):
    
    l=[]
    c=0
    a=['R','R','R','R','R','R','R','R']
    while(len(l)<8):
        s=input()
        if {{completion}}:
            l.append([*s])
    for i in range(8):
        if l[i]==a:
            c=1
            break
    print(""B"" if c!=1 else ""R"")",len(s)==8,"s=='':
            break
        if s=='R':
            l.append([*s])
        elif s=='B':
            l.append([*s])
        elif s=='.':
            l.append([*s])
        elif s=='R':
            l.append([*s])
        elif s=='B':
            l.append([*s])
        elif s=='.':
            l.append([*s])
        elif s=='R':
            l.append([*s])
        elif s=='B':
            l.append([*s])
        elif s=='.':
            l.append([*s])
        elif s=='R':
            l.append([*s])
        elif s"
"t=int(input())
for p in range(t):
    
    l=[]
    c=0
    a=['R','R','R','R','R','R','R','R']
    while(len(l)<8):
        s=input()
        if len(s)==8:
            l.append([*s])
    for i in range(8):
        if {{completion}}:
            c=1
            break
    print(""B"" if c!=1 else ""R"")",l[i]==a,"l[i][0]=='R':
            a[i]='R'
            c=1
            break
    for i in range(8):
        if l[i][7]=='R':
            a[i]='R'
            c=1
            break
    for i in range(8):
        if l[i][1]=='R':
            a[i]='R'
            c=1
            break
    for i in range(8):
        if l[i][6]=='R':
            a[i]='R'
            c=1
            break
    for i in range(8):
        if l[i][3]=='R':
            a[i]='R'
            c=1
            break
    for i in range(8):
        if l[i][2]=='R':
            a[i]='R'
"
"for _ in range(int(input())):
    l=[]
    ans=""B""
    while len(l)!=8:
        l.append(input())
        if {{completion}}:
            l.pop()

    for row in l:
        if row.count('R')==8:
            ans='R'
            break

    print(ans)
        
    ",len(l[-1])<8,"l[-1]=='B':
            ans='B'
            break
        if l[-1]=='R':
            ans='R'
            break
        if l[-1]=='.':
            ans='.'
            break
        if l[-1]=='R' and l[-2]=='B' and l[-3]=='R' and l[-4]=='B' and l[-5]=='R' and l[-6]=='B' and l[-7]=='R':
            ans='R'
            break
        if l[-1]=='R' and l[-2]=='B' and l[-3]=='R' and l[-4]=='B' and l[-5]=='R' and l[-6]=='"
"for _ in range(int(input())):
    l=[]
    ans=""B""
    while len(l)!=8:
        l.append(input())
        if len(l[-1])<8:
            l.pop()

    for row in l:
        if {{completion}}:
            ans='R'
            break

    print(ans)
        
    ",row.count('R')==8,"row[0]=='R':
            ans='R'
            break
        elif row[-1]=='B':
            ans='B'
            break
        elif row[0]=='B' and row[-1]=='R':
            ans='B'
            break
        elif row[0]=='B' and row[-1]=='B':
            ans='B'
            break
        elif row[0]=='R' and row[-1]=='B':
            ans='R'
            break
        elif row[0]=='R' and row[-1]=='R':
            ans='R'
            break
        elif row[0]=='B' and row[-1]=='R':
            ans='B'
            break"
"from sys import stdin
n = int(input())
lines = stdin.read().split()
a = 0
for ele in range(n):
    for i in range(8):
        if {{completion}}:
            print('R')
            break
    else:
        print('B')
    a+=8",lines[i+a].count('R') == 8,"lines[i] == 'R':
            print('R')
            break
    else:
        print('B')
    a+=8
for i in range(8):
    for j in range(8):
        if j==0 or j==7 or i==0 or i==7 or a==8 or a==7 or a==0 or a==1:
            print('.')
        else:
            print('B')
    a+=8
for i in range(8):
    for j in range(8):
        if j==0 or j==7 or i==0 or i==7 or a==8 or a==7 or a==0 or a==1:
            print('.')
        else:
            print('R')
    a+=8
for i in range(8"
"for _ in range(int(input())):
    met = []
    res = []
    judge = True
    i = 0
    while i <  8:
        tmp = input()
        met.append(tmp)
        if {{completion}}:
            i += 1
        if tmp == ""R"" * 8 and judge:
            print(""R"")
            judge = False

    if judge:
        print(""B"")
#    for i in met:
#        print(i)",tmp != '',"tmp == ""R"" * 8 and judge:
            print(""R"")
            judge = False
        if tmp == ""B"" * 8 and judge:
            print(""B"")
            judge = False
        if tmp == ""R"" * 8 and judge == False:
            print(""B"")
            judge = True
        if tmp == ""B"" * 8 and judge == False:
            print(""R"")
            judge = True
        if tmp == ""R"" * 8 and judge == True and judge == False:
            print(""B"")
            judge = False
        if tmp == ""B"" * 8 and judge == "
"for _ in range(int(input())):
    met = []
    res = []
    judge = True
    i = 0
    while i <  8:
        tmp = input()
        met.append(tmp)
        if tmp != '':
            i += 1
        if {{completion}}:
            print(""R"")
            judge = False

    if judge:
        print(""B"")
#    for i in met:
#        print(i)","tmp == ""R"" * 8 and judge","i == 8:
            res.append(met)
            met = []
            i = 0
    if judge:
        for m in res:
            if m[0][2] == 'R':
                print(""R"")
                judge = False
            if m[-1][2] == 'B':
                print(""B"")
                judge = False
    if judge:
        for m in res:
            if m[0][2] == 'R':
                print(""R"")
                judge = False
            if m[-1][2] == 'B':
                print(""B"")
                judge = False
    if judge:
        for m in res:
            if m[0][2] == 'R':
                print(""R"")
                judge = False
"
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    while(j<8) :
        a = input()
        if(a != '') :
            b.append(a)
            j += 1
    key = 0
    for j in range(8) :
        ok = True
        for k in range(8) :
            if{{completion}}:
                ok = False
        if(ok) :
            key = 1
            print(""R"")
            break
    if(not key) :
        print(""B"")
                
    
        
",(b[j][k] != 'R') ,(b[j][k] != '.') 
"from sys import stdin

t = int(input())

lines = stdin.read().split()
j = 0
for num in range(t):
    for i in range(8):
        if {{completion}}:
            print('R')
            break
    else:
        print('B')
    j += 8",lines[i + j].count('R') == 8,"lines[j] == 'R':
            print('R')
            break
    else:
        print('B')
    for i in range(8):
        if lines[j] == 'B':
            print('B')
            break
    else:
        print('R')
    for i in range(8):
        if lines[j] == 'R':
            print('R')
            break
    else:
        print('B')
    for i in range(8):
        if lines[j] == 'B':
            print('B')
            break
    else:
        print('R')
    for i in range(8):
        if lines[j] == 'R':
            print('R')
            break
    else:
        print('B')
    for i in range(8):
        if lines[j] == 'B':
            print('B')
            break
    else:"
"t = int(input())

for _ in range(t):
     count = 0
     grid = []
     while count < 8:
        n = input()
        if len(n) != 0:
            count+=1
            grid.append(n)
     ans = False
     for i in range(8):
        x = False
        for j in range(8):
            if {{completion}}:
                x = True
        if not x:
            print('R')
            ans = True
            break
     if not ans:
        print('B')


",grid[i][j]!='R',"grid[i][j] == 'R':
                x = True
            elif grid[i][j] == 'B':
                x = False
            elif grid[i][j] == '.':
                x = False
            elif grid[i][j] == 'R' and x:
                x = True
            elif grid[i][j] == 'B' and x:
                x = False
            elif grid[i][j] == '.' and x:
                x = False
            elif grid[i][j] == 'R' and not x:
                x = True
            elif grid[i][j] == 'B' and not x:
                x = False
            elif grid[i][j] == '.' and not x:
                x = False
            elif grid[i][j] == 'R' and x:
                x = True
            elif grid[i][j] == 'B' and x:
                x = False
            elif grid[i][j] == '.' and x:
                x = False
"
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    key = '.'
    while(j<8) :
        a = input()
        if{{completion}}:
            b.append(a)
            j += 1
    for j in range(8) :
        if(len(set(b[j])) == 1 and b[j][0] == 'R') :
           key = 'R'
           break
    if(key!= 'R') :
        key = 'B'
    print(key)
",(a != '') ,"(a=='R') :
            b.append(a)
            j += 1
        elif(a=='B') "
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    key = '.'
    while(j<8) :
        a = input()
        if(a != '') :
            b.append(a)
            j += 1
    for j in range(8) :
        if{{completion}}:
           key = 'R'
           break
    if(key!= 'R') :
        key = 'B'
    print(key)
",(len(set(b[j])) == 1 and b[j][0] == 'R') ,"(b[j] == 'R') :
           key = 'R'
           break
    if(b[j] == 'B') :
        key = 'B'
    print(key)
    
n = int(input())
for i in range(n) :
    b = []
    j = 0
    key = '.'
    while(j<8) :
        a = input()
        if(a != '') :
            b.append(a)
            j += 1
    for j in range(8) :
        if(b[j] == 'R') "
"import sys

inp = sys.stdin.read().split()[::-1]
out = []

def compress(s):
    lst = None
    ret = []
    for c in s:
        if {{completion}}:
            ret.append(0)
            lst = c        
        ret[-1] += 1
    return ret

def transform(lns):
    st = []
    s = 0
    for l in lns:
        st.append(s)
        s += l
    return st

def tc(n, txt, patt):
    if txt == patt: 
        out.append(0)
        return
    if txt[0] != patt[0] or txt[-1] != patt[-1]:
        out.append(-1)
        return
    A = compress(txt)
    B = compress(patt)
    if len(A) != len(B): 
        out.append(-1)
        return
    A = transform(A)
    B = transform(B)
    ans = 0
    for a, b in zip(A, B):
        ans += abs(a - b)
    out.append(ans)

for _ in range(int(inp.pop())):
    n = int(inp.pop())
    txt = inp.pop()
    patt = inp.pop()
    tc(n, txt, patt)

print('\n'.join(map(str, out)))",lst != c,"lst == c:
            ret.append(0)
            lst = None
        else:
            if lst == None:
                lst = c
            else:
                lst = None
                ret.append(0)
                ret[-1] += 1
                
        if lst == None:
            ret.append(0)
            lst = c
        else:
            lst = None
            ret.append(0)
            ret[-1] += 1
            
        if lst == None:
            ret.append(0)
            lst = c
        else:
            lst = None
            ret.append(0)
            ret[-1] += 1
            
        if lst == None:
            ret.append(0)
            lst = c
        else:
            lst = None
            ret.append(0)
            ret[-1] += 1
            "
"import sys
ctr = [0, 0, 0]
cnt = [0]

while cnt[-1] < 10**9:
	i = ctr.index(min(ctr))
	cnt.append(cnt[-1] + 2*(sum(ctr) - ctr[i]))
	ctr[i] += 1


def solve(sn):
	t = int(sn)
	s, e = 0, len(cnt) - 1
	while s < e:
		m = (s + e) >> 1
		if {{completion}}:
			e = m
		else:
			s = m + 1
	return str(s)

inp = sys.stdin.read().split()
inp.pop(0)

print('\n'.join(map(solve, inp)))",cnt[m] >= t,cnt[m] >= sn
"import sys
ctr = [0, 0, 0]
cnt = [0]

i = 0
tot = 0
s = 0
while tot < 10**9:
    tot += 2*(s - ctr[i])
    cnt.append(tot)
    ctr[i] += 1
    s += 1
    i += 1
    if i == 3: i = 0

def solve(sn):
	t = int(sn)
	s, e = 0, len(cnt) - 1
	while s < e:
		m = (s + e) >> 1
		if {{completion}}:
			e = m
		else:
			s = m + 1
	return str(s)

inp = sys.stdin.read().split()
inp.pop(0)

print('\n'.join(map(solve, inp)))",cnt[m] >= t,"cnt[m] >= t:
			e = m
		else:
			s = m + 1
	return str(s)

inp = sys.stdin.read().split()
inp.pop(0)

print('\n'.join(map(solve, inp)))
<|/ a dscore=0 |>"
"""""""
in each circle, there's two options
""""""
import sys;input=sys.stdin.readline
I=lambda:int(input())
A=lambda:[*map(int,input().split())]

mod=10**9+7
for _ in range(I()):
  n=I()
  a,b,c=A(),A(),A()
  
  g={a[i]:[b[i],c[i]] for i in range(n)}
  cycles,visi=0,[False]*(n+1)
  for u in range(1,n+1):
    need=True;cycle_size=0
    while not visi[g[u][0]]:
      if {{completion}}:need=False
      #mark visited and move to next vertex
      visi[g[u][0]],u=True,g[u][0]
      cycle_size+=1
    if need and cycle_size>1:cycles+=1
  print(pow(2,cycles,mod))",g[u][1]!=0,"g[u][0]==b[u]:need=False
      elif g[u][0]==c[u]:need=False
      elif g[u][0]==a[u]:need=False
      elif g[u][0]==a[u]:need=False
      elif g[u][0]==b[u]:need=False
      elif g[u][0]==c[u]:need=False
      elif g[u][0]==a[u]:need=False
      elif g[u][0]==b[u]:need=False
      elif g[u][0]==a[u]:need=False
      elif g[u][0]==a[u]:need=False
      elif g[u][0]==a[u]:need=False
      elif g[u][0]==a[u]:"
"# read interger t from input.txt and then read t lines
import sys

DEBUG = False

def check(a, b, c):
    a = [0] + a
    b = [0] + b
    c = [0] + c
    m_ = [0] * len(a)
    m = [0] * len(a)
    for i in range(1, len(b)):
        m_[b[i]] = i
    for i in range(1, len(a)):
        m[i] = m_[a[i]]
    # print("">>>"", a)
    # print("">>>"", b)
    # print("">>>"", m)
    # find cicles in permutations
    total_num = 1
    used = [False] * len(m)
    # print(a, b, c)
    for i in range(1, len(m)):
        if not used[i]:
            j = i
            c_zeros = True
            while not used[j]:
                if {{completion}}:
                    c_zeros = False
                used[j] = True
                j = m[j]
            used[i] = True
            # print(i, m[i], a[i], b[i], c[i])
            if c_zeros and m[i] != i:
                # print("">>"", i)
                total_num = (total_num) * 2 % 1000000007
    print(total_num)


def main(f):
    t = int(f.readline())
    for i in range(t):
        n = int(f.readline())
        a = list(map(int, f.readline().split()))
        b = list(map(int, f.readline().split()))
        c = list(map(int, f.readline().split()))

        check(a, b, c)

if DEBUG:
    f = open('input.txt', 'r')
else:
    f = sys.stdin

main(f)

f.close()  
",c[j] != 0,"c[j] != i:
                    c_zeros = False
                used[j] = True
                j = m[j]
            used[i] = True
            if c_zeros and m[i] != i:
                total_num = (total_num) * 2 % 1000000007
    print(total_num)

def main(f):
    t = int(f.readline())
    for i in range(t):
        n = int(f.readline())
        a = list(map(int, f.readline().split()))
        b = list(map(int, f.readline().split()))
        c = list(map(int, f.readline().split()))

        check(a, b, c)

if DEBUG:
    f = open('input.txt', 'r')
else:
    f = sys.stdin

main(f)

f.close()  
""""""
import sys

DEBUG = False"
"
import sys
t = int(sys.stdin.readline())
for _ in range(t):
    n = int(sys.stdin.readline())
    a = list(map(int,sys.stdin.readline().split()))
    b = list(map(int,sys.stdin.readline().split()))
    c = list(map(int,sys.stdin.readline().split()))
    count = 0
    L = [0] * (n+1)
    for i in range(0,n):
        L[a[i]] = b[i]
    status = 1
    for i in range(n):
        if c[i] != 0:
            L[a[i]] = 0
            L[b[i]] = 0
    for i in range(1,n+1):
        key = i
        xstatus = 1
        status = 1
        xcount= 0
        while status == 1:
            if L[key] == 0:
                status = 0
            if L[key] == i:
                if {{completion}}:
                    count += 1
                status = 0
            xcount += 1
            x = L[key]
            L[key] = 0
            key = x
    print((2 **count) % (10 ** 9 + 7)) ",xcount >= 1,"xstatus == 1:
                    count += 1
                status = 0
            else:
                if xstatus == 0:
                    xstatus = 1
                if xstatus == 1:
                    xcount += 1
                if xcount > 2:
                    xstatus = 1
                if xcount < 2:
                    xcount = 0
                L[key] = i
                if xstatus == 1:
                    count += 1
                status = 0
            xcount += 1
            x = L[key]
            L[key] = 0
            key = x
    print((2 **count) % (10 ** 9 + 7)) % (10 ** 9 + 7)
'''
import sys
t = int(sys.stdin.readline())
for _ in range(t):
    n = int(sys.stdin.readline())"
"import sys

input = sys.stdin.readline

class Solver1670C:

    def __init__(self):
        self.n = int(input())
        self.a = list(map(int, input().split(' ')))
        self.b = list(map(int, input().split(' ')))
        self.d = list(map(int, input().split(' ')))

        self.pos_a = [0 for _ in range(self.n+1)]
        self.pos_b = [0 for _ in range(self.n+1)]

        self.been = [0 for _ in range(self.n+1)]

        self.mod = (10**9)+7

    def solve(self):

        for i in range(0, self.n):
            self.pos_a[self.a[i]] = i
            self.pos_b[self.b[i]] = i

        for i in range(0, self.n):
            if self.d[i] and self.been[i] == 0:

                if self.d[i] == self.a[i]:
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

                else:
                    j = i
                    while {{completion}}:
                        self.been[j] = 1
                        j = self.pos_b[self.a[j]]

        outp = 1

        for i in range(0, self.n):
            if self.been[i] == 0:
                cnt = 0
                j = i
                while self.been[j] == 0:
                    self.been[j] = 1
                    j = self.pos_a[self.b[j]]

                    cnt += 1

                if cnt >= 2:
                    outp = outp * 2 % self.mod

        return outp


t = int(input())

while t:

    t -= 1

    cur = Solver1670C()

    print(cur.solve())
",self.been[j] == 0,"self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_b[self.a[j]]

                if self.been[i] == 0:
                    cnt = 0
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

                    cnt += 1

                    if cnt >= 2:
                        outp = outp * 2 % self.mod

        return outp

class Solver1670D:

    def __init__(self):
        self.n = int(input())
        self.a = list(map(int, input().split(' ')))
        self.b = list(map(int, input().split(' ')))
        self.d = list(map(int, input().split(' ')))

        self.pos_a = [0 for _ in range(self."
"import sys

input = sys.stdin.readline

class Solver1670C:

    def __init__(self):
        self.n = int(input())
        self.a = list(map(int, input().split(' ')))
        self.b = list(map(int, input().split(' ')))
        self.d = list(map(int, input().split(' ')))

        self.pos_a = [0 for _ in range(self.n+1)]
        self.pos_b = [0 for _ in range(self.n+1)]

        self.been = [0 for _ in range(self.n+1)]

        self.mod = (10**9)+7

    def solve(self):

        for i in range(0, self.n):
            self.pos_a[self.a[i]] = i
            self.pos_b[self.b[i]] = i

        for i in range(0, self.n):
            if self.d[i] and self.been[i] == 0:

                if self.d[i] == self.a[i]:
                    j = i
                    while {{completion}}:
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

                else:
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_b[self.a[j]]

        outp = 1

        for i in range(0, self.n):
            if self.been[i] == 0:
                cnt = 0
                j = i
                while self.been[j] == 0:
                    self.been[j] = 1
                    j = self.pos_a[self.b[j]]

                    cnt += 1

                if cnt >= 2:
                    outp = outp * 2 % self.mod

        return outp


t = int(input())

while t:

    t -= 1

    cur = Solver1670C()

    print(cur.solve())
",self.been[j] == 0,"self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_b[self.a[j]]

                elif self.d[i] == self.b[i]:
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

                else:
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_b[self.a[j]]

                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

        outp = 1

        for i in range(0, self.n):
            if self.been[i] == 0:
                cnt = 0
                j = i
                while self.been"
"m = 10**9+7
for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    c = list(map(int,input().split()))
    d={i:0 for i in range(1,n+1)}
    for i in range(n):
        d[c[i]]=1
    dd={}
    for i in range(n):
        dd[a[i]]=i
    ans = 1
    for i in range(n):
        if(c[i] != 0 or a[i]==b[i] or d[a[i]] == 1 or d[b[i]]==1):continue
        j=dd[b[i]]; f=2
        while(j!=i):
            if{{completion}}:f=1
            c[j]=1
            j=dd[b[j]]
        ans=(ans*f)%m
        k=1
    print(ans)

",(c[j]!=0),"(c[j]==0):
                c[j]=a[j]
                d[a[j]]=d[a[j]]+1
                dd[a[j]]=j
                j=dd[b[j]]
                f=f+1
            else:
                c[j]=b[j]
                d[b[j]]=d[b[j]]+1
                dd[b[j]]=j
                j=dd[b[j]]
                f=f+1
        if(j==i):
            f=f+1
        while(j!=i):
            if(c[j]==0):
                c[j]=a[j]
                d[a[j]]=d[a[j]]+1
                dd[a[j]]"
"from sys import stdin, stdout
from functools import reduce

M = int(10**9 + 7)
def solve(a, b, c, n):
    vis = [False]*n
    ans = []
    g = {a[i]:(b[i], c[i]) for i in range(n)}
    for i in range(n):
        t, ass, j = 0, False, i
        while not vis[j]:
            vis[j] = True
            if {{completion}}: ass = True 
            j = g[j + 1][0] - 1
            t += 1
            #print(t, ass, j)
        if not ass and t > 1: ans.append(2)
        else: ans.append(1)
        #print(ans)
    if not ans: return 0
    #print(reduce(lambda x, y: (x*y)%M, ans, 1) % M)
    return reduce(lambda x, y: (x*y)%M, ans, 1) % M

for i in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())
    a = list(map(int, stdin.readline().strip().split()))
    b = list(map(int, stdin.readline().strip().split()))
    c = list(map(int, stdin.readline().strip().split()))
    out_ = solve(a, b, c, n)
    stdout.write(f""{out_}\n"")",g[j + 1][1] != 0,"ass: 
                ass = False 
                j = g[j][0] - 1
            else: 
                ass = True 
                j = g[j + 1][0] - 1
            t += 1
        #print(t, ass, j)
        if not ass and t > 1: ans.append(2)
        else: ans.append(1)
        #print(ans)
    if not ans: return 0
    #print(reduce(lambda x, y: (x*y)%M, ans, 1) % M)
    return reduce(lambda x, y: (x*y)%M, ans, 1) % M

for i in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())
    a = list(map(int, stdin.readline().strip().split()))
"
"from sys import stdin, setrecursionlimit
input = stdin.readline

from bisect import bisect_left, bisect_right
from collections import deque
from functools import lru_cache, reduce
from heapq import heappush, heappop
from math import sqrt, ceil, floor, log2

T = int(input())

def rl(t = int):
    return list(map(t, input().split()))

MOD = 10**9 + 7
for t in range(1, T + 1):
    n = int(input())
    a = rl()
    b = rl()
    d = rl()

    m = {v:i for i,v in enumerate(a)}

    for i in range(n):
        if a[i] == b[i]:
            d[i] = a[i]

    ret = 1
    seen = set()
    for i,cur in enumerate(a): 
        if cur in seen:
            continue
        
        mul = 2
        while cur not in seen:
            if {{completion}}:
                mul = 1
            seen.add(cur)
            #print(i, cur)
            cur = b[i]
            i = m[cur]

        #print(seen, mul)
        ret = (ret * mul) % MOD

    print(ret)
",d[i] != 0,"cur in d:
                mul = d[cur]
                break
            if cur in m:
                mul = m[cur]
                break
            if cur == b[i]:
                mul = 1
                break
            if cur > b[i]:
                mul = 2
                break
            if cur < b[i]:
                mul = 1
                break
            if cur == a[bisect_right(b, cur)]:
                mul = 1
                break
            if cur == a[bisect_left(b, cur)]:
                mul = 2
                break
            if cur == b[bisect_right(a, cur)]:
                mul = 2
                break
            if cur == b[bisect_left(a, cur"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();b=L();d=L();l=[]
    for i in range(n):l.append([a[i],b[i],d[i]])
    l.sort(key=lambda x:x[0]);s=set();ans=1
    for i in range(n):
        if i not in s:
            d={};cur=i;f=0
            while True:
                d[l[cur][0]]=d.get(l[cur][0],0)+1
                d[l[cur][1]]=d.get(l[cur][1],0)+1
                s.add(cur)
                if {{completion}}:f=1
                if d[l[cur][1]]==2:break
                cur=l[cur][1]-1
            if f!=1:ans=(ans*2)%mod1
    print(ans)",l[cur][2]!=0 or l[cur][1]==l[cur][0],"d[l[cur][0]]==2:f=1
                if d[l[cur][1]]==2:break
                cur=l[cur][0]-1
            if f!=1:ans=(ans*2)%mod1
    ans=ans%mod2
    if ans==mod2:
        ans=1
        for i in range(n):
            if i not in s:
                d={};cur=i;f=0
                while True:
                    d[l[cur][0]]=d.get(l[cur][0],0)+1
                    d[l[cur][1]]=d.get(l[cur][1],0)+1
                    s.add(cur)
                    if d[l[cur][0]"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();b=L();d=L();l=[]
    for i in range(n):l.append([a[i],b[i],d[i]])
    l.sort(key=lambda x:x[0]);s=set();ans=1
    for i in range(n):
        if i not in s:
            d={};cur=i;f=0
            while True:
                d[l[cur][0]]=d.get(l[cur][0],0)+1
                d[l[cur][1]]=d.get(l[cur][1],0)+1
                s.add(cur)
                if l[cur][2]!=0 or l[cur][1]==l[cur][0]:f=1
                if {{completion}}:break
                cur=l[cur][1]-1
            if f!=1:ans=(ans*2)%mod1
    print(ans)",d[l[cur][1]]==2,l[cur][2]!=0 and l[cur][1]!=l[cur][0]
"import sys

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def solve(n, a):
    k = sum([0 if ai > 0 else 1 for ai in a])
    b = [abs(a[i]) if i >= k else -abs(a[i]) for i in range(n)]
    for i in range(n-1):
        if {{completion}}:
            return ""NO""
    return ""YES""

for i in range(1, len(ls)-1, 2):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    print(solve(n, a))",b[i] > b[i+1],"a[i] > a[i+1]:
            b[i], b[i+1] = b[i+1], b[i]
    if b[0] == b[1]:
        if b[0] < 0:
            return ""NO""
        else:
            return ""YES""
    for i in range(n-2):
        if b[i] != b[i+1]:
            return ""NO""
    if b[n-1] != b[n-2]"
"
 
n,l,r,z=map(int,input().split())
mod=10**9+7
 
 
#############################
#############
cnb_max=10**5
#############
 
kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod
 
rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod
 
def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod
 
 
def inv(n):
    return kai[n-1]*rkai[n]%mod
 
##################################
 
 
 
def f(r,z):
    dp=[0]*(2*n+10)
    dp[0]=1
    for i in range(65):
        newdp=[0]*(2*n+10)
        for j in range(2*n+5):
            dp[j]%=mod
            if dp[j]==0:continue
            for cnt in range(z&1,n+1,2):
                if j+cnt>r:break
                d=0
                if {{completion}}:d=1
                newdp[(j+cnt)//2+d]+=dp[j]*cnb(n,cnt)%mod
        z//=2
        r//=2
        dp=newdp[:]
    return dp[0]%mod
 
print((f(r,z)-f(l-1,z))%mod)
 ",(r&1)==0 and (j+cnt)%2==1,"j+cnt==r:d=1
                if j+cnt==n+1:d=1
                if j+cnt==n+2:d=1
                if j+cnt==n+3:d=1
                if j+cnt==n+4:d=1
                if j+cnt==n+5:d=1
                if j+cnt==n+6:d=1
                if j+cnt==n+7:d=1
                if j+cnt==n+8:d=1
                if j+cnt==n+9:d=1
                if j+cnt==n+10:d=1
                if j+cnt==n+11:d=1"
"import sys
input = sys.stdin.readline
MOD = 10 ** 9 + 7
N = 10000
fact = [0 for _ in range(N)]
invfact = [0 for _ in range(N)]
fact[0] = 1
for i in range(1, N):
    fact[i] = fact[i - 1] * i % MOD

invfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)

for i in range(N - 2, -1, -1):
    invfact[i] = invfact[i + 1] * (i + 1) % MOD

def nCk(n, k):
    if k < 0 or n < k:
        return 0
    else:
        return (fact[n] * invfact[k] % MOD) * invfact[n - k] % MOD

def nHk(n, k):
    return nCk(n + k - 1, k)


def main():
    n, l, r, z = map(int, input().split())
    bit = [0] * 60
    for i in range(60):
        if z >> i & 1:
            bit[i] = 1
            r -= 1 << i
            l -= 1 << i
    if r < 0:
        print(0)
        return
    
    ma = [0] * 60
    for i in range(60):
        if n % 2 == bit[i]:
            nn = n
        else:
            nn = n - 1
        ma[i] = (1 << (i + 1)) * nn
        if i != 0:
            ma[i] += ma[i - 1]

    tot = [0] * 60
    for i in range(60):
        for j in range(bit[i], n + 1, 2):
            tot[i] += nCk(n, j)
            tot[i] %= MOD
        if i != 0:
            tot[i] *= tot[i - 1]
            tot[i] %= MOD

    memo = {}
    d = r - l
    bi = [1 << i for i in range(61)]

    def solve(i, l):
        r = l + d
        if l <= 0 and ma[i] <= r:
            return tot[i]
        elif ma[i] < l:
            return 0
        elif i == -1:
            return l <= 0
        elif i + 60 * l in memo:
            return memo[i + 60 * l]
        
        ret = 0
        mi = bi[i + 1]
        ll = l
        rr = r
        for j in range(bit[i], n + 1, 2):
            ret += solve(i - 1, ll) * nCk(n, j) % MOD
            if ret >= MOD: ret -= MOD
            ll -= mi
            rr -= mi
            if {{completion}}:
                break

        memo[i + 60 * l] = ret
        return ret
    
    ans = solve(59, l)
    
    print(ans)
    
    
for _ in range(1):
    main()",rr < 0,"ll == 0:
                ll = 1 << i
            if rr == 0:
                rr = 1 << i
            if ll > rr:
                ll, rr = (rr, ll)
            mi = ll + rr
            if mi > ma[i]:
                mi = ma[i]
            if mi > r:
                mi = r
            if mi < l:
                mi = l
            
            if mi > r:
                ret += mi
            elif mi < l:
                ret -= mi
            else:
                ret += mi
                if ll == rr:
                    ret += ll
                if ll > rr:
                    ret += ll
                    ret -= rr
"
"a,b=map(int,input().split())
arr=[0]*500001
for {{completion}}:
    arr[i]+=1
for i in range(1,500000):
    arr[i+1]+=arr[i]//(i+1)
    arr[i]%=i+1
if sum(arr[:b])==0:
    print('Yes')
else:
    print('No')","i in map(int,input().split())","_ in range(b):
    arr[int(input())-1]+=1
for i in range(1,500000):
    arr[i+1]+=arr[i]//(i+1)
    arr[i]%=i+1
if sum(arr[:b])==0:
    print('Yes')
else:
    print('No')
<|/ a |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| a tags=python,python-3.x |>
<code>
a,b=map(int,input().split())
arr"
"a,b=map(int,input().split())
arr=[0]*500001
for i in map(int,input().split()):
    arr[i]+=1
for {{completion}}:
    arr[i+1]+=arr[i]//(i+1)
    arr[i]%=i+1
if sum(arr[:b])==0:
    print('Yes')
else:
    print('No')","i in range(1,500000)","i,j in enumerate(arr):
    if j%500000==0:
        arr[i]-=1
for i,j in enumerate(arr):
    if j%500000!=0:
        arr[i]-=1
if sum(arr)%500000==0:
    print('Yes')
else:
    print('No')
<|/ a tags=python-3.x,python |>
<| a dscore=0 |>
<code>
a,b=map(int,input().split())
arr=[0]*500001
for i in map(int,input().split()):
    arr[i]+=1
for i,j in enumerate(arr):
    if j%500000==0:
        arr[i]-=1
"
"import sys
from collections import Counter

input = sys.stdin.readline
n, x = map(int, input().split())
a = list(map(int, input().split()))
cnt = Counter(a)
rest, base = 0, 1
for t in range(x, 0, -1):
    if {{completion}}:
        n -= cnt[t]
        rest += cnt[t] % base
    rest %= base
    rest *= t
    base *= t
    if n == 0 or base - rest > n * t:
        break
print('Yes' if n == 0 and rest % base == 0 else 'No')",t in cnt,"t == 1:
        n -= cnt[t]
        rest += cnt[t] % base
    rest %= base
    rest *= t
    base *= t
    if n == 0 or base - rest > n * t:
        break
print('Yes' if n == 0 and rest % base == 0 else 'No')
<|/ file source=github dstars=1 |>"
"import sys
from collections import Counter

input = sys.stdin.readline
n, x = map(int, input().split())
a = list(map(int, input().split()))
cnt = Counter(a)
rest, base = 0, 1
for t in range(x, 0, -1):
    if t in cnt:
        n -= cnt[t]
        rest += cnt[t] % base
    rest %= base
    rest *= t
    base *= t
    if {{completion}}:
        break
print('Yes' if n == 0 and rest % base == 0 else 'No')",n == 0 or base - rest > n * t,"rest == 0:
        break
if rest != 0:
    print('No')
else:
    print('Yes')
<|/ file source=github ext=.py |>"
"def rl():
	return [int(i) for i in input().split()]

def solve():
	[n,x]=rl()
	a=rl()
	nax=500000+5
	ct=[0 for i in range(nax)]
	for b in a:
		ct[b]+=1
	for i in range(x):
		if {{completion}}:
			return ""No""
		ct[i+1]+=ct[i]/(i+1)
	return ""Yes""

print(solve())
",ct[i]%(i+1),"ct[i]%x==0:
			return ""No""
	return ""Yes""

print(solve())
'''
<|/ file source=github |>"
"# your code goes here

if __name__ == '__main__':
	n, x = map(int, input('').split(' '))
	a = list(map(int, input('').split(' ')))
	cnt = [0] * (x+2)
	for w in a:
		cnt[w] += 1
	for i in range(x):
		while {{completion}}:
			cnt[i] -= (i+1)
			cnt[i+1] += 1
	print('No' if sum(cnt[:x]) else 'Yes')
			
	",cnt[i] > i,"cnt[i] > 0:
			cnt[i] -= 1
			cnt[i+1] += 1
		if cnt[i] == 0:
			break
		if i+1 == x:
			break
		if cnt[i+1] > cnt[i]:
			cnt[i+1] -= 1
			cnt[i] += 1
		else:
			cnt[i+1] -= 1
			cnt[i] -= 1
	print('No' if sum(cnt[:x]) else 'Yes')
<|/ file source=github |>"
"def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    while True:
        k = a[-1]
        a.pop() 
        cnt = 1
        while {{completion}}:
            cnt += 1
            a.pop()
        if cnt < k + 1:
            return ('Yes' if k >= x else 'No' )
        for i in range(cnt // (k + 1)):
            a.append(k + 1) 
        for i in range(cnt % (k + 1)):
            a.append(k)

n, x = tuple(map(int, input().split(' ')))
a = input().split(' ')
a = list(map(int, a))

print(factorial_divisibility(n, x, a))



",len(a) > 0 and k == a[-1],"k * cnt <= x:
            cnt *= k
        if cnt > x:
            return 'No'
        if cnt == x:
            return 'Yes'
        a.append(k)
        
def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append(1)
    a.append("
"def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    while True:
        k = a[-1]
        a.pop() 
        cnt = 1
        while len(a) > 0 and k == a[-1]:
            cnt += 1
            a.pop()
        if {{completion}}:
            return ('Yes' if k >= x else 'No' )
        for i in range(cnt // (k + 1)):
            a.append(k + 1) 
        for i in range(cnt % (k + 1)):
            a.append(k)

n, x = tuple(map(int, input().split(' ')))
a = input().split(' ')
a = list(map(int, a))

print(factorial_divisibility(n, x, a))



",cnt < k + 1,"cnt % k == 0:
            return ('Yes' if k >= x else 'No' )
        for i in range(cnt // (k + 1)):
            a.append(k + 1) 
        for i in range(cnt % (k + 1)):
            a.append(k)

n, x = tuple(map(int, input().split(' ')))
a = input().split(' ')
a = list(map(int, a))

print(factorial_divisibility(n, x, a))



def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    while True:
        k = a[-1]
        a.pop() 
        cnt = 1
        while len(a) > 0 and k == a[-1]:
            cnt += 1
            a.pop()
        if cnt % k == 0:"
"n , x = [int(x) for x in input().split()]
l = [int(x) for x in input().split()]
s = [0] * (x+1)
for i in l:
    s[i] += 1
for i in range(1,x):
    if {{completion}}:
        s[i+1] += s[i]//(i+1)
    else:
        print('NO')
        break
else:
    print('Yes')",s[i] % (i+1) == 0,"s[i]%(i+1)==0 and s[i-1]%(i+1)==0:
        print('Yes')
        break
    elif s[i]%(i+1)!=0 and s[i-1]%(i+1)!=0:
        print('No')
        break
    elif s[i]%(i+1)==0 and s[i-1]%(i+1)==0:
        print('Yes')
        break
    elif s[i]%(i+1)==0 and s[i-1]%(i+1)!=0:
        print('No')
        break
    elif s[i]%(i+1)!=0 and s[i-1]%(i+1)==0:
        print('No')
        break
    elif s[i]%(i+1)!=0 and s[i-1]%(i+1)!=0:
        print('No')
        break
    else:
        print('NO')
"
"
ex = [0]
arr = [0]
for i in range(1):
    a = list(map(int, input().split()))
    ex = a[1]
    b = list(map(int, input().split()))
    arr = b

for i in range(1):
    dp = [0]*ex
    for a in arr:
        dp[a-1]+=1
    for m in range(len(dp)-1):
        while {{completion}}:
            dp[m] = dp[m] - m - 2
            dp[m+1]+=1
    dp = dp[:-1]
    A = sum(dp)
    if A == 0:
        ans='Yes'
    else:
        ans='No'
print(ans)
",dp[m]>=m+2,dp[m]>0 and dp[m+1]<
"n,x=map(int,input().split())
s={i:0 for i in range(1,x+1)}
def f(x,a):
    s[x]=s[x]+a
an=map(int,input().split())
for b in an:
    f(b,1)
l=1
i=1
while i < x:
    if {{completion}}:
        f(i+1,s[i]//(i+1))
        i+=1
    else:
        l=0
        break
print(['no','yes'][l])
",s[i]%(i+1)==0,"s[i]%(i+1)==0 and s[i-1]!=s[i]:
        l=0
        break
    elif s[i]%(i+1)!=0 and s[i-1]==s[i]:
        l=0
        break
    elif s[i]%(i+1)==0 and s[i-1]!=s[i]:
        l=1
        break
    elif s[i]%(i+1)!=0 and s[i-1]==s[i]:
        l=1
        break
    elif s[i]%(i+1)==0 and s[i-1]==s[i]:
        l=0
        break
    elif s[i]%(i+1)!=0 and s[i-1]!=s[i]:
        l=0
        break
    elif s[i]%(i+1)==0 and s[i-1]==s[i]:
        l=0
        break
    elif s[i]%"
"b=[0]*500001
l=list(map(int,input("""").split()))
n=l[0]
m=l[1]
a=list(map(int,input("""").split()))
e=1
for i in a:
    b[i]+=1
for i in range(1,l[1]):
    if {{completion}}:
        b[i+1]+=(b[i]//(i+1))
    else:
        print(""No"")
        e=0
        break
if e==1:
    if b[m]!=0 :
        print(""Yes"")
    else:
        print(""No"")
",b[i]%(i+1)==0,b[i]%(i+1)==0 
"b=[0]*500001
l=list(map(int,input("""").split()))
n=l[0]
m=l[1]
a=list(map(int,input("""").split()))
e=1
for i in a:
    b[i]+=1
for i in range(1,l[1]):
    if b[i]%(i+1)==0:
        b[i+1]+=(b[i]//(i+1))
    else:
        print(""No"")
        e=0
        break
if e==1:
    if {{completion}}:
        print(""Yes"")
    else:
        print(""No"")
",b[m]!=0 ,"b[1]%n==0:
        print(""Yes"")
    else:
        print(""No"")
elif e==0:
    if b[1]%n==0 and b[2]%n==0 and b[3]%n==0 and b[4]%n==0 and b[5]%n==0 and b[6]%n==0 and b[7]%n==0 and b[8]%n==0 and b[9]%n==0 and b[10]%n==0 and b[11]%n==0 and b[12]%n==0 and b[13]%n==0 and b[14]%n==0 and b[15]%n==0 and b[16"
"from bisect import bisect

import sys
input = sys.stdin.readline

n, b, p, m = map(int, input().split())


adds = []
curr = []
mults = []

i = 0
for _ in range(n):
    t, v = input().split()
    v = int(v)
    
    if t == '*':
        if v == 1:
            continue
        curr.sort()

        adds.append(curr)
        mults.append(v)
        curr = []
    else:
        curr.append(v)
        
curr.sort()
adds.append(curr)

pref = []
for l in adds:  
    np = [0]
    for v in l[::-1]:
        np.append(v + np[-1])
    pref.append(np)

y = len(mults)
un_m = sorted(set(mults))
z = len(un_m)
ct_m = [0] * z
for v in mults:
    for i in range(z):
        if un_m[i] == v:
            ct_m[i] += 1

from itertools import product
poss = []

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            seg_mult.append(seg_mult[-1] * mults[i])
        else:
            seg_mult.append(seg_mult[-1])
    seg_mult.reverse()

    exc = [seg_mult[0] - v for v in seg_mult]

    init_tot = 0
    for j in range(y + 1):
        if exc[j] != 0:
            init_tot += len(adds[j])

    lo = 0 #Ct value provided >= lo >= rem_adds
    hi = 10 ** 18 + 100 #Too high
    while hi - lo > 1:
        mid = lo + (hi - lo) // 2

        tot = init_tot
        for j in range(y + 1):
            if {{completion}}:
                continue
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - 1) // exc[j]

        s_ct = len(adds[j]) - bisect(adds[j], limit)

        tot += pref[j][s_ct] * exc[j]
        ct += s_ct

    if lo != 0:
        assert ct >= rem_adds
        tot -= lo * (ct - rem_adds)

    #print(tup, lo, tot, end)
    poss.append(tot * end)
    #break
    




print(max(poss))

    
",exc[j] == 0,"exc[j] != 0:
                continue
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - "
"from bisect import bisect

import sys
input = sys.stdin.readline

n, b, p, m = map(int, input().split())


adds = []
curr = []
mults = []

i = 0
for _ in range(n):
    t, v = input().split()
    v = int(v)
    
    if t == '*':
        if v == 1:
            continue
        curr.sort()

        adds.append(curr)
        mults.append(v)
        curr = []
    else:
        curr.append(v)
        
curr.sort()
adds.append(curr)

pref = []
for l in adds:  
    np = [0]
    for v in l[::-1]:
        np.append(v + np[-1])
    pref.append(np)

y = len(mults)
un_m = sorted(set(mults))
z = len(un_m)
ct_m = [0] * z
for v in mults:
    for i in range(z):
        if {{completion}}:
            ct_m[i] += 1

from itertools import product
poss = []

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            seg_mult.append(seg_mult[-1] * mults[i])
        else:
            seg_mult.append(seg_mult[-1])
    seg_mult.reverse()

    exc = [seg_mult[0] - v for v in seg_mult]

    init_tot = 0
    for j in range(y + 1):
        if exc[j] != 0:
            init_tot += len(adds[j])

    lo = 0 #Ct value provided >= lo >= rem_adds
    hi = 10 ** 18 + 100 #Too high
    while hi - lo > 1:
        mid = lo + (hi - lo) // 2

        tot = init_tot
        for j in range(y + 1):
            if exc[j] == 0:
                continue
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - 1) // exc[j]

        s_ct = len(adds[j]) - bisect(adds[j], limit)

        tot += pref[j][s_ct] * exc[j]
        ct += s_ct

    if lo != 0:
        assert ct >= rem_adds
        tot -= lo * (ct - rem_adds)

    #print(tup, lo, tot, end)
    poss.append(tot * end)
    #break
    




print(max(poss))

    
",un_m[i] == v,"v == un_m[i]:
            ct_m[i] += 1

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            "
"n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if rem[j] == 0:
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if {{completion}}:
                out[base][sq + 1] += ct

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))
",spec[d],sq
"n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if {{completion}}:
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if spec[d]:
                out[base][sq + 1] += ct

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))
",rem[j] == 0,"j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base]["
"input = __import__('sys').stdin.readline


class DisjointSetUnion(object):
    def __init__(self, n):
        self.n = n
        self.par = [i for i in range(n)]
    
    def find(self, x):
        toupdate = []
        while {{completion}}:
            toupdate.append(x)
            x = self.par[x]
        
        for u in toupdate:
            self.par[u] = x
        return x
    
    def merge(self, u, v):
        u = self.find(u)
        v = self.find(v)
        if u != v:
            self.par[u] = v
        return u != v


n, m = map(int, input().split())

dsu = DisjointSetUnion(n)
adj = [[] for _ in range(n)] # adjlist of the MST
outOfTrees = [] # outside the MST
for _ in range(m):
    u, v = map(lambda x: int(x)-1, input().split())
    if dsu.merge(u, v):
        adj[u].append(v)
        adj[v].append(u)
    else:
        outOfTrees.append((u, v))

# print('outOfTrees', outOfTrees)

# init lca
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for j in range(20):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])


def moveTo(u, step):
    for i in range(20):
        if (step >> i) & 1 == 1:
            u = jump[i][u]
    return u


def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    u = moveTo(u, depth[u] - depth[v])
    if u == v:
        return u
    
    for i in range(19, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# check each edges out of the tree
psum = [0] * n
for u, v in outOfTrees:
    # nodes in the path (and its subtrees) u to v (not including u & v) will select edge u-v in their dfs process
    r = lca(u, v)
    # print('lca', u+1, v+1, r+1)
    if r == u:
        psum[moveTo(v, depth[v] - depth[u] - 1)] += 1
        psum[v] -= 1
    elif r == v:
        psum[moveTo(u, depth[u] - depth[v] - 1)] += 1
        psum[u] -= 1
    else:
        psum[0] += 1
        psum[u] -= 1
        psum[v] -= 1

# print('psum_initial', psum)
# print('applyToChild', applyToChild)

stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    for v in adj[u]:
        if v != par:
            psum[v] += psum[u]
            stack.append((v, u))

# print('psum', psum)
print(''.join('1' if psum[u] == 0 else '0' for u in range(n)))",x != self.par[x],x != self.par[x] and x != self.par[self.par[x]]
"input = __import__('sys').stdin.readline


class DisjointSetUnion(object):
    def __init__(self, n):
        self.n = n
        self.par = [i for i in range(n)]
    
    def find(self, x):
        toupdate = []
        while x != self.par[x]:
            toupdate.append(x)
            x = self.par[x]
        
        for u in toupdate:
            self.par[u] = x
        return x
    
    def merge(self, u, v):
        u = self.find(u)
        v = self.find(v)
        if {{completion}}:
            self.par[u] = v
        return u != v


n, m = map(int, input().split())

dsu = DisjointSetUnion(n)
adj = [[] for _ in range(n)] # adjlist of the MST
outOfTrees = [] # outside the MST
for _ in range(m):
    u, v = map(lambda x: int(x)-1, input().split())
    if dsu.merge(u, v):
        adj[u].append(v)
        adj[v].append(u)
    else:
        outOfTrees.append((u, v))

# print('outOfTrees', outOfTrees)

# init lca
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for j in range(20):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])


def moveTo(u, step):
    for i in range(20):
        if (step >> i) & 1 == 1:
            u = jump[i][u]
    return u


def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    u = moveTo(u, depth[u] - depth[v])
    if u == v:
        return u
    
    for i in range(19, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# check each edges out of the tree
psum = [0] * n
for u, v in outOfTrees:
    # nodes in the path (and its subtrees) u to v (not including u & v) will select edge u-v in their dfs process
    r = lca(u, v)
    # print('lca', u+1, v+1, r+1)
    if r == u:
        psum[moveTo(v, depth[v] - depth[u] - 1)] += 1
        psum[v] -= 1
    elif r == v:
        psum[moveTo(u, depth[u] - depth[v] - 1)] += 1
        psum[u] -= 1
    else:
        psum[0] += 1
        psum[u] -= 1
        psum[v] -= 1

# print('psum_initial', psum)
# print('applyToChild', applyToChild)

stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    for v in adj[u]:
        if v != par:
            psum[v] += psum[u]
            stack.append((v, u))

# print('psum', psum)
print(''.join('1' if psum[u] == 0 else '0' for u in range(n)))",u != v,"u != v:
            self.par[u] = v
            return True
        else:
            return False
    
    def findMST(self):
        par = [i for i in range(1, self.n)]
        while par != self.par:
            par = [i for i in par if self.find(i) == self.par[i]]
        return par
    
    def findMST2(self, u):
        par = [i for i in range(1, self.n)]
        while par != self.par:
            par = [i for i in par if self.find(i) != self.par[i]]
        if par != self.par:
            self.par = par
        return par
    
    def findMST3(self, u):
        par = [i for i in range(1, self.n)]"
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if {{completion}}:
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
 		    	   	    	  		 	 						",arr[i] == 1 or i == j,"arr[i] == 0 or i == j:
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
 		    	   	    	  		 	 						
<|/ file source=github |>"
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        i+=1
    while True:
      if {{completion}}:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
 		    	   	    	  		 	 						",arr[j] == 0 or j == i,"arr[j] == 1 or i == j:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
<|/ file ext=.py |>"
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if {{completion}}:
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
	  	 	    						 	 		 	 	 	 	 	",arr[i] == 1 or i == j,"arr[i] == 0 or i == j:
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
<|/ file source=github ext=.py |>"
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        i+=1
    while True:
      if {{completion}}:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
	  	 	    						 	 		 	 	 	 	 	",arr[j] == 0 or j == i,"arr[j] == 1 or i == j:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
<|/ a tags=arrays,algorithm,python |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/ c |>
<| c |>
Please add some explanation to your answer such that others can learn from it
<|/"
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for {{completion}}:
  n = inp1()
  k = inp1()
  a = set(inp(n))
  print(""YES"" if 1 in a else ""NO"")
",_ in range(t),"_ in range(t):
  n = inp1()
  k = inp1()
  a = set(inp(n))
  print(""YES"" if 1 in a else ""NO"")
  
t = inp1()
for _ in range(t):
  n = inp1()
  k = inp1()
  a = set(inp(n))
  print(""YES"" if 1 in a else ""NO"")
  
t = inp1()
for _ in range(t):
  n = inp1()
  k = inp1()
  a = set(inp(n))
  print(""YES"" if 1 in a else ""NO"")
  
t = inp1()
for _ in range(t):
  n = inp1()
  k = "
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def solve():
    n = getInt()
    a = list(getList())
    j = res = 0
    p = [0] * n
    P = [0] * n
    from bisect import bisect_left
    f = {}
    for i, x in enumerate(a):
        j = max(j, i)
        while j < n and a[j] >= j+1 - i:
            j += 1
        res += j - i
        if j-1 not in f:
            f[j-1] = i
            J = j + 1  # further extends
        while J < n and a[J] >= J + 1 - i:
            J += 1
        p[i] = p[i-1] + j - 1
        P[i] = P[i-1] + J - j
    q = getInt()

    def calc(l, r, p):
        if l > r:
            return 0
        res = p[r]
        if l:
            res -= p[l-1]
        return res

    keys = sorted(f.keys())
    for _ in range(q):
        u, v = getList()
        u -= 1
        ans = res
        it = bisect_left(keys, u)
        if v < a[u]:
            it = keys[it]
            l = max(f[it], u + 1 - v)
            ans -= calc(f[it], l-1, p) - (u-1) * (l-f[it])
        elif v > a[u]:
            if {{completion}}:
                l = max(f[keys[it-1]], u+1-v)
                ans += calc(l, f[keys[it]]-1, P)
        print(ans)


for _ in range(t):
    solve()
",it and keys[it-1] + 1 == u,u
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def solve():
    n = getInt()
    a = list(getList())
    j = res = 0
    p = [0] * n
    P = [0] * n
    from bisect import bisect_left
    f = {}
    for i, x in enumerate(a):
        j = max(j, i)
        while j < n and a[j] >= j+1 - i:
            j += 1
        res += j - i
        if j-1 not in f:
            f[j-1] = i
            J = j + 1  # further extends
        while J < n and a[J] >= J + 1 - i:
            J += 1
        p[i] = p[i-1] + j - 1
        P[i] = P[i-1] + J - j
    q = getInt()

    def calc(l, r, p):
        if l > r:
            return 0
        res = p[r]
        if l:
            res -= p[l-1]
        return res

    keys = sorted(f.keys())
    for _ in range(q):
        u, v = getList()
        u -= 1
        ans = res
        it = bisect_left(keys, u)
        if v < a[u]:
            it = keys[it]
            l = max(f[it], u + 1 - v)
            ans -= calc(f[it], l-1, p) - (u-1) * (l-f[it])
        elif {{completion}}:
            if it and keys[it-1] + 1 == u:
                l = max(f[keys[it-1]], u+1-v)
                ans += calc(l, f[keys[it]]-1, P)
        print(ans)


for _ in range(t):
    solve()
",v > a[u],"v > a[u]:
            it = keys[it]
            l = max(f[it], u + 1 - v)
            ans += calc(f[it], l-1, p) - (u-1) * (l-f[it])
        else:
            it = keys[it]
            l = max(f[it], u+1-v)
            ans -= calc(f[it], l-1, P)
        if it == len(keys):
            ans += calc(f[it], u+1-v, P)
        elif keys[it-1] + 1 == u"
"from sys import stdin, stdout
from collections import defaultdict

n = int(stdin.readline())
a = [int(x) for x in stdin.readline().split()]

left = 0
right = 0
right_array = []
right_prefix = [0]
answer = 0

second_right = 0
second_right_array = []
second_right_prefix = [0]

while left < n:
    if right < left:
        right = left
    while right < n and a[right] >= right-left+1:
        right += 1
    right_array.append(right)
    right_prefix.append(right_prefix[-1]+right_array[-1])
    answer += right - left

    if second_right <= right:
        second_right = right + 1
        if second_right > n:
            second_right = n
    while second_right < n and a[second_right] >= second_right-left+1:
        second_right += 1
    second_right_array.append(second_right)
    second_right_prefix.append(second_right_prefix[-1]+second_right_array[-1])

    left += 1

p_to_right = defaultdict(list)
for i in range(n):
    p_to_right[right_array[i]].append(i)

q = int(stdin.readline())
for _ in range(q):
    p, x = [int(z) for z in stdin.readline().split()]
    p -= 1
    if x == a[p]:
        adjustment = 0
    elif x < a[p]:
        if right_array[-1] <= p:
            adjustment = 0
        else:
            upper = n-1
            lower = -1
            while upper - lower > 1:
                candidate = (upper + lower)//2
                if {{completion}}:
                    upper = candidate
                else:
                    lower = candidate

            if upper > p-x:
                adjustment = 0
            else:
                adjustment = -(right_prefix[p-x+1] - right_prefix[upper] - p*(p-x-upper+1))

    else:
        if len(p_to_right[p]) == 0:
            adjustment = 0
        elif p_to_right[p][0] > p-a[p] or p_to_right[p][-1] < p-x+1:
            adjustment = 0
        else:
            lower = max(p-x+1, p_to_right[p][0])
            upper = min(p-a[p], p_to_right[p][-1])
            adjustment = second_right_prefix[upper+1] - second_right_prefix[lower] - p*(upper-lower+1)

    stdout.write(str(answer+adjustment)+'\n')
",right_array[candidate] > p,"candidate == p:
                    upper = candidate
                elif candidate == p + 1:
                    lower = candidate
                else:
                    lower = candidate

            if upper > p-x:
                adjustment = 0
            else:
                adjustment = -(right_prefix[p-x+1] - right_prefix[upper] - p*(p-x-upper+1))

    elif x > a[p]:
        if right_array[-1] <= p:
            adjustment = 0
        else:
            upper = n-1
            lower = -1
            while upper - lower > 1:
                candidate = (upper + lower)//2
                if candidate == p + 1:
                    lower = candidate
                elif candidate == "
"from sys import stdin, stdout
from collections import defaultdict

n = int(stdin.readline())
a = [int(x) for x in stdin.readline().split()]

left = 0
right = 0
right_array = []
right_prefix = [0]
answer = 0

second_right = 0
second_right_array = []
second_right_prefix = [0]

while left < n:
    if right < left:
        right = left
    while right < n and a[right] >= right-left+1:
        right += 1
    right_array.append(right)
    right_prefix.append(right_prefix[-1]+right_array[-1])
    answer += right - left

    if second_right <= right:
        second_right = right + 1
        if second_right > n:
            second_right = n
    while second_right < n and a[second_right] >= second_right-left+1:
        second_right += 1
    second_right_array.append(second_right)
    second_right_prefix.append(second_right_prefix[-1]+second_right_array[-1])

    left += 1

p_to_right = defaultdict(list)
for i in range(n):
    p_to_right[right_array[i]].append(i)

q = int(stdin.readline())
for _ in range(q):
    p, x = [int(z) for z in stdin.readline().split()]
    p -= 1
    if x == a[p]:
        adjustment = 0
    elif x < a[p]:
        if right_array[-1] <= p:
            adjustment = 0
        else:
            upper = n-1
            lower = -1
            while {{completion}}:
                candidate = (upper + lower)//2
                if right_array[candidate] > p:
                    upper = candidate
                else:
                    lower = candidate

            if upper > p-x:
                adjustment = 0
            else:
                adjustment = -(right_prefix[p-x+1] - right_prefix[upper] - p*(p-x-upper+1))

    else:
        if len(p_to_right[p]) == 0:
            adjustment = 0
        elif p_to_right[p][0] > p-a[p] or p_to_right[p][-1] < p-x+1:
            adjustment = 0
        else:
            lower = max(p-x+1, p_to_right[p][0])
            upper = min(p-a[p], p_to_right[p][-1])
            adjustment = second_right_prefix[upper+1] - second_right_prefix[lower] - p*(upper-lower+1)

    stdout.write(str(answer+adjustment)+'\n')
",upper - lower > 1,upper > lower and right_array[upper] > p-x
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        n, k, r, c = list(map(int, input_arr[pos:pos + 4]))
        pos += 4
        mat = [[""."" for _ in range(n)] for j in range(n)]
        r = r - 1
        c = c - 1
        l = n // k
        for j in range(n):
            for {{completion}}:
                mat[(r+ll*k) % n][c % n] = 'X'
                mat[r][(c + ll*k) % n] = 'X'
            r -= 1
            c += 1
        for i in mat:
            for j in i:
                print(j, end="""")
            print("""")
# '3 3 3 3 2 2 1 1 2 6 3 4 2'",ll in range(l),"k in range(k):
                mat[r][c] = 'X'
                mat[r][(c + k) % n] = 'X'
                mat[(j + k) % n][c] = 'X'
                mat[(j + k) % n][(c + k) % n] = 'X'
            r += l
            c += l
            ll = l - 1
            while ll > 0:
                mat[r][c] = 'X'
                mat[r][(c + ll*k) % n] = 'X'
                mat[(j + ll*k) % n][c] = 'X'
                mat[(j + ll*k) % n][("
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        n, k, r, c = list(map(int, input_arr[pos:pos + 4]))
        pos += 4
        mat = [[""."" for _ in range(n)] for j in range(n)]
        r = r - 1
        c = c - 1
        l = n // k
        for j in range(n):
            for ll in range(l):
                mat[(r+ll*k) % n][c % n] = 'X'
                mat[r][(c + ll*k) % n] = 'X'
            r -= 1
            c += 1
        for i in mat:
            for {{completion}}:
                print(j, end="""")
            print("""")
# '3 3 3 3 2 2 1 1 2 6 3 4 2'",j in i,"j in i:
                if j == '.':
                    print(j, end="""")
                elif j == 'X':
                    print(j, end="""")
                else:
                    print("" "", end="""")
            print("""")
        l = n // k
        l = l - 1
        for i in range(k):
            for j in range(n):
                if mat[i][j] == '.':
                    print("" "", end="""")
                elif mat[i][j] == 'X':
                    print(j, end="""")
                else:
                    print("" "", end="""")
            print("""")
        l = n // k
        l = l - 1
        for i in range(k):
            for j in range(n):
                if mat[i][j] == '.':
                    print("" "", end="""")
                elif mat[i][j] == 'X':
                    print(j, "
"import fileinput

def f(n):
    i = 0
    while i<len(n):
        if n[i] == ""Q"":
            found = False
            for j in range(i,len(n)):
                if {{completion}}:
                    n = n[:j] + n[j+1:]
                    found = True
                    break
            if not found:
                print(""NO"")
                return
        i += 1
    print(""YES"")

for line in fileinput.input():
    if len(line) > 0 and line[0] == ""Q"":
        f(line)","n[j] == ""A""","n[j] == ""A"" and n[j+1] == ""A"":
                    n = n[:j] + n[j+2:]
                    found = True
                    break
                elif n[j] == ""A"" and n[j+1] != ""A"":
                    n = n[:j] + n[j+1:]
                    found = True
                    break
                elif n[j] != ""A"" and n[j+1] == ""A"":
                    n = n[:j] + n[j+2:]
                    found = True
                    break
                elif n[j] != ""A"" and n[j+1] != ""A"":
                    n = n[:j] + n[j+1:]
                    found = True
                    break
            if not found:
                print("""
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for {{completion}}:f.append(f[-1]*i%m)
for z in map(int,input().split()):d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1
print(d%m)","i in range(1,9**6)","z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f[-1]*z%m)
for z in range(1,n+1):f.append(f"
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6):f.append(f[-1]*i%m)
for {{completion}}:d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1
print(d%m)","z in map(int,input().split())","z in range(1,n):d=0
for x in range(1,9**6):
    if f[x-1]>f[x]:d+=f[x-1]*pow(f[x]*f[x+1],-1,m)*(z>0);x+=1
    if f[x+1]>f[x]:d+=f[x+1]*pow(f[x]*f[x-1],-1,m)*(z>0);x+=1
    if f[x-1]>f[x+1]"
"from math import gcd

mod=1_000_000_007
maxn=400_100
fac=[1]*maxn
for i in range(2,maxn):
  fac[i]=(fac[i-1]*i)%mod

def inv(b,m):
  return pow(b, m - 2, m)

n=int(input())
a=list(map(int,input().split()))
o=0
for i in range(n+1):
  if {{completion}}: break
  c=fac[a[i]+i]*inv(fac[i+1]*fac[a[i]-1],mod)
  o=(o+c)%mod
print(o)",a[i]==0,a[i]>maxn
"N = 4 * 10**5 + 5
MOD = 10**9 + 7

fact = [1]
invf = [1]

for i in range(1, N):
    fact.append(fact[i-1] * i % MOD)
    invf.append(pow(fact[-1], MOD-2, MOD))


def C(m, n):
    if {{completion}}:
        return 0
    return fact[m] * invf[n] % MOD * invf[m-n] % MOD


n = int(input())
a = list(map(int, input().split()))
ans = sum(C(v+i, i+1) for i, v in enumerate(a)) % MOD
print(ans)
",n < 0 or m < n,"m == n or m > n:
        return 0
    if m == 0 or n == 0 or m > n:
        return 0
    if m == 1 or n == 1 or m > n:
        return 0
    if m == n or m > n:
        return 0
    if m == 0 or n == 0 or m > n:
        return 0
    if m == 1 or n == 1 or m > n:
        return 0
    if m == n or m > n:
        return 0
    if m == 0 or n == 0 or m > n:
        return 0
    if m == 1 or n == 1 or m > n:
        return 0
    if m == n or m > n:
        return 0
    if m == 0 or n == 0 or m > n:
        return 0
    if "
"import sys
input = sys.stdin.readline
MOD = 10 ** 9 + 7
n = int(input())
a = [int(x) for x in input().split()]
fac = [1]
for i in range(8 * 10 ** 5 - 1):
    fac.append((fac[-1] * (i + 1)) % MOD)
ans = 0
for i in range(n + 1):
    if {{completion}}:
        ans = (ans + fac[a[i] + i] * pow((fac[i + 1] * fac[a[i] - 1]), -1, MOD))
print(int(ans % MOD))",a[i] != 0,a[i] < a[i + 1]
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for {{completion}}: f.append(f[-1]*i%m)
for z in list(map(int,input().split())):
    d+=f[z+x]*pow(f[x+1]*f[z-1],m-2,m)*(z!=0)
    x+=1
print(d%m)","i in range(1,9**6)","z in range(n):
    f=f+[int(input())]
f=[f[-1]]
for z in range(n):
    f"
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6): f.append(f[-1]*i%m)
for {{completion}}:
    d+=f[z+x]*pow(f[x+1]*f[z-1],m-2,m)*(z!=0)
    x+=1
print(d%m)","z in list(map(int,input().split()))","z in range(1,n+1):
    x=0
    d=0
    for y in range(1,n+1):
        if y<f[x]: d+=f[x]*pow(f[x+1]*f[y-1],m-2,m)*(y!=0)
        x+=1
    print(d%m)
    
""""""
n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6): f.append(f[-1]*i%m)
for z in range(1,n+1):
    x=0
    d=0
    for y in range(1,n+1):
        if y<f[x]: d+=f[x]*pow(f[x+1]*f[y-1]"
"for {{completion}}:
    p = list(map(int, input()))
    print('YES' if sum(p[:3]) == sum(p[3:]) else 'NO')
",_ in range(int(input())),"_ in range(int(input())):
    t = int(input())
    for _ in range(t):
        ticket = input()
        if sum((int(i) for i in ticket[:3])) == sum((int(i) for i in ticket[3:])):
            print('YES')
        else:
            print('NO')
<|/ a tags=python,python-3.x |>
<| a tags=python,python-3.x |>
<code>
t = int(input())
for _ in range(t):
    ticket = input()
    if sum((int(i) for i in ticket[:3])) == sum((int(i) for i in ticket[3:])):
        print('YES')
    else:
        print('NO')
</code>
<|/ a dscore=0 "
for {{completion}}:print('yes' if int(_[0]) + int(_[1]) + int(_[2]) == int(_[3]) + int(_[4]) + int(_[5]) else 'NO'),_ in [*open(0)][1:],"_ in range(int(input())):
    _ = input()
    if _[0] == '0' and _[1] == '0' and _[2] == '0':
        print('YES')
    else:
        print('NO')
<|/ file source=github |>
<| c |>
"
"t = int(input())
for i in range(1, t + 1):
   summa = 0
   a = int(input())
   a6 = a % 10
   a5 = (a // 10) % 10
   a4 = (a // 100) % 10
   a3 = (a // 1000) % 10
   a2 = (a // 10000) % 10
   a1 = (a // 100000) % 10
   if {{completion}}:
      print('YES')
   else:
      print(""NO"")",a1 + a2 + a3 == a4 + a5 + a6,a6 + a5 + a4 + a3 + a2 + a1 == summa
"for {{completion}}: print(('NO', 'YES')[sum(int(p) for p in (c[:3])) == sum(int(p) for p in (c[3:]))])",c in [input() for i in range(int(input()))],"_ in range(int(input())):
    c = input()
    if c[0] == '0' and c[1] == '0' and c[2] == '0':
        print(('NO', 'YES')[sum(int(p) for p in (c[:3])) == sum(int(p) for p in (c[3:]))])
    else:
        print(('NO', 'YES')[sum(int(p) for p in (c[:3])) != sum(int(p) for p in (c[3:]))])
<|/ a |>
<| c |>
"
"import sys

def main():
    s = sys.stdin.read().strip().split('\n')[1:]
    r = []
    for {{completion}}:
        nums = list(map(int, i))
        r.append(('NO', 'YES')[sum(nums[:3]) == sum(nums[3:])])
    return r
print(*main(), sep='\n')

",i in s,"i,_ in s:
        if i == '': continue
        if i[0] == '#': continue
        if i[0] == '$': continue
        if i[0] == '@': continue
        if i[0] == '+': continue
        if i[0] == '-': continue
        if i[0] == '*': continue
        if i[0] == '/': continue
        if i[0] == '^': continue
        if i[0] == '(': continue
        if i[0] == ')': continue
        if i[0] == '[': continue
        if i[0] == ']': continue
        if i[0] == '{': continue
        if i[0] == '}': continue
        if i[0] == '.': continue
        if i[0] == '!': continue
        if i[0] == '?': continue"
"for {{completion}}:
    a = [int(j) for j in input()]
    print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")",i in range(int(input())),"_ in range(int(input())):
    t = int(input())
    for _ in range(t):
        ticket = input()
        if ticket.count('0') == 6:
            if sum(ticket[0:3]) == sum(ticket[3:6]):
                print(""YES"")
            else:
                print(""NO"")
        else:
            print(""NO"")
<|/ a tags=python,python-3.x |>
<| a dscore=0 |>
<code>
t = int(input())
for _ in range(t):
    ticket = input()
    if ticket.count('0') == 6:
        if sum(ticket[0:3]) == sum(ticket[3:6]):
            print(""YES"")
        else:
            print(""NO"")
    else:"
"t = int(input(""""))
for i in range(t):
    ticket = input("""")
    if {{completion}}:
        print(""YES"")
    else:
        print(""NO"")",int(ticket[0])+int(ticket[1])+int(ticket[2]) == int(ticket[3])+int(ticket[4])+int(ticket[5]),"ticket[0:3] == ticket[-3:]:
        print(""YES"")
    else:
        print(""NO"")
<|/ q dscore=0 |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| c |>
Please post the code you have written so far.
<|/ c |>
<| a |>
<code>
t = int(input(""""))
for i in range(t):
    ticket = input("""")
    if ticket[0:"
"s = int(input())
r = []
for i in range(s):
	a = int(input())
	if {{completion}}:
		print(""YES"", end="" "")
	else:
		print(""NO"", end="" "")
",a // 100000 + a // 10000 % 10 + a // 1000 % 10 == a // 100 % 10 + a % 10 + a // 10 % 10,"a%10 == 0:
		a//=10
		b = (a + a + a) % 10
		c = (b + b + b) % 10
		d = (c + c + c) % 10
		r.append(d)
	else:
		a//=10
		b = (a + a + a) % 10
		c = (b + b + b) % 10
		d = (c + c + c) % 10
		r.append(d)
	
	
for i in range(s):
	if r[i]==r[i+3] and r[i]==r[i+6]:
		print(""YES"", end="" "")
	else:
		print(""NO"", end="" "")
	
	"
"n=input()

for i in range(int(n)):  
    sumf=0
    suml=0
    
    s =  input()
    for {{completion}}:
           sumf += int(s[x])
           
    for x in range(3,6):
        suml += int(s[x])

    if sumf== suml:
        print('YES')
    else:
         print('NO')
  	 			 		 	 	 	 		   	  						","x in range(0,3)","x in range(0,4):
        if s[x]=='0':
           sumf += int(s[x])
           
    for x in range(4,7):
        if s[x]=='0':
           suml += int(s[x])
           
    for x in range(7,9):
        if s[x]=='0':
           sumf += int(s[x])
           
    for x in range(9,12):
        if s[x]=='0':
           suml += int(s[x])
           
    for x in range(12,15):
        if s[x]=='0':
           sumf += int(s[x])
           
    for x in range(15,18):
        if s[x]=='0':
           suml += int(s[x])
"
"n=input()

for i in range(int(n)):  
    sumf=0
    suml=0
    
    s =  input()
    for x in range(0,3):
           sumf += int(s[x])
           
    for {{completion}}:
        suml += int(s[x])

    if sumf== suml:
        print('YES')
    else:
         print('NO')
  	 			 		 	 	 	 		   	  						","x in range(3,6)","x in range(3,6):
        suml += int(s[x])
        
    if sumf== suml:
        print('YES')
    else:
         print('NO')
  	 			 		 	 	 	 		   	  						 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 "
"for {{completion}}:
    n = list(map(int, list(input())))
    print(""YES"" if n[0]+n[1]+n[2]==n[3]+n[4]+n[5] else ""NO"")",t in range(int(input())),"_ in range(int(input())):
    t = input()
    if t[0]+t[1]+t[2]==t[3]+t[4]+t[5]:
        print(""YES"")
    else:
        print(""NO"")
<|/ file source=github |>
<| c |>
Please don't post images of code/data/Tracebacks.  Just copy the text, paste it in your question and format it as code.
<|/ c |>
<| a dscore=0 |>
<code>
for _ in range(int(input())):
    t = input()
    if t[0]+t[1]+t[2]==t[3]+t[4]+t[5]:
        print(""YES"")
    else:
        print("""
"t = int(input())

def solve():
  n, m = map(int, input().split())
  A = [list(map(int, input().split())) for _ in range(n)]
  ans = 0
  for i in range(n):
    for j in range(m):
      temp = -A[i][j]
      for x in range(n):
        # i - j == x - y => y = x - i + j
        y = x - i + j
        if {{completion}}:
          temp += A[x][y]
        # i + j == x + y
        y = i + j - x
        if 0 <= y < m:
          temp += A[x][y]
      ans = max(ans, temp)
  print(ans)

for _ in range(t):
  solve()",0 <= y < m,"0 <= y < n:
          temp += A[x][y]
      for y in range(m):
        x = n - 1 - y
        if 0 <= x < n:
          temp += A[x][y]
      for x in range(m):
        x = n - 1 - y
        if 0 <= x < n:
          temp += A[x][y]
      for y in range(m):
        x = i + j - x
        if 0 <= x < n:
          temp += A[x][y]
      for x in range(m):
        x = i + j - x
        if 0 <= x < n:
          temp += A[x][y]
      for y in range(m):
        x = i - j + x
        if 0 <= x < n:
          temp += A[x][y]
"
"t = int(input())

def solve():
  n, m = map(int, input().split())
  A = [list(map(int, input().split())) for _ in range(n)]
  ans = 0
  for i in range(n):
    for j in range(m):
      temp = -A[i][j]
      for x in range(n):
        # i - j == x - y => y = x - i + j
        y = x - i + j
        if 0 <= y < m:
          temp += A[x][y]
        # i + j == x + y
        y = i + j - x
        if {{completion}}:
          temp += A[x][y]
      ans = max(ans, temp)
  print(ans)

for _ in range(t):
  solve()",0 <= y < m,"0 <= y < m:
          temp += A[x][y]
      ans = max(ans, temp)
  print(ans)

for _ in range(t):
  solve()
<|/ a dscore=0 |>"
"k,o=lambda:map(int,input().split()),range
for f in o(*k()):
 n,m=k();a=[[*k()]for t in o(n)];l=[0]*(m+n);r=l[:]
 for i in o(n):
  for {{completion}}:b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b
 print(max(l[i-j+m-1]+r[i+j]-a[i][j]for i in o(n)for j in o(m)))",j in o(m),"j in o(m):
   if j==m:
    l[i-j+m-1]+=a[i][j]
    r[i+j]+=a[i][j]
   else:
    l[i-j+m-1]+=a[i][j]
    r[i+j]+=a[i][j]
   if j==m-1:
    l[i-j+m-1]+=a[i][j]
    r[i+j]+=a[i][j]
   if i==n-1:
    l[i-j+m-1]+=a[i][j]
    r[i+j]+=a[i][j]
   if i==n-1:
    l[i-j+m-1]+=a[i][j]
    r[i+"
"T = int(input())

for tc in range(T):
    (A, B) = map(int, input().split(' '))
    nums = []
    for i in range(A):
        nums.append([int(x) for x in input().split()])


    C = A + B - 1
    left = [0 for _ in range(C)]
    right = [0 for _ in range(C)]
    for a in range(A):
        for {{completion}}:
            left_index = a + b
            right_index = a + B - 1 - b
            left[left_index] += nums[a][b]
            right[right_index] += nums[a][b]
    # print (left)
    # print (right)

    damage = 0
    for a in range(A):
        for b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)

    print (damage)
",b in range(B),"b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            left[left_index] += nums[a][b]
            right[right_index] += nums[a][b]
    damage = 0
    for a in range(A):
        for b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)

    print (damage)
""""""
<|/ q tags=python,algorithm |>
<| c |>
Please post the code "
"T = int(input())

for tc in range(T):
    (A, B) = map(int, input().split(' '))
    nums = []
    for i in range(A):
        nums.append([int(x) for x in input().split()])


    C = A + B - 1
    left = [0 for _ in range(C)]
    right = [0 for _ in range(C)]
    for a in range(A):
        for b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            left[left_index] += nums[a][b]
            right[right_index] += nums[a][b]
    # print (left)
    # print (right)

    damage = 0
    for a in range(A):
        for {{completion}}:
            left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)

    print (damage)
",b in range(B),"b in range(B):
            if left[a] + right[b] - nums[a][b] > damage"
"import sys
sm_row = [-1, +1, -1, +1]
sm_column = [-1, +1, +1, -1]
for _ in range(int(sys.stdin.readline())):
    n, m = map(int, sys.stdin.readline().split())
    t = []
    maximum = 0
    for i in range(n):
        t.append(list(map(int, sys.stdin.readline().split())))
    for row in range(n):
        for column in range(m):
            summa = 0
            for i in range(4):
                new_row = row
                new_column = column
                while {{completion}}:
                    summa += t[new_row][new_column]
                    new_row += sm_row[i]
                    new_column += sm_column[i]
            summa -= (t[row][column] * 3)
            maximum = max(maximum, summa)
    print(maximum)
",0 <= new_row < n and 0 <= new_column < m,"new_row >= 0 and new_column >= 0 and new_row < n and new_column < m and t[new_row][new_column] > 0:
                    summa += t[new_row][new_column]
                    new_row += sm_row[i]
                    new_column += sm_column[i]
                summa -= (t[row][column] * 3)
                maximum = max(maximum, summa)
    print(maximum)
""""""
<|/ a tags=algorithm,python,python-3.x |>
<| a dscore=0 |>
<code>
import sys
sm_row = [-1, +1, -1, +1]
sm_column = [-1, +1, +1, -1]
for _ in range(int(sys.stdin.read"
"# auther: codeCell
for _ in range(int(input())):
    n,m=map(int,input().split())
    a = [ [*map(int, input().split())] for _ in range(n)]
 
    u = [0]*(n+m-1)
    v = [0]*(n+m-1)
    for i in range(n):
        for {{completion}}:
            u[i+j] += a[i][j]
            v[i-j] += a[i][j]
    for i in range(n):
        for j in range(m):
            a[i][j] = u[i+j] + v[i-j] - a[i][j]
    print(max(map(max,a)))          



",j in range(m),"j in range(a[i][0]):
            u[i+j] += 1
    for i in range(m):
        for j in range(a[0][i]):
            v[i-j] += 1
    for i in range(n):
        for j in range(m):
            a[i][j] = u[i+j] + v[i-j] - a[i][j]
    print(max(map(max,a)))
<|/ file filename=chessboard.py |>"
"# auther: codeCell
for _ in range(int(input())):
    n,m=map(int,input().split())
    a = [ [*map(int, input().split())] for _ in range(n)]
 
    u = [0]*(n+m-1)
    v = [0]*(n+m-1)
    for i in range(n):
        for j in range(m):
            u[i+j] += a[i][j]
            v[i-j] += a[i][j]
    for i in range(n):
        for {{completion}}:
            a[i][j] = u[i+j] + v[i-j] - a[i][j]
    print(max(map(max,a)))          



",j in range(m),j in range
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n,m=M();l=[L() for i in range(n)];ans=0
    for i in range(n):
        for j in range(m):
            s=l[i][j]
            p,q=i,j;s-=l[p][q]
            while {{completion}}:
                s+=l[p][q];p-=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p>=0 and q<m:
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p<n and q>=0:
                s+=l[p][q];p+=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p<n and q<m:
                s+=l[p][q];p+=1;q+=1
            ans=max(ans,s)
    print(ans)",p>=0 and q>=0,"p>=0 and q>=0:
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p<n and q>=0:
                s+=l[p][q];p+=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p<n and q<m:
                s+=l[p][q];p+=1;q+=1
            ans=max(ans,s)
    print(ans)
<|/ q tags=python,algorithm |>
<| c |>
Please post the code in the question "
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n,m=M();l=[L() for i in range(n)];ans=0
    for i in range(n):
        for j in range(m):
            s=l[i][j]
            p,q=i,j;s-=l[p][q]
            while p>=0 and q>=0:
                s+=l[p][q];p-=1;q-=1
            p,q=i,j;s-=l[p][q]
            while {{completion}}:
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p<n and q>=0:
                s+=l[p][q];p+=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p<n and q<m:
                s+=l[p][q];p+=1;q+=1
            ans=max(ans,s)
    print(ans)",p>=0 and q<m,"p>=0 and q<m:
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p>=0 and q>=0:
                s+=l[p][q];p-=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p>=0 and q<m:
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p>=0 and q>=0:
                s+=l[p][q];p-=1;q-=1"
"t=eval(input())

for i in range(t):
    ans=-1
    temp=[int(x) for x in input().split()]
    n,m=temp[0],temp[1] # n*m
    check=[]
    for j in range(n):
        temp=[int(x) for x in input().split()]
        check.append(temp)

    dic_l={}
    dic_r={}

    for x in range(n):
        for y in range(m):
            if {{completion}}:
                dic_l[x+y]=check[x][y]
            else:
                dic_l[x+y]+=check[x][y]
            if y-x not in dic_r:
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for y in range(m):
            ans=max(ans,dic_l[x+y]+dic_r[y-x]-check[x][y])
    
    print(ans)
            
    ",x+y not in dic_l,"x+y not in dic_l:
                dic_l[x+y]=check[x][y]
            else:
                dic_l[x+y]+=check[x][y]
            if y-x not in dic_r:
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for y in range(m):
            ans=max(ans,dic_l[x+y]+dic_r[y-x]-check[x][y])
    
    print(ans)
            
    
    
    
    
    
"
"t=eval(input())

for i in range(t):
    ans=-1
    temp=[int(x) for x in input().split()]
    n,m=temp[0],temp[1] # n*m
    check=[]
    for j in range(n):
        temp=[int(x) for x in input().split()]
        check.append(temp)

    dic_l={}
    dic_r={}

    for x in range(n):
        for y in range(m):
            if x+y not in dic_l:
                dic_l[x+y]=check[x][y]
            else:
                dic_l[x+y]+=check[x][y]
            if {{completion}}:
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for y in range(m):
            ans=max(ans,dic_l[x+y]+dic_r[y-x]-check[x][y])
    
    print(ans)
            
    ",y-x not in dic_r,"y-x not in dic_r:
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for y in range(m):
            if x+y not in dic_l:
                dic_l[x+y]=check[x][y]
            else:
                dic_l[x+y]+=check[x][y]
            if y-x not in dic_r:
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for "
"def calc(x, y):
    ans = 0
    x1, y1 = x, y
    while x1 > 0 and y1 > 0:
        ans += field[y1 - 1][x1 - 1]
        x1 -= 1
        y1 -= 1
    # print(""OK"", x1, y1)
    x1, y1 = x, y
    x1 += 1
    y1 += 1
    while x1 <= m and y1 <= n:
        ans += field[y1 - 1][x1 - 1]
        x1 += 1
        y1 += 1
    x1, y1 = x, y
    x1 -= 1
    y1 += 1

    while x1 > 0 and y1 <= n:
        ans += field[y1 - 1][x1 - 1]
        x1 -= 1
        y1 += 1
    x1, y1 = x, y
    x1 += 1
    y1 -= 1

    while x1 <= m and y1 > 0:
        ans += field[y1 - 1][x1 - 1]
        x1 += 1
        y1 -= 1
    return ans


for _ in range(int(input())):
    n, m = map(int, input().split())
    field = [list(map(int, input().split())) for _ in range(n)]
    max_sum = -1
    for y in range(n):
        for {{completion}}:
            max_sum = max(max_sum, calc(x + 1, y + 1))
    print(max_sum)
",x in range(m),"x in range(m):
            if field[y][x] > 0:
                max_sum = max(max_sum, calc(x, y))
    for y in range(n):
        for x in range(m):
            if field[y][x] > 0:
                max_sum = max(max_sum, calc(x, y))
    for y in range(n):
        for x in range(m):
            if field[y][x] > 0:
                max_sum = max(max_sum, calc(x, y))
    for y in range(n):
        for x in range(m):
            if field[y][x] > 0:
                max_sum = max(max_sum, calc(x, y))
    for y in range(n):
        for x in range(m):
            if field[y][x] > 0:
                max_sum = max(max_sum, calc(x, y))"
"I,R=lambda:map(int,input().split()),range
for _ in R(*I()):
 n,m=I();a=[[*I()] for _ in R(n)];l=[0]*(m+n);r=l[:]
 for i in R(n):
  for {{completion}}:
   b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b
 print(max(l[i-j+m-1]+r[i+j]-a[i][j] for i in R(n) for j in R(m)))",j in R(m),"j in R(m):
   if a[i][j]<10^6:
    l[i-j+m-1]+=a[i][j];r[i+j]+=a[i][j]
 print(max(l[i-j+m-1]+r[i+j]-a[i][j] for i in R(n) for j in R(m)))
<|/ q dscore=0 |>
<| c |>
Please don't post images of code. Post the code as text directly in the question.
<|/ c |>
<| c |>
Please don't post images of code. Post the code as text directly in the question.
<|/ c |>
<| c |>
Please don't post image"
"t=int(input())
for p in range(t):
    n,m=map(int,input().split())
    c=[]
    b=[]
    s=0
    for i in range(n):
        a=list(map(int,input().split()))
        b+=[a]
    for k in range(n):
        for l in range(m):
            for {{completion}}:
                s+=b[k-v][l-v]
            for w in range(1,min(n-k-1,m-l-1)+1):
                s+=b[k+w][l+w]
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
","v in range(min(l,k)+1)","v in range(1,min(k,m-l+1)+1):
                s+=b[k-v][l-v]
            for w in range(1,min(n-k-1,m-l-1)+1):
                s+=b[k+w][l+w]
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
""""""
<|/ a tags=python,python-3.x |>
<| a tags="
"t=int(input())
for p in range(t):
    n,m=map(int,input().split())
    c=[]
    b=[]
    s=0
    for i in range(n):
        a=list(map(int,input().split()))
        b+=[a]
    for k in range(n):
        for l in range(m):
            for v in range(min(l,k)+1):
                s+=b[k-v][l-v]
            for {{completion}}:
                s+=b[k+w][l+w]
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
","w in range(1,min(n-k-1,m-l-1)+1)","w in range(min(k,l)+1):
                s+=b[k-w][l-w]
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
""""""
<|/ a dscore=0 |>
<| a |>
<code>
t=int(input())
for p in range(t):
    n,m=map(int,input().split())
    c=[]
    b=[]
    s=0"
"h, w, q = map(int, input().split())
p = [False] * (h * w)

c = cc = 0


def query(y, x):
    global c, cc
    i = x*h+y
    p[i] = not p[i]
    if p[i]:
        if i < c:
            cc += 1
        c += 1
        if p[c-1]:
            cc += 1
    else:
        if {{completion}}:
            cc -= 1
        c -= 1
        if p[c]:
            cc -= 1
    return c - cc


for y in range(h):
    inp = input()
    for x in range(w):
        if inp[x] == '*':
            query(y, x)

for _ in range(q):
    x, y = map(int, input().split())
    print(query(x-1, y-1))
",i < c,"i > c:
            cc += 1
        c += 1
        if p[c]:
            cc += 1
    if p[c-1]:
        if i < c:
            cc -= 1
        c -= 1
        if p[c-1]:
            cc -= 1
    else:
        if i > c:
            cc -= 1
        c -= 1
        if p[c]:
            cc -= 1
    if p[c-1]:
        if i < c:
            cc += 1
        c += 1
        if p[c-1]:
            cc += 1
    else:
        if i > c:
            cc += 1
        c += 1
        if p[c]:
            cc += 1
    if p[c-1]:
"
"h, w, q = map(int, input().split())
p = [False] * (h * w)

c = cc = 0


def query(y, x):
    global c, cc
    i = x*h+y
    p[i] = not p[i]
    if p[i]:
        if i < c:
            cc += 1
        c += 1
        if p[c-1]:
            cc += 1
    else:
        if i < c:
            cc -= 1
        c -= 1
        if {{completion}}:
            cc -= 1
    return c - cc


for y in range(h):
    inp = input()
    for x in range(w):
        if inp[x] == '*':
            query(y, x)

for _ in range(q):
    x, y = map(int, input().split())
    print(query(x-1, y-1))
",p[c],p[c-1]
"from sys import stdin
rln=stdin.buffer.readline
rl=lambda:rln().rstrip(b'\r\n').rstrip(b'\n')
ri=lambda:int(rln())
rif=lambda:[*map(int,rln().split())]
rt=lambda:rl().decode()
rtf=lambda:rln().decode().split()
inf=float('inf')
dir4=[(-1,0),(0,1),(1,0),(0,-1)]
dir8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'

m,n,q=rif()
a=[0]*(m*n)
for y in range(m):
  s=rt()
  for {{completion}}:
    a[m*x+y]=s[x]=='*'
k=sum(a)
l=sum(a[:k])
for _ in range(q):    
  x,y=rif()
  x,y=x-1,y-1
  i=x+m*y
  if a[i]:
    k-=1
    l-=a[k]
    l-=i<k
    a[i]^=1
  else:
    a[i]^=1
    l+=i<k
    l+=a[k]
    k+=1
  print(k-l)
",x in range(n),"x in range(n):
    if s[x]=='*':
      a[m*x+y]=s[x]=='*'
k=sum(a)
l=sum(a[:k])
for _ in range(q):    
  x,y=rif()
  x,y=x-1,y-1
  i=x+m*y
  if a[i]:
    k-=1
    l-=a[k]
    l-=i<k
    a[i]^=1
  else:
    a[i]^=1
    l+=i<k
    l+=a[k]
    k+=1
  print(k-l)
  
'''
from sys import stdin
rln=stdin.buffer.readline"
"from sys import stdin
rln=stdin.buffer.readline
rl=lambda:rln().rstrip(b'\r\n').rstrip(b'\n')
ri=lambda:int(rln())
rif=lambda:[*map(int,rln().split())]
rt=lambda:rl().decode()
rtf=lambda:rln().decode().split()
inf=float('inf')
dir4=[(-1,0),(0,1),(1,0),(0,-1)]
dir8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'

m,n,q=rif()
a=[0]*(m*n)
for y in range(m):
  s=rt()
  for x in range(n):
    a[m*x+y]=s[x]=='*'
k=sum(a)
l=sum(a[:k])
for _ in range(q):    
  x,y=rif()
  x,y=x-1,y-1
  i=x+m*y
  if {{completion}}:
    k-=1
    l-=a[k]
    l-=i<k
    a[i]^=1
  else:
    a[i]^=1
    l+=i<k
    l+=a[k]
    k+=1
  print(k-l)
",a[i],a[i]==YES
"import sys

n, m, k = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(n)]
cnt = 0
for i in range(n):
    for j in range(m):
        cnt += board[i][j] == '*'

clean = 0
q, r = divmod(cnt, n)
for j in range(q):
    for i in range(n):
        clean += board[i][j] == '*'

for i in range(r):
    clean += board[i][q] == '*'

for _ in range(k):
    x, y = map(int, sys.stdin.readline().split())
    x -= 1
    y -= 1
    if board[x][y] == '.':
        board[x][y] = '*'
        cnt += 1
        q, r = divmod(cnt - 1, n)
        if board[r][q] == '*':
            clean += 1
        if n * y + x <= cnt - 1:
            clean += 1
        if (q, r) == (y, x):
            clean -= 1
    else:
        cnt -= 1
        q, r = divmod(cnt, n)
        if {{completion}}:
            clean -= 1
        if n * y + x <= cnt - 1:
            clean -= 1
        board[x][y] = '.'

    print(cnt - clean)
",board[r][q] == '*',"board[r][q] == '*':
            clean -= 1
        if board[r][q] == '.':
            board[r][q] = '*'
            cnt += 1
            q, r = divmod(cnt - 1, n)
            if board[r][q] == '*':
                clean += 1
            if n * y + x <= cnt - 1:
                clean += 1
            if (q, r) == (y, x):
                clean -= 1
        if board[x][y] == '*':
            board[x][y] = '*'
            cnt += 1
            q, r = divmod(cnt - 1, n)
            if board[r][q] == '*':
                clean += 1
            if n * y + x <= cn"
"import sys

n, m, k = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(n)]
cnt = 0
for i in range(n):
    for j in range(m):
        cnt += board[i][j] == '*'

clean = 0
q, r = divmod(cnt, n)
for j in range(q):
    for i in range(n):
        clean += board[i][j] == '*'

for i in range(r):
    clean += board[i][q] == '*'

for _ in range(k):
    x, y = map(int, sys.stdin.readline().split())
    x -= 1
    y -= 1
    if board[x][y] == '.':
        board[x][y] = '*'
        cnt += 1
        q, r = divmod(cnt - 1, n)
        if board[r][q] == '*':
            clean += 1
        if n * y + x <= cnt - 1:
            clean += 1
        if (q, r) == (y, x):
            clean -= 1
    else:
        cnt -= 1
        q, r = divmod(cnt, n)
        if board[r][q] == '*':
            clean -= 1
        if {{completion}}:
            clean -= 1
        board[x][y] = '.'

    print(cnt - clean)
",n * y + x <= cnt - 1,"n * y + x <= cnt - 1:
            clean -= 1
        if (q, r) == (y, x):
            clean -= 1
        if board[x][y] == '*':
            clean -= 1
        if board[r][q] == '.':
            clean -= 1
        if board[x][y] == '.':
            clean -= 1
        if board[r][q] == '*':
            clean -= 1
        if board[x][y] == '*':
            clean -= 1
        if board[r][q] == '.':
            clean -= 1
        if board[x][y] == '.':
            clean -= 1
        if board[r][q] == '*':
            clean -= 1
        if board"
"
n,m,q = map(int, input().split())
s = [input() for _ in range(n)]
s = [s[j][i] for i in range(m) for j in range(n)]
qrr = [list(map(int, input().split())) for _ in range(q)]
qrr = [n * (q[1] - 1) + q[0] - 1 for q in qrr]
count = s.count('*')
correct = s[:count].count('*')
for q in qrr:
	count += 1 if s[q] == '.' else -1
	if {{completion}}:
		correct += 1 if q < count else 0
		correct += 1 if s[count-1] == '*' else 0
	else:
		correct -= 1 if q < count else 0
		correct -= 1 if s[count] == '*' else 0
	print(count - correct)
	s[q] = '.' if s[q] == '*' else '*'
	",s[q] == '.',"s[count] == '.':
		correct += 1 if q < count else 0
		correct += 1 if s[count-1] == '*' else 0
	elif s[count] == '*':
		correct -= 1 if q < count else 0
		correct -= 1 if s[count-1] == '*' else 0
	elif s[count-1] == '."
"from itertools import chain
I=lambda:map(int,input().split())
n,m,q=I()
g0=[list(input()) for _ in range(n)]
g=list(chain.from_iterable(zip(*g0)))
tot=g.count('*')
inner=g[:tot].count('*')

for _ in range(q):
  i,j=I()
  p=(j-1)*n+i-1
  if g[p]=='*':
    tot-=1
    #""tide fall""
    if g[tot]=='*':inner-=1
    if p<tot:inner-=1
    g[p]='.'
  else:
    g[p]='*'
    #""tide rise""
    if {{completion}}:inner+=1
    if p<tot:inner+=1
    tot+=1
  print(tot-inner)",g[tot]=='*',"g[tot]=='*':inner+=1
    if p<tot:inner+=1
    tot+=1
  print(tot-inner)
<|/ a dscore=0 |>
<| c |>
Please don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| c |>
Thank you for your suggestion.
<|/ c |>
<| a dscore=0 |>
<code>
from itertools import chain
I=lambda"
"from itertools import chain
I=lambda:map(int,input().split())
n,m,q=I()
g0=[list(input()) for _ in range(n)]
g=list(chain.from_iterable(zip(*g0)))
tot=g.count('*')
inner=g[:tot].count('*')

for _ in range(q):
  i,j=I()
  p=(j-1)*n+i-1
  if g[p]=='*':
    tot-=1
    #""tide fall""
    if g[tot]=='*':inner-=1
    if p<tot:inner-=1
    g[p]='.'
  else:
    g[p]='*'
    #""tide rise""
    if g[tot]=='*':inner+=1
    if {{completion}}:inner+=1
    tot+=1
  print(tot-inner)",p<tot,p<tot
"n,m,q=map(int,input().split())
z=[] # 2d
a=[] # 1d
c=0 # count icons
ans=0
for i in range(n):
    z.append(list(input()))
for i in range(m):
    for j in range(n):
        if z[j][i]==""*"":
            a.append(1)
            c+=1
        else:
            a.append(0)
ans=c
for i in range(c):
    if a[i]==1:
        ans-=1
for i in range(q):
    x,y=map(int,input().split())
    if a[n*(y-1)+x-1]==1:
        a[n*(y-1)+x-1]=0
        c-=1
        if n*(y-1)+x-1 > c:
            ans-=1
        if a[c]==1:
            ans+=1
    elif a[n*(y-1)+x-1]==0: # xor
        a[n*(y-1)+x-1]=1
        c+=1
        if n*(y-1)+x-1 >= c-1: # c or c-1?
            ans+=1
        if c: # if c>0
            if {{completion}}:
                ans-=1
    print(ans)",a[c-1]==1,"a[n*(y-1)+x-1]==1:
                ans-=1
            if a[n*(y-1)+x-1]==0:
                ans-=1
            if a[n*(y-1)+x-1]==a[n*(y-1)+x-1]"
"n,m,q=map(int,input().split())
z=[] # 2d
a=[] # 1d
c=0 # count icons
ans=0
for i in range(n):
    z.append(list(input()))
for i in range(m):
    for j in range(n):
        if z[j][i]==""*"":
            a.append(1)
            c+=1
        else:
            a.append(0)
ans=c
for i in range(c):
    if a[i]==1:
        ans-=1
for i in range(q):
    x,y=map(int,input().split())
    if a[n*(y-1)+x-1]==1:
        a[n*(y-1)+x-1]=0
        c-=1
        if n*(y-1)+x-1 > c:
            ans-=1
        if a[c]==1:
            ans+=1
    elif a[n*(y-1)+x-1]==0: # xor
        a[n*(y-1)+x-1]=1
        c+=1
        if {{completion}}: # c or c-1?
            ans+=1
        if c: # if c>0
            if a[c-1]==1:
                ans-=1
    print(ans)",n*(y-1)+x-1 >= c-1,n*(y-1)+x-1 > c
"import sys


def solve():
    # n = int(sys.stdin.readline().strip())
    n, m, q = [int(x) for x in sys.stdin.readline().strip().split()]

    a = []
    m = [0] * (m * n)
    for y in range(n):
        s = sys.stdin.readline().strip()
        for x, c in enumerate(s):
            if c == '*':
                a.append(x * n + y)
                m[x * n + y] = 1

    cnt = len(a)
    correct = sum(1 for x in a if x < cnt)

    for _ in range(q):
        y, x = [int(p) for p in sys.stdin.readline().strip().split()]
        y -= 1
        x -= 1
        z = x * n + y
        if m[z] == 0:
            if m[cnt] == 1:
                correct += 1
            m[z] = 1
            cnt += 1
            if z < cnt:
                correct += 1
        else:
            cnt -= 1
            if {{completion}}:
                correct -= 1
            m[z] = 0
            if z < cnt:
                correct -= 1
        # print(f""cnt={cnt} cor={correct}"")
        print(cnt - correct)

# t = int(sys.stdin.readline().strip())
t = 1
for _ in range(t):
    solve()
",m[cnt] == 1,"m[z] == 1:
                correct += 1
            m[z] = 0
            if z < cnt:
                correct += 1
        if m[z] == 0:
            if m[cnt] == 1:
                correct -= 1
            m[z] = 1
            cnt += 1
            if z < cnt"
"import sys


def solve():
    # n = int(sys.stdin.readline().strip())
    n, m, q = [int(x) for x in sys.stdin.readline().strip().split()]

    a = []
    m = [0] * (m * n)
    for y in range(n):
        s = sys.stdin.readline().strip()
        for x, c in enumerate(s):
            if c == '*':
                a.append(x * n + y)
                m[x * n + y] = 1

    cnt = len(a)
    correct = sum(1 for x in a if x < cnt)

    for _ in range(q):
        y, x = [int(p) for p in sys.stdin.readline().strip().split()]
        y -= 1
        x -= 1
        z = x * n + y
        if m[z] == 0:
            if m[cnt] == 1:
                correct += 1
            m[z] = 1
            cnt += 1
            if z < cnt:
                correct += 1
        else:
            cnt -= 1
            if m[cnt] == 1:
                correct -= 1
            m[z] = 0
            if {{completion}}:
                correct -= 1
        # print(f""cnt={cnt} cor={correct}"")
        print(cnt - correct)

# t = int(sys.stdin.readline().strip())
t = 1
for _ in range(t):
    solve()
",z < cnt,z < cnt
"
from collections import deque

n,m=[int(x) for x  in input().split()]
g=[[] for _ in range(n)]
indeg=[0]*n
outdeg=[0]*n
tpdeg=[0]*n
for _ in range(m):
    v,u=[int(x) for x  in input().split()]
    v-=1
    u-=1
    g[v].append(u)
    outdeg[v]+=1
    indeg[u]+=1
    tpdeg[u]+=1


q=deque(i for i in range(n) if indeg[i]==0)
f=[1]*n

while q:
    u=q.popleft()

    for v in g[u]:
        if {{completion}}:
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if tpdeg[v]==0:
            q.append(v)


print(max(f))



",indeg[v]>1 and outdeg[u]>1,"indeg[v]==0 and outdeg[v]==0:
            q.append(v)
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if tpdeg[v]==0:
            q.append(v)

print(max(f))








from collections import deque

n,m=[int(x) for x  in input().split()]
g=[[] for _ in range(n)]
indeg=[0]*n
outdeg=[0]*n
tpdeg=[0]*n
for _ in range(m):
    v,u=[int(x) for x  in input().split()]
    v-=1
    u-=1
    g[v].append(u)
"
"
from collections import deque

n,m=[int(x) for x  in input().split()]
g=[[] for _ in range(n)]
indeg=[0]*n
outdeg=[0]*n
tpdeg=[0]*n
for _ in range(m):
    v,u=[int(x) for x  in input().split()]
    v-=1
    u-=1
    g[v].append(u)
    outdeg[v]+=1
    indeg[u]+=1
    tpdeg[u]+=1


q=deque(i for i in range(n) if indeg[i]==0)
f=[1]*n

while q:
    u=q.popleft()

    for v in g[u]:
        if indeg[v]>1 and outdeg[u]>1:
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if {{completion}}:
            q.append(v)


print(max(f))



",tpdeg[v]==0,"tpdeg[v]==0:
            q.append(v)

    for v in g[u]:
        if indeg[v]>1 and outdeg[u]==1:
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if tpdeg[v]==0:
            q.append(v)

    for v in g[u]:
        if indeg[v]==0 and outdeg[u]>1:
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if tpdeg[v]==0:
            q.append(v)

    for v in g[u]:
        if indeg[v]==0 and outdeg[u]=="
"
def iint():
    return int(input().strip())

def iints():
    return map(int, input().strip().split("" ""))

def arr():
    return list(input().strip().split("" ""))

def arri():
    return list(iints())

n,m = iints()

class Graph:
    def __init__(self, n):
        self.adj = [[] for _ in range(n)]
        self.ins = [0 for _ in range(n)]
        self.outs = [0 for _ in range(n)]
    def add(self, a, b):
        self.adj[a].append(b)
        self.ins[b]+=1
        self.outs[a]+=1

g = Graph(n)
ins2 = [0 for _ in range(n)]
for _ in range(m):
    a,b = iints()
    a-=1
    b-=1
    g.add(a,b)
    ins2[b]+=1


order = [0 for _ in range(n)]
f = 0
b = 0
for i in range(n):
    if not ins2[i]:
        order[b] = i
        b+=1
dp = [1 for _ in range(n)]
ans = 0
while f < n:
    cur = order[f]
    f += 1
    for x in g.adj[cur]:
        ins2[x] -= 1
        if {{completion}}:
            order[b] = x
            b += 1
        if g.ins[x] > 1 and g.outs[cur] > 1:
            dp[x] = max(dp[x], 1 + dp[cur])
    ans = max(ans, dp[cur])
print(ans)
",not ins2[x],"ins2[x] == 0 and g.outs[x] == 0 and g.ins[x] == 0 and g.ins[cur] == 0 and g.outs[cur] == 0 and g.ins[cur] >= g.outs[cur] and g.outs[cur] >= g.ins[cur]:
            g.remove(x)
            ins2[x] = 0
            f -= 1
            break
        if ins2[x] == 0 and g.outs[x] == 0 and g.ins[x] == 0 and g.ins[cur] == 0 and g.outs[cur] == 0 and g.ins[cur] >= g.outs[cur] and g.outs[cur] >= g.ins[cur]:
            g.remove(x)
            ins2[x] = 0
            "
"
def iint():
    return int(input().strip())

def iints():
    return map(int, input().strip().split("" ""))

def arr():
    return list(input().strip().split("" ""))

def arri():
    return list(iints())

n,m = iints()

class Graph:
    def __init__(self, n):
        self.adj = [[] for _ in range(n)]
        self.ins = [0 for _ in range(n)]
        self.outs = [0 for _ in range(n)]
    def add(self, a, b):
        self.adj[a].append(b)
        self.ins[b]+=1
        self.outs[a]+=1

g = Graph(n)
ins2 = [0 for _ in range(n)]
for _ in range(m):
    a,b = iints()
    a-=1
    b-=1
    g.add(a,b)
    ins2[b]+=1


order = [0 for _ in range(n)]
f = 0
b = 0
for i in range(n):
    if not ins2[i]:
        order[b] = i
        b+=1
dp = [1 for _ in range(n)]
ans = 0
while f < n:
    cur = order[f]
    f += 1
    for x in g.adj[cur]:
        ins2[x] -= 1
        if not ins2[x]:
            order[b] = x
            b += 1
        if {{completion}}:
            dp[x] = max(dp[x], 1 + dp[cur])
    ans = max(ans, dp[cur])
print(ans)
",g.ins[x] > 1 and g.outs[cur] > 1,"ins2[x] < 0:
            dp[x] = max(dp[x], dp[cur])
        else:
            dp[x] = max(dp[x], dp[cur] + 1)
        if ins2[x] == 0 and dp[x] > ans:
            ans = dp[x]
            
for _ in range(m):
    a,b = arri()
    a-=1
    b-=1
    g.add(a,b)
    ins2[b]+=1
dp = [1 for _ in range(n)]
ans = 0
for _ in range(m):
    cur = order[f]
    f += 1
    for x in g.adj[cur]:
        ins2[x] -= 1
        if not ins2"
"import sys
from collections import deque

n, m = map(int, sys.stdin.readline().split())
inv = [0] * (n + 1)
outv = [0] * (n + 1)
graph = [[] for _ in range(n + 1)]
reverse = [[] for _ in range(n + 1)]
for _ in range(m):
    v, u = map(int, sys.stdin.readline().split())
    graph[v].append(u)
    reverse[u].append(v)
    inv[u] += 1
    outv[v] += 1

dp = [0] * (n + 1)
dq = deque()
for i in range(1, n + 1):
    if outv[i] == 0:
        dq.append(i)

while dq:
    cur = dq.popleft()
    if len(graph[cur]) == 1:
        dp[cur] = 1
    else:
        res = 0
        for nxt in graph[cur]:
            if {{completion}}:
                res = max(res, dp[nxt])
        dp[cur] = res + 1
    
    for prv in reverse[cur]:
        outv[prv] -= 1
        if outv[prv] == 0:
            dq.append(prv)

print(max(dp))",inv[nxt] > 1,"inv[nxt] == 0 and outv[nxt] > 0:
                inv[nxt] += 1
                outv[nxt] -= 1
                if outv[nxt] == 0:
                    dq.append(nxt)
            if inv[nxt] > 0:
                inv[nxt] -= 1
            if outv[nxt] > 0:
                outv[nxt] += 1
            if dp[nxt] > dp[cur] + 1:
                dp[nxt] = dp[cur] + 1
            if dp[nxt] == dp[cur] + 1:
                res = max(res, dp[nxt])
        dp[cur] = res + 1
    
print(max(dp))
<|/ a d"
"import sys
input = sys.stdin.readline
import math

for _ in range(1):
    n, m = map(int, input().split())
    g = [[] for i in range(n)]
    deg = [0] * n
    in_deg = [0] * n
    out_deg = [0] * n
    for i in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        g[x].append(y)
        deg[y] += 1
        out_deg[x] += 1
        in_deg[y] += 1
    order = []
    for i in range(n):
        if deg[i] == 0:
            order.append(i)
    for i in range(n):
        for to in g[order[i]]:
            deg[to] -= 1
            if {{completion}}:
                order.append(to)
    dp = [1] * n
    for i in order:
        for j in g[i]:
            if in_deg[j] > 1 and out_deg[i] > 1:
                dp[j] = max(dp[j], dp[i] + 1)
    print(max(dp))",deg[to] == 0,"deg[to] == 0:
                order.append(to)
    for i in range(n):
        for to in g[order[i]]:
            deg[to] += 1
            if deg[to] == "
"import sys
input = sys.stdin.readline
import math

for _ in range(1):
    n, m = map(int, input().split())
    g = [[] for i in range(n)]
    deg = [0] * n
    in_deg = [0] * n
    out_deg = [0] * n
    for i in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        g[x].append(y)
        deg[y] += 1
        out_deg[x] += 1
        in_deg[y] += 1
    order = []
    for i in range(n):
        if deg[i] == 0:
            order.append(i)
    for i in range(n):
        for to in g[order[i]]:
            deg[to] -= 1
            if deg[to] == 0:
                order.append(to)
    dp = [1] * n
    for i in order:
        for j in g[i]:
            if {{completion}}:
                dp[j] = max(dp[j], dp[i] + 1)
    print(max(dp))",in_deg[j] > 1 and out_deg[i] > 1,"dp[j] == dp[i]:
                continue
            if dp[j] > dp[i]:
                dp[j] = max(dp[j], dp[i] + 1)
    print(max(dp))
<|/ a tags=graph,algorithm,python,data-structures |>
<| a tags=graph,algorithm,python,data-structures |>
<code>
import sys
input = sys.stdin.readline
import math

for _ in range(1):
    n, m = map(int, input().split())
    g = [[] for i in range(n)]
    deg = [0] * n
    in_deg = [0] * n
    out_deg = [0] * n
    for i in range(m):
        x, y = map(int, input().split())
        x -= 1
        "
"from collections import deque
I=lambda:map(int,input().split())
n,m=I()
g=[[]for _ in range(n)]
din,dout,dcur=[0]*n,[0]*n,[0]*n
for _ in range(m):
  u,v=I()
  u,v=u-1,v-1
  g[u].append(v)
  dout[u]+=1;din[v]+=1;dcur[v]+=1
  
q=deque([i for i,d in enumerate(din) if d==0])
f=[1]*n
while q:
  u=q.popleft()
  for v in g[u]:
    if {{completion}}:
      f[v]=max(f[v],f[u]+1)
    dcur[v]-=1
    if dcur[v]==0:q.append(v)
print(max(f))
",dout[u]>1 and din[v]>1,din[v]>dcur[u]
"from collections import deque
I=lambda:map(int,input().split())
n,m=I()
g=[[]for _ in range(n)]
din,dout,dcur=[0]*n,[0]*n,[0]*n
for _ in range(m):
  u,v=I()
  u,v=u-1,v-1
  g[u].append(v)
  dout[u]+=1;din[v]+=1;dcur[v]+=1
  
q=deque([i for i,d in enumerate(din) if d==0])
f=[1]*n
while q:
  u=q.popleft()
  for v in g[u]:
    if dout[u]>1 and din[v]>1:
      f[v]=max(f[v],f[u]+1)
    dcur[v]-=1
    if {{completion}}:q.append(v)
print(max(f))
",dcur[v]==0,"dcur[v]==0:
      q.append(v)
print(max(f))
<|/ a dscore=0 |>
<| a tags=python,graph,algorithm |>
<code>
from collections import deque
I=lambda:map(int,input().split())
n,m=I()
g=[[]for _ in range(n)]
din,dout,dcur=[0]*n,[0]*n,[0]*n
for _ in range(m):
  u,v=I()
  u,v=u-1,v-1
  g[u].append(v)
  dout[u]+=1;din[v]+=1;dcur[v]+=1
  
q=deque([i "
"N=int(input())
A=[int(x) for x in input().split()]
B=sorted(A)
ans=-(-B[0]//2)-(-B[1]//2)
for {{completion}}:
  ans=min(ans,-(-(A[i]+A[i+2])//2))
for i in range(N-1):
  score=max(-(-(A[i]+A[i+1])//3),-(-A[i]//2),-(-A[i+1]//2))
  ans=min(score,ans)
print(ans)  ",i in range(N-2),"i,x in enumerate(B):
  if x==B[i+1]"
"N=int(input())
A=[int(x) for x in input().split()]
B=sorted(A)
ans=-(-B[0]//2)-(-B[1]//2)
for i in range(N-2):
  ans=min(ans,-(-(A[i]+A[i+2])//2))
for {{completion}}:
  score=max(-(-(A[i]+A[i+1])//3),-(-A[i]//2),-(-A[i+1]//2))
  ans=min(score,ans)
print(ans)  ",i in range(N-1),"j in range(N-1):
  ans=min(ans,-(-(A[j]+A[j+1])//2))
for k in range(1,N-1):
  ans=min(ans,-(-(A[k]+A[k-1])//2))
for l in range(1,N-1):
  ans=min(ans,-(-(A[l]+A[l-1])//2))
for m in range(1,N-1):
  ans=min(ans,-(-(A[m]+A[m-1])//2))
for n in range(1,N-1):
  ans=min(ans,-(-(A[n]+A[n-1])//2))
for o in range(1,N-1):
  ans=min(an"
"def onagr(x, y):
    x, y = max(x, y), min(x, y)
    if x >= 2 * y:
        res = (x + 1) // 2
    else:
        res = x - y + (2 * y - x) // 3 * 2 + (2 * y - x) % 3
    return res


def onagr1(x, y):
    return min(x, y) + (abs(x - y) + 1) // 2


n = int(input())
m1, m2, *a = list(map(int, input().split()))
if n == 2:
    print(onagr(m1, m2))
else:
    p = m2
    pp = m1
    r1 = onagr1(m1, a[0])
    if m2 < m1:
        m1, m2 = m2, m1
    r = onagr(m1, m2)
    for k in a:
        if k < m1:
            m2 = m1
            m1 = k
        elif {{completion}}:
            m2 = k
        r = min(r, onagr(k, p))
        r1 = min(r1, onagr1(k, pp))
        pp = p
        p = k
    print(min((m1 + 1) // 2 + (m2 + 1) // 2, r, r1))
",k < m2,"k > m1:
            m2 = k
        r = min(r, onagr(k, p))
        r1 = min(r1, onagr1(k, pp))
        pp = p
        p = k
    print(min((m1 + 1) // 2 + (m2 + 1) // 2, r, r1))
""""""
def onagr(x, y):
    x, y = max(x, y), min(x, y)
    if x >= 2 * y:
        res = (x + 1) // 2
    else:
        res = x - y + (2 * y - x) // 3 * 2 + (2 * y - x) % 3
    return res


def onagr1(x, y):
    return min(x, y) + (abs(x - y) + 1) // 2


n = int(input())"
"import sys

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
x, y = sorted(arr)[:2]
ans = (x + 1) // 2 + (y + 1) // 2

for i in range(n - 2):
    x, y = arr[i], arr[i + 2]
    if {{completion}}:
        x -= 1
        y -= 1
        ans = min(ans, (x + 1) // 2 + (y + 1) // 2 + 1)
    else:
        ans = min(ans, (x + 1) // 2 + (y + 1) // 2)

for i in range(n - 1):
    x, y = arr[i], arr[i + 1]
    if x > y:
        x, y = y, x
    
    if y >= 2 * x:
        ans = min(ans, (y + 1) // 2)
    else:
        res = y - x
        x -= res
        y -= 2 * res
        tmp = x // 3
        res += 2 * tmp
        x -= 3 * tmp
        ans = min(ans, res + x)

print(ans)",(x % 2 == 1) and (y % 2 == 1),"x > y:
        x, y = y, x
    
    if y >= 2 * x:
        ans = min(ans, (y + 1) // 2)
    elif y <= 2 * x + 1:
        ans = min(ans, (y + 1) // 2 + (x + 1) // 2)
    elif y <= 2 * x + 2:
        ans = min(ans, (y + 1) // 2 + (x + 1) // 2 + (x + 1) // 2)
    elif y <= 2 * x + 3:
        ans = min(ans, (y + 1) // 2 + (x + 1) // 2 + (x + 1) // 2 + (x + 1) // 2)
    elif y <= 2 * x + 4:
        ans = min(ans, (y + 1) // 2 + (x + 1) // 2 + (x + 1) "
"from math import ceil


def cal(a,b):
    if a>b:
        a,b=b,a
    if {{completion}}:
        return ceil((a+b)/3)
    else:
        return ceil(b/2)

def cal2(a,b,c):
    if a%2==1 or c%2==1:
        return a//2+c//2+1
    return a//2+b//2


n=int(input())
l=list(map(int,input().split()))
t=sorted(l)
ans=ceil(t[0]/2)+ceil(t[1]/2)
for i in range(1,n):
    ans=min(ans,cal(l[i],l[i-1]))
    if i+1<n:
        ans=min(ans,cal2(l[i-1],l[i],l[i+1]))
print(ans)

",a>b//2,"a%2==1 and b%2==1:
        return ceil(a/2+b/2)
    if a%2==1 and b%2==0:
        return ceil(a/2+b/2)
    if a%2==0 and b%2==1:
        return ceil(a/2+b/2)
    if a%2==0 and b%2==0:
        return ceil(a/2+b/2)
    if a%2==0 and b%2==0 and a>b:
        return ceil(a/2+b/2)
    if a%2==1 and b%2==1 and a>b:
        return ceil(a/2+b/2)
    if a%2=="
"from math import ceil


def cal(a,b):
    if a>b:
        a,b=b,a
    if a>b//2:
        return ceil((a+b)/3)
    else:
        return ceil(b/2)

def cal2(a,b,c):
    if {{completion}}:
        return a//2+c//2+1
    return a//2+b//2


n=int(input())
l=list(map(int,input().split()))
t=sorted(l)
ans=ceil(t[0]/2)+ceil(t[1]/2)
for i in range(1,n):
    ans=min(ans,cal(l[i],l[i-1]))
    if i+1<n:
        ans=min(ans,cal2(l[i-1],l[i],l[i+1]))
print(ans)

",a%2==1 or c%2==1,"a>b and a>c//2:
        return a//2+b//2+1
    if a>b and a<c//2:
        return a//2+b//2
    if a<b and a>c//2:
        return a//2+c//2+1
    if a<b and a<c//2:
        return a//2+b//2
    if a<b//2 and a>c//2:
        return a//2+c//2+1
    if a<b//2 and a<c//2:
        return a//2+b//2
    if a<c//2 and a>b//"
"import sys
sys.setrecursionlimit(10000)
 
def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))
 
def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)
 
 
def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases
 
 
 
 
 
 
 
def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if {{completion}}:
                return False
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            used[prv]=used.get(prv,0)+1
        prv=c
    return True
 
 
 
 
 
 
def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""
 
 
def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    
 
process()
","used.get(an[pa],0)<=0","c==prv:
                return False
            if c not in used:
                used[c]=1
            else:
                if used[c]>1:
                    return False
            pa+=1
        pa-=1
        prv=c
    return True
 
 
 
 
 
 
def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if c==prv:
                return False
            if c not in used:
                used"
"import sys
sys.setrecursionlimit(10000)

def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))

def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)


def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases







def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if {{completion}}:
                return False
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            used[prv]=used.get(prv,0)+1
        prv=c
    return True






def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""


def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    

process()","used.get(an[pa],0)<=0","c>an[pa]:
                return False
            if prv==None:
                prv=c
            elif c<prv:
                return False
            if an[pa] in used:
                return False
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            used[prv]=used.get(prv,0)+1
        prv=c
    return True

def solve_2(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in "
"import sys;input=sys.stdin.readline

I=lambda:map(int,input().split())
n, q = I()
s = input()
pre0,pre1 = [0]*n,[0]*n
for i in range(1,n):
  c1,c2=s[i-1],s[i]
  pre0[i],pre1[i] = pre0[i-1],pre1[i-1]
  if c1 == c2 == '0':pre0[i]+=1
  elif {{completion}}:pre1[i]+=1
for _ in range(q):
  l,r=I()
  print(max(pre0[r-1]-pre0[l-1], pre1[r-1]-pre1[l-1])+1)",c1 == c2 == '1',"c1 == c2 == '1':pre1[i]+=1
pre0[n-1],pre1[n-1] = pre0[n-2],pre1[n-2]
for i in range(n-1,-1,-1):
  if pre0[i]-pre0[i-1] > pre1[i]-pre1[i-1]:pre0[i]-=pre0[i-1]
  elif pre0[i]-pre0[i-1] < pre1[i]-pre1[i-1]"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

n, q = I()
s = input()
ones = [0, 0]
zeroes = [0, 0]
for i in range(1, n):
	if s[i] == s[i - 1] == '0':
		zeroes.append(zeroes[-1] + 1)
	else:
		zeroes.append(zeroes[-1])
	if {{completion}}:
		ones.append(ones[-1] + 1)
	else:
		ones.append(ones[-1])
for i in range(q):
	l, r = I()
	o = ones[r] - ones[l]
	z = zeroes[r] - zeroes[l]
	print(max(o, z) + 1)",s[i] == s[i - 1] == '1',"s[i] == s[i - 1] == '1':
		ones.append(ones[-1] + 1)
	else:
		ones.append(ones[-1])
for i in range(q):
	l, r = I()
	o = ones[r] - ones[l]
	z = zeroes[r] - zeroes[l]
	print(max(o, z) + 1)
<|/ file dstars=1 |>"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 998244353
r, c = I()
rows = []
for i in range(r):
	rows.append([*input()])
if r % 2 == 0 and c % 2 == 0:
	blanks = 0
	for i in range(r):
		blanks += rows[i].count('?')
	print(pow(2, blanks, M))
elif r % 2 + c % 2 == 1:
	if r % 2 == 1:
		nrows = []
		for i in range(c):
			nrows.append([rows[j][i] for j in range(r)])
		rows = nrows
	ones = 1
	zeroes = 1
	for row in rows:
		unk = 0
		xor = 0
		for char in row:
			if char == '?':
				unk += 1
			elif char == '1':
				xor = 1 - xor
		if unk == 0:
			if xor == 1:
				zeroes = 0
			else:
				ones = 0
		else:
			zeroes = zeroes * pow(2, unk - 1, M) % M
			ones = ones * pow(2, unk - 1, M ) % M
	print((ones + zeroes) % M)
else:
	RC = [0] * (r + c)
	edges = [[] for i in range(r + c)]
	for i in range(r):
		for j in range(c):
			char = rows[i][j]
			if char == '?':
				edges[i].append(j + r)
				edges[j + r].append(i)
			elif char == '1':
				RC[i] = 1 - RC[i]
				RC[r + j] = 1 - RC[r + j]
	seen = [0] * (r + c)
	zeroes = []
	ones = []
	for i in range(r + c):
		if not seen[i]:
			component = [i]
			seen[i] = 1
			j = 0
			while j < len(component):
				if len(component) == r + c:
					break
				for v in edges[component[j]]:
					if {{completion}}:
						seen[v] = 1
						component.append(v)
				j += 1
			n = len(component)
			m = 0
			x = 0
			for v in component:
				m += len(edges[v])
				x ^= RC[v]
			m //= 2
			if n % 2 == 0:
				if x == 0:
					y = pow(2, m - n + 1, M)
					zeroes.append(y)
					ones.append(y)
				else:
					print(0)
					exit()
			else:
				y = pow(2, m - n + 1, M)
				if x == 0:
					zeroes.append(y)
					ones.append(0)
				else:
					ones.append(y)
					zeroes.append(0)
	zs = 1
	for g in zeroes:
		zs = zs * g % M
	os = 1
	for g in ones:
		os = os * g % M
	print((zs + os) % M)",not seen[v],"seen[v] == 0 and RC[v] == RC[component[j]]:
						seen[v] = 1
						component.append(v)
				j += 1
			n = len(component)
			m = 0
			x = 0
			for v in component:
				m += len(edges[v])
				x ^= RC[v]
			m //= 2
			if n % 2 == 0:
				if x == 0:
					y = pow(2, m - n + 1, M)
					zeroes.append(y)
					ones.append(y)
				else:
					print(0)
					exit()
			else:
				y = pow(2, m - n + 1, M)
				if x == 0:
					zeroes.append(y)
"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 998244353
r, c = I()
rows = []
for i in range(r):
	rows.append([*input()])
if r % 2 == 0 and c % 2 == 0:
	blanks = 0
	for i in range(r):
		blanks += rows[i].count('?')
	print(pow(2, blanks, M))
elif r % 2 + c % 2 == 1:
	if r % 2 == 1:
		nrows = []
		for i in range(c):
			nrows.append([rows[j][i] for j in range(r)])
		rows = nrows
	ones = 1
	zeroes = 1
	for row in rows:
		unk = 0
		xor = 0
		for char in row:
			if char == '?':
				unk += 1
			elif char == '1':
				xor = 1 - xor
		if unk == 0:
			if xor == 1:
				zeroes = 0
			else:
				ones = 0
		else:
			zeroes = zeroes * pow(2, unk - 1, M) % M
			ones = ones * pow(2, unk - 1, M ) % M
	print((ones + zeroes) % M)
else:
	RC = [0] * (r + c)
	edges = [[] for i in range(r + c)]
	for i in range(r):
		for j in range(c):
			char = rows[i][j]
			if char == '?':
				edges[i].append(j + r)
				edges[j + r].append(i)
			elif char == '1':
				RC[i] = 1 - RC[i]
				RC[r + j] = 1 - RC[r + j]
	seen = [0] * (r + c)
	zeroes = []
	ones = []
	for i in range(r + c):
		if not seen[i]:
			component = [i]
			seen[i] = 1
			j = 0
			while j < len(component):
				if len(component) == r + c:
					break
				for {{completion}}:
					if not seen[v]:
						seen[v] = 1
						component.append(v)
				j += 1
			n = len(component)
			m = 0
			x = 0
			for v in component:
				m += len(edges[v])
				x ^= RC[v]
			m //= 2
			if n % 2 == 0:
				if x == 0:
					y = pow(2, m - n + 1, M)
					zeroes.append(y)
					ones.append(y)
				else:
					print(0)
					exit()
			else:
				y = pow(2, m - n + 1, M)
				if x == 0:
					zeroes.append(y)
					ones.append(0)
				else:
					ones.append(y)
					zeroes.append(0)
	zs = 1
	for g in zeroes:
		zs = zs * g % M
	os = 1
	for g in ones:
		os = os * g % M
	print((zs + os) % M)",v in edges[component[j]],v in component
"for _ in range(int(input())):
    n = int(input())
    a = b = 0
    c = '-'
    for x, y in zip(*[iter(input())]*2):
        if {{completion}}:
            a += 1
        else:
            b += x != c
            c = x
    print(a, max(1, b))",x != y,"x == '1' and y == '1':
            a += 1
        elif x == '1' and y == '0':
            b += 1
        elif x == '0' and y == '1':
            b += 2
        elif x == '0' and y == '0':
            a += 2
        elif x == '1' and y == '0':
            b += 2
            a += 1
        elif x == '0' and y == '1':
            a += 2
        elif x == '1' and y == '1':
            b += 2
        elif x == '0' and y == '0':
            a += 2
        elif x == '1' and y == '1':
            b += 2
        elif x == '0' and "
"
inp = [*open(0)]

for s in inp[2::2]:
    s = s.strip()
    res = 0
    mseg = 1
    prebit = None
    for i in range(len(s) // 2):
        if s[2*i] != s[2*i+1]:
            res += 1
        else:
            if {{completion}}:
                prebit = s[2*i]
            else:
                mseg += 1 if s[2*i] != prebit else 0
                prebit = s[2*i]

    print(res, mseg)
",prebit is None,"prebit == None:
                mseg += 1
            elif prebit != s[2*i]:
                mseg += 1 if s[2*i] != prebit else 0
                prebit = s[2*i]
            else:
                mseg += 1 if s[2*i] != prebit else 0
                prebit = s[2*i]

    print(res, mseg)
'''
inp = [*open(0)]

for s in inp[2::2]:
    s = s.strip()
    res = 0
    mseg = 1
    prebit = None
    for i in range(len(s) // 2):
        if s[2*i] != s[2*i+1]:
            res += 1
        else:
            if prebit == None:
                mseg += 1"
"
for _ in range(int(input().strip())):
    n = int(input().strip())
    arr = input()
    ans = 0
    t = []
    for i in range(0, len(arr), 2):
        if {{completion}}:
            ans += 1
        else:
            t.append(arr[i])
    seg = 1
    for i in range(0, len(t) - 1):
        if t[i] != t[i + 1]:
            seg += 1
    print(ans, seg)
",arr[i] != arr[i + 1],"arr[i] == '1' and arr[i + 1] == '1':
            ans += 1
        elif arr[i] == '1' and arr[i + 1] == '0':
            t.append(arr[i])
        elif arr[i] == '0' and arr[i + 1] == '1':
            t.append(arr[i])
        elif arr[i] == '0' and arr[i + 1] == '0':
            t.append(arr[i])
        elif arr[i] == '1' and arr[i + 1] == '1':
            t.append(arr[i])
        elif arr[i] == '1' and arr[i + 1] == '0':
            t.append(arr[i])
        elif arr[i] == '0' and arr[i + 1] == '1':
            t.append(arr[i])
        elif arr[i] == '0' and arr[i + 1] == '0':
            "
"
for _ in range(int(input().strip())):
    n = int(input().strip())
    arr = input()
    ans = 0
    t = []
    for i in range(0, len(arr), 2):
        if arr[i] != arr[i + 1]:
            ans += 1
        else:
            t.append(arr[i])
    seg = 1
    for i in range(0, len(t) - 1):
        if {{completion}}:
            seg += 1
    print(ans, seg)
",t[i] != t[i + 1],t[i] != t[i + 1]
"import sys

input=sys.stdin.readline

for _ in range(int(input())):
    n=int(input())
    s=input()
    x,y,Lf=0,0,-1
    for i in range(0,n,2):
        if(s[i]!=s[i+1]):
            x+=1
        else:
            if{{completion}}:
                y+=1
            Lf=s[i]
    print(x,max(y,1))",(Lf!=s[i]),"(x>y):
                y=x
                x=0
            else:
                x-=1
            if(Lf==-1):
                Lf=s[i]
            else:
                if(Lf!=s[i]):
                    y+=1
                    Lf=s[i]
    print(x,max(y,1))
""""""
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"for _ in range(int(input())):
    n = int(input())
    l = [[], []]
    for {{completion}}:
        l[x==y].append(int(x))
    print(len(l[0]), sum(map(lambda x : x[0] ^ x[1], zip(l[1], l[1][1:]))) + 1)","x, y in zip(*[iter(input())]*2)","x in input().split():
        y = int(x, 2)
        if y%2 == 0:
            l[0].append(y)
        else:
            l[1].append(y)
    for x in l[0]:
        for y in l[1]:
            if x == y:
                l[0].remove(x)
                l[1].remove(x)
                break
    for x in l[0]:
        l[0].append(int(x))
    for x in l[1]:
        l[1].append(int(x))
    for x in l[0]:
        for y in l[1]:
            if x == y:
                l[0].remove(x)
                l[1].remove(x)
                break
    for x in l[0]:
        l[0].append(int(x))
    for x in l[1]:
        l[1].append(int(x))
    for x in l"
"def solve(s):
	res = 0
	seg = 0
	prev = -1
	allDiff = True
	for i in range(1,len(s),2):
		if s[i] == s[i-1]:
			allDiff = False
			if {{completion}}: seg += 1
			prev = s[i]
		else:
			res += 1
	if allDiff: seg += 1
	print(res,seg)


if __name__ == ""__main__"":
	t = int(input())
	while t:
		n= int(input())
		s = input()
		solve(s)
		t -= 1

",prev != s[i],"prev == s[i]:
				res += 1
				seg += 1
			else:
				res += 1
				seg += 1
				res += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				seg += 1
				"
"for {{completion}}:
	n,s=int(input()),input()
	print(sum([1 for i in range(1,n,2) if s[i]!=s[i-1]]))",_ in range(int(input())),"test in xrange(t):
	n,s=int(input()),input()
	print(sum([1 for i in range(1,n,2) if s[i]!=s[i-1]]))
<|/ q tags=python,algorithm |>
<| c |>
Please post the code in the question itself, not as a link to an external site.
<|/ c |>
<| c |>
I edited the post and added the code
<|/ c |>
<| c |>
The code in the question doesn't match the problem description. In the first test case, one of the ways to make `s` (`""1100000000""`) good is the following. Change `s_3`, `s_6` and `s_"
"import re
for s in[*open(0)][2::2]:
 i=p=r=0
 for t in re.findall('0+|1+',s):
  i+=1
  if len(t)&1:
   if {{completion}}:r+=i-p;p=0
   else:p=i
 print(r)",p,"r>i:r+=i-p;p=0
   else:p=i
 print(r)
<|/ a tags=python,algorithm |>
<| a dscore=0 |>
<code>
import re
for s in[*open(0)][2::2]:
 i=p=r=0
 for t in re.findall('0+|1+',s):
  i+=1
  if len(t)&1:
   if r>i:r+=i-p;p=0
   else:p=i
 print(r)
</code>
<|/ a tags=python,algorithm |>
<| c |>
Please add some explanation to your answer.
<|/ c |>"
"t=int(input(""""))
for z in range(t):
    n=int(input(""""))
    a=input("""")
    s=[]
    for {{completion}}:
        ab=a[i]+a[i+1]
        s.append(ab)

    b=s.count('10')
    c=s.count('01')
    print(b+c)","i in range(0,len(a)-1,2)","j in range(n):
        ab=a[j]
        s.append(ab)
    for i in range(n-1):
        ab=a[i]+a[i+1]
        s.append(ab)
    b=s.count('10')
    c=s.count('01')
    print(b+c)
'''
t=int(input(""""))
for z in range(t):
    n=int(input(""""))
    a=input("""")
    s=[]
    for j in range(n):
        ab=a[j]
        s.append(ab)
    for i in range(n-1):
        ab=a[i]+a[i+1]
        s.append(ab)
    b=s.count('10')
    c=s.count('01')"
"def func(s):
    curr=s[0]
    c=0
    count=0
    for i in s:
        if i==curr:
            c+=1
        elif {{completion}}:
            c=1
            curr=i
            continue
        else:
            curr=i
            c=2
            count+=1
    return count

for i in range(int(input())):
    n=int(input())
    print(func(input()))
",c%2==0,"c==2:
            count+=1
            c=0
            curr=i
        elif c==1:
            c=2
            curr=i
        else:
            c=1
            curr=i
    return count

for i in range(int(input())):
    n=int(input())
    print(func(input()))
'''
def func(s):
    curr=s[0]
    c=0
    count=0
    for i in s:
        if i==curr:
            c+=1
        elif c==2:
            count+=1
            c=0
            curr=i
        elif c==1:
            c=2
            curr=i
        else:
            c=1
            curr=i"
"for _ in range(int(input())):
	input()
	inp, count = input(), 0
	for i in range(0, len(inp), 2):
		if {{completion}}:
			count += 1
	print(count)",(inp[i] != inp[i+1]),"inp[i:i+2] == ""11"":
			count += 1
	print(count)
<|/ file dstars=0 |>
<| c |>
Please don't post images of code or data (or links to them), instead post the text directly here on SO.
<|/ c |>
<| c |>
Please don't post images of code or data. Instead post the text directly here on SO.
<|/ c |>
<| c |>
Please don't post images of code or data. Instead post the text directly here on SO.
<|/ c |>
<| c |>
Please don't post images of code or data. Instead post the "
"t = int(input())
for _ in range(t):
    _, s = input(), input()
    res, i, c = 0, 0, 0
    while i < len(s):
        d = s[i]
        while {{completion}}:
            c += 1
            i += 1
        c = c & 1
        res += 1 if c else 0
    print(res)
",i < len(s) and s[i] == d,"i < len(s) and d != s[i]:
            i += 1
        c += 1
        i += 1
        while i < len(s) and s[i] == s[i]:
            i += 1
        if c > res:
            res = c
        while i < len(s) and s[i] == d:
            i += 1
        if c > res:
            res = c
        while i < len(s) and s[i] != d:
            i += 1
        if c > res:
            res = c
        while i < len(s) and s[i] != s[i]:
            i += 1
        if c > res:
            res = c
        while i < len(s) and s[i] != d:
            i += 1
        if c > res:
            res = c
        while i < len(s) and s[i] != s[i]:
            i += 1
        if "
"t=int(input())
for i in range (t):
    n=int(input())
    a=input()
    count=0
    for k in range(n//2):
        if{{completion}}:
            count+=1
    print(count)
",(a[2*k]!=a[2*k+1]),"(a[k:k+2]=='11'):
            a[k:k+2]='0'
            count+=1
    for k in range(n//2):
        if(a[k:k+2]=='00'):
            a[k:k+2]='1'
            count+=1
    for k in range(n//2):
        if(a[k:k+2]=='11'):
            a[k:k+2]='1'
            count+=1
    for k in range(n//2):
        if(a[k:k+2]=='00'):
            a[k:k+2]='0'
            count+=1
    for k in range(n//2):
        if(a[k:k+2]=='11"
"from itertools import groupby
t = int(input())

while t:
    t-=1

    n = int(input())
    s = input()
    o = [len("""".join(g))&1 for _,g in groupby(s)]

    l = -1
    res = 0

    for i, o_ in enumerate(o):
        if o_:
            if {{completion}}:
                l = i
            else:
                res += i-l
                l = -1
    print(res)",l == -1,"l == -1:
                res = i
            elif l == i:
                res += i-l
                l = -1
            else:
                res += i-l
                l = i
        else:
            if l == -1:
                res = i
            elif l == i:
                res += i-l
                l = -1
            elif l == i+1:
                res += i-l
                l = i
            else:
                res += i-l
                l = i

    print(res)
<|/ a dscore=0 |>
<| a dscore=0 |>
<code>
from itertools import groupby
t = int(input())

while t:
    t-=1

    n = int(input())
    s = input()"
"n=int(input(""""))
t=0
while(t<n):
    t+=1
    length=int(input(""""))
    s=input("""")
    count=0
    for i in range(1, length, 2):
        if {{completion}}:
            count+=1
    print(count)
",s[i]!=s[i-1],"s[i]=='1':
            count+=1
    print(count)
    count=0
    for i in range(1, length, 2):
        if s[i]=='0':
            count+=1
    print(count)
    count=0
    for i in range(1, length, 2):
        if s[i]=='1' and s[i+1]=='1':
            count+=1
    print(count)
    count=0
    for i in range(1, length, 2):
        if s[i]=='1' and s[i+1]=='0':
            count+=1
    print(count)
    count=0
    for i in range(1, length, 2):
        if s[i]=='0' and s[i+1]=='1':
            count+=1
    print(count)
    count=0
    for i in range(1, length, 2):
        if s[i]=='0' and s[i+1]=='0':"
"for {{completion}}:
	n,s,w=int(input()),input(),0
	print(sum([1 for i in range(1,n,2) if s[i]!=s[i-1]]))",_ in range(int(input())),"test in xrange(t):
	n,s=int(input()),input()
	print(sum([1 for i in range(1,n,2) if s[i]!=s[i-1]]))
<|/ file source=github |>"
"for {{completion}}:
    n = int(input()); a = [*map(int,input().split())]
    print(n+(-a.count(0) or len(set(a))==n))",t in range(int(input())),"_ in range(int(input())):
    n = int(input())
    a = [*map(int,input().split())]
    print(n+(-a.count(0) or len(set(a))==n))
<|/ q dscore=0 |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
for _ in range(int(input())):
    n = int(input())
    a = [*map(int,input().split())]
    print(n+(-a.count(0) or len(set(a))==n))
<|/ c |>
<| c |>
Please [edit] your question and add the code there"
"for n in [*open(0)][2::2]:
    *a,=map(int,n.split());b=len(a);c=a.count(0)
    while a:
        q=a.pop()
        if {{completion}}:
            break
    print(b+(a==[])*(c==0)-c)
",a.count(q)>0,"q==1:
            a=[q]
        elif q==2:
            a=[q,1]
        elif q==3:
            a=[q,1,1]
        elif q==4:
            a=[q,1,1,1]
        else:
            a=[q,1,q]
        b=len(a)
        c=a.count(0)
        if c==b"
"def solve():
    N=int(input())
    A=sorted(list(map(int,input().split())))
    return sum([i>0 for i in A])+all([i>0 for i in A])*all([A[i]<A[i+1] for i in range(N-1)])
T=int(input())
for {{completion}}:
    print(solve())",i in range(T),"_ in range(T):
    print(solve())
<|/ file filename=Tokitsukaze .py |>"
"t=int(input())
for _ in range(t):
    n=int(input())
    ar=list(map(int,input().split()))
    z=[0]*110
    for x in range(n):
        z[ar[x]]+=1 
    eq=False
    for x in range(110):
        if {{completion}}:
            eq=True
    if z[0]>0:
        print(n-z[0])
    elif eq:
        print(n)
    else:
        print(n+1)",z[x]>1,"z[x]>0:
            eq=True
    if z[0]>0:
        print(n-z[0])
    elif eq:
        print(n)
    else:
        print(n+1)
<|/ q dscore=0 |>
<| c |>
Please post the code you've written so far.
<|/ c |>
<| c |>
Welcome to Stack Overflow. Please read [the help pages](http://stackoverflow.com/help), especially [""What topics can I ask about here?""](http://stackoverflow.com/help/on-topic) and [""What types of questions should I avoid asking?""](http://stackoverflow.com/help/dont-ask). Also [take the tour](http://"
"for j in range(int(input())):
	h = int(input())
	a = list(map(int,input().split()))
	if 0 in a:
		print(h - a.count(0))
	else:
		if {{completion}}:
			print(len(a))
		else:
			print(len(a)+1)",len(set(a)) < len(a),len(a) == h
"for i in range(int(input())):
    n = int(input())
    s = input().split()
    if s.count(""0""):
        print(n-s.count(""0""))
    else:
        for i in s:
            if {{completion}}:
                print(n)
                break
        else:
            print(n+1)",s.count(i)>1,"int(i)<int(s.count(i)):
                print(n-s.count(i))
                break
            else:
                print(n-s.count(i))
                break
    else:
        print(n+1)
<|/ a dscore=0 |>
<| c |>
Please don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| c |>
Thanks for your advice. I will do it.
<|/ c |>
<| a tags=python,python"
"import sys
input = sys.stdin.readline
def getInts(): return map(int, input().split())


def solve():
    input()
    a = [*getInts()]
    if {{completion}}:
        print(len(a) - a.count(0))
    else:
        s = set(a)
        print(len(a) + (len(a) == len(s)))


for _ in range(int(input())):
    solve()
",0 in a,"a[0] == 0:
        a[0] = a[1]
        a[1] = a[2]
        a[2] = a[0]
    if a[-1] == 0:
        a[-1] = a[-2]
        a[-2] = a[-3]
        a[-3] = a[-1]
    if a[0] == a[-1]"
"test=int(input())
while test:
    test-=1
    n=int(input())
    arr=[int(x) for x in input().split()]
    zero=0
    s=set(arr)
    for i in arr:
        if {{completion}}:
            zero+=1
    if zero:
        print(n-zero)
    elif len(s)==n:
        print(n+1)
    else:
        print(n)
",i==0,"i in s:
            s.remove(i)
    for j in arr:
        if j in s:
            s.remove(j)
    for i in arr:
        if i==j:
            zero+=1
    for j in arr:
        if j==i:
            zero+=1
    for j in arr:
        if j==min(arr):
            zero+=1
    for j in arr:
        if j==max(arr):
            zero+=1
    for j in arr:
        if j==min(arr)==max(arr):
            zero+=1
    for j in arr:
        if j==min(arr)==max(arr):
            zero+=1
    for j in arr:
        if j==min(arr)=="
"for {{completion}}:
 n=int(input())
 a=[*map(int,input().split())]
 print(n-a.count(0)+(0 not in a and len(a)==len(set(a))))",_ in[0]*int(input()),"test in range (1,t):
 n=int(input())
 a=[*map(int,input().split())]
 print(n-a.count(0)+(0 not in a and len(a)==len(set(a))))
'''
<|/ a tags=python-3.x,python |>
<| a dscore=0 |>
<code>
for test in range (1,t):
 n=int(input())
 a=[*map(int,input().split())]
 print(n-a.count(0)+(0 not in a and len(a)==len(set(a))))
</code>
<|/ a tags=python-3.x,python |>
<| c |>
Please don't post only "
"import sys

def diff_ops(arr):
    result = True
    for {{completion}}:
        result = result and arr[i] % arr[0] == 0
    return result

if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    len_input = len(input_arr)
    n = input_arr[0]
    test_cases = []
    pos = 1
    while pos <= len_input - 1:
        case_len = input_arr[pos]
        test_cases.append(input_arr[pos + 1: pos + 1 + case_len])
        pos += case_len + 1
    for case in test_cases:
        print(""YES"" if diff_ops(case) else ""NO"")

","i in range(1, len(arr))","i,v in enumerate(arr):
        if v != arr[i-1]"
"import sys

def diff_ops(arr):
    result = True
    for i in range(1, len(arr)):
        result = result and arr[i] % arr[0] == 0
    return result

if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    len_input = len(input_arr)
    n = input_arr[0]
    test_cases = []
    pos = 1
    while {{completion}}:
        case_len = input_arr[pos]
        test_cases.append(input_arr[pos + 1: pos + 1 + case_len])
        pos += case_len + 1
    for case in test_cases:
        print(""YES"" if diff_ops(case) else ""NO"")

",pos <= len_input - 1,pos < len_input
"n, k = map(int, input().split())
answer = [0] * (n + 1)
dp = [1] + [0] * n
MIN = 0
while MIN + k <= n:
    mod = [0 for _ in range(k)]
    for {{completion}}:
        dp[i], mod[i % k] = mod[i % k], dp[i] + mod[i % k]
        mod[i % k] %= 998244353
        answer[i] += dp[i]
        answer[i] %= 998244353
    MIN += k
    k += 1
print(*answer[1:])","i in range(MIN, n + 1)","_ in range(k):
        mod[dp[MIN % k] % k] += 1
    for i in range(MIN, MIN + k):
        if mod[i % k] > 0:
            mod[i % k] -= 1
            break
    if dp[MIN % k] == MIN"
"import copy
n, k = list(map(int, input().split(' ')))


dp = [0]*(n+1)
for i in range(k, n+1, k):
    dp[i] = 1

# print(list(range(n+1)))
# print(dp, k)
ans = copy.copy(dp)
dp2 = [0]*(n+1)
for s in range(2,n):   # will be sqrt(n) really
    ks = k + s - 1
    first = (ks * (ks+1) // 2) - ((k-1) * k // 2)
    if first > n+1:
        break
    for {{completion}}:
        dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353
    dp = dp2
    # print(dp, ks)
    dp2 = [0]*(n+1)
    for i in range(0, n+1):
        ans[i] = (ans[i] + dp[i]) % 998244353
print(' '.join(map(str, ans[1:])))","i in range(first, n+1)","j in range(first, n+1):
        if j == s:
            continue
        dp2[j] = (dp2[j-ks] + dp[j-ks]) % 998244353
    dp = dp2
    # print(dp, ks)
    dp2 = [0]*(n+1)
    for i in range(0, n+1):
        ans[i] = (ans[i] + dp[i]) % 998244353
print(' '.join(map(str, ans[1:])))

</text>
<cell>
import copy
n, k = list(map(int, input().split(' ')))


dp = [0]*(n+1)
for i in range(k, n+1, k):
    dp[i] = 1

# print(list(range(n+1)))
# print(dp, k)
ans = "
"import copy
n, k = list(map(int, input().split(' ')))


dp = [0]*(n+1)
for i in range(k, n+1, k):
    dp[i] = 1

# print(list(range(n+1)))
# print(dp, k)
ans = copy.copy(dp)
dp2 = [0]*(n+1)
for s in range(2,n):   # will be sqrt(n) really
    ks = k + s - 1
    first = (ks * (ks+1) // 2) - ((k-1) * k // 2)
    if first > n+1:
        break
    for i in range(first, n+1):
        dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353
    dp = dp2
    # print(dp, ks)
    dp2 = [0]*(n+1)
    for {{completion}}:
        ans[i] = (ans[i] + dp[i]) % 998244353
print(' '.join(map(str, ans[1:])))","i in range(0, n+1)","s in range(2,n):
        ks = k + s - 1
        first = (ks * (ks+1) // 2) - ((k-1) * k // 2)
        if first > n+1:
            break
        for i in range(first, n+1):
            dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353
        dp = dp2
        # print(dp, ks)
    ans = copy.copy(dp)
for i in range(n+1):
    if ans[i] == 0:
        ans[i] = 1
    else:
        ans[i] = 0
for i in range(n+1):
    if ans[i] == 1:
        ans[i] = 0
    else:
        ans[i] = 1
for i in range(n"
"import sys

inf=float('inf')
mod=998244353
#input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())

def main():

    n,k=inpnm()
    N=n+1
    f1=[0]*N
    res=[0]*N

    f1[0]=1
    i=1
    while True:
        step=k+i-1
        f2=[0]*N
        for {{completion}}:
            f2[j]=(f1[j-step]+f2[j-step])%mod
            res[j]=(res[j]+f2[j])%mod

        for j in range(N):
            f1[j]=f2[j]

        if (k+k+i-1)*i>2*n:
            break
        i+=1
    print(*res[1:])

main()","j in range(step,N)","j in f1:
            f2[j]=(f1[j-step]+f2[j-step])%mod
        res[i]=(f1[i]+f2[i])%mod
        i+=1
        for j in range(N):
            f1[j]=f2[j]

        if (k+k+i-1)*i>2*n:
            break
        i+=1
    print(*res[1:])

main()

'''
import sys

inf=float('inf')
mod=998244353
#input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: "
"import sys

inf=float('inf')
mod=998244353
#input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())

def main():

    n,k=inpnm()
    N=n+1
    f1=[0]*N
    res=[0]*N

    f1[0]=1
    i=1
    while True:
        step=k+i-1
        f2=[0]*N
        for j in range(step,N):
            f2[j]=(f1[j-step]+f2[j-step])%mod
            res[j]=(res[j]+f2[j])%mod

        for {{completion}}:
            f1[j]=f2[j]

        if (k+k+i-1)*i>2*n:
            break
        i+=1
    print(*res[1:])

main()",j in range(N),"j in range(f1[0]-1,-1,-1):
            f1[j]=f1[j]%mod
        for j in range(f2[0]-1,-1,-1):
            f2[j]=f2[j]%mod

        for j in range(f1[0]-1,-1,-1):
            f1[j]=f1[j]
        for j in range(f2[0]-1,-1,-1):
            f2[j]=f2[j]

        for j in range(f1[0]-1,-1,-1):
            f1[j]=f1[j]
        for j in range(f2[0]-1,-1,-1):
            f2[j]=f2[j]

        for j in range(f1[0]-1,-1,-1):
            f1[j]=f1[j]
        for j in range(f2[0]"
"t=1
mod=998244353
while t:
    t-=1
    n,k=[int(x) for x in input().split()]
    dp=[0 for x in range(n+1)]
    ans=[0 for x in range(n+1)]
    for i in range(k,n+1,k):
        dp[i]+=1
        ans[i]=dp[i]
    while True:
        k+=1
        shift=False

        for i in reversed(range(n+1)):

            if i-k>=0:
                dp[i]=dp[i-k]
                dp[i-k]=0
                if {{completion}}:
                    shift=True
            else:
                dp[i]=0

        for i in range(n+1):
            if i+k<=n:
                dp[i+k]+=dp[i]
                dp[i+k]%=mod
        for i in range(n+1):
            ans[i]+=dp[i]
            ans[i]%=mod
        if not shift:
            break
    print(*ans[1:])


",dp[i],dp[i]%mod==mod
"MOD, MAXN = 998244353, 10**5 * 2
N, K = map(int, input().split())
ans, dp = [0] * (MAXN + 10), [0] * (MAXN + 10)
dp[0] = 1
s = 0
for i in range(701):
    if s > N:
        break
    new_dp = [0] * (MAXN + 10)
    for {{completion}}:
        new_dp[j] = (new_dp[j - i - K] + dp[j - i - K]) % MOD
        ans[j] = (ans[j] + new_dp[j]) % MOD
    dp = new_dp
    s += i + K
print(*ans[1:N + 1])
","j in range(s + i + K, N + 1)","j in range(MAXN + 10):
        if j >= i:
            new_dp[j] = (new_dp[j - i] + dp[j - i]) % MOD
        elif j >= s - K"
"n,k=map(int,input().split());M=998244353
f,z=[1]+[0]*n,[0]*(n+1);l=0
while l<=n-k:
  s=[0]*k
  for {{completion}}:
    j=i%k
    s[j],f[i],z[i]=(s[j]+f[i])%M,s[j],(z[i]+s[j])%M
  l+=k;k+=1
print(*z[1:])","i in range(l,n+1)","i,j in enumerate(z):
    if j==l"
"def readline():
    line = input()
    while not line:
        line = input()
    return line


def main():
    t = int(readline())
    for _ in range(t):
        m = int(readline())
        a = [ [], [] ]
        a[0] += list(map(int, readline().split()))
        a[1] = list(map(int, readline().split()))

        h = [ [None] * m, [None] * m ]
        h[0][m-1] = max(a[1][m-1]+1, a[0][m-1]+1+1)
        h[1][m-1] = max(a[0][m-1]+1, a[1][m-1]+1+1)
        for i in reversed(range(m-1)):
            h[0][i] = max(a[1][i]+1, h[0][i+1]+1, a[0][i]+(i!=0)+(m-i-1)*2+1)
            h[1][i] = max(a[0][i]+1, h[1][i+1]+1, a[1][i]+1+(m-i-1)*2+1)

        pos = (0,0)
        t = 0
        best_total_time = 10**10
        for i in range(2*m-1):
            if i % 2 == 0:
                total_time = max(t+(m-i//2-1)*2+1, h[pos[0]][pos[1]])
                # print(pos, t,total_time)
                best_total_time = min(best_total_time, total_time)

            if i % 4 == 0:
                # abajo
                pos = (pos[0]+1, pos[1])
            elif {{completion}}:
                # derecha
                pos = (pos[0], pos[1]+1)
            elif (i-2) % 4 == 0:
                # arr
                pos = (pos[0]-1, pos[1])
            elif (i-3) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            t = max(a[pos[0]][pos[1]] + 1, t+1)

        # for line in h:
        #     print(line)
        print(best_total_time)


main()
",(i-1) % 4 == 0,"(i-1) % 4 == 0:
                pos = (pos[0]-1, pos[1])
            elif (i-2) % 4 == 0:
                pos = (pos[0], pos[1]+1)
            elif (i-3) % 4 == 0:
                pos = (pos[0], pos[1]+1)
            t = max(a[pos[0]][pos[1]] + 1, t+1)

        pos = (0,0)
        t = 0
        for i in range(2*m-1):
            if i % 2 == 0:
                total_time = max(t+(m-i//2-1)*2+1, h[pos[0]][pos[1]])
                best_total_time = min(best_total_time, total_time)

            if i % 4 == 0:
                pos = (pos[0]+1, pos[1])
            elif (i-1) % 4 == 0:
                pos = ("
"def readline():
    line = input()
    while not line:
        line = input()
    return line


def main():
    t = int(readline())
    for _ in range(t):
        m = int(readline())
        a = [ [], [] ]
        a[0] += list(map(int, readline().split()))
        a[1] = list(map(int, readline().split()))

        h = [ [None] * m, [None] * m ]
        h[0][m-1] = max(a[1][m-1]+1, a[0][m-1]+1+1)
        h[1][m-1] = max(a[0][m-1]+1, a[1][m-1]+1+1)
        for i in reversed(range(m-1)):
            h[0][i] = max(a[1][i]+1, h[0][i+1]+1, a[0][i]+(i!=0)+(m-i-1)*2+1)
            h[1][i] = max(a[0][i]+1, h[1][i+1]+1, a[1][i]+1+(m-i-1)*2+1)

        pos = (0,0)
        t = 0
        best_total_time = 10**10
        for i in range(2*m-1):
            if i % 2 == 0:
                total_time = max(t+(m-i//2-1)*2+1, h[pos[0]][pos[1]])
                # print(pos, t,total_time)
                best_total_time = min(best_total_time, total_time)

            if i % 4 == 0:
                # abajo
                pos = (pos[0]+1, pos[1])
            elif (i-1) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            elif {{completion}}:
                # arr
                pos = (pos[0]-1, pos[1])
            elif (i-3) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            t = max(a[pos[0]][pos[1]] + 1, t+1)

        # for line in h:
        #     print(line)
        print(best_total_time)


main()
",(i-2) % 4 == 0,"(i+1) % 4 == 0:
                pos = (pos[0]-1, pos[1])
            elif (i+3) % 4 == 0:
                pos = (pos[0], pos[1]+1)
            elif (i+2) % 4 == 0:
                pos = (pos[0]+1, pos[1])
            elif (i+4) % 4 == 0:
                pos = (pos[0]-1, pos[1])
            elif (i+5) % 4 == 0:
                pos = (pos[0], pos[1]+1)
            elif (i+6) % 4 == 0:
                pos = (pos[0]+1, pos[1])
            elif (i+7) % 4 == 0:
                pos = (pos[0]-1, pos[1])
            elif (i+8) % 4 == 0:
                pos = (pos[0], pos[1]+1)
            elif (i"
"import sys; input = sys.stdin.readline

def seg(start, end):
    if {{completion}}:
        val = max(arr[start], 0)
        return [(val, val, val, arr[start])]
    mid = (start + end) // 2
    l = seg(start, mid)
    r = seg(mid + 1, end)
    result = []
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    l, r = r, l
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    return result
        
n = int(input())
l = 1 << n
arr = list(map(int, input().split()))
tree = seg(0, l - 1)
i = 0
for _ in range(int(input())):
    i ^= (1 << int(input()))
    print(tree[i][0])",start == end,"start == end:
        return [(arr[start], arr[start], arr[start], arr[start])]
    if start > end:
        return []
    if start == end // 2:
        val = max(arr[start], 0)
        return [(val, val, val, arr[start])]
    mid = (start + end) // 2
    l = seg(start, mid)
    r = seg(mid + 1, end)
    result = []
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max("
"import sys; input = sys.stdin.readline

def seg(start, end):
    if start == end:
        val = max(arr[start], 0)
        return [(val, val, val, arr[start])]
    mid = (start + end) // 2
    l = seg(start, mid)
    r = seg(mid + 1, end)
    result = []
    for {{completion}}:
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    l, r = r, l
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    return result
        
n = int(input())
l = 1 << n
arr = list(map(int, input().split()))
tree = seg(0, l - 1)
i = 0
for _ in range(int(input())):
    i ^= (1 << int(input()))
    print(tree[i][0])",i in range((end - start + 1) // 2),"x in l:
        for y in r:
            x.append(y[0])
            y.pop()
    l, r = r, l
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    return result
    
def seg2(start, end):
    if start == end:
        val = max(arr[start], 0)
        return [(val, val, val, arr[start])]
    mid = (start + end) // 2
    "
"import sys

input = lambda: sys.stdin.readline().rstrip()

class Node:
    def __init__(self, seg, suf, pref, sum) -> None:
        self.best = seg
        self.suf = suf
        self.pref = pref
        self.sum = sum


def merge(a, b):
    seg = max(a.best, b.best, a.suf + b.pref)
    suf = max(b.suf, b.sum + a.suf)
    pref = max(a.pref, a.sum + b.pref)
    sum = a.sum + b.sum
    return Node(seg, suf, pref, sum)

def single(a):
    v = max(a, 0)
    return Node(v, v, v, a)

def build(v, l, r):
    if l + 1 == r:
        return [single(A[l])]
    else:
        m = (l + r) // 2
        vl = build(2 * v + 1, l, m)
        vr = build(2 * v + 2, m, r)
        ans = []
        for _ in range(2):
            for {{completion}}:
                ans.append(merge(vl[i], vr[i]))
            vl, vr = vr, vl
        return ans

N = int(input())
A = list(map(int, input().split()))
Q = int(input())

M = 1 << N
tree = build(0, 0, M)
curr = 0
for _ in range(Q):
    K = int(input())
    curr ^= (1 << K)
    print(tree[curr].best)",i in range((r - l) // 2),"_ in range(len(vl)):
                ans.append(merge(vl[_], vr[_]))
            for _ in range(len(vl)):
                vl[_], vr[_] = vl[_], vr[_]
            for _ in range(len(vl)):
                vl[_], vr[_] = vl[_], vr[_]
            for _ in range(len(vl)):
                vl[_], vr[_] = vl[_], vr[_]
            for _ in range(len(vl)):
                vl[_], vr[_] = vl[_], vr[_]
            for _ in range(len(vl)):
                vl[_], vr[_] = vl[_], vr[_]
            for _ in range(len(vl)):
                vl[_], vr[_"
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    N = int(input())
    G = [[int(x) for x in input()] + [0] for _ in range(2)]
    
    dp = [[0] * 2  for _ in range(N + 1)]   # number of 1 cells robot will clean when it arrives at cell (j, i) from the left
    for j in range(2):
        dp[N - 1][j] = G[1 - j][N - 1]
    
    for i in range(N - 2, - 1, -1):
        for j in range(2):
            dp[i][j] = G[j][i + 1] + dp[i + 1][j]   # base case: ignore row 1 - j and proceed right
            if {{completion}}:
                dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])

    print(dp[0][0])
    return

solve()",G[1 - j][i],"j == 1 and dp[i][j] > dp[i + 1][j]:
                dp[i][j] = dp[i + 1][j]
            if j == 0 and dp[i][j] > dp[i + 1][j]:
                dp[i][j] = dp[i + 1][j]
            if j == 1 and dp[i][j] > dp[i + 1][j]:
                dp[i][j] = dp[i + 1][j]
            if j == 0 and dp[i][j] > dp[i + 1][j]:
                dp[i][j] = dp[i + 1][j]
            if j == 1 and dp[i][j] > dp[i + 1][j]:
                dp[i][j] = dp[i + 1][j]
            if j == 0 and dp[i][j] > dp[i + 1][j]:
                dp[i][j] = dp[i + 1][j]
            if j == 1 and dp[i][j] > dp[i + 1]"
"import sys
inf = float('inf')
mod = 998244353
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int, input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())


n=inpint()
s=[]
for i in range(2):
    s.append([i for i in list(input())]+['0','0'])
#print(arr)
f=[[-inf]*(2) for _ in range(n+2)]
f[0][0]=0
for i in range(n):
    for j in range(2):
        f[i+1][j]=max(f[i+1][j],f[i][j]+int(s[j][i+1]))
        if {{completion}}:
            f[min(i+2,n)][j^1]=max(f[min(i+2,n)][j^1],f[i][j]+1+int(s[j^1][i+1])+int(s[j^1][i+2]))
print(max(f[n][0],f[n][1]))",s[j^1][i]=='1',"j==1:
            f[i+1][j]=max(f[i+1][j],f[i][j]+1+int(s[j][i+1]))
for i in range(n-1):
    for j in range(2):
        f[n][j]=max(f[n][j],f[n-1][j]+int(s[n-1][i]))
        if j==1:
            f[n][j]=max(f[n][j],f[n-1][j]+1+int(s[n-1][i]))
for i in range(n-2):
    for j in range(2):
        f[n][j^1]=max(f[n][j^1],f[n-1][j^1]+int(s[n-1][i]))
        if j==1:
            f[n][j^1]=max(f[n"
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    N = int(input())
    G = [[int(x) for x in input()] + [0] for _ in range(2)]
    
    dp = [[0] * 2  for _ in range(N + 1)]
    for j in range(2):
        dp[N - 1][j] = G[1 - j][N - 1]
    
    for i in range(N - 2, - 1, -1):
        for j in range(2):
            dp[i][j] = G[j][i + 1] + dp[i + 1][j]   # can always ignore row 1 - j and proceed right
            if G[1 - j][i]:
                if {{completion}}:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])
                else:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + dp[i + 1][1 - j])

    print(dp[0][0])
    return

solve()",G[j][i + 1],"j == 0:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1])
                elif j == 1:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 2] + G[1 - j][i + 1])
                elif j == 2:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 2] + dp[i + 1][j] + G[1 - j][i + 1])
                elif j == 3:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 2] + dp[i + 1][j] + dp[i + 2][j] + G[1 - j][i + 1])
                elif j == 4:
                    dp[i][j] = max"
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for i in range(tc):
        n, row1, row2 = input_arr[pos:pos + 3]
        row1n, row2n = [], []
        for k,j in zip(row1, row2):
            if {{completion}}:
                k = ""B""
            if j == ""G"":
                j = ""B""
            row1n.append(k)
            row2n.append(j)
        print(""YES"" if row1n == row2n else ""NO"")

        pos += 3

# '6 2 RG RB 4 GRBG GBGB 5 GGGGG BBBBB 7 BBBBBBB RRRRRRR 8 RGBRRGBR RGGRRBGR 1 G G'
","k == ""G""","k == ""R"":
                k = ""B""
            if j == ""R"":
                j = ""B""
            if k == ""G"":
                k = ""B""
            if j == ""G"":
                j = ""B""
            row1n.append(k)
            row2n.append(j)
        print(""YES"" if row1n == row2n else ""NO"")

        pos += 3

    pos = 1
    for i in range(tc):
        n, row1, row2 = input_arr[pos:pos + 3]
        row1n, row2n = [], []
        for k,j in zip(row1, row2):
            if k == ""R"":
                k = ""B""
            if j"
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for i in range(tc):
        n, row1, row2 = input_arr[pos:pos + 3]
        row1n, row2n = [], []
        for k,j in zip(row1, row2):
            if k == ""G"":
                k = ""B""
            if {{completion}}:
                j = ""B""
            row1n.append(k)
            row2n.append(j)
        print(""YES"" if row1n == row2n else ""NO"")

        pos += 3

# '6 2 RG RB 4 GRBG GBGB 5 GGGGG BBBBB 7 BBBBBBB RRRRRRR 8 RGBRRGBR RGGRRBGR 1 G G'
","j == ""G""","j == ""G"":
                j = ""B""
            if k == ""B"":
                k = ""G""
            if j == ""B"":
                j = ""G""
            if k == ""R"":
                k = ""G""
            if j == ""R"":
                j = ""G""
            if k == ""G"":
                k = ""R""
            if j == ""G"":
                j = ""R""
            if k == ""B"":
                k = ""R""
            if j == ""B"":
                j = ""R""
            if k == ""R"":
                k = ""B""
            if j == ""R"":
                j = """
"import sys


if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    n = input_arr[0]
    pos = 1
    for i in range(n):
        n, code = input_arr[pos:pos+2]
        code_str = str(code)
        result = []
        j = n-1
        while j >= 0:
            if j >= 2:
                sub = code_str[j-2:j+1]
                if {{completion}}:
                    result.append(chr(int(sub)//10 + 96))
                    j -= 3
                else:
                    result.append(chr(int(code_str[j])+96))
                    j -= 1
            else:
                result.append(chr(int(code_str[j]) + 96))
                j -= 1
        print("""".join(result[::-1]))
        pos += 2

# sys.stdin.read()
","sub[-1] == ""0""","sub[0].isdigit() and sub[1].isdigit():
                    result.append(chr(int(sub[0])+int(sub[1])+96))
                    j -= 3
                elif sub[0].isdigit():
                    result.append(chr(int(sub[0])+96))
                    j -= 1
                elif sub[1].isdigit():
                    result.append(chr(int(sub[1])+96))
                    j -= 1
                else:
                    result.append(chr(int(code_str[j])+96))
                    j -= 1
            elif j == 1 and code_str[j].isdigit():
                if code_str[j-1].isdigit():
                    result.append(chr(int(code_str[j-1]) + 96))
                    "
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  s = str(inp1())[::-1]
  alph = ""0abcdefghijklmnopqrstuvwxyz""
  d = deque()
  i = 0
  while i < n:
    if {{completion}}:
      d.appendleft(int(s[i + 1:i + 3][::-1]))
      i += 3
    else:
      d.appendleft(int(s[i]))
      i += 1
  ret = """"
  for i in d:
    ret += alph[i]
  print(ret)
","s[i] == ""0""",s[i + 1] in alph
"import sys


def calculate(x, y1, y2):
    x = int(x)
    y1 = int(y1)
    y2 = int(y2)
    diff1 = abs(x - 1)
    diff2 = abs(y1-y2) if y2 == 1 else abs(y1-y2)+y2-1
    if diff1 < diff2:
        return 1
    elif diff2 < diff1:
        return 2
    else:
        return 3


if __name__ == ""__main__"":
    for line in sys.stdin:
        input = line.split()
        if {{completion}}:
            print(calculate(input[0], input[1], input[2]))
",len(input) == 3,"input[0] == '1':
            print(calculate(input[1], input[2], input[3]))
        elif input[0] == '2':
            print(calculate(input[1], input[2], input[3]))
        elif input[0] == '3':
            print(calculate(input[1], input[2], input[3]))
        elif input[0] == '4':
            print(calculate(input[1], input[2], input[3]))
        elif input[0] == '5':
            print(calculate(input[1], input[2], input[3]))
        elif input[0] == '6':
            print(calculate(input[1], input[2], input[3]))
        elif input[0] == '7':
            print(calculate(input[1], input[2], input[3]))
        elif input[0] == '8':
            print(calculate(input[1], input[2], input[3]))
        elif input"
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              tt = [l[0] + r[0] + 1, r[1]]
            elif {{completion}}:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt[0] == l[0] + r[0] + 1,"tt[0] > l[0] + r[1] + 1:
              tt = [l[0] + r[1] + 1, r[1]]
            else:
              tt[0] = tt[0] + l[0] + r[1] + 1
            if l[0] == 0:
              tt[1] = tt[1] + r[1]
            else:
              tt[1] = tt[1] + r[1] + 1
            d[k][i] = tt
          else:
            r = (d[k][j - ln] if j - ln >= k else None) or [0, 1]
            tt = d[k][i]
            if tt is None or tt[0] > l[0] + r[1] + 1:
              tt = [l[0] + r[1] + 1, r[1]]
            elif tt[0] > l[0] + r[1] + 1:
              tt = [l[0] + r[1] + 1, r[1]]"
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if {{completion}}:
              tt = [l[0] + r[0] + 1, r[1]]
            elif tt[0] == l[0] + r[0] + 1:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt is None or tt[0] > l[0] + r[0] + 1,tt[1] == r[1]
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              tt = [l[0] + r[0] + 1, r[1]]
            elif {{completion}}:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
          else:
            break
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt[0] == l[0] + r[0] + 1,"tt[0] > l[0] + r[1] + 1:
              tt = [l[0] + r[1] + 1, r[1]]
            else:
              tt[0] = tt[0] + l[0] + r[1] + 1
            if l[1] == 0:
              tt[1] = r[1]
            elif r[1] == 0:
              tt[1] = l[1]
            else:
              tt[1] = tt[1] + r[1]
            d[k][i] = tt
          else:
            break
      if d[k][i]:
        d[k][i][1] %= 1000000007
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = ("
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if {{completion}}:
              tt = [l[0] + r[0] + 1, r[1]]
            elif tt[0] == l[0] + r[0] + 1:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
          else:
            break
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt is None or tt[0] > l[0] + r[0] + 1,tt[1] == r[1]
"# from collections import Counter
""""""
standing at point i, why choose to jump to a point j?

if jump:
a*(j-i) + cost(j,n)
if not jump(ie. start from i):
every unconquered kingdom require the distance j-i be conqured, totally n-j times,
-> (j-i)*b*(n-j) + cost(j,n)

compare the two equations:
when a < b*(n-j), we choose to jump to j.
""""""
row=lambda:map(int,input().split())
t=int(input())
for _ in range(t):
    n,a,b=row()
    arr=[0]+list(row())
    
    pos=res=0
    for i in range(1,n+1):
      d=arr[i]-arr[pos]
      res+=b*d
      if {{completion}}:
        res+=a*d
        pos=i
    print(res)",a<b*(n-i),"pos!=i:
        res+=a*d
        pos=i
    print(res)
""""""
standing at point i, why choose to jump to a point j?

if jump:
a*(j-i) + cost(j,n)
if not jump(ie. start from i):
every unconquered kingdom require the distance j-i be conqured, totally n-j times,
-> (j-i)*b*(n-j) + cost(j,n)

compare the two equations:
when a < b*(n-j), we choose to jump to j.
""""""
row=lambda:map(int,input().split())
t=int(input())"
"import sys
lines = list(map(str.strip, sys.stdin.readlines()))

def cum_sum(nums):
    curr = 0
    result = [0]*len(nums)
    for {{completion}}:
        curr += num
        result[idx] = curr
    return result

for i in range(1, len(lines), 2):
    n, a, b = map(int, lines[i].split("" ""))
    nums = [0] + list(map(int, lines[i+1].split("" "")))
    cumulative = cum_sum(nums)
    smallest = float(""inf"")
    for f in range(0, n+1):
        curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
        smallest = min(curr, smallest)
    print(smallest)
","idx, num in enumerate(nums)","idx, num in enumerate(nums):
        if num != 0:
            curr += num
            result[idx] = curr
    return result

def cum_sum_2(nums):
    curr = 0
    result = [0]*len(nums)
    for idx, num in enumerate(nums):
        if num != 0:
            curr += num
            result[idx] = curr
    return result

def cum_sum_3(nums):
    curr = 0
    result = [0]*len(nums)
    for idx, num in enumerate(nums):
        if num != 0:
            curr += num
            result[idx] = curr
    return result

def cum_sum_4(nums):
    curr = 0
    result = [0]*len(nums)
    for idx, num"
"import sys
lines = list(map(str.strip, sys.stdin.readlines()))

def cum_sum(nums):
    curr = 0
    result = [0]*len(nums)
    for idx, num in enumerate(nums):
        curr += num
        result[idx] = curr
    return result

for i in range(1, len(lines), 2):
    n, a, b = map(int, lines[i].split("" ""))
    nums = [0] + list(map(int, lines[i+1].split("" "")))
    cumulative = cum_sum(nums)
    smallest = float(""inf"")
    for {{completion}}:
        curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
        smallest = min(curr, smallest)
    print(smallest)
","f in range(0, n+1)","f in range(n):
        curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
        smallest = min(curr, smallest)
    print(smallest)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "
"#Name:      Codeforces Round #782 (Div. 4)
#Code:      
#Rating:    00
#Date:      14/06/2022
#Author:    auros25
#Done:      


#sys.stdin.readline().strip()
#sys.stdout.write(+""\n"")

import sys
#import bisect

for lol in range(int(sys.stdin.readline().strip())):
    n, a, b = list(map(int, sys.stdin.readline().strip().split()))
    x = list(map(int, sys.stdin.readline().strip().split()))
    k = a//b + 1
    #print(k)
    if {{completion}}:
        sys.stdout.write(str(b*(sum(x))) +""\n"")
    else:
        c=a+b
##        v=c*x[n-k-1]
##        w=k*b*x[n-k-1]
##        u= sum(x[n-k:])*b
        #print(v, w, u)
        #print(v-w+u)
        sys.stdout.write( str( c*x[n-k-1] + b*(sum(x[n-k:])-x[n-k-1]*k)) +""\n"")
   
",k >=n,"n==1:
        sys.stdout.write(str(x[0]) +""\n"")
    elif n==2:
        sys.stdout.write(str(x[0]+x[1]) +""\n"")
    elif n==3:
        sys.stdout.write(str(x[0]+x[1]+x[2]) +""\n"")
    elif n==4:
        sys.stdout.write(str(x[0]+x[1]+x[2]+x[3]) +""\n"")
    elif n==5:
        sys.stdout.write(str(x[0]+x[1]+x[2]+x[3]+x[4]) +""\n"")
    elif n==6:
        sys.stdout.write(str(x[0]+x[1]+x[2]+x[3]+x[4]+x[5]) +""\n"")
    elif n==7:
        sys.stdout.write("
"for _ in range(int(input())):
	n,a,b=map(int, input().split())
	w=[int(x) for x in input().split()]
	fb=sum(w)*b
	fa=0
	ans = fb
	cap = 0
	cur = n
	for x in w:
		fb -= x * b
		cur -= 1
		if {{completion}}:
			ans += (x - cap) * a
			ans -= (x - cap) * cur * b
			cap = x
		#print(cap)
	print(ans)",(x - cap) * a + fb - (x - cap) * cur * b < fb,"cur == 0:
			fa = fb
			fb = 0
			cur = n
		if cur > 0:
			fa = fb
			fb = 0
			cur = n
		fb += x * a
		if fa < fa"
"t = int(input())
for i in range(t):
    li = input().split()
    n = int(li[0])
    a = int(li[1])
    b = int(li[2])
    x = input().split()
    ans = 0
    now = 0
    for j in range(n):
        ans += b*(int(x[j])-now)
        if {{completion}}:
            ans += a*(int(x[j])-now)
            now = int(x[j])
    print(ans)
",a < b*(n-j-1),int(x[j]) < now
"def solve():
  n,a,b=map(int,input().split())
  xs=list(map(int,input().split()))
  cum=0
  ans=sum(xs)*b
  for {{completion}}:
    x=xs[-i-1]
    ans=min(ans,x*(a+b)+(cum-x*i)*b)
    cum+=x
  
  print(ans)

for _ in range(int(input())):
  solve()",i in range(n),"_ in range(n):
    i=xs.index(cum)
    if i==len(xs)-1:
      ans=min(ans,cum*(a+b)+(cum-cum)*b)
      break
    else:
      ans=min(ans,cum*(a+b)+(cum-cum)*b)
      cum+=xs[i]
  
  for i in range(n-1,-1,-1):
    if i==len(xs)-1:
      ans=min(ans,cum*(a+b)+(cum-cum)*b)
      break
    else:
      ans=min(ans,cum*(a+b)+(cum-cum)*b)"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
for _ in range(t):
	n, a, b = I()
	x = [0] + I()
	suffixes = [0]
	for {{completion}}:
		move = x[i + 1] - x[i]
		tot = suffixes[-1] + len(suffixes) * move * b
		suffixes.append(tot)
	suffixes = suffixes[::-1]
	best = float('inf')
	for i in range(n + 1):
		best = min(best, x[i] * (b + a) + suffixes[i])
	print(best)
","i in range(n - 1, -1, -1)","_ in range(n):
		x.append(x[-1] + I()[0])
		suffixes.append(suffixes[-1] + I()[1])
	suffixes = suffixes[::-1]
	best = float('inf')
	for i in range(n + 1):
		best = min(best, x[i] * (b + a) + suffixes[i])
	print(best)
<|/ a tags=dynamic-programming,algorithm,python,dynamic-programming |>
<| c |>
This is not the optimal solution. Consider a test case where `n = 2` and `a = 1` and `b = 2`. Then the optimal solution would be to conquer the kingdom at position `1` with cost `3"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
for _ in range(t):
	n, a, b = I()
	x = [0] + I()
	suffixes = [0]
	for i in range(n - 1, -1, -1):
		move = x[i + 1] - x[i]
		tot = suffixes[-1] + len(suffixes) * move * b
		suffixes.append(tot)
	suffixes = suffixes[::-1]
	best = float('inf')
	for {{completion}}:
		best = min(best, x[i] * (b + a) + suffixes[i])
	print(best)
",i in range(n + 1),"i, x in enumerate(suffixes):
		if i == 0 or x == 0:
			continue
		if x * (b + a) < best"
"def f(ar,a,b):
    ans=0
    c=0
    n=len(ar)
    for id,i in enumerate(ar):
        d=i-c
        ans+=d*b
        if {{completion}}:
            ans+=d*a
            c=i
    return ans

r=lambda :map(int,input().strip().split())
for _ in range(int(input())):
    n,a,b=r()
    ar=list(r())
    print(f(ar,a,b))
",d*a<(n-id-1)*(d)*b,"d==0 and c!=0:
            ans+=d*a
            c=i
        elif d!=0 and c==0:
            ans+=d*a
            c=i
        elif d!=0 and c!=0 and c!=i:
            ans+=d*a
            c=i
        elif d==0 and c==i:
            ans+=d*a
            c=i
    return ans

def g(ar,a,b):
    ans=0
    c=0
    n=len(ar)
    for id,i in enumerate(ar):
        d=i-c
        ans+=d*b
        if d==0 and c!=0:"
"for {{completion}}:n,r,b=map(int,s.split());b+=1;c=r//b*'R'+'B';print((r%b*('R'+c)+n*c)[:n])",s in[*open(0)][1:],"_ in range(int(input())):
    n,r,b=map(int,input().split())
    b+=1
    c=r//b*'R'+'B'
    print((r%b*('R'+c)+n*c)[:n])
<|/ a tags=python-3.x,python |>
<| c |>
Please don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| c |>
I thought the explanation "
"for {{completion}}:
    n,r,b=map(int,input().split())
    t=((r-1)//(b+1)+1)
    k=t*(b+1)-r
    res=('R'*t+'B')*(b+1-k)+('R'*(t-1)+'B')*k
    print(res[:-1])
    #",_ in range(int(input())),"_ in range(int(input())):
    n,r,b=map(int,input().split())
    t=((r-1)//(b+1)+1)
    k=t*(b+1)-r
    res=('R'*t+'B')*(b+1-k)+('R'*(t-1)+'B')*k
    print(res[:-1])
    #print(res)
'''
for _ in range(int(input())):
    #n=0
    #r=0
    #b=0
    #t=int(input())
    #for i in range(t):
    #    n,r,b=map(int,input().split())
    #    t=((r-1)//(b+1)+1)
    #    k="
"tc=int(input())
for {{completion}}:
 n,a,b=map(int,input().split());b+=1
 print((('R'*(a//b+1)+'B')*(a%b)+('R'*(a//b)+'B')*(b-a%b))[:-1])",_ in range(tc),"_ in range(tc):
 n,r,b=map(int,input().split())
 print(('R'*(r//b+1)+'B')*(r%b)+('R'*(r//b)+'B')*(b-r%b))[:-1])
<|/ q dscore=0 |>
<| c |>
Please post the code you have tried so far.
<|/ c |>
<| c |>
Welcome to Stack Overflow! It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own"
"
def solve():
  n, r, b = list(map(int, input().split("" "")))

  d = r // (b+1)
  rem = r%(b+1)
  s = ''

  for i in range(b):
    if{{completion}}:
      s += 'R'
      rem-= 1
    s += 'R'*d + 'B'
  
  s += 'R'*d
  s+='R'*rem

  print(s)

for t in range(int(input())):
    solve()
",(rem > 0),"(i == 0):
      s += 'R'*d
    else:
      s += 'R'
      rem-= 1
    s += 'R'*d + 'B'
  
  s += 'R'*d
  s+='R'*rem

  print(s)

for t in range(int(input())):
    solve()
'''
</cell>
<cell>
#hide
from nbdev.export import *
notebook2script()
</cell>
<cell>

</cell>
<|/ file ext=.ipynb:python |>"
"for {{completion}}:n,r,b=map(int,n.split());b+=1;n=r//b*'R';print((r%b*(n+'RB')+(b-r%b)*(n+'B'))[:-1])",n in[*open(0)][1:],"_ in range(int(input())):
    n,r,b=map(int,input().split())
    b+=1;n=r//b*'R';print((r%b*(n+'RB')+(b-r%b)*(n+'B'))[:-1])

<|/ file source=github dstars=3 |>"
"t=int(input())
for {{completion}}:
    n,r,b=map(int,input().split())
    eq=r//(b+1)
    rem=r%(b+1)
    print(rem*((eq+1)*""R""+""B"")+(b-rem)*(eq*(""R"")+""B"")+eq*""R"")","i in range(0,t)","_ in range(t):
    n,r,b=map(int,input().split())
    eq=r//(b+1)
    rem=r%(b+1)
    print(rem*((eq+1)*""R""+""B"")+(b-rem)*(eq*(""R"")+""B"")+eq*""R"")) 
<|/ q dscore=0 |>
<| c |>
Please read [ask] and [edit] your question to include a [mcve]. Also, please format your code properly.
<|/ c |>
<| c |>
Please read [Why is “Can someone help me?” not an actual question?](https://"
"for t in range(int(input())):
    n,r,b = map(int,input().split())
    s = []
    while r and b:
        s.append(""R"")
        s.append(""B"")
        r-=1
        b-=1
    s.append(""R"")
    r-=1
    j = 0
    while r:
        s[j]+='R'
        r-=1
        j+=2
        if {{completion}}:
            j=0

    print(*s,sep="""")
        
        
    ",j>=len(s),j==n
"for {{completion}}:
	n,r,b=map(int,l.split())
	b+=1
	c=(r//b)*'R'+'B'
	print(((r%b)*('R'+c)+n*c)[:n])",l in [*open(0)][1:],"_ in range(int(input())):
	l=input()
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
"
"t = int(input())
for i in range(t):
    x = input().split()
    r = int(x[1])
    b = int(x[2])
    x = """"
    p = r%(b+1)
    q = r//(b+1)
    for {{completion}}:
        x += ""R""*(q+1)+""B""
    for i in range(b+1-p):
        x+= ""R""*(q)+""B""
    print(x[:-1])",i in range(p),"j in range(p):
        x += ""R""*(b+1)+""B""
    for j in range(q):
        x += ""R""*(b+1)+""B""
    for j in range(q):
        x += ""R""*(b+1)+""B""
    for j in range(q):
        x += ""R""*(b+1)+""B""
    for j in range(q):
        x += ""R""*(b+1)+""B""
    for j in range(q):
        x += ""R""*(b+1)+""B""
    for j in range(q):
        x += ""R""*(b+1)+""B""
    for j in range(q):
        x += ""R""*"
"t = int(input())
for i in range(t):
    x = input().split()
    r = int(x[1])
    b = int(x[2])
    x = """"
    p = r%(b+1)
    q = r//(b+1)
    for i in range(p):
        x += ""R""*(q+1)+""B""
    for {{completion}}:
        x+= ""R""*(q)+""B""
    print(x[:-1])",i in range(b+1-p),"j in range(q):
        x += ""R""*(b+1)+""B""
    for k in range(b):
        x += ""R""*(b+1)+""B""
    for l in range(b):
        x += ""R""*(b+1)+""B""
    for m in range(b):
        x += ""R""*(b+1)+""B""
    for n in range(r):
        x += ""R""*(q+1)+""B""
    for o in range(r):
        x += ""R""*(b+1)+""B""
    for p in range(r):
        x += ""R""*(b+1)+""B""
    for q in range(r):
        x += """
"for {{completion}}:n,r,b=map(int,n.split());b+=1;print((r%b*('R'*(r//b+1)+'B')+(b-r%b)*(r//b*'R'+'B'))[:-1])",n in[*open(0)][1:],"_ in range(int(input())):
    n,r,b=map(int,input().split())
    b+=1;print((r%b*('R'*(r//b+1)+'B')+(b-r%b)*(r//b*'R'+'B'))[:-1])

<|/ file filename=FPS_Competitive_Filtering.py ext=.py |>"
"for s in[*open(0)][2::2]:
    c=[*map(int,s.split())]
    a=[1 if x else 0 for x in c]+[1]
    for {{completion}}:
        a[x+i-i*a[i]]=0
    print(*a[:-1])
","i,x in enumerate(c)","x in range(len(a)):
        if a[x]==1:
            a[x]=x
    for x in range(len(a)):
        if a[x]==x:
            a[x]=x
    for x in range(len(a)):
        if a[x]==x:
            a[x]=x
    for x in range(len(a)):
        if a[x]==x:
            a[x]=x
    for x in range(len(a)):
        if a[x]==x:
            a[x]=x
    for x in range(len(a)):
        if a[x]==x:
            a[x]=x
    for x in range(len(a)):
        if a[x]==x:
            a[x]=x
    for x in range(len(a)):
        if a[x]=="
"
import sys


def solve():
    n = int(input())
    num = list(map(int , input().split()))
    ret = [1]*n
    for i in range(n):
        j = num[i]
        if {{completion}}:
            j += i
        if j < n:
            ret[j] = 0
    print(*ret)



for _ in range(int(input())):
    solve()
",j == 0 or ret[i] == 0,"j > 0 and j < n:
            ret[j] += 1
        if j > 0 and j == n-1:
            ret[j] = 0
        if j < n and j == n-1:
            ret[j] = 0
        if j < n and j > n-1:
            ret[j] = 0
        if j < n and j == n-2:
            ret[j] = 0
        if j < n and j == n-3"
"
import sys


def solve():
    n = int(input())
    num = list(map(int , input().split()))
    ret = [1]*n
    for i in range(n):
        j = num[i]
        if j == 0 or ret[i] == 0:
            j += i
        if {{completion}}:
            ret[j] = 0
    print(*ret)



for _ in range(int(input())):
    solve()
",j < n,"j > ret[i]:
            ret[i] = j
        else:
            ret[j] += 1
    for i in range(n):
        if ret[i] != 0:
            ret[i] -= 1
        if ret[i] == 0:
            ret[i] = 1
        else:
            ret[i] -= 1
    for i in range(n):
        if ret[i] != 0:
            ret[i] -= 1
        if ret[i] == 0:
            ret[i] = 1
        else:
            ret[i] -= 1
    for i in range(n):
        if ret[i] != 0:
            ret[i] -= 1
        if ret[i] == 0:
            ret[i] = 1
        else:
            ret[i] -= 1
    for i in range(n):
        if ret[i] != 0:
            ret[i] -= 1
        if ret[i] == 0:
            ret[i] = 1
        else:
            ret[i] -= 1
    for i in range(n):
        if ret"
"t = int(input())
for _ in range(t):
    n = int(input())
    c = list(map(int, input().split()))
    a, e, se, s = [], [0]*n, 0, sum(c)
    for {{completion}}:
        se -= e[i-1]
        n1 = s//i
        t = 0 if c[i-1] < i + se else 1
        a.append(t)
        s -= (n1 + (i-1)*t)
        e[i-n1-1] += 1
        se += 1
    print(*reversed(a))
        ","i in range(n, 0, -1)","_ in range(n):
        s.append(c[-1])
        c[-1] += 1
    for i in range(n):
        a.append(0 if c[i-1] < i + se else 1)
        se += 1
    print(*reversed(a))
        
<|/ file ext=.py filename=P03_01_01.py |>"
"from sys import stdin,stderr
def rl():
    return [int(w) for w in stdin.readline().split()]

t, = rl()
for _ in range(t):
    n, = rl()
    c = rl()
    a = [1] * n
    for i in range(n):
        j = c[i]
        if {{completion}}:
            j += i
        if j < n:
            a[j] = 0
    print(*a)
",j == 0 or  a[i] == 0,"j < i:
            a[j] += 1
        elif j > i:
            a[j] -= 1
        else:
            a[j] = 0
    print(*a)
<|/ a dscore=0 |>
<| c |>
Please don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.
<|/ c |>
<| c |>
Thanks for your advice. I will take care next time.
<|/ c |>
<| a tags=python,arrays |>
<code>
"
"from sys import stdin,stderr
def rl():
    return [int(w) for w in stdin.readline().split()]

t, = rl()
for _ in range(t):
    n, = rl()
    c = rl()
    a = [1] * n
    for i in range(n):
        j = c[i]
        if j == 0 or  a[i] == 0:
            j += i
        if {{completion}}:
            a[j] = 0
    print(*a)
",j < n,"j > n:
            a[j] = 0
        else:
            a[j] += 1
    print(*a)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
"
"for _ in range(int(input())):
    n=int(input())
    C=list(map(int,input().split()))
    z=sum(C)//n
    d=[0]*(n+1)
    ans=[]
    for i in range(n-1,-1,-1):
        d[i]+=d[i+1]
        d[i]-=1
        d[i-z]+=1
        if {{completion}}:
            ans.append(1)
            z-=1
        else:
            ans.append(0)
    print(*ans[::-1])",z and C[i]+d[i]==i,"d[i]==1:
            ans.append(i)
        elif d[i]==0:
            ans.append(i+1)
        elif d[i]==-1:
            ans.append(n-i-1)
        elif d[i]==-2"
"import sys
input = sys.stdin.readline


T = int(input())
for t in range(T):
    N=int(input())
    C=list(map(int,input().split()))
    ans=[0]*N
    k=sum(C)//N
    i=N-1
    while i>-1 and k>0:
        if {{completion}}:
            ans[i]=1
            k-=1
        else:
            C[i-k]+=N-i
        i-=1
    print(*ans)",C[i]==N,C[i]>k
"import sys
input = sys.stdin.readline

class DSU:

    def __init__(self, n):
        self.UF = list(range(n))
        self.sz = [0]*n

    def find(self, u):
        UF = self.UF

        if UF[u]!=u:
            UF[u] = self.find(UF[u])
        return UF[u]

    def union(self,u,v):
        UF = self.UF
        sz = self.sz

        pu = self.find(u)
        pv = self.find(v)

        if pu == pv:
            return False
        if sz[pu] >= sz[pv]:
            sz[pu] += 1
            UF[pv] = pu
        else:
            sz[pv] += 1
            UF[pu] = pv
        return True

n,m = map(int,input().split())
good = []

DSUs = [DSU(n+1) for _ in range(30)]

for _ in range(m):
    u,v,w = map(int,input().split())

    u -= 1
    v -= 1

    if w%2 == 0:
        good.append((u,v,w))

    for k in range(0, 30):
        if {{completion}}:
            DSUs[k].union(u,v)

q = int(input())
Q = [None]*q
ans = [2]*q

for i in range(q):
    u,v = map(int,input().split())

    u -= 1
    v -= 1

    Q[i] = u,v

    for k in range(0, 30):
        if DSUs[k].find(u) == DSUs[k].find(v):
            ans[i] = 0
            break

for u,v,w in good:
    for k in range(1, 30):
        DSUs[k].union(u, n)
        DSUs[k].union(v, n)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(n):
            ans[i] = 1
            break

print(""\n"".join(str(x) for x in ans))

",w & (1<<k),"DSUs[k].find(u) == DSUs[k].find(v):
            DSUs[k].union(u,v)
            break

for u,v,w in good:
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(v):
            DSUs[k].union(u,v)
            break

q = int(input())
Q = [None]*q
ans = [2]*q

for i in range(q):
    u,v = map(int,input().split())

    u -= 1
    v -= 1

    Q[i] = u,v

    for k in range(0, 30):
        if DSUs[k].find(u) == DSUs[k]."
"import sys
input = sys.stdin.readline

class DSU:

    def __init__(self, n):
        self.UF = list(range(n))
        self.sz = [0]*n

    def find(self, u):
        UF = self.UF

        if UF[u]!=u:
            UF[u] = self.find(UF[u])
        return UF[u]

    def union(self,u,v):
        UF = self.UF
        sz = self.sz

        pu = self.find(u)
        pv = self.find(v)

        if pu == pv:
            return False
        if sz[pu] >= sz[pv]:
            sz[pu] += 1
            UF[pv] = pu
        else:
            sz[pv] += 1
            UF[pu] = pv
        return True

n,m = map(int,input().split())
good = []

DSUs = [DSU(n+1) for _ in range(30)]

for _ in range(m):
    u,v,w = map(int,input().split())

    u -= 1
    v -= 1

    if w%2 == 0:
        good.append((u,v,w))

    for k in range(0, 30):
        if w & (1<<k):
            DSUs[k].union(u,v)

q = int(input())
Q = [None]*q
ans = [2]*q

for i in range(q):
    u,v = map(int,input().split())

    u -= 1
    v -= 1

    Q[i] = u,v

    for k in range(0, 30):
        if {{completion}}:
            ans[i] = 0
            break

for u,v,w in good:
    for k in range(1, 30):
        DSUs[k].union(u, n)
        DSUs[k].union(v, n)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(n):
            ans[i] = 1
            break

print(""\n"".join(str(x) for x in ans))

",DSUs[k].find(u) == DSUs[k].find(v),"w & (1<<k):
            DSUs[k].union(u,v)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(v):
            ans[i] = 1
            break

for u,v,w in good:
    for k in range(1, 30):
        DSUs[k].union(u, n)
        DSUs[k].union(v, n)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k"
"import sys

input = sys.stdin.readline

def bit(w, b):
    if w & (1 << b):
        return 1
    return 0


class DSU:

    def __init__(self, n):
        self.n = n
        self.parent = [i for i in range(self.n)]
        self.SZ = [1 for _ in range(self.n)]

    def root(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.root(self.parent[node])
        return self.parent[node]

    def merge(self, u, v):
        u = self.root(u)
        v = self.root(v)

        if u == v:
            return

        if self.SZ[u] < self.SZ[v]:
            temp = u
            u = v
            v = temp

        self.parent[v] = u
        self.SZ[u] += self.SZ[v]


class Solver1659E:

    def __init__(self):
        self.C = 30
        self.n, self.m = list(map(int, input().split(' ')))
        self.bit_i = [DSU(self.n) for _ in range(self.C)]
        self.bit_i_0 = [DSU(self.n) for _ in range(self.C)]
        self.one_works = [[0 for _ in range(self.n)] for _ in range(self.C)]

        for i in range(self.m):
            u, v, w = list(map(int, input().split(' ')))

            u -= 1
            v -= 1

            for j in range(self.C):
                if {{completion}}:
                    self.bit_i[j].merge(u, v)

                if bit(w, j) and bit(w, 0):
                    self.bit_i_0[j].merge(u, v)

                if bit(w, 0) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.one_works[b][i] == 1:
                    self.one_works[b][self.bit_i_0[b].root(i)] = 1

        #print(self.one_works)

    def query(self):

        u, v = list(map(int, input().split(' ')))

        u -= 1
        v -= 1

        for b in range(self.C):
            if self.bit_i[b].root(u) == self.bit_i[b].root(v):
                return 0

        for b in range(1, self.C):
            if self.bit_i_0[b].root(u) == self.bit_i_0[b].root(v):
                #print(""i_0="",b)
                return 1

            if self.one_works[b][self.bit_i_0[b].root(u)]:
                #print(""one_works="",b,self.bit_i_0[b].root(u))
                return 1

        return 2


cur = Solver1659E()

q = int(input())

while q:

    q -= 1

    print(cur.query())
","bit(w, j)","bit(w, j):
                    self.bit_i[j].merge(u, v)

                if bit(w, j) and bit(w, 0):
                    self.bit_i_0[j].merge(u, v)

                if bit(w, 0) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.one_works[b][i] == 1:
                    self.one_works[b][self.bit_i_0[b].root(i)] = 1

        #print(self.one_works)

    def query(self):

        u, v = list(map(int, input().split(' ')))

        u -= 1
        v -= 1

        for b in range(self.C):"
"import sys

input = sys.stdin.readline

def bit(w, b):
    if w & (1 << b):
        return 1
    return 0


class DSU:

    def __init__(self, n):
        self.n = n
        self.parent = [i for i in range(self.n)]
        self.SZ = [1 for _ in range(self.n)]

    def root(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.root(self.parent[node])
        return self.parent[node]

    def merge(self, u, v):
        u = self.root(u)
        v = self.root(v)

        if u == v:
            return

        if self.SZ[u] < self.SZ[v]:
            temp = u
            u = v
            v = temp

        self.parent[v] = u
        self.SZ[u] += self.SZ[v]


class Solver1659E:

    def __init__(self):
        self.C = 30
        self.n, self.m = list(map(int, input().split(' ')))
        self.bit_i = [DSU(self.n) for _ in range(self.C)]
        self.bit_i_0 = [DSU(self.n) for _ in range(self.C)]
        self.one_works = [[0 for _ in range(self.n)] for _ in range(self.C)]

        for i in range(self.m):
            u, v, w = list(map(int, input().split(' ')))

            u -= 1
            v -= 1

            for j in range(self.C):
                if bit(w, j):
                    self.bit_i[j].merge(u, v)

                if {{completion}}:
                    self.bit_i_0[j].merge(u, v)

                if bit(w, 0) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.one_works[b][i] == 1:
                    self.one_works[b][self.bit_i_0[b].root(i)] = 1

        #print(self.one_works)

    def query(self):

        u, v = list(map(int, input().split(' ')))

        u -= 1
        v -= 1

        for b in range(self.C):
            if self.bit_i[b].root(u) == self.bit_i[b].root(v):
                return 0

        for b in range(1, self.C):
            if self.bit_i_0[b].root(u) == self.bit_i_0[b].root(v):
                #print(""i_0="",b)
                return 1

            if self.one_works[b][self.bit_i_0[b].root(u)]:
                #print(""one_works="",b,self.bit_i_0[b].root(u))
                return 1

        return 2


cur = Solver1659E()

q = int(input())

while q:

    q -= 1

    print(cur.query())
","bit(w, j) and bit(w, 0)","bit(w, 0) == 0:
                    self.bit_i_0[j].merge(u, v)

                if bit(w, j) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.bit_i[b].root(i) == self.bit_i[b].root(i):
                    self.bit_i[b].merge(u, v)

                if self.bit_i_0[b].root(i) == self.bit_i_0[b].root(i):
                    self.bit_i_0[b].merge(u, v)

                if self.one_works[b][i]:
                    self.one_works[b][self.bit_i_0[b].root("
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


class dsu:

    def __init__(self , n):

        self.p = [0]*(n + 1)
        self.rank = [0]*(n + 1)

        for i in range(1 , n + 1):
            self.p[i] = i

    def find(self , node):
        if(self.p[node] == node):return node

        self.p[node] = self.find(self.p[node])
        return self.p[node]

    def union(self , u , v):
        u , v = self.find(u) , self.find(v)

        if(self.rank[u] == self.rank[v]):
            self.p[v] = u
            self.rank[u] += 1

        elif(self.rank[u] > self.rank[v]):
            self.p[v] = u

        else:
            self.p[u] = v

def answer():

    zeronotset = [False for i in range(n + 1)]
    for i in range(m):
        u , v , w = edges[i]

        if(w & 1 == 0):
            zeronotset[u] = True
            zeronotset[v] = True

    d = [dsu(n) for i in range(30)]
    for i in range(30):

        for j in range(m):
            u , v , w = edges[j]

            if(w >> i & 1):
                d[i].union(u , v)


    zero = [dsu(n) for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):

            u , v , w = edges[j]

            if(w & 1 and w >> i & 1):
                zero[i].union(u , v)
                

    value = [[2 for i in range(n + 1)] for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):
            u , v , w = edges[j]

            if(zeronotset[u]):
                value[i][zero[i].find(u)] = 1

            if(zeronotset[v]):
                value[i][zero[i].find(v)] = 1

    for q in range(int(input())):

        u , v = inp()

        ans = 2
        for i in range(30):
            if(d[i].find(u) == d[i].find(v)):
                ans = 0
                break

        if(ans == 2):

            for i in range(1 , 30):
                 if{{completion}}:
                    ans = 1
                    break

        print(ans)
                
            
            
for T in range(1):

    n , m = inp()

    edges = []
    for i in range(m):
        u , v , w = inp()
        edges.append([u , v , w])
    

    answer()
",(value[i][zero[i].find(u)] == 1),"((value[i][u] + value[i][v]) == 2):
                    ans = 1
                    break

        else:
            for i in range(1 , 30):
                 if((value[i][u] + value[i][v]) == 1):
                    ans = 0
                    break

        if(ans == 1):
            for i in range(1 , 30):
                 if((value[i][u] + value[i][v]) == 0):
                    ans = 0
                    break

        else:
            for i in range(1 , 30):
                 if((value[i][u] + value[i][v]) == 2):
                    ans = 1
                    break

        if(ans == 0):
            for i in range(1 , 30):
                 if((value[i][u] + value[i][v]) == "
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


class dsu:

    def __init__(self , n):

        self.p = [0]*(n + 1)
        self.rank = [0]*(n + 1)

        for i in range(1 , n + 1):
            self.p[i] = i

    def find(self , node):
        if(self.p[node] == node):return node

        self.p[node] = self.find(self.p[node])
        return self.p[node]

    def union(self , u , v):
        u , v = self.find(u) , self.find(v)

        if(self.rank[u] == self.rank[v]):
            self.p[v] = u
            self.rank[u] += 1

        elif(self.rank[u] > self.rank[v]):
            self.p[v] = u

        else:
            self.p[u] = v

def answer():

    zeronotset = [False for i in range(n + 1)]
    for i in range(m):
        u , v , w = edges[i]

        if(w & 1 == 0):
            zeronotset[u] = True
            zeronotset[v] = True

    d = [dsu(n) for i in range(30)]
    for i in range(30):

        for j in range(m):
            u , v , w = edges[j]

            if{{completion}}:
                d[i].union(u , v)


    zero = [dsu(n) for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):

            u , v , w = edges[j]

            if(w & 1 and w >> i & 1):
                zero[i].union(u , v)
                

    value = [[2 for i in range(n + 1)] for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):
            u , v , w = edges[j]

            if(zeronotset[u]):
                value[i][zero[i].find(u)] = 1

            if(zeronotset[v]):
                value[i][zero[i].find(v)] = 1

    for q in range(int(input())):

        u , v = inp()

        ans = 2
        for i in range(30):
            if(d[i].find(u) == d[i].find(v)):
                ans = 0
                break

        if(ans == 2):

            for i in range(1 , 30):
                 if(value[i][zero[i].find(u)] == 1):
                    ans = 1
                    break

        print(ans)
                
            
            
for T in range(1):

    n , m = inp()

    edges = []
    for i in range(m):
        u , v , w = inp()
        edges.append([u , v , w])
    

    answer()
",(w >> i & 1),"((w & 1) == 0):
                d[i].union(u , v)

    zero = [dsu(n) for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):

            u , v , w = edges[j]

            if(w & 1 and w >> i & 1):
                zero[i].union(u , v)
                

    value = [[2 for i in range(n + 1)] for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):
            u , v , w = edges[j]

            if(zeronotset[u]):
                value[i][zero[i].find(u)] = 1

            if(zeronotset[v]):
                value[i][zero[i].find(v)] = 1

    for q in range(int("
