eval_prompt,ground_truth,model_output
"n,q = map(int,input().split())
graph = [set() for _ in range(n)]
start = [0xffffffff]*n
for _ in range(q):
    i,j,x = map(int,input().split())
    i -= 1; j -= 1
    graph[i].add(j)
    graph[j].add(i)
    start[i] &= x
    start[j] &= x
for i in range(n):
    if i in graph[i]:
        {{completion}}
    val = start[i]
    for j in graph[i]:
        val &= start[j]
    start[i] ^= val
print(*start)",continue,val &= start[j]
"n,q = map(int,input().split())
graph = [set() for _ in range(n)]
start = [0xffffffff]*n
for _ in range(q):
    i,j,x = map(int,input().split())
    i -= 1; j -= 1
    graph[i].add(j)
    graph[j].add(i)
    start[i] &= x
    start[j] &= x
for i in range(n):
    if i in graph[i]:
        continue
    val = start[i]
    for j in graph[i]:
        {{completion}}
    start[i] ^= val
print(*start)",val &= start[j],"val = start[i]
for j in graph[i]:
    val &= start[j]
start[i] ^= val"
"import sys

n, Q = list(map(int, sys.stdin.readline().strip().split()))
m = [0] * n
M = [2 ** 30 - 1] * n
L = [[] for i in range (0, n)]
for q in range (0, Q):
    i, j, x = list(map(int, sys.stdin.readline().strip().split()))
    i -= 1
    j -= 1
    M[i] &= x
    M[j] &= x
    L[i].append((j, x))
    L[j].append((i, x))
for i in range (0, n):
    for (j, x) in L[i]:
        if j != i:
            m[i] |= x ^ M[j]
        else:
            {{completion}}
    M[i] = m[i]
print(*m)
",m[i] = x,continue
"from sys import stdin, stdout
input, print = stdin.buffer.readline, stdout.write

n, T = [int(x) for x in input().split()]

ans = [(1<<31)-1] * n


from collections import defaultdict
R = defaultdict(list)

for _ in range(T):
    a,b, x = [int(_a) for _a in input().split()]
    a -= 1
    b -= 1
    a,b = min(a,b), max(a,b)
    ans[a] &=  x
    ans[b] &=  x
    R[a].append(b)
    R[b].append(a)



for i in range(len(ans)):
    for b in range(30,-1,-1):
        mask = 1 << b
        if mask & ans[i] == 0:
            continue
        can_remove = True
        for j in R[i]:
            if i == j or mask & ans[j] == 0:
                {{completion}}
        if can_remove:
            ans[i] ^= mask

print("" "".join(str(x)for x in ans)+""\n"")
","can_remove = False
                break",can_remove = True
"n,q = map(int, input().split())
adj = [list() for i in range(n+1)]
val = [-1]*(n+1)
for _ in range(q):
    i,j,x=map(int, input().split())
    val[i] &= x
    val[j] &= x
    adj[i].append(j)
    adj[j].append(i)
# print(*val[1:], sep="" "")
# print(*adj, sep=""\n"")

for a in range(1, n+1):
    if val[a] == -1:
        val[a] = 0
        continue
    t = val[a]
    for b in adj[a]: 
        if b == a:
            {{completion}}
        t &= val[b]
    val[a] ^= t
    # print(*val[1:], sep="" "")

print(*val[1:], sep="" "")
        


    
","t = 0
            break",t = val[a]
"n, q = map(int, input().strip().split())

qs = [[] for _ in range(n)]
refers_self = [False for _ in range(n)]
for _ in range(q):
    i, j, x = map(int, input().strip().split())
    if i==j:
        refers_self[i-1] = True
    qs[i-1].append((j-1, x))
    qs[j-1].append((i-1, x))

a = []
for i in range(n):
    if qs[i]:
        ans = (2<<32) - 1
        for j, x in qs[i]:
            {{completion}}
        a.append(ans)
    else:
        a.append(0)


for i in range(n):
    if refers_self[i]:
        continue
    ans = (2<<32) - 1
    for j, x in qs[i]:
        ans = ans & a[j]

    a[i] = a[i] - (a[i]&ans)

print(*a)
",ans = ans & x,ans = ans & a[j]
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def update(i , t):

    global ans

    if(i + 1 < n and a[i] == a[i + 1]):
        ans += t * (i + 1)
    else:
        ans += t * (n - i) * (i + 1)

    return ans

def answer():

    global ans

    ans = 0
    for i in range(n):

        update(i , 1)


    for q in range(m):
        i , x = inp()
        i -= 1

        if(i >= 0):{{completion}}
        update(i , -1)

        a[i] = x
        if(i >= 0):update(i - 1 , 1)
        update(i , 1)

        print(ans)

        
for T in range(1):

    n , m = inp()
    a = inp()
    
    answer()
","update(i - 1 , -1)","update(i - 1, 1)"
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def update(i , t):

    global ans

    if(i + 1 < n and a[i] == a[i + 1]):
        ans += t * (i + 1)
    else:
        ans += t * (n - i) * (i + 1)

    return ans

def answer():

    global ans

    ans = 0
    for i in range(n):

        update(i , 1)


    for q in range(m):
        i , x = inp()
        i -= 1

        if(i >= 0):update(i - 1 , -1)
        update(i , -1)

        a[i] = x
        if(i >= 0):{{completion}}
        update(i , 1)

        print(ans)

        
for T in range(1):

    n , m = inp()
    a = inp()
    
    answer()
","update(i - 1 , 1)","update(i - 1, 1)"
"import sys
input = sys.stdin.readline 

n, m = map(int, input().split())
a = list(map(int, input().split()))
a.insert(0, 0)
a.append(0)
ans = 0 
for i in range(1, n + 1):
    {{completion}} 
    
while(m):
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    m -= 1
",ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i,"this is the start of the ground truth
i, x = map(int, input().split())
    ans -= (a[i]!= a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i]!= a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i]!= a[i - 1]) * (n - i + 1) * (i -"
"import sys
input = sys.stdin.readline 

n, m = map(int, input().split())
a = list(map(int, input().split()))
a.insert(0, 0)
a.append(0)
ans = 0 
for i in range(1, n + 1):
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    
while(m):
    {{completion}}
","i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    m -= 1",ans += (a[i]!= a[i + 1]) * (n - (i + 1) + 1) * i
"import time, sys

n, m = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]
t1 = time.time()
w = [(i+1)*(n-i-1) for i in range(n-1)]
c = sum([w[i] if a[i+1] != a[i] else 0 for i in range(n-1)])
for _ in range(m):
    ix, x = [int(i) for i in sys.stdin.readline().split()]
    ix -= 1
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += w[ix-1]
        elif a[ix] != a[ix-1] == x:
            {{completion}}
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif a[ix] != a[ix+1] == x:
            c -= w[ix]
    a[ix] = x

    sys.stdout.write(str(c+(n*(n+1))//2) + '\n')",c -= w[ix-1],c -= w[ix]
"import time, sys

n, m = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]
t1 = time.time()
w = [(i+1)*(n-i-1) for i in range(n-1)]
c = sum([w[i] if a[i+1] != a[i] else 0 for i in range(n-1)])
for _ in range(m):
    ix, x = [int(i) for i in sys.stdin.readline().split()]
    ix -= 1
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += w[ix-1]
        elif a[ix] != a[ix-1] == x:
            c -= w[ix-1]
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif a[ix] != a[ix+1] == x:
            {{completion}}
    a[ix] = x

    sys.stdout.write(str(c+(n*(n+1))//2) + '\n')",c -= w[ix],c -= w[ix]
"import sys
import collections
inf=float('inf')
mod=10**5+7
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())
# for case in range(inpint()):
n,m=inpnm()
arr=inparr()
res=[1]
cnt=0
se=1
t=1
for i in range(1,n):
    if arr[i]==arr[i-1]:
        cnt+=1
        res.append(res[-1]+1)
    else:
 
        {{completion}}
 
ans=sum(res)
for q in range(m):
 
    i,x=inpnm()
    i-=1
    if i!=0 and arr[i-1]!=arr[i]:
        ans-=i*(n-i)
    if i!=n-1 and arr[i+1]!=arr[i]:
        ans-=(i+1)*(n-i-1)
 
    arr[i]=x
 
    if i!=0 and arr[i-1]!=x:
        ans+=i*(n-i)
 
    if i!=n-1 and arr[i+1]!=x:
        ans+=(i+1)*(n-i-1)
    print(ans)","se+=1
        t=res[-1]
        res.append(res[-1]+se+cnt)","ans-=i*(n-i)
    ans+=(i+1)*(n-i-1)"
"def update_awesomeness(arr, i, x, curr_aws):
    {{completion}}


INPUT = [*open(0)]

n, m = map(int, INPUT[0].split())
arr = list(map(int, INPUT[1].split()))
tar = [0] * n
aws = (n * (n + 1)) // 2

for i, x in enumerate(arr):
    aws = update_awesomeness(tar, i, x, aws)

for line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i - 1, x, aws)
    print(aws)","left_edit = (x != arr[i - 1]) - (arr[i] != arr[i - 1]) if i != 0 else 0
    right_edit = (x != arr[i + 1]) - (arr[i] != arr[i + 1]) if i != n - 1 else 0
    arr[i] = x
    return curr_aws + left_edit * i * (n - i) + right_edit * (i + 1) * (n - i - 1)","aws = update_awesomeness(tar, i, x, aws)"
"def update_awesomeness(arr, i, x, curr_aws):
    left_edit = (x != arr[i - 1]) - (arr[i] != arr[i - 1]) if i != 0 else 0
    right_edit = (x != arr[i + 1]) - (arr[i] != arr[i + 1]) if i != n - 1 else 0
    arr[i] = x
    return curr_aws + left_edit * i * (n - i) + right_edit * (i + 1) * (n - i - 1)


INPUT = [*open(0)]

n, m = map(int, INPUT[0].split())
arr = list(map(int, INPUT[1].split()))
tar = [0] * n
aws = (n * (n + 1)) // 2

for i, x in enumerate(arr):
    {{completion}}

for line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i - 1, x, aws)
    print(aws)","aws = update_awesomeness(tar, i, x, aws)","this is the start of the ground truth
left_edit = (x!= arr[i - 1]) - (arr[i]!= arr[i - 1]) if i!= 0 else 0
    right_edit = (x!= arr[i + 1]) - (arr[i]!= arr[i + 1]) if i!= n - 1 else 0
    arr[i] = x
    return curr_aws + left_edit * i * (n - i) + right_edit * (i + 1) * (n"
"""""""
author: Manoj
inp_start
5 5
1 2 3 4 5
3 2
4 2
3 1
2 1
2 2

inp_end
""""""
n, m = list(map(int, input().split()))
li = list(map(int, input().split()))
ans = int((n*(n+1))/2)

for i in range(1, n):
	if li[i]!=li[i-1]:
		ans += i*(n-i) 

al = []
for tc in range(m):
	i, x = list(map(int, input().split()))
	i -= 1
	if i>0:
		if li[i]!=li[i-1]:
			{{completion}}
		if x!=li[i-1]:
			ans+=i*(n-i)
	if i+1<n:
		if li[i]!=li[i+1]:
			ans-=(i+1)*(n-i-1)
		if x!=li[i+1]:
			ans+=(i+1)*(n-i-1)
			
	li[i]=x
	al.append(ans)
	
print(*al)
	
	",ans-=i*(n-i),ans+=i*(n-i)
"""""""
author: Manoj
inp_start
5 5
1 2 3 4 5
3 2
4 2
3 1
2 1
2 2

inp_end
""""""
n, m = list(map(int, input().split()))
li = list(map(int, input().split()))
ans = int((n*(n+1))/2)

for i in range(1, n):
	if li[i]!=li[i-1]:
		ans += i*(n-i) 

al = []
for tc in range(m):
	i, x = list(map(int, input().split()))
	i -= 1
	if i>0:
		if li[i]!=li[i-1]:
			ans-=i*(n-i)
		if x!=li[i-1]:
			{{completion}}
	if i+1<n:
		if li[i]!=li[i+1]:
			ans-=(i+1)*(n-i-1)
		if x!=li[i+1]:
			ans+=(i+1)*(n-i-1)
			
	li[i]=x
	al.append(ans)
	
print(*al)
	
	",ans+=i*(n-i),ans+=i*(n-i)
"import sys
input=lambda:sys.stdin.readline().rstrip()
n,q=map(int,input().split())
arr=[0]+[*map(int,input().split())]+[0]
awe=0
awr=[0]*(n+1)
for i in range(1,n+1):
    if arr[i]!=arr[i-1]:
        awr[i]+=awr[i-1]+(i-1)
    else:
        {{completion}}
    awr[i]+=1
awe=sum(awr)
for _ in range(q):
    i,x=map(int,input().split())
    lprev=arr[i]!=arr[i-1]
    rprev=arr[i]!=arr[i+1]
    arr[i]=x
    laftr=arr[i]!=arr[i-1]
    raftr=arr[i]!=arr[i+1]
    dl=laftr-lprev
    dr=raftr-rprev
    awe+=dl*(i-1)*(n-i+1)
    awe+=dr*(i)*(n-i)
    print(awe)",awr[i]+=awr[i-1],awr[i]+=1
"



import sys
input=sys.stdin.readline #文字列入力はするな！！



########################################
from heapq import heappush, heappop
B=10**5+10
def dijkstra( G, dist, INF=10**11):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    G[v] = [(nod, cost)]:
        頂点vから遷移可能な頂点(nod)とそのコスト(cost)
    s: 始点の頂点""""""

    N=len(dist)
    hp=[]
    for i in range(N):
        heappush(hp,dist[i]*B+i)
    while hp:
        cv=heappop(hp)
        c, v = cv//B,cv%B
        if dist[v] < c:
            continue
        for u, cost in G[v]:
            if dist[v] + cost < dist[u]:
                {{completion}}
    return dist
##################################################




#########################################
from collections import deque
class Convex_Hull_Trick():

    #https://tjkendev.github.io/procon-library/python/convex_hull_trick/deque.html
    #追加する傾きが単調かつqueryのxが単調
    #単調性なしが良いならこちらへ(queryのxは先読み) https://judge.yosupo.jp/submission/30579

    def __init__(self):
        self.deq=deque()
    def check(self,f1, f2, f3):
        return (f2[0] - f1[0]) * (f3[1] - f2[1]) >= (f2[1] - f1[1]) * (f3[0] - f2[0])
    def f(self,f1, x):
        return f1[0] * x + f1[1]

    # add f_i(x) = a*x + b
    def add_line(self,a, b):
        f1 = (a, b)
        while len(self.deq) >= 2 and self.check(self.deq[-2], self.deq[-1], f1):
            self.deq.pop()
        self.deq.append(f1)

    # min f_i(x)
    def query(self,x):
        while len(self.deq) >= 2 and self.f(self.deq[0], x) >= self.f(self.deq[1], x):
            self.deq.popleft()
        return self.f(self.deq[0], x)

##################################


n,m,k=map(int,input().split())
root=[[] for i in range(n+2)]
for i in range(m):
    a,b,c=map(int,input().split())
    root[a].append((b,c))
    root[b].append((a,c))
dp=[10**11]*(n+1)
dp[1]=0
dp=dijkstra(root,dp)
for iii in range(k):
    newdp=[10**11]*(n+1)
    cht=Convex_Hull_Trick()
    for i in range(1,n+1):
        cht.add_line(-2*i,dp[i]+i**2)
    for i in range(1,n+1):
        newdp[i]=cht.query(i)+i**2


    dp=newdp[:]
    dp=dijkstra(root,dp)
print(*dp[1:])




","dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)","while len(self.deq) >= 2 and self.check(self.deq[-2], self.deq[-1], f1):
    self.deq.pop()"
"



import sys
input=sys.stdin.readline #文字列入力はするな！！



########################################
from heapq import heappush, heappop
B=10**5+10
def dijkstra( G, dist, INF=10**11):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    G[v] = [(nod, cost)]:
        頂点vから遷移可能な頂点(nod)とそのコスト(cost)
    s: 始点の頂点""""""

    N=len(dist)
    hp=[]
    for i in range(N):
        heappush(hp,dist[i]*B+i)
    while hp:
        cv=heappop(hp)
        c, v = cv//B,cv%B
        if dist[v] < c:
            {{completion}}
        for u, cost in G[v]:
            if dist[v] + cost < dist[u]:
                dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)
    return dist
##################################################




#########################################
from collections import deque
class Convex_Hull_Trick():

    #https://tjkendev.github.io/procon-library/python/convex_hull_trick/deque.html
    #追加する傾きが単調かつqueryのxが単調
    #単調性なしが良いならこちらへ(queryのxは先読み) https://judge.yosupo.jp/submission/30579

    def __init__(self):
        self.deq=deque()
    def check(self,f1, f2, f3):
        return (f2[0] - f1[0]) * (f3[1] - f2[1]) >= (f2[1] - f1[1]) * (f3[0] - f2[0])
    def f(self,f1, x):
        return f1[0] * x + f1[1]

    # add f_i(x) = a*x + b
    def add_line(self,a, b):
        f1 = (a, b)
        while len(self.deq) >= 2 and self.check(self.deq[-2], self.deq[-1], f1):
            self.deq.pop()
        self.deq.append(f1)

    # min f_i(x)
    def query(self,x):
        while len(self.deq) >= 2 and self.f(self.deq[0], x) >= self.f(self.deq[1], x):
            self.deq.popleft()
        return self.f(self.deq[0], x)

##################################


n,m,k=map(int,input().split())
root=[[] for i in range(n+2)]
for i in range(m):
    a,b,c=map(int,input().split())
    root[a].append((b,c))
    root[b].append((a,c))
dp=[10**11]*(n+1)
dp[1]=0
dp=dijkstra(root,dp)
for iii in range(k):
    newdp=[10**11]*(n+1)
    cht=Convex_Hull_Trick()
    for i in range(1,n+1):
        cht.add_line(-2*i,dp[i]+i**2)
    for i in range(1,n+1):
        newdp[i]=cht.query(i)+i**2


    dp=newdp[:]
    dp=dijkstra(root,dp)
print(*dp[1:])




",continue,"dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)"
"n,k=map(int,input().split())
l=list(map(int,input().split()))

ans=-2
b=l.count(0)

for y in range(n):
	a=l[y:]+l[:y]
	ind=[]
	s=0
	
	for i in range(n):
		if a[i]==0:
			{{completion}}
		s+=a[i]
	
	while s>0 and len(ind)>0:
		a[ind[-1]]=max(k-s,-k)
		s+=(-k+a[ind[-1]])
		ind=ind[:-1]
	
	s=0
	f=0
	for i in range(n):
		s+=a[i]
		f=max(f,s)
	
	if sum(a)==0:
		ans=max(ans,f)
	

print(ans+1)
","ind+=[i]
			a[i]=k",ind=[]
"R=lambda:map(int,input().split())
n,k=R();n+=1
a=[0]+[*R()]

p0,p=[0]*n,[0]*n
for i in range(1,n):
  p0[i]=p0[i-1]+int(a[i]==0)
  p[i]=p[i-1]+a[i]
s=p[-1]

if p0[-1]*k<abs(s):
  res=-1
else:
  res=0
  for i in range(n):
    for j in range(i+1,n):
      {{completion}}
print(res)","l0=p0[j]-p0[i];r0=p0[-1]-l0
      l,r=max(-l0*k, -s-r0*k),min(l0*k, -s+r0*k)
      v=p[j]-p[i]
      res=max(res, 1+abs(v+l), 1+abs(v+r))",p[i]-=a[i]
"import sys
input = sys.stdin.readline

def ProGamerMove():
	n, k = map(int, input().split())
	a = list(map(int, input().split()))
	zeros = a.count(0)
	sm = sum(a)
	s1, s2 = 0, 0
	c1, c2 = 0, 0
	res = -2
	def intersect(m1, b1, m2, b2):
		l1, r1 = m1 - b1 * k, m1 + b1 * k
		l2, r2 = m2 - b2 * k, m2 + b2 * k
		return not (r1 < l2 or r2 < l1)
	for l in range(0, n + 1):
		s2, c2 = 0, 0
		for r in range(0, n + 1):
			if l <= r:
				b1, b2, b3 = c1, c2 - c1, zeros - c2
				m1, m2, m3 = s1, s2 - s1, sm - s2
				# b1 + b3 == -b2
				# min b1, b3
				if not intersect(m1 + m3, b1 + b3, -m2, b2): {{completion}}
				r1 = max(m1 + m3 - (b1 + b3) * k, -m2 - b2 * k)
				r2 = min(m1 + m3 + (b1 + b3) * k, -m2 + b2 * k)
				res = max(res, abs(r1), abs(r2))
			if r < n:
				s2 += a[r]
				c2 += a[r] == 0
		if l < n:
			s1 += a[l]
			c1 += a[l] == 0
	print(res + 1)

n = 1
#n = int(input())
for _ in range(0, n): ProGamerMove()
",continue,"r1 = max(m1 + m3 - (b1 + b3) * k, -m2 - b2 * k)
				r2 = min(m1 + m3 + (b1 + b3) * k, -m2 + b2 * k)
				res = max(res, abs(r1), abs(r2))"
"n, k = map(int, input().split())
A = list(map(int, input().split()))

ans = 0
for i in range(n):
    C = [0]*n
    for j in range(n-1, -1, -1):
        if A[j] == 0:
            C[j] = 1
        if j+1 < n:
            C[j] += C[j+1]
    B = A.copy()
    s = sum(B)
    flag = True
    for j in range(n):
        if B[j] == 0:
            if j+1 < n:
                x = C[j+1]
            else:
                {{completion}}
            B[j] = min(k, x*k-s)
            if B[j] < -k:
                flag = False
            s += B[j]
    if flag:
        pos = 0
        mn = 0
        mx = 0
        for j in range(n):
            pos += B[j]
            mn = min(mn, pos)
            mx = max(mx, pos)
        if pos == 0:
            ans = max(ans, mx-mn+1)
    A = A[1:]+A[0:1]

if ans != 0:
    print(ans)
else:
    print(-1)
",x = 0,"x=min(k, x*k-s)
            B[j] = min(k, x*k-s)"
"MOD = 998244353
TRANS = [6, 3, 7, 4, 1, 0]
 
s = input().strip()
dp = [0] * 7 + [1]
for c in map(int, s):
    dp1 = [0] * 8
    for i in range(8):
        for k in TRANS:
            if c:
                dp1[k & i] += dp[i]
            elif (k & i) == 0:
                {{completion}}
    dp = [x % MOD for x in dp1]
n = int(s, base=2) + 1
print((n**3 + 3 * n**2 - n - 3 * sum(dp)) % MOD)",dp1[i] += dp[i],dp1[k&i]+=dp[i]
"MOD=998244353
TRANS=[6,3,7,4,1,0]
s=input().strip()
dp=[0]*7+[1]
for c in map(int,s):
    dp1=[0]*8
    for i in range(8):
        for k in TRANS:
            if c:
                dp1[k&i]+=dp[i]
            elif(k&i)==0:
                {{completion}}
    dp=[x%MOD for x in dp1]
n=int(s,base=2)+1
print((n**3+3*n**2-n-3*sum(dp))%MOD)",dp1[i]+=dp[i],dp1[i]+=dp[i]
"I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if zero and p>0:{{completion}}
    if p==0:zero=True
    if p<0:z=0;break
  print(['NO','YES'][zero and z])",z=0;break,zero=True
"I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if zero and p>0:z=0;break
    if p==0:{{completion}}
    if p<0:z=0;break
  print(['NO','YES'][zero and z])",zero=True,if p==0:zero=True
"import sys
input = lambda : sys.stdin.readline().rstrip()

dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]


def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    if sum(arr)!=0:
        return 0

    psum = 0
    f = 0
    
    for i in range(len(arr)):
        psum += arr[i]
        if psum < 0:
            return 0
        if psum==0:
            f = 1
        elif f:
            {{completion}}
        
    return 1


for __ in range(int(input())):
    print('Yes' if solve() else 'No')",return 0,"if psum < 0:
    return 0
if psum==0:
    f = 1
elif f:
    return 1"
"for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    tot = a[0]

    for i in range(1, n):
        if tot < 0:
            break
        elif tot == 0:
            if a[i] != 0:
                {{completion}}
        else:
            tot += a[i]
    else:
        if tot == 0:
            print(""Yes"")
            continue

    print(""No"")
",break,"print(""Yes"")"
"from sys import stdin

t = int(stdin.readline())
for h in range(t):
    n = int(stdin.readline())
    a = list(map(int,stdin.readline().split(' ')))
    b = 0
    v = True
    for i in range(n):
        b += a[i]
        if b<0:
            v = False
            break
        elif b==0:
            for j in range(i+1,n):
                if a[j] != 0:
                    {{completion}}
            break
    if v and sum(a) == 0:
        print('YES')
    else:
        print('NO')","v = False
                    break","if a[i]==0:
    for j in range(i+1,n):
        if a[j]!=0:
            print(""NO"")
            break
    else:
        print(""YES"")"
"for _ in [0]*int(input()):
    input()
    n = list(map(int,input().split()))
    s,f,m = 0,0,0
    for i in n:
        s+=i
        if s<0:{{completion}}
        if s==0:f=1
        if f and s>0:m=1;break
    print(""YNEOS""[(m or not f)::2])",m = 1;break,f=1
"for _ in [0]*int(input()):
    input()
    n = list(map(int,input().split()))
    s,f,m = 0,0,0
    for i in n:
        s+=i
        if s<0:m = 1;break
        if s==0:{{completion}}
        if f and s>0:m=1;break
    print(""YNEOS""[(m or not f)::2])",f=1,if s==0:f=1
"if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        n = int(input())
        a = [int(i) for i in input().split()]

        x = a[0]

        ok = True
        for v in a[1:]:
            if x < 0:
                {{completion}}
            if x == 0 and v != 0:
                ok = False
                break
            x += v

        print(""yes"" if ok and x == 0 else ""no"")
","ok = False
                break","ok = False
                break"
"if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        n = int(input())
        a = [int(i) for i in input().split()]

        x = a[0]

        ok = True
        for v in a[1:]:
            if x < 0:
                ok = False
                break
            if x == 0 and v != 0:
                {{completion}}
            x += v

        print(""yes"" if ok and x == 0 else ""no"")
","ok = False
                break","ok = False
                break"
"input = __import__('sys').stdin.readline


def solve():
    n = int(input())
    allzeros = False
    total = 0
    for x in map(int, input().split()):
        total += x
        if total < 0 or total != 0 and allzeros:
            {{completion}}
        allzeros = allzeros or total == 0

    print('YES' if total == 0 else 'NO')


for _ in range(int(input())):
    solve()","print('No')
            return",allzeros = False
"import sys
input=sys.stdin.readline
I = lambda : list(map(int,input().split()))

t,=I()
for _ in range(t):
	n, = I()
	l = I()
	pos = 0
	if sum(l)!=0 or l[-1]>0:
		pos=1
	else:
		pref = l[0]
		seen = 0
		if pref<0:
			pos=1
		if pref==0:
			seen = 1
		for i in range(1,n):
			pref+=l[i]
			if pref<0:
				pos=1
				break
			elif pref==0:
				seen = 1
			else:
				if seen:
					{{completion}}
	print(""YNeos""[pos::2])","pos=1
					break",pos=1
"for t in range(int(input())):
    
    n=int(input())
    a=list(map(int,input().split()))
    i=n-1
    while(a[i]==0 and i!=0):
        i-=1 
    while(i>0):
        if a[i]>=0:
            print(""NO"")
            break
        a[i-1]+=a[i]
        i-=1
    else:
        if a[i]==0:
            print(""YES"")
        else:
            {{completion}}
","print(""NO"")","print(""YES"")"
"for i in range(int(input())):
    n=int(input())
    c=[int(j) for j in input().split()]
    k=1
    if [0]*n==c:
        print('Yes')
    else:
        g=0
        while c[-1]==0:
            c.pop()
        while len(c)-1:
            if g<=c[-1]:
                {{completion}}
            g=g-c.pop()
        print(['No','Yes'][g==c[0] and k])","k=0
                break","this is the start of the ground truth
if g<=c[-1]:
    k=1
    g=g-c.pop()
    while c[-1]==0:
        c.pop()
    while len(c)-1:
        if g<=c[-1]:
            k=1
            g=g-c.pop()
        else:
            g=g-c.pop()
    print(['No','Yes'][g==c[0] and k])

this is the end of the"
"import heapq as hq
INF = 1001001001
N, M = map(int, input().split())
G = [[] for _ in range(N)]
d = [0] * N
for _ in range(M):
    U, V = map(int, input().split())
    G[V - 1].append(U - 1)
    d[U - 1] += 1

dists = [INF] * N
dists[N - 1] = 0
queue = [(0, N - 1)]
while queue:
    dist, V = hq.heappop(queue)
    if dists[V] < dist: continue
    for v in G[V]:
        if dist + d[v] < dists[v]:
            {{completion}}
        d[v] -= 1
print(dists[0])","dists[v] = dist + d[v]
            hq.heappush(queue, (dist + d[v], v))","dists[v]=dist+d[v]
            hq.heappush(queue,(dist+d[v],v))"
"from heapq import*;I=input;R=lambda:map(int,I().split())
n,m=R();g,q,vis=[[] for _ in range(n)],[(0,n-1)],[0]*n
d,out=[m+1]*n,[0]*n;d[-1]=0
for _ in range(m):u,v=R();u,v=u-1,v-1;g[v].append(u);out[u]+=1
while q:
  _,u=heappop(q)
  if vis[u]:continue
  vis[u]=1
  for v in g[u]:
    if d[u]+out[v]<d[v]:{{completion}}
    out[v]-=1
print(d[0])","d[v]=d[u]+out[v];heappush(q,(d[v],v))","d[v]=d[u]+out[v]
            heappush(q,(d[v],v))"
"


import sys
input=sys.stdin.readline #文字列入力はするな！！
from heapq import *

n,m=map(int,input().split())
root=[[] for i in range(n+2)]
rootinv=[[] for i in range(n+2)]
no=[0]*(n+2)
for i in range(m):
    u,v=map(int,input().split())
    root[u].append(v)
    rootinv[v].append(u)
    no[u]+=1
dp=[10**18]*(n+3)
dp[n]=0
hp=[(0,n)]
while hp:
    c,x=heappop(hp)
    if dp[x]<c:continue
    for y in rootinv[x]:
        no[y]-=1
        cost=no[y]+1
        if dp[y]>dp[x]+cost:
            {{completion}}
print(dp[1])



","dp[y]=dp[x]+cost
            heappush(hp,(dp[y],y))","dp[y]=min(dp[y],dp[x]+cost)
            heappush(hp,(dp[y],y))"
"import sys, heapq
input=sys.stdin.readline

n,m=map(int,input().split())
iadj=[{} for _ in range(n)]  # inverted road
nadj=[0]*n
dist=[n+1]*n
cost=[float(""inf"")]*n
visit=[0]*n

for _ in range(m):
    v,u=map(int,input().split())
    v-=1
    u-=1
    pi=iadj[u].setdefault(v,0)
    iadj[u][v]=1+pi  # road from v->u
    nadj[v]+=1

q = [(0,n-1)]
cost[n-1]=0
while q:
    d,v=heapq.heappop(q)
    if visit[v]:
        continue
    visit[v]=1
    for u in iadj[v]:
        nadj[u]-=iadj[v][u]
        if cost[v] + nadj[u] + 1 < cost[u]:
            {{completion}}

print(cost[0])","cost[u]=cost[v]+nadj[u] + 1
            heapq.heappush(q, (cost[u], u))","cost[u]=min(cost[u],cost[v]+nadj[u])
            heapq.heappush(q,(cost[u],u))"
"input = __import__('sys').stdin.readline


n = int(input())
a = list(map(int, input().split())) + [n+1]


ans = 0
cache = {}
for i in range(n):
    u = 0
    d = n+1
    
    keys = []
    j = i
    while j+1 <= n:
        key = (j, u, d)
        v = cache.get(key, -1)
        if v != -1:
            j = v
            break
        
        keys.append(key)
        # greedy
        if u < a[j] < d: # if can insert to both
            if a[j] < a[j+1]:
                u = max(u, a[j])
            elif a[j] > a[j+1]:
                {{completion}}
        elif u < a[j]: # if only can insert to increasing subsequence
            u = a[j]
        elif d > a[j]: # if only can insert to decreasing subsequence
            d = a[j]
        else:
            break

        j += 1
    
    for key in keys:
        cache[key] = j

    ans += j - i
    # print(f'at {i} max {j} ans {ans}', u, d)

# print(f'count={len(cache)}')
print(ans)
","d = min(d, a[j])","d = min(d, a[j])"
"input = __import__('sys').stdin.readline


n = int(input())
a = list(map(int, input().split())) + [n+1]

cache = {}
def check(i, u, d):
    keys = []
    j = i
    while j+1 <= n:
        key = (j, u, d)
        v = cache.get(key, -1)
        if v != -1:
            j = v
            break
        
        keys.append(key)
        if u < a[j] < d: # if can insert to both
            if a[j] < a[j+1]:
                u = max(u, a[j])
            elif a[j] > a[j+1]:
                {{completion}}
        elif u < a[j]: # if only can insert to increasing subsequence
            u = a[j]
        elif d > a[j]: # if only can insert to decreasing subsequence
            d = a[j]
        else:
            break

        j += 1
    
    for key in keys:
        cache[key] = j
    
    return j

ans = 0
for i in range(n):
    u = 0
    d = n+1
    j = check(i, u, d)
    ans += j - i
    # print(f'at {i} max {j} ans {ans}', u, d)

# print(f'count={count}')
print(ans)
","d = min(d, a[j])","d = min(d, a[j])"
"#from niumeng

from itertools import accumulate
I=input;R=lambda:map(int,I().split())
n,q=R();a=sorted(R())[::-1];p=[0]+list(accumulate(a))
for _ in range(q):
  {{completion}}
","x,y=R();print(p[x]-p[x-y])","x,y=R();print(p[x]-p[x-y])"
"n, q = [int(x) for x in input().split()]
prices = [int(price) for price in input().split("" "")]
prices.sort(reverse=True)
for i in range(1, len(prices)):
    {{completion}}
 
while q:
    # 5 5 3 2 1
    # 5 10 13 15 16
    x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1",prices[i] += prices[i-1],"x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1"
"n, q = [int(x) for x in input().split()]
prices = [int(price) for price in input().split("" "")]
prices.sort(reverse=True)
for i in range(1, len(prices)):
    prices[i] += prices[i-1]
 
while q:
    # 5 5 3 2 1
    # 5 10 13 15 16
    {{completion}}","x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1","































































































































"
"n,q=map(int,input().split())
a=[0]
for x in sorted(map(int,input().split()))[::-1]:{{completion}}
for _ in[0]*q:x,y=map(int,input().split());print(a[x]-a[x-y])
","a+=a[-1]+x,","x,y=map(int,input().split());print(a[x]-a[x-y])"
"n,q=map(int,input().split())
a=[0]
for x in sorted(map(int,input().split()))[::-1]:a+=a[-1]+x,
for _ in[0]*q:{{completion}}
","x,y=map(int,input().split());print(a[x]-a[x-y])","x,y=map(int,input().split());print(a[x]-a[x-y])"
"f=open(0)
R=lambda:map(int,next(f).split())
n,q=R();p=[0]
for w in sorted(R()): {{completion}}
for _ in "" ""*q: x, y=R();print(p[n-x+y]-p[n-x])
","p+=p[-1]+w,","x, y=R();print(p[n-x+y]-p[n-x])"
"f=open(0)
R=lambda:map(int,next(f).split())
n,q=R();p=[0]
for w in sorted(R()): p+=p[-1]+w,
for _ in "" ""*q: {{completion}}
","x, y=R();print(p[n-x+y]-p[n-x])","x,y=R();print(p[n-x+y]-p[n-x])"
"from sys import stdin
# t = int(stdin.readline().rstrip())
# while t>0:
    
#     t-=1
n,q = map(int,stdin.readline().split())
l = list(map(int,stdin.readline().split()))
l.sort()
for i in range(1,n):
    l[i] += l[i-1]
# print(l)
for i in range(q):
    x,y = map(int,stdin.readline().split())
    actual = n-x+y-1
    val = l[actual]
    if n-x > 0:
        {{completion}}
    print(val)
    ",val -= l[n-x-1],print(val)
"Y=lambda:map(int,input().split())
O=[];n,q=Y();p=sorted(Y())[::-1];s=[0]
for i in p:{{completion}}
for _ in[0]*q:x,y=Y();O+=[str(s[x]-s[x-y])]
print('\n'.join(O))",s+=[s[-1]+i],"x,y=Y();O+=[str(s[x]-s[x-y])]"
"Y=lambda:map(int,input().split())
O=[];n,q=Y();p=sorted(Y())[::-1];s=[0]
for i in p:s+=[s[-1]+i]
for _ in[0]*q:{{completion}}
print('\n'.join(O))","x,y=Y();O+=[str(s[x]-s[x-y])]","x,y=Y();print(s[x]-s[x-y])"
"arr=[int(i) for i in input().split()]
ans=[]
prices=[int(i) for i in input().split()]
prices.sort(reverse=True)
for i in range(1,arr[0]):
    prices[i]=prices[i]+prices[i-1]
    
for i in range(arr[1]):
    xy=[int(i) for i in input().split()]
    if(xy[0]==xy[1]):
        ans.append(prices[xy[0]-1])
    else:
        {{completion}}
for ele in ans:
    print(ele)",ans.append(prices[xy[0]-1]-prices[xy[0]-xy[1]-1]),"x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1"
"import sys

n, p = map(int, sys.stdin.readline().split())
l = map(int, sys.stdin.readline().split())
l = sorted(l, reverse=True)

for i in range(n-1, 0, -1):
    l[i-1] += l[i]

for _ in range(p):
    xi, yi = map(int, sys.stdin.readline().split())
    a = n-xi
    b = a+yi

    if a == 0:
        print(l[-b])
    else:
        {{completion}}
",print(l[-b]-l[-a]),print(l[a-1])
"## cf does not have numpy so with lists
r=open(0)
g=lambda:map(int,next(r).split())
n,q=g()
a=[0]
for x in sorted(g())[::-1]:{{completion}}
for b in[0]*q:x,y=g();print(a[x]-a[x-y])


","a+=a[-1]+x,","x,y=g();print(a[x]-a[x-y])"
"## cf does not have numpy so with lists
r=open(0)
g=lambda:map(int,next(r).split())
n,q=g()
a=[0]
for x in sorted(g())[::-1]:a+=a[-1]+x,
for b in[0]*q:{{completion}}


","x,y=g();print(a[x]-a[x-y])","x, y=g();print(a[n-x+y]-a[n-x])"
"(n, q) = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort(reverse=True)
for i in range (1,n):
   arr[i] = arr[i] + arr[i-1]
for trial in range(q):
    (x, y) = map(int, input().split())
    if (x==y):
        print (arr[x-1])
    else:
        {{completion}}",print (arr[x-1] - arr[x-y-1]),print (arr[x-1]-arr[x-1-y])
"from collections import deque

def solve():
    n = int(input())
    MOD = 998244353
    arr = [list(map(int, input().split())) for i in range(n)]
    dis = [[10**9]*n for i in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                dis[i][j] = abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1])
    g = [[] for i in range(n)]
    adj = [[0]*n for i in range(n)]
    for i in range(n):
        m = min(dis[i])
        for j in range(n):
            if dis[i][j] == m:
                g[i].append(j)
                adj[i][j] = 1

    gr = []
    for i in range(n):
        cur = []
        queue = deque()
        queue.append(i)
        v = [0] * n
        v[i] = 1
        while queue:
            x = queue.popleft()
            cur.append(x)
            for y in g[x]:
                if v[y] == 0:
                    {{completion}}
        ok = 1
        for x in cur:
            for y in cur:
                if x != y and adj[x][y] == 0:
                    ok = 0
                    break
        if ok:
            if min(cur) == i:
                gr.append(len(cur))
        else:
            gr.append(1)
    dp = [0]*(n+1)
    dp[0] = 1
    for a in gr:
        dp1 = [0]*(n+1)
        for i in range(n):
            dp1[i+1] = (dp1[i+1]+dp[i])%MOD
            if a > 1 and i+a <= n:
                dp1[i+a] = (dp1[i+a]+dp[i])%MOD
        dp = dp1
    ans = 0
    k = n
    for i in range(1, n+1):
        ans = (ans+dp[i]*k)%MOD
        k = k*(n-i)%MOD
    return ans


import sys
input = lambda: sys.stdin.readline().rstrip()
print(solve())
","v[y] = 1
                    queue.append(y)",flag=0
"from collections import deque

def solve():
    n = int(input())
    MOD = 998244353
    arr = [list(map(int, input().split())) for i in range(n)]
    dis = [[10**9]*n for i in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                dis[i][j] = abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1])
    g = [[] for i in range(n)]
    adj = [[0]*n for i in range(n)]
    for i in range(n):
        m = min(dis[i])
        for j in range(n):
            if dis[i][j] == m:
                g[i].append(j)
                adj[i][j] = 1

    gr = []
    for i in range(n):
        cur = []
        queue = deque()
        queue.append(i)
        v = [0] * n
        v[i] = 1
        while queue:
            x = queue.popleft()
            cur.append(x)
            for y in g[x]:
                if v[y] == 0:
                    v[y] = 1
                    queue.append(y)
        ok = 1
        for x in cur:
            for y in cur:
                if x != y and adj[x][y] == 0:
                    {{completion}}
        if ok:
            if min(cur) == i:
                gr.append(len(cur))
        else:
            gr.append(1)
    dp = [0]*(n+1)
    dp[0] = 1
    for a in gr:
        dp1 = [0]*(n+1)
        for i in range(n):
            dp1[i+1] = (dp1[i+1]+dp[i])%MOD
            if a > 1 and i+a <= n:
                dp1[i+a] = (dp1[i+a]+dp[i])%MOD
        dp = dp1
    ans = 0
    k = n
    for i in range(1, n+1):
        ans = (ans+dp[i]*k)%MOD
        k = k*(n-i)%MOD
    return ans


import sys
input = lambda: sys.stdin.readline().rstrip()
print(solve())
","ok = 0
                    break","v[y] = 1
                    queue.append(y)"
"from math import perm, comb
import sys
input = sys.stdin.readline
 
M = 998244353
 
n = int(input())
x, y = [0]*n, [0]*n
for i in range(n):
    x[i], y[i] = map(int, input().split())
# print(x, y)
 
dist = [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        dist[i].append(abs(x[i] - x[j]) + abs(y[i] - y[j]))
# print(dist)
 
mindist, nbr = [M] * n, [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        if i == j:
            continue
        if dist[i][j] < mindist[i]:
            mindist[i] = dist[i][j]
            nbr[i] = [j]
        elif dist[i][j] == mindist[i]:
            nbr[i].append(j)
# print(mindist, nbr)
 
grp = [0] * n
for i in range(n):
    if grp[i] > 0:
        continue
    if len(nbr[i]) > 3:
        grp[i] = 1
        continue
 
    checknbr = [False] * n
    checknbr[i] = True
    for j in nbr[i]:
        checknbr[j] = True
 
    check = False
    for j in nbr[i]:
        if len(nbr[j]) != len(nbr[i]):
            check = True
            break
        for c in nbr[j]:
            if not checknbr[c]:
                {{completion}}
    if check:
        grp[i] = 1
    else:
        grp[i] = len(nbr[i]) + 1
        for j in nbr[i]:
            grp[j] = grp[i]
# print(grp)
 
cnt = [0] * 5
for i in grp:
    cnt[i] += 1
cnt[2] //= 2
cnt[3] //= 3
cnt[4] //= 4
# print(cnt)
 
ans = 0
for i in range(cnt[2] + 1):
    for j in range(cnt[3] + 1):
        for k in range(cnt[4] + 1):
            z = (comb(cnt[2], i) * comb(cnt[3], j) * comb(cnt[4], k)) % M
            z *= perm(n, n - i - 2*j - 3*k)
            z %= M
            ans = (ans + z) % M
print(ans)","check = True
                break",nbr[i].append(j)
"from math import perm, comb
import sys
input = sys.stdin.readline
 
M = 998244353
 
n = int(input())
x, y = [0]*n, [0]*n
for i in range(n):
    x[i], y[i] = map(int, input().split())
# print(x, y)
 
dist = [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        dist[i].append(abs(x[i] - x[j]) + abs(y[i] - y[j]))
# print(dist)
 
mindist, nbr = [M] * n, [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        if i == j:
            continue
        if dist[i][j] < mindist[i]:
            mindist[i] = dist[i][j]
            nbr[i] = [j]
        elif dist[i][j] == mindist[i]:
            {{completion}}
# print(mindist, nbr)
 
grp = [0] * n
for i in range(n):
    if grp[i] > 0:
        continue
    if len(nbr[i]) > 3:
        grp[i] = 1
        continue
 
    checknbr = [False] * n
    checknbr[i] = True
    for j in nbr[i]:
        checknbr[j] = True
 
    check = False
    for j in nbr[i]:
        if len(nbr[j]) != len(nbr[i]):
            check = True
            break
        for c in nbr[j]:
            if not checknbr[c]:
                check = True
                break
    if check:
        grp[i] = 1
    else:
        grp[i] = len(nbr[i]) + 1
        for j in nbr[i]:
            grp[j] = grp[i]
# print(grp)
 
cnt = [0] * 5
for i in grp:
    cnt[i] += 1
cnt[2] //= 2
cnt[3] //= 3
cnt[4] //= 4
# print(cnt)
 
ans = 0
for i in range(cnt[2] + 1):
    for j in range(cnt[3] + 1):
        for k in range(cnt[4] + 1):
            z = (comb(cnt[2], i) * comb(cnt[3], j) * comb(cnt[4], k)) % M
            z *= perm(n, n - i - 2*j - 3*k)
            z %= M
            ans = (ans + z) % M
print(ans)",nbr[i].append(j),"check = True
                break"
"input = __import__('sys').stdin.readline


MOD = 998244353

fact = [1]
invfact = [1]

for i in range(1, 101):
    fact.append(fact[-1] * i % MOD)
    invfact.append(pow(fact[-1], MOD-2, MOD))


def C(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD


def P(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[n-k] % MOD


n = int(input())
coords = []
for _ in range(n):
    x, y = map(int, input().split())
    coords.append((x, y))

min_dist = [10**9] * n
dist = [[-1] * n for _ in range(n)]
for u in range(n):
    for v in range(n):
        dist[u][v] = abs(coords[u][0] - coords[v][0]) + abs(coords[u][1] - coords[v][1])
        if u != v:
            min_dist[u] = min(min_dist[u], dist[u][v])

cnt = [0, 0, 0, 0, 0]
vis = [False]*n
for u in sorted(range(n), key=lambda x: min_dist[x]):
    if vis[u]:
        continue

    vis[u] = True
    seen = [False]*n
    seen[u] = True    
    ptr = 0
    found = [u]
    while ptr < len(found):
        v = found[ptr]
        ptr += 1
        for w in range(n):
            if not seen[w] and dist[v][w] == min_dist[v]:
                {{completion}}
    
    ok = all(dist[found[i]][found[j]] == min_dist[u] for i in range(len(found)) for j in range(i+1, len(found)))
    if len(found) == 1 or not ok:
        cnt[1] += 1
    else:
        # print('found', found, ok)
        cnt[len(found)] += 1
        for u in found:
            vis[u] = True


# print('cnt', cnt[1:])

ans = 0
for two in range(cnt[2] + 1):
    for three in range(cnt[3] + 1):
        for four in range(cnt[4] + 1):
            ans += P(n, n - two - 2*three - 3*four) * C(cnt[2], two) % MOD \
                * C(cnt[3], three) % MOD \
                * C(cnt[4], four) % MOD
            if ans >= MOD:
                ans -= MOD
            # print(f'add P({n},{n - two - 2*three - 3*four})*C({cnt[2]},{two})*C({cnt[3]},{three})*C({cnt[4]},{four}) {ans}')
print(ans)","seen[w] = True
                found.append(w)",ans -= MOD
"input = __import__('sys').stdin.readline


MOD = 998244353

fact = [1]
invfact = [1]

for i in range(1, 101):
    fact.append(fact[-1] * i % MOD)
    invfact.append(pow(fact[-1], MOD-2, MOD))


def C(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD


def P(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[n-k] % MOD


n = int(input())
coords = []
for _ in range(n):
    x, y = map(int, input().split())
    coords.append((x, y))

min_dist = [10**9] * n
dist = [[-1] * n for _ in range(n)]
for u in range(n):
    for v in range(n):
        dist[u][v] = abs(coords[u][0] - coords[v][0]) + abs(coords[u][1] - coords[v][1])
        if u != v:
            min_dist[u] = min(min_dist[u], dist[u][v])

cnt = [0, 0, 0, 0, 0]
vis = [False]*n
for u in sorted(range(n), key=lambda x: min_dist[x]):
    if vis[u]:
        continue

    vis[u] = True
    seen = [False]*n
    seen[u] = True    
    ptr = 0
    found = [u]
    while ptr < len(found):
        v = found[ptr]
        ptr += 1
        for w in range(n):
            if not seen[w] and dist[v][w] == min_dist[v]:
                seen[w] = True
                found.append(w)
    
    ok = all(dist[found[i]][found[j]] == min_dist[u] for i in range(len(found)) for j in range(i+1, len(found)))
    if len(found) == 1 or not ok:
        cnt[1] += 1
    else:
        # print('found', found, ok)
        cnt[len(found)] += 1
        for u in found:
            vis[u] = True


# print('cnt', cnt[1:])

ans = 0
for two in range(cnt[2] + 1):
    for three in range(cnt[3] + 1):
        for four in range(cnt[4] + 1):
            ans += P(n, n - two - 2*three - 3*four) * C(cnt[2], two) % MOD \
                * C(cnt[3], three) % MOD \
                * C(cnt[4], four) % MOD
            if ans >= MOD:
                {{completion}}
            # print(f'add P({n},{n - two - 2*three - 3*four})*C({cnt[2]},{two})*C({cnt[3]},{three})*C({cnt[4]},{four}) {ans}')
print(ans)",ans -= MOD,"seen[w] = True
                found.append(w)"
"



#############################
#############
cnb_max=10**5
mod=998244353
#############

kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod

rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod

def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod


def inv(n):
    return kai[n-1]*rkai[n]%mod

##################################



n=int(input())
x=[]
y=[]
for i in range(n):
    a,b=map(int,input().split())
    x.append(a)
    y.append(b)
ok=[[0]*n for i in range(n)]
tto=[0]*n
def dist(i,j):
    return abs(x[i]-x[j])+abs(y[i]-y[j])
for i in range(n):
    mi=10**18
    for j in range(n):
        if i==j:continue
        mi=min(mi,dist(i,j))
    for j in range(n):
        if i==j:continue
        if mi==dist(i,j):
            ok[i][j]=1
            tto[i]+=1

s=[]
for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
            for d in range(c+1,n):
                nod=[a,b,c,d]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:{{completion}}
                        flag&=ok[i][j]
                    if tto[i]!=3:flag=0
                if flag:s.append(4)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=2:flag=0
                if flag:s.append(3)

for a in range(n):
    for b in range(a+1,n):
                nod=[a,b]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=1:flag=0
                if flag:s.append(2)

dp=[0]*(n+1)
dp[n-sum(s)]=1
for cnt in s:
    newdp=[0]*(n+1)
    for i in range(n+1):
        dp[i]%=mod
        if i+cnt<=n:newdp[i+cnt]+=dp[i]
        if i+1<=n:newdp[i+1]+=dp[i]
    dp=newdp[:]
ans=0
for k in range(n+1):
    ans+=dp[k]*cnb(n,k)*kai[k]
    ans%=mod
print(ans)



",continue,flag=0
"



#############################
#############
cnb_max=10**5
mod=998244353
#############

kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod

rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod

def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod


def inv(n):
    return kai[n-1]*rkai[n]%mod

##################################



n=int(input())
x=[]
y=[]
for i in range(n):
    a,b=map(int,input().split())
    x.append(a)
    y.append(b)
ok=[[0]*n for i in range(n)]
tto=[0]*n
def dist(i,j):
    return abs(x[i]-x[j])+abs(y[i]-y[j])
for i in range(n):
    mi=10**18
    for j in range(n):
        if i==j:continue
        mi=min(mi,dist(i,j))
    for j in range(n):
        if i==j:continue
        if mi==dist(i,j):
            ok[i][j]=1
            tto[i]+=1

s=[]
for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
            for d in range(c+1,n):
                nod=[a,b,c,d]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=3:{{completion}}
                if flag:s.append(4)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=2:flag=0
                if flag:s.append(3)

for a in range(n):
    for b in range(a+1,n):
                nod=[a,b]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=1:flag=0
                if flag:s.append(2)

dp=[0]*(n+1)
dp[n-sum(s)]=1
for cnt in s:
    newdp=[0]*(n+1)
    for i in range(n+1):
        dp[i]%=mod
        if i+cnt<=n:newdp[i+cnt]+=dp[i]
        if i+1<=n:newdp[i+1]+=dp[i]
    dp=newdp[:]
ans=0
for k in range(n+1):
    ans+=dp[k]*cnb(n,k)*kai[k]
    ans%=mod
print(ans)



",flag=0,continue
"for _ in range(int(input())):
    {{completion}}
","r = int(input())
    print('Division', 4 - sum(r >= p for p in (1400, 1600, 1900)))","x = int(input())
    print(""Division 4"" if x < 1400 else ""Division 3"" if x < 1600 else ""Division 2"" if x < 1900 else ""Division 1"")"
for n in[*open(0)][1:]:{{completion}},"r=int(n)/100;print('Division',1+(r<19)+(r<16)+(r<14))","
'''
How pros write B)
'''

for i in range(int(input())):
    x = int(input())
    print(""Division 4"" if x < 1400 else ""Division 3"" if x < 1600 else ""Division 2"" if x < 1900 else ""Division 1"")

'''
How pros write B)
'''

for i in range(int(input())):
    x = int(input())
    print(""Division 4"" if x < "
"from bisect import bisect
b = [-5001, 1400, 1600, 1900]
for i in range(int(input())): {{completion}}","print(f'Division {-bisect(b, int(input()))+5}')","
Complete the code in python to solve this programming problem:

Description: Codeforces separates its users into $$$4$$$ divisions by their rating:  For Division 1: $$$1900 \leq \mathrm{rating}$$$  For Division 2: $$$1600 \leq \mathrm{rating} \leq 1899$$$  For Division 3: $$$1400 \leq \mathrm{rating} \leq 1599$$$  For Division 4: $$$\mathrm{rating} \leq 139"
"n=int(input())
while n:
    num=int(input())
    if num>=1900:print(""Division 1"")
    elif num>=1600:{{completion}}
    elif num>=1400:print(""Division 3"")
    else:print(""Division 4"")
    n-=1","print(""Division 2"")","print(""Division 2"")"
"n=int(input())
while n:
    num=int(input())
    if num>=1900:print(""Division 1"")
    elif num>=1600:print(""Division 2"")
    elif num>=1400:{{completion}}
    else:print(""Division 4"")
    n-=1","print(""Division 3"")","































































































































"
"def div(n):
    {{completion}}

for _ in range(int(input())):
    print(f'Division {div(int(input()))}')
",return 1 if n >= 1900 else 2 if n >= 1600 else 3 if n >= 1400 else 4,"def div(n):
    return 1 if n >= 1900 else 2 if n >= 1600 else 3 if n >= 1400 else 4

for _ in range(int(input())):
    print(f'Division {div(int(input()))}')"
"def div(n):
    return 1 if n >= 1900 else 2 if n >= 1600 else 3 if n >= 1400 else 4

for _ in range(int(input())):
    {{completion}}
",print(f'Division {div(int(input()))}'),"r=int(input())
print('Division',div(r))"
"x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif int(z) >= 1600:
        {{completion}}
    elif int(z) >= 1400:
        print('Division 3')
    else:
        print('Division 4')
",print('Division 2'),print('Division 2')
"x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif int(z) >= 1600:
        print('Division 2')
    elif int(z) >= 1400:
        {{completion}}
    else:
        print('Division 4')
",print('Division 3'),print('Division 3')
"k = 0
a = int(input())
for x in range(1, a+1):
    b = int(input())
    if 1900<= b:
        d = 1
    elif 1600 <= b <= 1899:
        {{completion}}
    elif 1400 <= b <= 1599:
        d = 3
    elif b <= 1399:
        d = 4
    print('Division', d)",d = 2,d = 2
"k = 0
a = int(input())
for x in range(1, a+1):
    b = int(input())
    if 1900<= b:
        d = 1
    elif 1600 <= b <= 1899:
        d = 2
    elif 1400 <= b <= 1599:
        {{completion}}
    elif b <= 1399:
        d = 4
    print('Division', d)",d = 3,d = 3
"t = int(input())
while t > 0:
	n = int(input())
	if n >= 1900:
		print(""Division"",1)
	elif n >= 1600 and n <1900:
		{{completion}}
	elif n >= 1400 and n < 1600:
		print(""Division"", 3)
	else:
		print(""Division"",4)
	t -= 1
","print(""Division"", 2)","print(""Division"", 2)"
"t = int(input())
while t > 0:
	n = int(input())
	if n >= 1900:
		print(""Division"",1)
	elif n >= 1600 and n <1900:
		print(""Division"", 2)
	elif n >= 1400 and n < 1600:
		{{completion}}
	else:
		print(""Division"",4)
	t -= 1
","print(""Division"", 3)","print(""Division"", 3)"
"x=int(input(""""))
for i in range (x):
    c=int(input(""""))
    if c<=1399:
        print("" Division 4"")
    elif 1400<=c<=1599:
        {{completion}}
    elif 1600<=c<=1899:
       print("" Division 2"") 
    else :
       print("" Division 1"")","print("" Division 3"")","print("" Division 3"")"
"x=int(input(""""))
for i in range (x):
    c=int(input(""""))
    if c<=1399:
        print("" Division 4"")
    elif 1400<=c<=1599:
        print("" Division 3"")
    elif 1600<=c<=1899:
       {{completion}} 
    else :
       print("" Division 1"")","print("" Division 2"")","































































































































"
"'''
How pros write B)
'''

for i in range(int(input())):
    {{completion}}","x = int(input())
    print(""Division 4"" if x < 1400 else ""Division 3"" if x < 1600 else ""Division 2"" if x < 1900 else ""Division 1"")","    r = int(input())
    print('Division', 4 - sum(r >= p for p in (1400, 1600, 1900)))


'''
How beginners write B)
'''

for i in range(int(input())):
    r = int(input())
    if r >= 1900:
        print('Division', 1)
    elif r >= 1600:
        print('Division', 2)
    elif r >= 1400"
"from collections import deque
for _ in range(int(input())):
    n = int(input())
    l = deque(map(int, input().split()))
    a, b = 0, 0
    ans = 0
    cur = 0
    while l:
        cur+=1
        if a>=b:
            b += l.pop()
        else:
            {{completion}}
        if a==b:
            ans = cur
    print(ans)
",a += l.popleft(),"b+=l.pop()
            cur-=1"
"for n in[*open(0)][2::2]:
    n=[*map(int,n.split())]
    a,b,l,f=[0]*4;r=len(n)-1
    while l<=r:
        if a<=b:
            a+=n[l]
            l+=1
        elif b<a:
            {{completion}}
        if a==b:
            f=len(n)-r+l-1
    print(f)","b+=n[r]
            r-=1","b=b+n[r]
            r=r-1"
"from bisect import *
from itertools import *

t = int(input())
for _ in range(t):
	n = int(input())
	w = list(map(int, input().split()))
	aw = list(accumulate(w))
	bw = list(accumulate(w[::-1]))
	mx = 0
	for i, a in enumerate(aw):
		c = bisect_left(bw, a, hi=len(bw)-i-2)
		if a==bw[c] and i<(len(bw)-c-1):
			{{completion}}
	print(mx)
","mx = max(mx, (i+1)+(c+1))","mx=max(mx,i+c+1)"
"def solve():
 n=int(input())
 a=[*map(int,input().split())]
 b=a[:]
 for i in range(n-1):a[i+1]+=a[i]
 for i in range(n-1,0,-1):b[i-1]+=b[i]
 l,r=0,n-1
 sol=0
 while r-l>=1:
  if a[l]==b[r]:sol=l+n-r+1;l+=1
  if a[l]<b[r]:l+=1
  else:{{completion}}
 return sol
for _ in [0]*int(input()):print(solve())",r-=1,"if a[l]<b[r]:l+=1
            else:
                b[r]=b[r]-a[l]
                l+=1"
"I=lambda:[int(i) for i in input().split()]
for _ in range(I()[0]):
    n=I()[0]
    l=I()
    l2=[]
    s1,s2=0,0
    p1,p2=0,n-1
    while (p1-1<=p2):
        if s1 == s2: {{completion}}
        if s1 < s2: s1+=l[p1]; p1+=1
        if s2 < s1: s2+=l[p2]; p2-=1
    print(l2[-1])

    ",l2.append(p1 + n-1-p2); s1+=l[p1]; p1+=1,s1+=l[p1]; p1+=1
"I=lambda:[int(i) for i in input().split()]
for _ in range(I()[0]):
    n=I()[0]
    l=I()
    l2=[]
    s1,s2=0,0
    p1,p2=0,n-1
    while (p1-1<=p2):
        if s1 == s2: l2.append(p1 + n-1-p2); s1+=l[p1]; p1+=1
        if s1 < s2: {{completion}}
        if s2 < s1: s2+=l[p2]; p2-=1
    print(l2[-1])

    ",s1+=l[p1]; p1+=1,s1+=l[p1]; p1+=1
"import math as m

i = input()
inp = []
for a in range(0,int(i)):
    inp += [[input(), input()]]

def maxx(arr):
    if arr == []:
        return 0
    else:
        return max(arr)

for s in inp:
    n = int(s[0])
    arr = [int(x) for x in s[1].split()]
    
    i = 0
    j = n-1
    lsum = arr[i]
    rsum = arr[j]

    best = 0
    while i < j:
        if lsum < rsum:
            i += 1
            lsum += arr[i]
        elif rsum < lsum:
            {{completion}}
        else:
            best = i + (n-1-j) + 2
            i += 1
            lsum += arr[i]
    print(best)
    
    
","j -= 1
            rsum += arr[j]","best = i + (n-1-j) + 2
            i += 1
            lsum += arr[i]"
"import math as m

i = input()
inp = []
for a in range(0,int(i)):
    inp += [[input(), input()]]

def maxx(arr):
    if arr == []:
        return 0
    else:
        return max(arr)

for s in inp:
    n = int(s[0])
    arr = [int(x) for x in s[1].split()]
    
    i = 0
    j = n-1
    lsum = arr[i]
    rsum = arr[j]

    best = 0
    while i < j:
        if lsum < rsum:
            i += 1
            lsum += arr[i]
        elif rsum < lsum:
            j -= 1
            rsum += arr[j]
        else:
            {{completion}}
    print(best)
    
    
","best = i + (n-1-j) + 2
            i += 1
            lsum += arr[i]","best=max(best,i+j+1)"
"for t in range(int(input())):
    n=int(input())
    l1=list(map(int,input().split()))
    l=0
    h=n-1
    ans=0
    a=0
    b=0
    while(l<=h):
        if(a>b):
            b=b+l1[h]
            h=h-1
        else:
            {{completion}}
        if(a==b):
            ans=l+n-h-1
    print(ans)","a=a+l1[l]
            l=l+1","a+=l1[h]
            h-=1"
"for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    x = sum(a) // 2
    s, d = 0, {}
    for idx, i in enumerate(a):
        s += i
        if s > x: {{completion}}
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if s in d: r = idx + 1 + d[s]
    print(r)",break,r = idx + 1 + d[s]
"for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    x = sum(a) // 2
    s, d = 0, {}
    for idx, i in enumerate(a):
        s += i
        if s > x: break
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if s in d: {{completion}}
    print(r)",r = idx + 1 + d[s],r=d[s]
"n = int(input())
for i in range(n):
    h = 1
    g = 1
    counter = 0
    m = int(input())
    lst = list(map(int, input().split()))
    index =0
    e= 0
    r =m-1
    highest = lst[m-1]
    lowest = lst[0]
    while h+g <= m:
        if lowest<highest:
            lowest+=lst[e+1]
            e+=1
            g +=1
        elif highest<lowest:
            {{completion}}
        elif highest == lowest:
            lowest+=lst[e+1]
            e+=1
            g+=1
            index = e + (m - r)
    print(index)
","highest+=lst[r-1]
            r-=1
            h+=1","lowest+=lst[e+1]
            e+=1
            g+=1
            index = e + (m - r)"
"n = int(input())
for i in range(n):
    h = 1
    g = 1
    counter = 0
    m = int(input())
    lst = list(map(int, input().split()))
    index =0
    e= 0
    r =m-1
    highest = lst[m-1]
    lowest = lst[0]
    while h+g <= m:
        if lowest<highest:
            lowest+=lst[e+1]
            e+=1
            g +=1
        elif highest<lowest:
            highest+=lst[r-1]
            r-=1
            h+=1
        elif highest == lowest:
            {{completion}}
    print(index)
","lowest+=lst[e+1]
            e+=1
            g+=1
            index = e + (m - r)","highest+=lst[r-1]
            r-=1
            h+=1"
"def read():
    return int(input())

def readline():
    return list(map(int,input().split()))

def solve():
    n=read()
    arr=readline()
    ans,cur=0,0
    a,suma=-1,0
    b,sumb=n,0
    while True:
        if a>=b: break
        elif suma>sumb:
            {{completion}}
        elif suma<sumb:
            a+=1
            suma+=arr[a]
            cur+=1
        else :
            ans=cur
            a+=1
            b-=1
            suma+=arr[a]
            sumb+=arr[b]
            cur+=2
    print(ans)


if __name__ == ""__main__"":
    T=read()
    for i in range(T):
        solve()","b-=1
            sumb+=arr[b]
            cur+=1","a+=1
            suma+=arr[a]
            cur+=1"
"def read():
    return int(input())

def readline():
    return list(map(int,input().split()))

def solve():
    n=read()
    arr=readline()
    ans,cur=0,0
    a,suma=-1,0
    b,sumb=n,0
    while True:
        if a>=b: break
        elif suma>sumb:
            b-=1
            sumb+=arr[b]
            cur+=1
        elif suma<sumb:
            {{completion}}
        else :
            ans=cur
            a+=1
            b-=1
            suma+=arr[a]
            sumb+=arr[b]
            cur+=2
    print(ans)


if __name__ == ""__main__"":
    T=read()
    for i in range(T):
        solve()","a+=1
            suma+=arr[a]
            cur+=1","a+=1
            suma+=arr[a]
            cur+=1"
"for _ in range(int(input())):
    n, _ = map(int, input().split())
    a = map("""".join, zip(*(input() for _ in range(n))))
    a = (""o"".join("""".join(sorted(y, reverse=True)) for y in x.split(""o"")) for x in a)
    for x in zip(*a):
        {{completion}}
 			  	 	    				   	  	 	    	","print("""".join(x))","print(*x,sep='')"
"# Write your code here :-)
# Fall Down
def solution():
    n, m = [int(i) for i in input().split()]
    grid = [list(input()) for _ in range(n)]
    for i in range(m):
        for j in range(n - 1, -1, -1):
            if grid[j][i] == ""*"":
                grid[j][i] = "".""
                pos = j
                while pos < n - 1 and grid[pos + 1][i] == ""."":
                    {{completion}}
                grid[pos][i] = ""*""
    for row in grid:
        print(*row, sep="""")


t = int(input())
for _ in range(t):
    solution()
",pos += 1,"pos=j
while pos<n-1 and grid[pos+1][i]=='.':
    pos+=1
grid[pos][i]='*'"
"def res(s):
 a=s.split('o');t=''
 for i in a:t+=i.count('*')*'*'+i.count('.')*'.'+'o'
 return t[:-1]

for _ in[0]*int(input()):
 n,m=map(int,input().split())
 a=[[*input()] for x in[0]*n]
 b=[]
 for i in range(m):b+=res(''.join([a[~j][i] for j in range(n)])),
 for i in range(n):
  for j in range(m):{{completion}}
  print()
 print()","print(b[j][~i],end='')","a[j][i],a[j+count][i]='.',a[j][i]"
"c=input()
for _ in range(int(c)):
    b=input().split()
    a=[]
    for i in range(int(b[0])):
        a.append(list(input()))
    for i in range(int(b[1])):
        count=0
        row=int(b[0])-1
        for j in range(int(b[0])):
            if a[row][i]=='.':
                count+=1
            elif a[row][i]=='o':
                {{completion}}
            else:
                a[row][i],a[row+count][i]='.',a[row][i]
            row-=1
    for i in range(int(b[0])):
        print("""".join(a[i]))


",count=0,"a[row][i],a[row+count][i]='.',a[row][i]"
"c=input()
for _ in range(int(c)):
    b=input().split()
    a=[]
    for i in range(int(b[0])):
        a.append(list(input()))
    for i in range(int(b[1])):
        count=0
        row=int(b[0])-1
        for j in range(int(b[0])):
            if a[row][i]=='.':
                count+=1
            elif a[row][i]=='o':
                count=0
            else:
                {{completion}}
            row-=1
    for i in range(int(b[0])):
        print("""".join(a[i]))


","a[row][i],a[row+count][i]='.',a[row][i]",count=0
"import sys
input = sys.stdin.readline
for _ in [0]*int(input()):
    n,m=map(int,input().split())
    s=['']*m
    for _ in [0]*n:
        s=[s[i]+j for i,j in zip(range(m),input())]
    col=['']*n
    k=0
    for i in s:
        bl=0
        x=''
        for j in i[::-1]:
            if j=='o':
                x=j+'.'*bl+x
                bl=0
            elif j=='*':
                {{completion}}
            else:
                bl=bl+1
        x='.'*bl+x
        col=[col[ind]+val for val,ind in zip(x,range(n))]
        k=k+1
    for j in col:
        print(j)",x=j+x,bl=bl+1
"import sys
input = sys.stdin.readline
for _ in [0]*int(input()):
    n,m=map(int,input().split())
    s=['']*m
    for _ in [0]*n:
        s=[s[i]+j for i,j in zip(range(m),input())]
    col=['']*n
    k=0
    for i in s:
        bl=0
        x=''
        for j in i[::-1]:
            if j=='o':
                x=j+'.'*bl+x
                bl=0
            elif j=='*':
                x=j+x
            else:
                {{completion}}
        x='.'*bl+x
        col=[col[ind]+val for val,ind in zip(x,range(n))]
        k=k+1
    for j in col:
        print(j)",bl=bl+1,x=j+x
"for i in range(int(input())):
    n,m=map(int,input().split())
    s=[list(input()) for j in range(n)]
    for _ in range(n):
        for a in reversed(range(n-1)):
            for b in range(m):
                if s[a][b]=='*':
                    if s[a+1][b]=='o' or s[a+1][b]=='*':
                        continue
                    else:
                        {{completion}}
    for a in range(n):
        print(*s[a],sep='')","s[a][b]='.'
                        s[a+1][b]='*'","s[a][b],s[a+1][b]='.','*'"
"I=lambda:map(int,input().split())
for _ in range(int(input())):
    n,m=I()
    a=[input() for _ in range(n)]
    
    at=[''.join(col).split('o') for col in zip(*a)]
    f=lambda s:''.join(sorted(s,reverse=True))
    at=['o'.join(map(f, col)) for col in at]
    
    for row in zip(*at):
      {{completion}}",print(''.join(row)),"        print(''.join(row))


"
"I = input
for _ in range(int(I())):
    n,m = map(int,I().split())
    grid = [I().strip() for __ in range(n)]
    res = []
    for col in range(m):
        newcol = ''
        for seg in (''.join(grid[row][col] for row in range(n))).split('o'):
            {{completion}}
        res.append(newcol[0:-1])
    for row in range(n):
        print(''.join(res[col][row] for col in range(m)))",newcol += '.'*seg.count('.')+'*'*seg.count('*')+'o',"print(res[col][row],end='')"
"for ii in range(int(input())):
	n,m = map(int, input().split())
	mat=[]
	r=[0]*m
	for jj in range(n):
		a=list(input())
		for kk in range(m):
			if a[kk]==""*"":
				r[kk]+=1
				a[kk]="".""
			elif a[kk]==""o"":
				while r[kk]:
					{{completion}}
		mat.append(a)
	for jj in range(m):
		while r[jj]:
			mat[n-r[jj]][jj]=""*""
			r[jj]-=1
	for jj in range(n):
		print("""".join(mat[jj]))","mat[jj-r[kk]][kk]=""*""
					r[kk]-=1",r[jj]-=1
"t = int(input())

for i in range (t):
    n, m = map(int,input().split())
    arr = [[0]*m]*n
    for j in range(n):
        arr[j] = list(input())
        # for h in range(m):
            # print(arr[j][h])
    for k in range(m):
        for l in range(n-1, -1, -1):
           if arr[l][k]=='.':
            #    print(""yes"")
               for f in range(l-1,-1,-1):
                   if arr[f][k]=='o':
                       break
                   elif arr[f][k]=='*':
                    #    print(""yes"")
                       {{completion}}
    for g in range(n):
        for h in range(m-1):
            print(arr[g][h],end="""")
        print(arr[g][m-1],end=""\n"")
                
                
            
            
        

","arr[f][k]='.'
                       arr[l][k]='*'
                       break","arr[l][k]='.'
                        arr[l+1][k]='*'"
"from collections import Counter
for _ in range(int(input())):
    n = int(input())
    num = Counter(input() for x in [1]*n)
    cnt = 0
    for x in num:
        for y in num:
            if x!=y and (x[0] == y[0] or x[1] == y[1]):
                {{completion}}
    print(cnt//2)",cnt+=num[x]*num[y],cnt += num[x]*num[y]
"from collections import Counter
from itertools import islice
from sys import stdin

LETTERS = 'abcdefghijk'

data = (line.strip() for line in stdin.readlines()[1:])

res = []
for line in data:
    n = int(line)
    s = 0
    ctr = Counter()
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if l != a:
                {{completion}}
            if l != b:
                s += ctr[f'{a}{l}']
    res.append(s)

print('\n'.join(str(x) for x in res))
",s += ctr[f'{l}{b}'],s += ctr[f'{a}{l}']
"from collections import Counter
from itertools import islice
from sys import stdin

LETTERS = 'abcdefghijk'

data = (line.strip() for line in stdin.readlines()[1:])

res = []
for line in data:
    n = int(line)
    s = 0
    ctr = Counter()
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if l != a:
                s += ctr[f'{l}{b}']
            if l != b:
                {{completion}}
    res.append(s)

print('\n'.join(str(x) for x in res))
",s += ctr[f'{a}{l}'],s += ctr[f'{a}{l}']
"for i in range(int(input())):
    data = [[0 for l in range(11)] for k in range(11)]

    for j in range(int(input())):
        first, second = input()
        data[ord(first)-ord('a')][ord(second)-ord('a')] += 1

    answer = 0
    for j in range(11):
        for k in range(11):
            for l in range(11):
                if j != l:
                    {{completion}}

                if k != l:
                    answer += data[j][k]*data[j][l]

    print(answer//2)",answer += data[j][k]*data[l][k],answer += data[j][k]*data[l][k]
"for i in range(int(input())):
    data = [[0 for l in range(11)] for k in range(11)]

    for j in range(int(input())):
        first, second = input()
        data[ord(first)-ord('a')][ord(second)-ord('a')] += 1

    answer = 0
    for j in range(11):
        for k in range(11):
            for l in range(11):
                if j != l:
                    answer += data[j][k]*data[l][k]

                if k != l:
                    {{completion}}

    print(answer//2)",answer += data[j][k]*data[j][l],answer += data[j][k]*data[j][l]
"from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if c != s[0]:
                if d[c + s[1]] > 0:
                    {{completion}}
            if c != s[1]:
                if d[s[0] + c] > 0:
                    count += d[s[0] + c]
        d[s] += 1
    print(count)",count += d[c + s[1]],count += d[s[0] + c]
"from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if c != s[0]:
                if d[c + s[1]] > 0:
                    count += d[c + s[1]]
            if c != s[1]:
                if d[s[0] + c] > 0:
                    {{completion}}
        d[s] += 1
    print(count)",count += d[s[0] + c],count += d[s[0] + c]
"for ii in range(int(input())):
	n=int(input())
	a=[]
	co=0
	x=set()
	for jj in range(n):
		a.append(input())
	for jj in range(n):
		mul=1
		if jj not in x:
			for kk in range(jj+1,n):
				if a[jj][0]!=a[kk][0] and a[jj][1]==a[kk][1]:
					co+=mul
				elif a[jj][0]==a[kk][0] and a[jj][1]!=a[kk][1]:
					{{completion}}
				elif a[jj][0]==a[kk][0] and a[jj][1]==a[kk][1]:
					mul+=1
					x.add(kk)
	print(co)",co+=mul,"mul+=1
					x.add(kk)"
"for ii in range(int(input())):
	n=int(input())
	a=[]
	co=0
	x=set()
	for jj in range(n):
		a.append(input())
	for jj in range(n):
		mul=1
		if jj not in x:
			for kk in range(jj+1,n):
				if a[jj][0]!=a[kk][0] and a[jj][1]==a[kk][1]:
					co+=mul
				elif a[jj][0]==a[kk][0] and a[jj][1]!=a[kk][1]:
					co+=mul
				elif a[jj][0]==a[kk][0] and a[jj][1]==a[kk][1]:
					{{completion}}
	print(co)","mul+=1
					x.add(kk)",co+=mul
"t=int(input())
for i in range(t):
  n=int(input())
  result=0
  dic1={}
  dic2={}
  dic3={}
  for i in range(n):
    S=input()
    if S[0] in dic1:
      result+=dic1[S[0]]
      dic1[S[0]]+=1
    else:
      {{completion}}
    if S[1] in dic2:
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      dic2[S[1]]=1
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)",dic1[S[0]]=1,dic2[S[1]]=1
"t=int(input())
for i in range(t):
  n=int(input())
  result=0
  dic1={}
  dic2={}
  dic3={}
  for i in range(n):
    S=input()
    if S[0] in dic1:
      result+=dic1[S[0]]
      dic1[S[0]]+=1
    else:
      dic1[S[0]]=1
    if S[1] in dic2:
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      {{completion}}
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)",dic2[S[1]]=1,dic1[S[0]]=1
"for i in range(int(input())):
    n= int(input())
    a = dict()
    b = dict()
    c = dict()
    ans = 0
    for j in range(n):
        d,e = str(input())
        try:
            ans += a[d]
            a[d] += 1
        except KeyError:
            {{completion}}
        try:
            ans += b[e]
            b[e] += 1
        except KeyError:
            b[e] = 1
        if d+e not in c:
            c[d+e] = 0
        else:
            ans -= c[d+e]
        c[d+e] += 2
    print(ans)",a[d] = 1,a[d] += 1
"for i in range(int(input())):
    n= int(input())
    a = dict()
    b = dict()
    c = dict()
    ans = 0
    for j in range(n):
        d,e = str(input())
        try:
            ans += a[d]
            a[d] += 1
        except KeyError:
            a[d] = 1
        try:
            ans += b[e]
            b[e] += 1
        except KeyError:
            {{completion}}
        if d+e not in c:
            c[d+e] = 0
        else:
            ans -= c[d+e]
        c[d+e] += 2
    print(ans)",b[e] = 1,b[e] = 1
"from collections import Counter

t=int(input())
while(t!=0):
    n=int(input())
    s = Counter(input() for x in [1]*n)
    cnt = 0
    for x in s:
        for y in s:
            if(x!=y and (x[1]==y[1] or x[0]==y[0])): {{completion}}
    print(cnt//2)
   
    t-=1
",cnt += s[x]*s[y],cnt+=s[x]*s[y]
"t = int(input())
for x in range(t):
    n = int(input())
    d1 = {}
    for i in range(97,109):
        for j in range(97,109):
            d1[chr(i)+chr(j)] = 0
    ans1 = 0
    for y in range(n):
        s = input()
        for l in range(2):
            for m in range(97,109):
                a = list(s)
                a[l] = chr(m)
                a = ''.join(a)
                if a == s:
                    {{completion}}
                ans1+=d1[a]
        d1[s]+=1
    print(ans1)",continue,d1[s]+=1
"for n in range(int(input())):
    a = {}
    for j in range(int(input())):
        c = input()
        if c not in a:
            a[c] = 1
        elif c in a:
            a[c] += 1
    count = 0
    for i in a.keys():
        for j in a.keys():
            if i != j and (i[0] == j[0] or i[1] == j[1]):
                {{completion}}
    print(count // 2)
",count += a[i] * a[j],count += a[i] * a[j]
for s in[*open(0)][2::2]:{{completion}},"print('YNEOS'[1in map(len,map(set,s[:-1].split('W')))::2])","num = int(input())
    line = [elem for elem in input().split(""W"") if elem!= """"]
    print(""YES"" if all([""B"" in elem and ""R"" in elem for elem in line]) else ""NO"")"
"for _ in range(int(input())) :
	{{completion}}","l = int(input())
	print(""NO"" if any (len(set(x)) == 1 for x in input().split('W') ) else ""YES"")","for _ in range(int(input())):
    n = int(input())
    s = input()
    print(""YES"" if all([""B"" in elem and ""R"" in elem for elem in s[:-1].split(""W"")]) else ""NO"")"
"def solve():
    n = int(input())
    s = input().split('W')
    for i in s:
        bs = 'B' in i
        rs = 'R' in i
        if bs ^ rs:
            {{completion}}

    print('YES')

for t in range(int(input())):
    solve()
","print('NO')
            return","def solve():
    n = int(input())
    s = input().split('W')
    for i in s:
        bs = 'B' in i
        rs = 'R' in i
        if bs ^ rs:
            print('YES')
            return
    print('NO')

for t in range(int(input())):
    solve()"
"g = input()
for i in range(int(g)):
    input()
    numb = input().split('W')
    ans = 'yes'
    for z in numb:
        if z == '':
            pass
        else:
            if ('R' in z) and ('B' in z):
                pass
            else:
                {{completion}}
    print(ans)
",ans = 'no',"num = int(input())
    line = [elem for elem in input().split(""W"") if elem!= """"]
    print(""YES"" if all([""B"" in elem and ""R"" in elem for elem in line]) else ""NO"")"
"for s in[*open(0)][2::2]:
    b=0
    for i in s[:-1].split('W'):{{completion}}
    print('YNEOS'[b::2])",b|=len({*i})%2,b|=(len(set(i))==1)
"t=int(input())

for i in range(t):
    n=int(input())
    s=input()
    s=s.strip(""W"")
    temp=list(s.split('W'))

    for i in temp:
        if i:
            if 'B' not in i or 'R' not in i:
                {{completion}}
    else:
        print(""YES"")
        ","print(""NO"")
                break","this is the start of the ground truth
t=int(input())

for i in range(t):
    n=int(input())
    s=input()
    s=s.strip(""W"")
    temp=list(s.split('W'))

    for i in temp:
        if i:
            if 'B' not in i or 'R' not in i:
                print(""NO"")
                break
    else:
        print(""YES"")

this is the"
"for i in range(int(input())):
    {{completion}}","num = int(input())
    line = [elem for elem in input().split(""W"") if elem != """"]
    print(""YES"" if all([""B"" in elem and ""R"" in elem for elem in line]) else ""NO"")","num = int(input())
    line = [elem for elem in input().split(""W"") if elem!= """"]
    print(""YES"" if all([""B"" in elem and ""R"" in elem for elem in line]) else ""NO"")"
"for s in[*open(0)][2::2]:
    b = 0
    for i in s[:-1].split(""W""):
        {{completion}}
    print('YNEOS '[b::2])",b|=(len(set(i))==1),b|=(len(set(i))==1)
"t = int(input())
Ans = [-1]*t
for z in range(t):
    n = int(input())
    l = input().split('W')
    bad = False
    for s in l:
        b1 = 'R' in s
        b2 = 'B' in s
        if (b1 ^ b2):
        	{{completion}}
    print(""NO"" if bad else ""YES"")
    

",bad = True,"































































































































"
"n=int(input())
l=[int(i) for i in input().split()]

def f(l):
    cur = 0
    n = 0
    for i in l:
        {{completion}}
    return n

print(min(f(l[i+1:])+f(l[:i][::-1]) for i in range(n)))","n += cur // i + 1
        cur = i * (cur // i + 1)","































































































































"
"n = int(input().strip())
a = list(map(int, input().strip().split()))
ans = None

for i in range(n):
    acc, p = 0, 0
    for j in range(i-1, -1, -1):
        {{completion}}
    p = 0
    for j in range(i+1, n):
        x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]
    ans = min(ans, acc) if ans is not None else acc

print(ans)
","x = (p - 1) // a[j]
        acc += -x
        p = x * a[j]","x = (p - 1) // a[j]
        acc += -x
        p = x * a[j]"
"n = int(input().strip())
a = list(map(int, input().strip().split()))
ans = None

for i in range(n):
    acc, p = 0, 0
    for j in range(i-1, -1, -1):
        x = (p - 1) // a[j]
        acc += -x
        p = x * a[j]
    p = 0
    for j in range(i+1, n):
        {{completion}}
    ans = min(ans, acc) if ans is not None else acc

print(ans)
","x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]","x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]"
"from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float(""inf"")
for i in range(len(a)):
    t=[0]*n
    temp=0
    j=i-1
    prev =0
    while j>=0:
        {{completion}}
    
    k=i+1
    prev=0
    while k<len(a):
        x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1
    ans=min(ans,temp)
print(int(ans))","x=(ceil((prev+1)/a[j]))
        temp+=x
        prev=(a[j]*x)
        j-=1","x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1"
"from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float(""inf"")
for i in range(len(a)):
    t=[0]*n
    temp=0
    j=i-1
    prev =0
    while j>=0:
        x=(ceil((prev+1)/a[j]))
        temp+=x
        prev=(a[j]*x)
        j-=1
    
    k=i+1
    prev=0
    while k<len(a):
        {{completion}}
    ans=min(ans,temp)
print(int(ans))","x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1","x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1"
"
for _ in range(1):
    n = int(input())
    a = list(map(int, input().split()))
    Min = 1e18
    for l in range(n):
        m = a[l]
        answer = 1
        for i in range(l-1, -1, -1):
            answer += (m + a[i]) // a[i]
            m = a[i] * ((m + a[i]) // a[i])
        if l + 1 < n:
            m = 0
            for i in range(l + 2, n):
                {{completion}}
        Min = min(answer, Min)
    print(Min)","answer += (m + a[i]) // a[i]
                m = a[i] * ((m + a[i]) // a[i])","m = 0
for i in range(l + 2, n):
    m += a[i] - m % a[i]
    answer += m // a[i]"
"m=int(input())
a=[int(i)for i in input().split()]
t1,min=0,10**20
while(t1<m):
    t2=t1
    k,t=0,0
    while(t2<m-1):
        {{completion}}
    t2=t1
    k=0
    while(t2>0):
        t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1
    if(min>t):
        min=t
    t1+=1
print(min)
","t+=(k//a[t2+1]+1)
        k=a[t2+1]*(k//a[t2+1]+1)
        t2+=1","t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1"
"m=int(input())
a=[int(i)for i in input().split()]
t1,min=0,10**20
while(t1<m):
    t2=t1
    k,t=0,0
    while(t2<m-1):
        t+=(k//a[t2+1]+1)
        k=a[t2+1]*(k//a[t2+1]+1)
        t2+=1
    t2=t1
    k=0
    while(t2>0):
        {{completion}}
    if(min>t):
        min=t
    t1+=1
print(min)
","t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1","t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1"
"import math
n = int(input())
a = list(map(int, input().split(' '))) # numbers w/ ws

c = None
d = 0
for i in range(len(a)):
	p = 0
	t = 0
	for k in a[i+1:]:
		{{completion}}
	t = 0
	for k in reversed(a[:i]):
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	if c == None or p < c:
		c = p

print(c)","d = math.ceil((t+1)/k)
		t = k*d
		p += d","d = math.ceil((t+1)/k)
		t = k*d
		p += d"
"import math
n = int(input())
a = list(map(int, input().split(' '))) # numbers w/ ws

c = None
d = 0
for i in range(len(a)):
	p = 0
	t = 0
	for k in a[i+1:]:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	t = 0
	for k in reversed(a[:i]):
		{{completion}}
	if c == None or p < c:
		c = p

print(c)","d = math.ceil((t+1)/k)
		t = k*d
		p += d","d = math.ceil((t+1)/k)
		t = k*d
		p += d"
"def f(b, i):
    return e(b[::-1], i)

def e(b, i):
    if b == []:
        {{completion}}
    count = 0
    ggg = [0] * len(b)
    for i in range(len(b)):
        ggg[i] = (b[i - 1] * ggg[i - 1]) // b[i] + 1
        count += ggg[i]
    return count

def c(b, i):
    return e(b[i + 1:], 0) + f(b[:i], 0)

a = int(input())
b = input().split()
for i in range(a):
    b[i] = int(b[i])
d = c(b, 1)
for i in range(2, a - 1):
    d = min(d, c(b, i))
print(d)
",return 0,"ggg[i] = (b[i - 1] * ggg[i - 1]) // b[i] + 1
        count += ggg[i]"
"def f(b, i):
    return e(b[::-1], i)

def e(b, i):
    if b == []:
        return 0
    count = 0
    ggg = [0] * len(b)
    for i in range(len(b)):
        {{completion}}
    return count

def c(b, i):
    return e(b[i + 1:], 0) + f(b[:i], 0)

a = int(input())
b = input().split()
for i in range(a):
    b[i] = int(b[i])
d = c(b, 1)
for i in range(2, a - 1):
    d = min(d, c(b, i))
print(d)
","ggg[i] = (b[i - 1] * ggg[i - 1]) // b[i] + 1
        count += ggg[i]","for i in range(len(b)):
    ggg[i] = b[i]
    for j in range(i):
        ggg[j] = min(ggg[j], ggg[j + 1])
        ggg[i] = min(ggg[i], ggg[j])
        count += ggg[i] - ggg[j]"
"

n=int(input())


a=list(map(int,input().split()))
b=[int(0) for _ in range(n)]
m=1e18
for i in range(n):
    c=0
    p=0
    for j in range(i+1,len(b)):
        {{completion}}
    p=0
    for j in range(i-1,-1,-1):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    m=min(m,c)

print(m)


","p+=a[j]-p%a[j]
        c+=p//a[j]","p+=a[j]-p%a[j]
        c+=p//a[j]"
"

n=int(input())


a=list(map(int,input().split()))
b=[int(0) for _ in range(n)]
m=1e18
for i in range(n):
    c=0
    p=0
    for j in range(i+1,len(b)):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i-1,-1,-1):
        {{completion}}
    m=min(m,c)

print(m)


","p+=a[j]-p%a[j]
        c+=p//a[j]","p+=a[j]-p%a[j]
        c+=p//a[j]"
"t=lambda:map(int,input().split())
for _ in range(int(input())):{{completion}}","n,m=t();a=[*t()];print(""YNEOS""[sum(a)+max(a)-min(a)+n>m::2])","t=lambda:map(int,input().split())
for _ in range(int(input())):
    n,m=t()
    a=sorted(t())
    print('YNEOS'[sum(max(a[i-1],a[i])for i in range(n))+n>m::2])"
"for _t in range(int(input())):
	n,m = map(int, input().split(' ')) # numbers w/ ws
	a = sorted(map(int, input().split(' ')))

	tot = 0
	dis = 0
	p_i = a[-1]
	for i in a:
		tot += 2*i+1
		if p_i < i:
			dis += p_i
		else:
			{{completion}}
		p_i = i

	if tot-dis <= m:
		print(""YES"")
	else:
		print(""NO"")",dis += i,"print(""YES"")"
"
import sys


def solve():
    {{completion}}


for _ in range(int(input())):
    solve()
","n, m = map(int, input().split())
    num = list(map(int , input().split())) 
    num.sort()
    s = sum(num[1:]) + num[-1] + n
    print(""YES"" if s <= m else ""NO"")","n,m=t();a=[*t()];print(""YNEOS""[sum(a)+max(a)-min(a)+n>m::2])"
"
import sys


def solve():
    n, m = map(int, input().split())
    num = list(map(int , input().split())) 
    num.sort()
    s = sum(num[1:]) + num[-1] + n
    print(""YES"" if s <= m else ""NO"")


for _ in range(int(input())):
    {{completion}}
",solve(),solve()
"import sys
for t in range(int(sys.stdin.readline())):
    n,m = map(int, sys.stdin.readline().strip().split())
    a = list(map(int, sys.stdin.readline().strip().split()))
    if sum(a)-min(a)+max(a) + n <= m:print('yes')
    else:{{completion}}",print('no'),"n, m = map(int, input().split())
    num = list(map(int, input().split())) 
    num.sort()
    s = sum(num[1:]) + num[-1] + n
    print(""YES"" if s <= m else ""NO"")"
"x = lambda: map(int,input().split())
t,= x()
for _ in [1]*t:
    {{completion}}","p,n = x()
    a = [*x()]
    s = sum(a) + (p-1) - min(a)
    print(""YNEOS""[n-1-s<max(a)::2])","t-=1;n,m=x();a=sorted(x());print('YNEOS'[sum(max(a[i-1],a[i])for i in range(n))+n>m::2])"
"def Dist():
    {{completion}}


num_iter = int(input())
for _ in range(num_iter):
    Dist()
    
    ","num_nm = input().split()
    m = int(num_nm[1])
    n = int(num_nm[0])
    
    a = input().split()
    a = list(map(int, a))
    
    wish = n + sum(a) - min(a) + max(a) 
    print(""NO"" if wish >m else ""YES"")","def Dist():
    n,m = map(int,input().split())
    num = list(map(int, input().split())) 
    num.sort()
    s = sum(num[1:]) + num[-1] + n
    print(""YES"" if s <= m else ""NO"")"
"def Dist():
    num_nm = input().split()
    m = int(num_nm[1])
    n = int(num_nm[0])
    
    a = input().split()
    a = list(map(int, a))
    
    wish = n + sum(a) - min(a) + max(a) 
    print(""NO"" if wish >m else ""YES"")


num_iter = int(input())
for _ in range(num_iter):
    {{completion}}
    
    ",Dist(),"num_nm = input().split()
    m = int(num_nm[1])
    n = int(num_nm[0])
    
    a = input().split()
    a = list(map(int, a))
    
    wish = n + sum(a) - min(a) + max(a) 
    print(""NO"" if wish >m else ""YES"")"
"for T in range (int(input())) :
    n,m = map(int, input().strip().split())
    a = sorted(list(map(int,input().strip().split())),reverse=True)
    m -= 2*a[0] + 1
    cont = 0
    for i in range(1,n) :
        if m <= 0 : {{completion}}
        m -= a[i] + 1
        cont +=1

    if cont == n-1 : print('YES')
    else : print ('NO')
",break,"print(""YES"")"
"I=lambda:[*map(int,input().split())]
t,=I()
while t:{{completion}}","t-=1;n,m=I();a=sorted(I());print('YNEOS'[sum(max(a[i-1],a[i])for i in range(n))+n>m::2])","n,m=I();a=I();print(""YNEOS""[sum(a)+max(a)-min(a)+n>m::2])"
"for i in range(int(input())):
	n,m=map(int,input().split())
	a=list(map(int,input().split()))
	if n+sum(a)+max(a)-min(a)>m:
		print(""no"")
	else:
		{{completion}}","print(""yes"")","p,n = x()
    a = [*x()]
    s = sum(a) + (p-1) - min(a)
    print(""YNEOS""[n-1-s<max(a)::2])"
"from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


MOD = 998244353
input = stdin.readline
finp = [int(x) for x in stdin.buffer.read().split()]

def inp(force_list=False):
    re = list(map(int, input().split()))
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def qmod(a, b, mod=MOD):
    res = 1
    while b:
        if b&1:
            res = (res*a)%mod
        b >>= 1
        a = (a*a)%mod
    return res

def inv(a):
    return qmod(a, MOD-2)

INF = 1<<30

class Seg(object):
    def __init__(self, n):
        self._da = [-INF] * (n * 5)
        self._op = [-INF] * (n * 5)

    def update(self, p):
        self._op[p] = max(self._op[p*2], self._op[p*2+1])

    def modify(self, pos, x, p, l, r):
        if l==r-1:
            self._da[p] = self._op[p] = x
            return
        mid = (l+r)//2
        if pos < mid:
            self.modify(pos, x, p*2, l, mid)
        else:
            self.modify(pos, x, p*2 + 1, mid, r)
        self.update(p)

    def query(self, x, y, p, l, r):
        if x <= l and r <= y:
            return self._op[p]
        if x >= r or y<=l:
            return -INF
        mid = (l+r)//2
        return max(self.query(x, y, p*2, l, mid), self.query(x, y, p*2+1, mid, r))


class Fenwick(object):
    def __init__(self, n):
        self._da = [-INF] * (n+2)
        self._mx = n+2

    def max(self, x):
        res = -INF
        while x>0:
            res = max(res, self._da[x])
            x = (x&(x+1))-1
        return res

    def modify(self, p, x):
        while p < self._mx:
            self._da[p] = max(self._da[p], x)
            p |= p+1

def my_main():
    # print(500000)
    # for i in range(500000):
    #     print(1)
    #     print(-1000000000)
    ii = 0 
    kase = finp[ii];ii+=1
    pans = []
    for skase in range(kase):
        # print(""Case #%d: "" % (skase+1), end='')
        n = finp[ii];ii+=1
        da = finp[ii:ii+n];ii+=n
        pref = [0]
        for i in da:
            pref.append(pref[-1] + i)
        spos, sneg = sorted([(pref[i], -i) for i, v in enumerate(pref)]), sorted([(pref[i], i) for i, v in enumerate(pref)])
        ordpos, ordneg = [0] * (n+1), [0] * (n+1)
        pfen, nfen = Fenwick(n), Fenwick(n)
        dmx = {}
        for i in range(n+1):
            ordpos[-spos[i][-1]] = i
            ordneg[sneg[i][-1]] = i
        dp = [0] * (n+1)
        dmx[0] = 0
        pfen.modify(ordpos[0], 0)
        nfen.modify(n+1-ordneg[0], 0)
        for i in range(1, n+1):
            dp[i] = max(i+pfen.max(ordpos[i]), nfen.max(n+1-ordneg[i])-i, dmx.get(pref[i], -INF))
            pfen.modify(ordpos[i], dp[i]-i)
            nfen.modify(n+1-ordneg[i], dp[i]+i)
            if dp[i] > dmx.get(pref[i], -INF):
                {{completion}}
        pans.append(str(dp[n]))
    print('\n'.join(pans))


my_main()


",dmx[pref[i]] = dp[i],"self.modify(pos, x, p, l, mid)"
"from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


MOD = 998244353
input = stdin.readline
finp = [int(x) for x in stdin.buffer.read().split()]

def inp(force_list=False):
    re = list(map(int, input().split()))
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def qmod(a, b, mod=MOD):
    res = 1
    while b:
        if b&1:
            res = (res*a)%mod
        b >>= 1
        a = (a*a)%mod
    return res

def inv(a):
    return qmod(a, MOD-2)

INF = 1<<30

class Seg(object):
    def __init__(self, n):
        self._da = [-INF] * (n * 5)
        self._op = [-INF] * (n * 5)

    def update(self, p):
        self._op[p] = max(self._op[p*2], self._op[p*2+1])

    def modify(self, pos, x, p, l, r):
        if l==r-1:
            self._da[p] = self._op[p] = x
            return
        mid = (l+r)//2
        if pos < mid:
            self.modify(pos, x, p*2, l, mid)
        else:
            {{completion}}
        self.update(p)

    def query(self, x, y, p, l, r):
        if x <= l and r <= y:
            return self._op[p]
        if x >= r or y<=l:
            return -INF
        mid = (l+r)//2
        return max(self.query(x, y, p*2, l, mid), self.query(x, y, p*2+1, mid, r))


class Fenwick(object):
    def __init__(self, n):
        self._da = [-INF] * (n+2)
        self._mx = n+2

    def max(self, x):
        res = -INF
        while x>0:
            res = max(res, self._da[x])
            x = (x&(x+1))-1
        return res

    def modify(self, p, x):
        while p < self._mx:
            self._da[p] = max(self._da[p], x)
            p |= p+1

def my_main():
    # print(500000)
    # for i in range(500000):
    #     print(1)
    #     print(-1000000000)
    ii = 0 
    kase = finp[ii];ii+=1
    pans = []
    for skase in range(kase):
        # print(""Case #%d: "" % (skase+1), end='')
        n = finp[ii];ii+=1
        da = finp[ii:ii+n];ii+=n
        pref = [0]
        for i in da:
            pref.append(pref[-1] + i)
        spos, sneg = sorted([(pref[i], -i) for i, v in enumerate(pref)]), sorted([(pref[i], i) for i, v in enumerate(pref)])
        ordpos, ordneg = [0] * (n+1), [0] * (n+1)
        pfen, nfen = Fenwick(n), Fenwick(n)
        dmx = {}
        for i in range(n+1):
            ordpos[-spos[i][-1]] = i
            ordneg[sneg[i][-1]] = i
        dp = [0] * (n+1)
        dmx[0] = 0
        pfen.modify(ordpos[0], 0)
        nfen.modify(n+1-ordneg[0], 0)
        for i in range(1, n+1):
            dp[i] = max(i+pfen.max(ordpos[i]), nfen.max(n+1-ordneg[i])-i, dmx.get(pref[i], -INF))
            pfen.modify(ordpos[i], dp[i]-i)
            nfen.modify(n+1-ordneg[i], dp[i]+i)
            if dp[i] > dmx.get(pref[i], -INF):
                dmx[pref[i]] = dp[i]
        pans.append(str(dp[n]))
    print('\n'.join(pans))


my_main()


","self.modify(pos, x, p*2 + 1, mid, r)","self.modify(pos, x, p, l, mid)"
"import sys
input = sys.stdin.readline

n = int(input())
ans = []
if n <= 2:
    k = 1
    ans.append("" "".join(map(str, (1, 1))))
elif n == 3:
    k = 2
    ans.append("" "".join(map(str, (1, 1))))
    ans.append("" "".join(map(str, (1, 2))))
else:
    for i in range(100000, -1, -1):
        if 3 * i + 2 <= n:
            {{completion}}
    z = 1
    for i in range(x):
        ans.append("" "".join(map(str, (z + x - i - 1, z + i))))
    z += x
    x += 1
    for i in range(x):
        ans.append("" "".join(map(str, (z + x - i - 1, z + i))))
    z += x
    for i in range((n - 2) % 3):
        ans.append("" "".join(map(str, (z + (n - 2) % 3 - i - 1, z + i))))
    k = len(ans)
print(k)
sys.stdout.write(""\n"".join(ans))","x = i
            break","ans.append("" "".join(map(str, (z + (n - 2) % 3 - i - 1, z + i))))"
"import sys
input = sys.stdin.readline

n = int(input())

o1 = [0] * (n * n)
o2 = [0] * (n * n)
for i in range(n):
    curr = (list(map(int, input().split())))

    for j in range(n):
        {{completion}}
        

row_count = [0] * n
col_count = [0] * n

ct = 0

for u in range(n * n):
    i = o1[u]
    j = o2[u]

    ct += row_count[i] * col_count[j]

    row_count[i] += 1
    col_count[j] += 1


n2 = (n * n - n)//2

ct -= n2 * n2

print(n2 * n2 - ct)
","o1[curr[j] - 1] = i
        o2[curr[j] - 1] = j","o1[As[i][j] - 1] = (i, j)"
"import sys
import random

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N = int(input())
As = [list(map(int, input().split())) for _ in range(N)]

# N = 1500
# As = list(range(1, N ** 2 + 1))
# random.shuffle(As)
# As = [As[i * N:(i + 1) * N] for i in range(N)]

ijs = [0] * (N ** 2)
for i in range(N):
    for j in range(N):
        {{completion}}

answer = 0
row_sum = [0] * N
col_sum = [0] * N
for i, j in ijs:
    l_row = row_sum[i]
    g_row = N - 1 - row_sum[i]
    l_col = col_sum[j]
    g_col = N - 1 - col_sum[j]
    answer += l_col * g_row + g_col * l_row
    row_sum[i] += 1
    col_sum[j] += 1

assert answer % 2 == 0
print(answer // 2)
","ijs[As[i][j] - 1] = (i, j)","ijs[i * N + j] = 1
        row_sum[i] += 1
        col_sum[j] += 1"
"import sys
import bisect

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N, V = map(int, input().split())
Ts = list(map(int, input().split()))
As = list(map(int, input().split()))

points = []
for T, A in zip(Ts, As):
    B = T * V
    x = B - A
    y = B + A
    if x < 0 or y < 0:
        continue
    points.append((x, y))

points.sort()
# print(points)

lis = []
for _, w in points:
    index = bisect.bisect_right(lis, w)
    if index < len(lis):
        lis[index] = w
    else:
        {{completion}}

print(len(lis))

",lis.append(w),print(len(lis))
"from bisect import bisect_right,bisect_left
n,v = map(int,input().split())
t = [*map(int,input().split())]
a = [*map(int,input().split())]
res = []
for i in range(n):
    xi,yi = t[i]*v+a[i],t[i]*v-a[i]
    if(xi>=0 and yi>=0):
        {{completion}}
res.sort()
dp = [float(""inf"")]*(n+3)
dp[0] = 0
dp[n+2] = 0
for i in range(len(res)):
    pos = bisect_right(dp,res[i][1],0,n+2)
    dp[pos] = res[i][1]
for i in range(n,-1,-1):
    if(dp[i]!=float(""inf"")):
        print(i)
        break","res.append((xi,yi))","print(i)
        break"
"from bisect import bisect_right,bisect_left
n,v = map(int,input().split())
t = [*map(int,input().split())]
a = [*map(int,input().split())]
res = []
for i in range(n):
    xi,yi = t[i]*v+a[i],t[i]*v-a[i]
    if(xi>=0 and yi>=0):
        res.append((xi,yi))
res.sort()
dp = [float(""inf"")]*(n+3)
dp[0] = 0
dp[n+2] = 0
for i in range(len(res)):
    pos = bisect_right(dp,res[i][1],0,n+2)
    dp[pos] = res[i][1]
for i in range(n,-1,-1):
    if(dp[i]!=float(""inf"")):
        {{completion}}","print(i)
        break","        print(i)


























































































































"
"t = int(input())
for _ in range(t):

    field = [[0 for _ in range(2*360)] for _ in range(42)]
    vis = [[False for _ in range(2*360)] for _ in range(42)]
    
    n = int(input())
    for _ in range(n):

        line = input().split()
        a, b, c = map(int, line[1:])

        if line[0] == ""C"":
            y = 2*a

            x = 2*b
            while x != 2*c:
                field[y][x] = -1
                x = (x + 1) % 720

            field[y][x] = -1
        else:
            x = 2*c

            for y in range(2*a, 2*b+1):
                field[y][x] = -1


    # for row in field: print(*row)

    def check():
        st = [(0, 0)]

        while st:
            y, x = st.pop(-1)

            x = (x + 720) % 720
            if y < 0 or y >= 42 or field[y][x] < 0: continue

            if vis[y][x]: continue
            vis[y][x] = True

            if y > 40: return True

            for ny in range(y-1, y+1+1):
                for nx in range(x-1, x+1+1):
                    {{completion}}

        return False

    print(""YES"" if check() else ""NO"")
","st.append((ny, nx))",vis[y][x] = True
"from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited

for tc in range(int(input())):
    graph = {}
    for r in range(0, 22):
        for angle in range(0, 360):
            graph[(r,angle)] = set([
                (r, (angle+1)%360),
                (r, (angle-1)%360)])
            if r < 21:
                graph[(r,angle)].add((r+1, angle))
            if r > 0:
                graph[(r,angle)].add((r-1, angle))
    nwalls = int(input())
    for wallid in range(nwalls):
        typ, a, b, c = input().split()
        if typ == 'C':
            rad, t1, t2 = map(int, (a,b,c))
            th = t1
            while th != t2:
                graph[(rad, th)].remove((rad-1, th))
                graph[(rad-1, th)].remove((rad, th))
                th = (th + 1) % 360
                #print(th)
                #print((rad, th%360), (rad-1, th%360))
        else:
            r1, r2, th = map(int, (a,b,c))
            for rad in range(r1, r2):
                {{completion}}
        
    if (0,0) in bfs(graph, (21, 0)):
        print('YES')
    else:
        print('NO')
","graph[(rad, th)].remove((rad, (th-1)%360))
                graph[(rad, (th-1)%360)].remove((rad, th))","































































































































"
"from itertools import islice, chain
from sys import stdin

MAX_RADIUS = 20

lines = iter(stdin.readlines()[1:])

for line in lines:
    n = int(line)
    circular_wall, straight_wall = ([[False] * 360 for _ in range(MAX_RADIUS)] for _ in range(2))
    for shape, *params in map(str.split, islice(lines, n)):
        params = map(int, params)
        if shape == 'C':
            r, theta_1, theta_2 = params
            r -= 1
            theta_range = range(theta_1, theta_2) if theta_1 <= theta_2 \
                else chain(range(theta_1, 360), range(0, theta_2))
            for theta in theta_range:
                circular_wall[r][theta] = True
        else:
            assert shape == 'S'
            r1, r2, theta = params
            r1 -= 1
            r2 -= 1
            for r in range(r1, r2):
                {{completion}}

    queue = [(0, i) for i, inner_wall in enumerate(circular_wall[0]) if not inner_wall]
    seen = set(queue)
    while queue:
        row, col = queue.pop()
        # print(row, col)
        neighbors = []
        if row >= 1 and not circular_wall[row][col]:
            neighbors.append((row - 1, col))
        right_col = (col + 1) % 360
        if not straight_wall[row][right_col]:
            neighbors.append((row, right_col))
        if not straight_wall[row][col]:
            neighbors.append((row, (col - 1) % 360))
        next_row = row + 1
        if not circular_wall[next_row][col]:
            if next_row == MAX_RADIUS - 1:
                print('YES')
                break
            neighbors.append((next_row, col))

        for neighbor in neighbors:
            if neighbor in seen:
                continue
            queue.append(neighbor)
            seen.add(neighbor)
    else:  # no break
        print('NO')
",straight_wall[r][theta] = True,"queue.append((next_row, col))"
"from itertools import chain
from sys import stdin

(n, m), population, shops = [[int(x) for x in line.split()] for line in stdin.readlines()]
shops.sort()
shops = chain([float('-inf')], (v / 100 for v in shops), [float('inf')])

shop_left, shop_right = next(shops), next(shops)
hut_left_idx = max_score = score = 0
for hut_right_idx, hut_right_score in enumerate(population):
    score += hut_right_score
    # print(f'{score=}')
    while shop_right <= hut_right_idx:
        {{completion}}
    # print(f'{hut_right_idx=} {shop_left=} {shop_right=}')
    shop_delta = shop_right - shop_left
    while shop_left >= hut_left_idx or 2 * (hut_right_idx - hut_left_idx) >= shop_delta:
        score -= population[hut_left_idx]
        hut_left_idx += 1
    # print(f'{score=} {hut_left_idx=} {hut_right_idx=} {shop_delta=}')
    if score > max_score:
        max_score = score
print(max_score)
","shop_left, shop_right = shop_right, next(shops)","score -= population[hut_left_idx]
        hut_left_idx += 1"
"from itertools import chain
from sys import stdin

(n, m), population, shops = [[int(x) for x in line.split()] for line in stdin.readlines()]
shops.sort()
shops = chain([float('-inf')], (v / 100 for v in shops), [float('inf')])

shop_left, shop_right = next(shops), next(shops)
hut_left_idx = max_score = score = 0
for hut_right_idx, hut_right_score in enumerate(population):
    score += hut_right_score
    # print(f'{score=}')
    while shop_right <= hut_right_idx:
        shop_left, shop_right = shop_right, next(shops)
    # print(f'{hut_right_idx=} {shop_left=} {shop_right=}')
    shop_delta = shop_right - shop_left
    while shop_left >= hut_left_idx or 2 * (hut_right_idx - hut_left_idx) >= shop_delta:
        {{completion}}
    # print(f'{score=} {hut_left_idx=} {hut_right_idx=} {shop_delta=}')
    if score > max_score:
        max_score = score
print(max_score)
","score -= population[hut_left_idx]
        hut_left_idx += 1","shop_left, shop_right = shop_right, next(shops)"
"n,m=map(int,input().split())
p=list(map(int,input().split()))
x=sorted(list(map(int,input().split())))
s=sum(p[:-(-(x[0])//100)])
for i in range(len(x)-1):
    if x[i]//100+1>=n:
       {{completion}}
    num=int(((x[i+1]-x[i])/2)//(100)+1)
    l=x[i]//100+1
    r=-(-(x[i+1])//100)
    r=min(r,n)
    prefs=0
    if l+num<=r:
        prefs=sum(p[l:l+num])
        s=max(s,prefs)
    while l+num<r:
        prefs-=p[l]
        prefs+=p[l+num] if l+num<n else 0
        s=max(s,prefs)
        l+=1
s=max(s,sum(p[x[-1]//100+1:]))
print(s)",break,"prefs=sum(p[l:l+num])
        s=max(s,prefs)"
"n,m=map(int,input().split())
p=list(map(int,input().split()))
x=sorted(list(map(int,input().split())))
s=sum(p[:-(-(x[0])//100)])
for i in range(len(x)-1):
    if x[i]//100+1>=n:
       break
    num=int(((x[i+1]-x[i])/2)//(100)+1)
    l=x[i]//100+1
    r=-(-(x[i+1])//100)
    r=min(r,n)
    prefs=0
    if l+num<=r:
        {{completion}}
    while l+num<r:
        prefs-=p[l]
        prefs+=p[l+num] if l+num<n else 0
        s=max(s,prefs)
        l+=1
s=max(s,sum(p[x[-1]//100+1:]))
print(s)","prefs=sum(p[l:l+num])
        s=max(s,prefs)",break
"N, M = [int(x) for x in input().split()]
hut = [int(x) for x in input().split()]
shop = [int(x) for x in input().split()]
shop = sorted([-1e9] + shop + [1e9])
events = []
j = 0
for i in range(N):
  while shop[j] < 100*i:
    {{completion}}
  if shop[j] != 100 * i:
    d = min(100*i - shop[j-1], shop[j] - 100*i)
    events.append((100*i-d, hut[i]))
    events.append((100*i+d, -hut[i]))
events.sort()
cont = 0
max = 0
for a in events:
    cont += a[1]
    if cont > max:
        max = cont
print(max)
",j += 1,"d = min(100*i - shop[j-1], shop[j] - 100*i)
    events.append((100*i-d, hut[i]))
    events.append((100*i+d, -hut[i]))"
"N, M = [int(x) for x in input().split()]
hut = [int(x) for x in input().split()]
shop = [int(x) for x in input().split()]
shop = sorted([-1e9] + shop + [1e9])
events = []
j = 0
for i in range(N):
  while shop[j] < 100*i:
    j += 1
  if shop[j] != 100 * i:
    {{completion}}
events.sort()
cont = 0
max = 0
for a in events:
    cont += a[1]
    if cont > max:
        max = cont
print(max)
","d = min(100*i - shop[j-1], shop[j] - 100*i)
    events.append((100*i-d, hut[i]))
    events.append((100*i+d, -hut[i]))",j += 1
"from math import sqrt, floor
from sys import stdin

data = [int(x) for x in stdin.read().split()[1:]]
res = []
for w, l in zip(data[::2], data[1::2]):
    half_perimeter = w + l - 2
    solutions = {1, 2}
    for i in range(2, floor(sqrt(half_perimeter)) + 1):
        div, mod_i = divmod(half_perimeter, i)
        if mod_i != 0:
            continue
        for a in [i, div]:
            mod_a = w % a
            if mod_a <= 2:
                {{completion}}
    res.append(f""{len(solutions)} {' '.join(map(str, sorted(solutions)))}"")
print('\n'.join(res))
","assert (l - 2 + mod_a) % a == 0
                solutions.add(a)","if mod_a <= 2:
        solutions.add(a)"
"t = int(input())
for _ in range(t):
    a, b, c, d = [int(i) for i in input().split()]
    s = input()
    if s.count('A') != a+c+d:
        print(""NO"")
        continue
    ult = 'X'
    k = 0
    z = []
    for x in s:
        if x == ult:
            z.append((k, ult))
            k = 1
        else:
            ult = x
            k += 1
    z.append((k, ult))
    r = 0
    z.sort()
    for k,v in z:
        if k % 2 == 0:
            if v == 'A' and d >= k//2:
                d -= k//2
            elif v == 'B' and c >= k//2:
                {{completion}}
            else:
                r += k//2 - 1
        else:
            r += k//2
    print(""YES"" if r >= c+d else ""NO"")",c -= k//2,r += k//2 - 1
"t = int(input())
for _ in range(t):
    a, b, c, d = [int(i) for i in input().split()]
    s = input()
    if s.count('A') != a+c+d:
        print(""NO"")
        continue
    ult = 'X'
    k = 0
    z = []
    for x in s:
        if x == ult:
            z.append((k, ult))
            k = 1
        else:
            ult = x
            k += 1
    z.append((k, ult))
    r = 0
    z.sort()
    for k,v in z:
        if k % 2 == 0:
            if v == 'A' and d >= k//2:
                d -= k//2
            elif v == 'B' and c >= k//2:
                c -= k//2
            else:
                {{completion}}
        else:
            r += k//2
    print(""YES"" if r >= c+d else ""NO"")",r += k//2 - 1,r += k//2 - 1
"def canmake(s,a,b,c,d):
    anum = s.count('A')
    bnum = s.count('B')

    cnum = s.count('AB')
    dnum = s.count('BA')

    if cnum < c or dnum < d or anum != a + c + d or bnum != b + c + d:
        return False

    n=len(s)

    ans=0

    abls=[]
    bals=[]
    l=0
    while l<n:
        while l<n-1 and  s[l]==s[l+1]:
            l+=1

        r=l
        while r<n-1 and s[r]!=s[r+1]:
            r+=1

        if s[l]== s[r]=='B':
            ans+=(r-l+1)//2
        if s[l]==s[r]=='A':
            ans+=(r-l+1)//2

        if s[l]=='A' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='B' and s[r]=='A':
            bals.append((r-l+1)//2)


        l=r+1
    abls.sort()
    bals.sort()

    for i in abls:
        if i<=c:
            c-=i
        else:

            {{completion}}

    for i in bals:
        if i<=d:
            d-=i
        else:

            c-=i-d-1
            d = 0



    return (c+d)<=ans


t=int(input())

for _ in range(t):
    a,b,c,d=[int(x) for x  in input().split()]
    s=input()
    res=canmake(s,a,b,c,d)
    if res:
        print('YES')
    else:
        print('NO')","d-=i-c-1
            c = 0","c-=i-d-1
            d = 0"
"def canmake(s,a,b,c,d):
    anum = s.count('A')
    bnum = s.count('B')

    cnum = s.count('AB')
    dnum = s.count('BA')

    if cnum < c or dnum < d or anum != a + c + d or bnum != b + c + d:
        return False

    n=len(s)

    ans=0

    abls=[]
    bals=[]
    l=0
    while l<n:
        while l<n-1 and  s[l]==s[l+1]:
            l+=1

        r=l
        while r<n-1 and s[r]!=s[r+1]:
            r+=1

        if s[l]== s[r]=='B':
            ans+=(r-l+1)//2
        if s[l]==s[r]=='A':
            ans+=(r-l+1)//2

        if s[l]=='A' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='B' and s[r]=='A':
            bals.append((r-l+1)//2)


        l=r+1
    abls.sort()
    bals.sort()

    for i in abls:
        if i<=c:
            c-=i
        else:

            d-=i-c-1
            c = 0

    for i in bals:
        if i<=d:
            d-=i
        else:

            {{completion}}



    return (c+d)<=ans


t=int(input())

for _ in range(t):
    a,b,c,d=[int(x) for x  in input().split()]
    s=input()
    res=canmake(s,a,b,c,d)
    if res:
        print('YES')
    else:
        print('NO')","c-=i-d-1
            d = 0","c-=i-d-1
            d = 0"
"for _ in range(int(input())):
    a,b,ab,ba=map(int,input().split());s=input()
    if s.count('A')!=a+ab+ba:print('NO');continue
    stack=[[1,s[0]]]
    for i in range(1,len(s)):
        if stack[-1][1]!=s[i]:
            x=stack.pop()
            stack.append([x[0]+1,s[i]])
        else: stack.append([1,s[i]])
    stack.sort();trash=0
    for val,ele in stack:
        if not val%2:
            if ele=='A' and ba>=val//2:ba-=(val//2)
            elif ele=='B' and ab>=val//2:{{completion}}
            else:trash+=(val//2-1)
        else:
            trash+=(val//2)
    print('YES' if trash>=ab+ba else 'NO')",ab-=(val//2),trash+=(val//2-1)
"for _ in range(int(input())):
    a,b,ab,ba=map(int,input().split());s=input()
    if s.count('A')!=a+ab+ba:print('NO');continue
    stack=[[1,s[0]]]
    for i in range(1,len(s)):
        if stack[-1][1]!=s[i]:
            x=stack.pop()
            stack.append([x[0]+1,s[i]])
        else: stack.append([1,s[i]])
    stack.sort();trash=0
    for val,ele in stack:
        if not val%2:
            if ele=='A' and ba>=val//2:ba-=(val//2)
            elif ele=='B' and ab>=val//2:ab-=(val//2)
            else:{{completion}}
        else:
            trash+=(val//2)
    print('YES' if trash>=ab+ba else 'NO')",trash+=(val//2-1),ab-=(val//2)
"import sys,os,io
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
input = sys.stdin.readline

for _ in range (int(input())):
    c = [int(i) for i in input().split()]
    s = list(input().strip())
    if s.count('A') != c[0] + c[2] + c[3] or s.count('B') != c[1] + c[2] + c[3]:
        print(""NO"")
        continue
    n = len(s)
    a = [[s[0]]]
    for i in range (1,n):
        if s[i]==s[i-1]:
            a.append([s[i]])
        else:
            a[-1].append(s[i])
    extra = 0
    for i in a:
        if len(i)%2:
            c[ord(i[0]) - ord('A')] -= 1
            extra += len(i)//2
    
    a.sort(key = lambda x: len(x))
    
    for i in a:
        if len(i)%2==0:
            cnt = len(i)//2
            if cnt <= c[2 + ord(i[0])-ord('A')]:
                c[2 + ord(i[0]) - ord('A')]-=cnt
            else:
                {{completion}}              
    if min(c)<0 or extra < c[2]+c[3]:
        print(""NO"")
    else:
        print(""YES"")",extra += cnt - 1,extra -= 1
"import sys
import math

def do_test():

    a,b,ab,ba = map(int, input().split())
    S = input().strip()
    n = len(S)
    
    ac = 0
    for i in S:
        if i == 'A':
            ac += 1

    if (ac != a + ab + ba):
        return ""NO""

    

    a_parts = []
    b_parts = []
    ab_total = 0

    l = 0
    f = -1
    p = S[0]
    S = S + S[n-1]
    
    for i in S:
        
        if i == p:
            
            if l > 1:
                if l % 2 == 1:
                    ab_total += l // 2
                elif f == 'A':
                    {{completion}}
                else:
                    b_parts.append(l // 2)
                
            l = 1
            f = i
        else:
            l += 1

        p = i

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = i
        if ba >= k:
            ba -= k
        else:
            k -= ba
            ba = 0
            if ab > 0:
                ab -= k-1

    if ab + ba > ab_total:
        return ""NO""

    return ""YES""               
                

    
    

input = sys.stdin.readline
t = int(input())
for _test_ in range(t):
    print(do_test())

    
    
        
    
    
    
    
    
        
    

    
",a_parts.append(l // 2),b_parts.append(l // 2)
"import sys
import math

def do_test():

    a,b,ab,ba = map(int, input().split())
    S = input().strip()
    n = len(S)
    
    ac = 0
    for i in S:
        if i == 'A':
            ac += 1

    if (ac != a + ab + ba):
        return ""NO""

    

    a_parts = []
    b_parts = []
    ab_total = 0

    l = 0
    f = -1
    p = S[0]
    S = S + S[n-1]
    
    for i in S:
        
        if i == p:
            
            if l > 1:
                if l % 2 == 1:
                    ab_total += l // 2
                elif f == 'A':
                    a_parts.append(l // 2)
                else:
                    {{completion}}
                
            l = 1
            f = i
        else:
            l += 1

        p = i

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = i
        if ba >= k:
            ba -= k
        else:
            k -= ba
            ba = 0
            if ab > 0:
                ab -= k-1

    if ab + ba > ab_total:
        return ""NO""

    return ""YES""               
                

    
    

input = sys.stdin.readline
t = int(input())
for _test_ in range(t):
    print(do_test())

    
    
        
    
    
    
    
    
        
    

    
",b_parts.append(l // 2),a_parts.append(l // 2)
"def solve():
    cnt_a, cnt_b, cnt_ab, cnt_ba = map(int, input().strip().split())
    # print(cntA, cntB, cntAB, cntBA)
    s = input()
    if s.count('A') != cnt_a + cnt_ba + cnt_ab:
        print(""NO"")
        return

    stk = [[1, s[0]]]
    for i in range(1, len(s)):
        if i == 0:
            continue
        c = s[i]
        if c != stk[-1][1]:
            x = stk.pop()
            stk.append([x[0] + 1, c])
        else:
            stk.append([1, c])
    stk.sort()
    rest = 0
    for cnt, last in stk:
        # print(cnt, last)
        if not cnt % 2:
            if last == 'A' and cnt_ba >= (cnt >> 1):
                cnt_ba -= cnt >> 1
            elif last == 'B' and cnt_ab >= (cnt >> 1):
                {{completion}}
            else:
                rest += (cnt >> 1) - 1
        else:
            rest += cnt >> 1
    # print(rest, cnt_ab, cnt_ba)
    if rest >= cnt_ab + cnt_ba:
        print(""YES"")
    else:
        print(""NO"")


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        solve()
",cnt_ab -= cnt >> 1,rest += (cnt >> 1) - 1
"def solve():
    cnt_a, cnt_b, cnt_ab, cnt_ba = map(int, input().strip().split())
    # print(cntA, cntB, cntAB, cntBA)
    s = input()
    if s.count('A') != cnt_a + cnt_ba + cnt_ab:
        print(""NO"")
        return

    stk = [[1, s[0]]]
    for i in range(1, len(s)):
        if i == 0:
            continue
        c = s[i]
        if c != stk[-1][1]:
            x = stk.pop()
            stk.append([x[0] + 1, c])
        else:
            stk.append([1, c])
    stk.sort()
    rest = 0
    for cnt, last in stk:
        # print(cnt, last)
        if not cnt % 2:
            if last == 'A' and cnt_ba >= (cnt >> 1):
                cnt_ba -= cnt >> 1
            elif last == 'B' and cnt_ab >= (cnt >> 1):
                cnt_ab -= cnt >> 1
            else:
                {{completion}}
        else:
            rest += cnt >> 1
    # print(rest, cnt_ab, cnt_ba)
    if rest >= cnt_ab + cnt_ba:
        print(""YES"")
    else:
        print(""NO"")


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        solve()
",rest += (cnt >> 1) - 1,cnt_ab -= cnt >> 1
"import fileinput

lines = []

for line in fileinput.input():
    line_f = [int(x) for x in line.split()]
    if len(line_f) > 0:
        lines.append(line_f)
    # print ffs



for i in range(1, len(lines), 2):
    n = lines[i][0]
    a = lines[i+1]

    b = 123 + 23
    c=  b + 1


    sm = 0
    for elem in a:
        sm += elem

    found = False
    for elem in a:
        lhs = elem
        rhs = ((sm - elem) / (n-1))
        if lhs == rhs:
            {{completion}}
    if found:
        print(""YES"")
    else:
        print(""NO"")
","found = True
            break","print(""YES"")
            return"
"import fileinput

lines = []

for line in fileinput.input():
    line_f = [int(x) for x in line.split()]
    if len(line_f) > 0:
        lines.append(line_f)
    # print ffs



for i in range(1, len(lines), 2):
    n = lines[i][0]
    a = lines[i+1]

    numoddseg = 0
    prev = -1
    i = 0
    while i < n:
        if a[i] < prev:
            numoddseg += 1
            prev = -1
        else:
            {{completion}}
        i += 1

    print(numoddseg)
    ",prev = a[i],numoddseg=0
"from sys import stdin, stderr

data = [int(x) for x in stdin.read().split()[1:]]

ns, ms = data[::2], data[1::2]

output = []
for n, m in zip(ns, ms):
    # n = 2 ** a * 5 ** b * c
    a = b = 0
    c = n
    while c % 2 == 0:
        a += 1
        c //= 2
    while c % 5 == 0:
        b += 1
        c //= 5
    t = 1  # our result should be a multiple of t
    if a > b:
        while a > b and 5 * t <= m:
            t *= 5
            b += 1
    elif b > a:
        while b > a and 2 * t <= m:
            {{completion}}
    while 10 * t <= m:
        t *= 10
    #print(n, m, t, file=stderr)
    output.append(n * (m - (m % t)))

print('\n'.join(str(x) for x in output))
","t *= 2
            a += 1","t = 1 
    if a > b:
        while a > b and 5 * t <= m:
            t *= 5
            b += 1
    elif b > a:
        while b > a and 2 * t <= m:
            t *= 2
            a += 1
    while 10 * t <= m:
        t *= 10
    output.append(n * (m - (m % t)))"
"from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List


def solve() -> None:
  n = next_int()
  k = next_int()
  a = next_int_array(n)
  ndivs = 31
  d = [[0] * ndivs for _ in range(n + 1)]
  for i in range(n-1, -1, -1):
    for j in range(ndivs - 1):
      d[i][j] = max((a[i] >> j) + d[i + 1][j] - k, (a[i] >> (j + 1)) + d[i + 1][j + 1])
  print(d[0][0])


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              {{completion}}
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",solve(),tt[1] = tt[1] + r[1]
"from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List


def solve() -> None:
  n = next_int()
  k = next_int()
  a = next_int_array(n)
  ndivs = 31
  d = [[0] * ndivs for _ in range(n + 1)]
  for i in range(n-1, -1, -1):
    for j in range(ndivs - 1):
      d[i][j] = max((a[i] >> j) + d[i + 1][j] - k, (a[i] >> (j + 1)) + d[i + 1][j + 1])
  print(d[0][0])


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            {{completion}}
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",solve(),"d[i][j] = max((a[i] >> j) + d[i + 1][j] - k, (a[i] >> (j + 1)) + d[i + 1][j + 1])"
"t=int(input())
while(t):
    i=0
    s=input()
    if(len(s)==1):
        print(""NO"")
        t=t-1
        continue
    while(i<len(s)):
        if(i==0):
            if(s[0:2]==""ab"" or s[0:2]==""ba""):
                print(""NO"")
                t=t-1
                break
        if(i>0 and i<len(s)-1):
            if(s[i-1:i+2]==""bab"" or s[i-1:i+2]==""aba""):
                print(""NO"")
                t=t-1
                break
        if(i==len(s)-1):
            if(s[i-1:]==""ba"" or s[i-1:]==""ab""):
                print(""NO"")
                t=t-1
                break
            else:
                {{completion}}
        i+=1
                ","print(""YES"")
                t=t-1
                break","if(s[i-1:]==""ba"" or s[i-1:]==""ab""):
    print(""NO"")
    t=t-1
    break
else:
    print(""YES"")
    t=t-1"
"n = int(input())
s = input()

c = 1


def dfs(i):
    if i >= 2**(n-1)-1:
        {{completion}}
    global c
    l = dfs(2*i + 1)
    r = dfs(2*i + 2)
    if l != r:
        c *= 2
    if l > r:
        l, r = r, l
    return s[i] + l + r


dfs(0)
print(c % 998244353)
",return s[i],c *= 2
"n = int(input())
s = input()

c = 1


def dfs(i):
    if i >= 2**(n-1)-1:
        return s[i]
    global c
    l = dfs(2*i + 1)
    r = dfs(2*i + 2)
    if l != r:
        {{completion}}
    if l > r:
        l, r = r, l
    return s[i] + l + r


dfs(0)
print(c % 998244353)
",c *= 2,return s[i]
"mod=998244353
cnt=0
n=int(input())
s=input()

import random
q=random.randint(10**9,2*10**9)
p=random.randint(10**9,2*10**9)
r=10**9+7

a=[-1]
for i in s:
  if i=='A':
    a.append(p)
  else:
    {{completion}}

for i in range(2**(n-1)-1,0,-1):
  if a[2*i]!=a[2*i+1]:
    cnt+=1
  a[i]=a[i]^(2*a[2*i]+2*a[2*i+1])
  a[i]%=r
  

print(pow(2,cnt,mod))",a.append(q),cnt+=1
"MOD = 998244353
 
n, s = int(input()), input()
 
 
def calc(u: int) -> tuple:
    if u >= (1 << n):
        {{completion}}
    t1, t2 = calc(u * 2), calc(u * 2 + 1)
    return (t1[0] + t2[0] + (t1[1] != t2[1]),
            hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))
 
 
print(pow(2, calc(1)[0], MOD))
","return (0, 0)","return (t1[0] + t2[0] + (t1[1]!= t2[1]),
        hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))"
"def dfs(tree,i,h):
    if i>=2**(h-1)-1:
        return [tree[i],1]
    ls,li=dfs(tree,i*2+1,h)
    rs,ri=dfs(tree,i*2+2,h)
    res=li*ri
    if ls!=rs:
        res*=2
    if ls>rs:
        return [tree[i]+rs+ls,res]
    else:
        {{completion}}


h=int(input())
tree=input()
print(dfs(tree,0,h)[1]%998244353 )
","return [tree[i]+ls+rs,res]","return [tree[i]+rs+ls,res]"
"import sys

N = int(sys.stdin.readline().strip())
s = sys.stdin.readline().strip()

# print(N, s)
m = 1 << N
mod = 998244353


def dfs(i):
    if i >= m: return (1, '')
    ln, ls = dfs(i * 2)
    rn, rs = dfs(i * 2 + 1)
    ln = ln % mod
    rn = rn % mod
    if ls < rs:
        return ln * rn * 2, ls + s[i - 1] + rs
    elif ls > rs:
        {{completion}}
    else:
        return ln * rn, ls + s[i - 1] + rs


n, _ = dfs(1)
print(n % mod)
","return ln * rn * 2, rs + s[i - 1] + ls","return ln * rn, ls + s[i - 1] + rs"
"import sys

N = int(sys.stdin.readline().strip())
s = sys.stdin.readline().strip()

# print(N, s)
m = 1 << N
mod = 998244353


def dfs(i):
    if i >= m: return (1, '')
    ln, ls = dfs(i * 2)
    rn, rs = dfs(i * 2 + 1)
    ln = ln % mod
    rn = rn % mod
    if ls < rs:
        return ln * rn * 2, ls + s[i - 1] + rs
    elif ls > rs:
        return ln * rn * 2, rs + s[i - 1] + ls
    else:
        {{completion}}


n, _ = dfs(1)
print(n % mod)
","return ln * rn, ls + s[i - 1] + rs","return ln * rn, ls + s[i - 1] + rs"
"# trans rights
N = int(input())
N = 2 ** N
S = input()
U = [0] * N
cnt = 0
for i in range(N - 2, -1, -1):
    a = 2 * i + 1
    b = 2 * i + 2
    if b >= N:
        {{completion}}
    if U[a] != U[b]:
        cnt += 1
    U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
    U[i] %= 2 ** 104

print(pow(2, cnt, 998244353))
","U[i] = ord(S[i])
        continue",cnt += 1
"# trans rights
N = int(input())
N = 2 ** N
S = input()
U = [0] * N
cnt = 0
for i in range(N - 2, -1, -1):
    a = 2 * i + 1
    b = 2 * i + 2
    if b >= N:
        U[i] = ord(S[i])
        continue
    if U[a] != U[b]:
        {{completion}}
    U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
    U[i] %= 2 ** 104

print(pow(2, cnt, 998244353))
",cnt += 1,"U[i] = ord(S[i])
        continue"
"import sys;I=sys.stdin.readline;R,P,G=lambda:map(int,I().split()),print,range
n,q=R();n+=1;a=[0]+[*R()];p,s,last,oe=[0]*n,[0]*n,[0]*n,[{},{}]
for i in G(1,n):
  p[i]=a[i]^p[i-1]
  if a[i]==0:s[i]=s[i-1]+1
  d=oe[i&1]
  if p[i] in d:last[i]=d[p[i]]
  oe[i&1][p[i-1]]=i
for _ in G(q):
  l,r=R()
  if s[r]>=r-l+1:P(0)
  elif p[l-1]^p[r] or r-l<2:{{completion}}
  elif (r-l)&1==0 or a[l]==0 or a[r]==0:P(1)
  elif last[r]>l:P(2)
  else:P(-1)",P(-1),P(1)
"import sys;I=sys.stdin.readline;R,P,G=lambda:map(int,I().split()),print,range
n,q=R();n+=1;a=[0]+[*R()];p,s,last,oe=[0]*n,[0]*n,[0]*n,[{},{}]
for i in G(1,n):
  p[i]=a[i]^p[i-1]
  if a[i]==0:s[i]=s[i-1]+1
  d=oe[i&1]
  if p[i] in d:last[i]=d[p[i]]
  oe[i&1][p[i-1]]=i
for _ in G(q):
  l,r=R()
  if s[r]>=r-l+1:P(0)
  elif p[l-1]^p[r] or r-l<2:P(-1)
  elif (r-l)&1==0 or a[l]==0 or a[r]==0:{{completion}}
  elif last[r]>l:P(2)
  else:P(-1)",P(1),P(1)
"import sys

n, q = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]

cur = 0
odd = {}
even = {}
last = [-1]*(n+1)
pxor = [0]*(n+1)
psum = [0]*(n+1)

for i, num in enumerate(a):
    pxor[i+1] = pxor[i] ^ num
    psum[i+1] = psum[i] + num
    cur = pxor[i+1]
    if i&1 == 0:
        if cur in odd:
            last[i+1] = odd[cur]
        even[cur] = i + 1
    else:
        if cur in even:
            last[i+1] = even[cur]
        odd[cur] = i + 1

for _ in range(q):
    l, r = [int(i) for i in sys.stdin.readline().split()]
    if pxor[l-1] != pxor[r]:
        print(""-1"")
    elif psum[l-1] == psum[r]:
        print(""0"")
    else:
        if (r-l)%2==0:
            print(""1"")
        elif a[l-1]==0 or a[r-1]==0:
            {{completion}}
        elif last[r] >= l:
            print(""2"")
        else:
            print(""-1"")

","print(""1"")","print(""2"")"
"import sys

n, q = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]

cur = 0
odd = {}
even = {}
last = [-1]*(n+1)
pxor = [0]*(n+1)
psum = [0]*(n+1)

for i, num in enumerate(a):
    pxor[i+1] = pxor[i] ^ num
    psum[i+1] = psum[i] + num
    cur = pxor[i+1]
    if i&1 == 0:
        if cur in odd:
            last[i+1] = odd[cur]
        even[cur] = i + 1
    else:
        if cur in even:
            last[i+1] = even[cur]
        odd[cur] = i + 1

for _ in range(q):
    l, r = [int(i) for i in sys.stdin.readline().split()]
    if pxor[l-1] != pxor[r]:
        print(""-1"")
    elif psum[l-1] == psum[r]:
        print(""0"")
    else:
        if (r-l)%2==0:
            print(""1"")
        elif a[l-1]==0 or a[r-1]==0:
            print(""1"")
        elif last[r] >= l:
            {{completion}}
        else:
            print(""-1"")

","print(""2"")","print(""2"")"
"import sys
input = sys.stdin.readline
n,q = map(int,input().split())
a = [0] + list(map(int,input().split()))
cml = a[::1]
for i in range(1, n+1):
  a[i] ^= a[i-1]
  cml[i] += cml[i-1]
qs = [list(map(int,input().split())) for i in range(q)]

from collections import defaultdict
d = defaultdict(list)
dd = defaultdict(list)
cnt = defaultdict(int)
ord = [0]*(n+1)
for i in range(n+1):
  dd[a[i]].append(i % 2)
  cnt[a[i]] += 1
  ord[i] = cnt[a[i]]
for k,v in dd.items():
  dd[k] = [0] + v
  for i in range(len(v)+1):
    if i == 0: continue
    else:
      dd[k][i] += dd[k][i-1]
for l,r in qs:
  if a[r] != a[l-1]: 
    print(-1)
  else:
    if cml[r] - cml[l-1] == 0:
      print(0)
    elif (r-l) % 2 == 0 or a[l] == a[l-1] or a[r] == a[r-1]:
      print(1)
    else:
      ll = ord[l-1]-1
      rr = ord[r]
      tot = dd[a[r]][rr] - dd[a[r]][ll]
      if tot == rr-ll or tot == 0:
        print(-1)
      else:
        {{completion}}
",print(2),print(-1)
"import sys
 
def input():
    return sys.stdin.readline().strip()
    
n, q = map(int, input().split())
a = list(map(int, input().split()))
b, s = [0], [0]
nx = [n+5] * (n + 1)
d = {0: [0]}
for i, e in enumerate(a):
    bx = b[-1]^e
    sx = s[-1] + e
    b.append(bx)
    s.append(sx)
    if bx in d.keys():
        if (i + 1 - d[bx][-1]) % 2 == 0:
            d[bx].append(i + 1)
        else:
            for x in d[bx]:
                nx[x] = i + 1
            d[bx] = [i + 1]
    else:
        d[bx] = [i + 1]
        
# print(nx)
for i in range(q):
    l, r = map(int, input().split())
    if b[r] != b[l-1]:
        sys.stdout.write(""-1\n"")
    else:
        if s[r] - s[l-1] == 0:
            sys.stdout.write(""0\n"")
        elif (r - l + 1) % 2:
            sys.stdout.write(""1\n"")
        else:
            if a[l - 1]*a[r - 1] == 0:
                sys.stdout.write(""1\n"")
            elif nx[l-1] <= r:
                {{completion}}
            else:
                sys.stdout.write(""-1\n"")
","sys.stdout.write(""2\n"")","sys.stdout.write(""-1\n"")"
"import sys
 
def input():
    return sys.stdin.readline().strip()
    
n, q = map(int, input().split())
a = list(map(int, input().split()))
b, s = [0], [0]
nx = [n+5] * (n + 1)
d = {0: [0]}
for i, e in enumerate(a):
    bx = b[-1]^e
    sx = s[-1] + e
    b.append(bx)
    s.append(sx)
    if bx in d.keys():
        if (i + 1 - d[bx][-1]) % 2 == 0:
            d[bx].append(i + 1)
        else:
            for x in d[bx]:
                nx[x] = i + 1
            d[bx] = [i + 1]
    else:
        d[bx] = [i + 1]
        
# print(nx)
for i in range(q):
    l, r = map(int, input().split())
    if b[r] != b[l-1]:
        sys.stdout.write(""-1\n"")
    else:
        if s[r] - s[l-1] == 0:
            sys.stdout.write(""0\n"")
        elif (r - l + 1) % 2:
            sys.stdout.write(""1\n"")
        else:
            if a[l - 1]*a[r - 1] == 0:
                sys.stdout.write(""1\n"")
            elif nx[l-1] <= r:
                sys.stdout.write(""2\n"")
            else:
                {{completion}}
","sys.stdout.write(""-1\n"")","sys.stdout.write(""-1\n"")"
"import collections
import sys
input = sys.stdin.readline
def sol(arr, n, m, q):
    xor = [0]
    curr = 0
    for i in arr:
        curr ^= i
        xor.append(curr)
    pre = [0]
    curr = 0
    for i in arr:
        curr += i
        pre.append(curr)
    qd = collections.defaultdict(list)
    for i in range(m):
        qd[q[i][1]].append((q[i][0], i))
    
    
    res = [-1] * m
    last = [collections.defaultdict(int), collections.defaultdict(int)]
    for r in range(1, n + 1):
        last[r & 1][xor[r]] = r
        for l, i in qd[r]:
            if xor[r] ^ xor[l - 1] != 0: 
                res[i] = (-1)
            elif pre[r] == pre[l - 1]: 
                res[i] = (0)
            elif (r - l) & 1 and arr[l - 1] and arr[r - 1]:
                if last[(r & 1) ^ 1][xor[r]] >= l:
                    res[i] = (2)
                else:
                    {{completion}}
            else: 
                res[i] = (1)
    
    for i in res:
        print(i)


n, m = list(map(int,input().split()))
arr = list(map(int,input().split()))
q = []
for i in range(m):
    q.append(list(map(int,input().split())))
(sol(arr, n, m, q))
",res[i] = (-1),"this is the start of the ground truth
sol([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3"
"for t in range(int(input())):
    n = int(input())
    if n == 1:
        {{completion}}
    i = 2
    j = 3*n
    ans = []
    while i<j:
        ans.append((i,j))
        i += 3
        j -= 3
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

","print(""1\n1 2"")
        continue","ans.append((i,j))
        i += 3
        j -= 3"
"for t in range(int(input())):
    n = int(input())
    if n == 1:
        print(""1\n1 2"")
        continue
    i = 2
    j = 3*n
    ans = []
    while i<j:
        {{completion}}
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

","ans.append((i,j))
        i += 3
        j -= 3","ans = []
    while i<j:
        ans.append((i,j))
        i += 3
        j -= 3"
"t = int(input())
for i in range(t):
    n = int(input())
    if n == 1:
    	print(1)
    	print(1,2)
    elif n%2 :
        print(int((n+1)/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            {{completion}}
    else :
        print(int(n/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            print(e,e + int(3*n/2) + 1)","print(e,e + int((3*n)/2))","print(e,e + int(3*n/2) + 1)"
"t = int(input())
for i in range(t):
    n = int(input())
    if n == 1:
    	print(1)
    	print(1,2)
    elif n%2 :
        print(int((n+1)/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            print(e,e + int((3*n)/2))
    else :
        print(int(n/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            {{completion}}","print(e,e + int(3*n/2) + 1)","print(e,e + int(3*n/2) + 1)"
"import math

for _ in [0]*int(input()):
    n=int(input())
    if n==1:
        print(""1"")
        print(""1 2"")
    elif n==2:
        print(""1"")
        print(""2 6"")
    else:
        d=math.ceil(n/2)
        print(d)
        i=1
        j=3*n
        for _ in range(d):
            {{completion}}





","print(str(i)+"" ""+str(j))
            i+=3
            j-=3","print(i,j)"
"from sys import stdin
t = int(stdin.readline().strip())
for i in range(t):
    n = int(stdin.readline().strip())
    b = list('ban'*n)
    if n==1:
        print(1)
        print(1, 2)
    else:
        z = n*3-1
        print(n//2+n%2)
        for i3 in range(n//2+n%2):
            for i2 in range(n*3):
                if b[i2]=='a':
                    {{completion}}","c = b[z]
                    b[z] = 'a'
                    b[i2] = c
                    print(min(i2+1, z+1), max(i2+1, z+1))
                    z-=3
                    break","                    print(i2,i2+z)



















































































































"
"# get testcase input
t = int(input())
result = """"

while t:
    t -= 1
    n = int(input())
    aux = int(n/2 if n%2==0 else n/2+1)

    if n == 1:
        {{completion}}
    
    result += str(aux) + ""\n""
    for i in range(aux):
        result += str(2+3*i) + ' ' + str(3+3*(n-i-1)) + ""\n""
print(result[:-1])","result += ""1\n1 2\n""
        continue","result += str(2+3*i) +'' + str(3+3*(n-i-1)) + ""\n"""
"# get testcase input
t = int(input())
result = """"

while t:
    t -= 1
    n = int(input())
    aux = int(n/2 if n%2==0 else n/2+1)

    if n == 1:
        result += ""1\n1 2\n""
        continue
    
    result += str(aux) + ""\n""
    for i in range(aux):
        {{completion}}
print(result[:-1])","result += str(2+3*i) + ' ' + str(3+3*(n-i-1)) + ""\n""","result += ""1\n1 2\n""
        continue"
"w=int(input())
for i in range(w):
	p=int(input())
	if p%2==0:
		t=p//2
		print(t)
		for k in range(t):
			print((k*3)+2,((p*3)-(k*3)))
	else:
		if p==1:
			print(1)
			print(1,2)
		else:
			t=p//2+1
			print(t)
			print(1,2)
			for k in range(t-1):
				{{completion}}
		","print((k*3)+1+4,((p*3)-(k*3)))","print((k*3)+2,((p*3)-(k*3)))"
"def ban(n):
	if n == 1:
		{{completion}}

	x = 0
	lt = []
	i = 2
	j = 3 * n
	while i < j:
		lt.append([i, j])
		x += 1
		i += 3
		j -= 3

	return [x, lt]

OUTPUT = []
for _ in range(int(input())):
	N = int(input())
	OUTPUT.append(ban(N))

for _ in OUTPUT:
	print(_[0])
	for i in _[1]:
		print(*i)
","return [1, [[1, 2]]]","x += 1
		i += 3
		j -= 3"
"def ban(n):
	if n == 1:
		return [1, [[1, 2]]]

	x = 0
	lt = []
	i = 2
	j = 3 * n
	while i < j:
		{{completion}}

	return [x, lt]

OUTPUT = []
for _ in range(int(input())):
	N = int(input())
	OUTPUT.append(ban(N))

for _ in OUTPUT:
	print(_[0])
	for i in _[1]:
		print(*i)
","lt.append([i, j])
		x += 1
		i += 3
		j -= 3","return [1, [[1, 2]]]"
"for t in range(int(input())):
    n = int(input())
    if n == 1:
        print(1)
        print(""1 2"")

    elif n == 2:
        print(1)
        print(""2 6"")

    else:
        if n % 2 == 0:
            print(n // 2)
            for k in range((n // 2)):
                ans = (3 * k) + 1
                print(ans, (3 * n) - ans + 1)

        else:
            print(n // 2 + 1)
            for k in range((n // 2) + 1):
                {{completion}}
                ","ans = (3 * k) + 1
                print(ans, (3 * n) - ans + 1)","print(""1\n1 2"")
        continue"
"n = int(input())
for i in range(n):
    k = int(input())

    if k == 1:
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
    else:
        t = []
        p = [0, 1, 2] * k
        x, y = 0, len(p) - 1
        while x < y:
            while x < y and p[x] != 1: {{completion}}
            while x < y and p[y] != 2: y -= 1
            if x >= y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
",x += 1,y -= 1
"n = int(input())
for i in range(n):
    k = int(input())

    if k == 1:
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
    else:
        t = []
        p = [0, 1, 2] * k
        x, y = 0, len(p) - 1
        while x < y:
            while x < y and p[x] != 1: x += 1
            while x < y and p[y] != 2: {{completion}}
            if x >= y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
",y -= 1,y -= 1
"input = __import__('sys').stdin.readline


n = int(input())

adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v, x = map(lambda x: int(x)-1, input().split())
    adj[u].append((v, x))
    adj[v].append((u, x))


TRAVERSE = 0
UPDATE_DP = 1

prev_node_stack = [[0] for _ in range(n)]
prev_node = [0]*n
sz = [1]*n
dp_root = [0]*n
dp_remove = [0]*n

stack = [(TRAVERSE, (0, -1, 0))]
while len(stack) > 0:
    state, param = stack.pop()
    if state == TRAVERSE:
        u, par, i = param
        if i < len(adj[u]) and adj[u][i][0] == par:
            i += 1
        if i < len(adj[u]):
            v, x = adj[u][i]
            stack.append((TRAVERSE, (u, par, i+1)))
            stack.append((UPDATE_DP, (v, u, x)))
            stack.append((TRAVERSE, (v, u, 0)))
            prev_node_stack[x].append(v)

    if state == UPDATE_DP:
        v, u, x = param
        prev_node_stack[x].pop()
        sz[u] += sz[v]
        prev_node[v] = prev_node_stack[x][-1]
        if prev_node[v] == 0:
            dp_root[x] += sz[v]
        else:
            {{completion}}


# print('prev_node', prev_node)
# print('dp_root', dp_root)
# print('dp_remove', dp_remove)

ans = sum((sz[v] - dp_remove[v]) * (sz[prev_node[v]] - (dp_root[x] if prev_node[v] == 0 else dp_remove[prev_node[v]]))
    for u in range(n) for v, x in adj[u] if sz[u] > sz[v])
print(ans)
",dp_remove[prev_node[v]] += sz[v],dp_root[x] += sz[v]
"



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))


p=[0]*(n+2)
num=[0]*(n+3)

omomi=defaultdict(int)


nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            p[next]=now
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            x=now
            num[x]=1
            for y in root[x]:
                if y==p[x]:continue
                num[x]+=num[y]
            if x>1:
                c=col[x,p[x]]
                omomi[x,c]+=num[x]
                omomi[nextp[x],c]-=num[x]
            else:
                for c in range(1,n+1):
                    {{completion}}
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)

ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)









","omomi[x,c]+=num[x]",func3(now)
"




##########################



def tree_search(n,G,s,func1,func2,func3):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        if seen[now]==0 and func1!=0:func1(now)
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            if func2!=0:func2(now,next)
            search.append(next)
        else:
            if func3!=0:{{completion}}
            search.pop()

#############################



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))

def cnb(n):
    return n*(n-1)//2

p=[0]*(n+2)
num=[0]*(n+3)
dp=[defaultdict(int) for i in range(n+3)]
omomi=defaultdict(int)

def f2(x,y):
    p[y]=x

def f3(x):
    num[x]=1
    for y in root[x]:
        if y==p[x]:continue
        num[x]+=num[y]

    for y in root[x]:
        if y==p[x]:continue
        if len(dp[x])<len(dp[y]):
            res=dp[y]
            for ke in dp[x]:res[ke]+=dp[x][ke]
        else:
            res = dp[x]
            for ke in dp[y]: res[ke] += dp[y][ke]
        dp[x] = res
    if x>1:
        c=col[x,p[x]]
        omomi[x,c]=num[x]-dp[x][c]
        dp[x][c]=num[x]
    else:
        for c in range(1,n+1):
            omomi[1,c]=num[1]-dp[1][c]

tree_search(n,root,1,0,f2,f3)
nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)


ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)






",func3(now),res[ke] += dp[y][ke]
"




##########################



def tree_search(n,G,s,func1,func2,func3):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        if seen[now]==0 and func1!=0:func1(now)
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            if func2!=0:func2(now,next)
            search.append(next)
        else:
            if func3!=0:func3(now)
            search.pop()

#############################



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))

def cnb(n):
    return n*(n-1)//2

p=[0]*(n+2)
num=[0]*(n+3)
dp=[defaultdict(int) for i in range(n+3)]
omomi=defaultdict(int)

def f2(x,y):
    p[y]=x

def f3(x):
    num[x]=1
    for y in root[x]:
        if y==p[x]:continue
        num[x]+=num[y]

    for y in root[x]:
        if y==p[x]:continue
        if len(dp[x])<len(dp[y]):
            res=dp[y]
            for ke in dp[x]:res[ke]+=dp[x][ke]
        else:
            res = dp[x]
            for ke in dp[y]: {{completion}}
        dp[x] = res
    if x>1:
        c=col[x,p[x]]
        omomi[x,c]=num[x]-dp[x][c]
        dp[x][c]=num[x]
    else:
        for c in range(1,n+1):
            omomi[1,c]=num[1]-dp[1][c]

tree_search(n,root,1,0,f2,f3)
nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)


ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)






",res[ke] += dp[y][ke],func3(now)
"import sys
input = sys.stdin.readline
N = int(input())
logN = (N - 2).bit_length()

door = []
for _ in range(N - 1):
    _, a, b, _ = map(int, input().split())
    door.append([a - 1, b - 1])

# door = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(N - 1)]

dist = [[[-1] * 4 for _ in range(logN)] for _ in range(N - 2)]

'''
0: 0->0
1: 0->1
2: 1->0
3: 1->1
'''

for i in range(N - 2):
    d1 = abs(i - door[i][1]) + abs(door[i][0] - i)
    dist[i][0][0] = abs(door[i][0] - door[i + 1][0]) + 1
    dist[i][0][3] = abs(door[i][1] - door[i + 1][1]) + 1
    dist[i][0][1] = min(
        abs(i + 1 - door[i + 1][1]) + abs(door[i][0] - (i + 1)) + 1,
        d1 + dist[i][0][3]
    )
    dist[i][0][2] = min(
        abs(door[i][1] - (i + 1)) + abs(i + 1 - door[i + 1][0]) + 1,
        d1 + dist[i][0][0]
    )

for j in range(1, logN):
    k = 1 << (j - 1)
    for i in range(N - 1 - (1 << j)):
        for fr in range(2):
            for to in range(2):
                {{completion}}

Q = int(input())
for _ in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x) - 1, input().split())
    l1 = max(h1, w1)
    l2 = max(h2, w2)
    if l1 == l2:
        print(abs(h1 - h2) + abs(w1 - w2))
        continue
    if l1 > l2:
        l1, l2 = l2, l1
        h1, w1, h2, w2 = h2, w2, h1, w1
    now = l1
    l = l2 - l1 - 1
    d0 = abs(h1 - now) + abs(w1 - door[now][0])
    d1 = abs(h1 - door[now][1]) + abs(w1 - now)
    for i in range(logN - 1, -1, -1):
        if l >> i & 1:
            d0, d1 = min(d0 + dist[now][i][0], d1 + dist[now][i][2]), min(d0 + dist[now][i][1], d1 + dist[now][i][3])
            now += 1 << i
    print(min(d0 + abs(now + 1 - h2) + abs(door[now][0] - w2), d1 + abs(door[now][1] - h2) + abs(now + 1 - w2)) + 1)","dist[i][j][fr << 1 | to] = min(
                    dist[i][j - 1][fr << 1] + dist[i + k][j - 1][to],
                    dist[i][j - 1][fr << 1 | 1] + dist[i + k][j - 1][2 | to]
                )","d0, d1 = min(d0 + dist[now][i][0], d1 + dist[now][i][2]), min(d0 + dist[now][i][1], d1 + dist[now][i][3])
now += 1 << i"
"input = __import__('sys').stdin.readline


def manhattan(A, B, dA=None, dB=None):
    if dA is not None:
        A = list(A)
        A[0] += dA[0]
        A[1] += dA[1]
    if dB is not None:
        B = list(B)
        B[0] += dB[0]
        B[1] += dB[1]
    return abs(A[0] - B[0]) + abs(A[1] - B[1])


n = int(input())
a = []
for _ in range(n-1):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    a.append((
        (x1, y1),
        (x2, y2),
    ))
a.append((
    (a[-1][0][0] + 1, a[-1][0][1]),
    (a[-1][1][0], a[-1][1][1] + 1),
))

jump = [
    [
        (
            min(manhattan(a[i][0], a[i+1][0], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][0], dA=(0, 1))) + 1,
            min(manhattan(a[i][0], a[i+1][1], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][1], dA=(0, 1))) + 1,
            min(manhattan(a[i][1], a[i+1][0], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][0], dA=(1, 0))) + 1,
            min(manhattan(a[i][1], a[i+1][1], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][1], dA=(1, 0))) + 1,
        ) for i in range(n-1)
    ]
]


def merge(A, B):
    return (
        min(A[0] + B[0], A[1] + B[2]),
        min(A[0] + B[1], A[1] + B[3]),
        min(A[2] + B[0], A[3] + B[2]),
        min(A[2] + B[1], A[3] + B[3]),
    )

# print(jump[0])
for j in range(20):
    jump.append([
        merge(jump[j][i], jump[j][i + (1 << j)]) for i in range(len(jump[j]) - (1 << j))
    ])
    # print(jump[-1])


for _ in range(int(input())):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    m1, m2 = max(x1, y1), max(x2, y2)
    if m1 > m2:
        m1, m2 = m2, m1
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    
    if m1 == m2:
        print(manhattan((x1, y1), (x2, y2)))
        continue
    
    s = m1
    sz = m2 - m1 - 1
    dist = None
    for i in range(20):
        if (sz >> i) & 1 == 1:
            if dist is None:
                dist = jump[i][s]
            else:
                {{completion}}
            s += (1 << i)
    
    if m1 + 1 == m2:
        dist = (0, manhattan(a[m1][0], a[m1][1]), manhattan(a[m1][1], a[m1][0]), 0)
    # print('dist', dist, a[m1], a[m2-1])
    # print('>', manhattan((x1, y1), a[m1][0]), dist[0], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][0]), dist[1], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[2], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[3], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print([
    #     manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    # ])
    print(min(
        manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    ))","dist = merge(dist, jump[i][s])",dist = jump[i][s]
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


def isMountain(ar):
    prefixInc = [False] * len(ar)
    prefixInc[0] = 1
    for i in range(1, len(ar)):
        prefixInc[i] = prefixInc[i - 1] and ar[i - 1] <= ar[i]

    suffixInc = [0] * len(ar)
    suffixInc[-1] = 1
    for i in range(len(ar) - 2, -1, -1):
        suffixInc[i] = suffixInc[i + 1] and ar[i] >= ar[i + 1]

    ans = prefixInc[-1] or suffixInc[0]
    for i in range(len(ar)):
        ans = ans or (prefixInc[i] and suffixInc[i])
    return ans

testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)
    print(""yes"" if isMountain(A) else ""no"")


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        {{completion}}
    assert not tokens",solve(tc + 1),prefixInc[i] = prefixInc[i - 1] and ar[i - 1] <= ar[i]
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


def isMountain(ar):
    prefixInc = [False] * len(ar)
    prefixInc[0] = 1
    for i in range(1, len(ar)):
        {{completion}}

    suffixInc = [0] * len(ar)
    suffixInc[-1] = 1
    for i in range(len(ar) - 2, -1, -1):
        suffixInc[i] = suffixInc[i + 1] and ar[i] >= ar[i + 1]

    ans = prefixInc[-1] or suffixInc[0]
    for i in range(len(ar)):
        ans = ans or (prefixInc[i] and suffixInc[i])
    return ans

testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)
    print(""yes"" if isMountain(A) else ""no"")


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",prefixInc[i] = prefixInc[i - 1] and ar[i - 1] <= ar[i],solve(tc + 1)
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    P = [getIntArray(2) for i in range(N)] + [[0, 0]]
    minX = abs(min(p[0] for p in P))
    maxX = abs(max(p[0] for p in P))
    minY = abs(min(p[1] for p in P))
    maxY = abs(max(p[1] for p in P))
    print(minX + minY + maxX + maxY << 1)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        {{completion}}
    assert not tokens",solve(tc + 1),minX + minY + maxX + maxY << 1
"a=[*map(int,[*open(0)][1].split())]
for k in 0,1:
	for i in range(19):
		z=1<<i
		for j in range(len(a)):
			if j&z:{{completion}}
print(*reversed(a))
",a[j-k*z]^=a[j+k*z-z],a[j]^=a[l]
"a=[*map(int,[*open(0)][1].split())]
n=len(a)
for k in 0,1:
    for i in range(19):
        for j in range(n):
            l=j^1<<i
            if k^(l<j)and l<n:
                {{completion}}
print(*reversed(a))
",a[j]^=a[l],a[j-k*z]^=a[j+k*z-z]
"input()
n = int(input(), 2)
m = n
for i in range(30):
    {{completion}}
print(bin(n)[2:])","n = max(n, m | m >> i)",n = n | n >> i
"n = int(input())
s=input()
b=int(s,2)
a=b;
mx=a|b
for i in range(0,7):
  a=a>>1
  m=a|b
  if m>mx:
    {{completion}}
st=format(mx ,""b"")
print(st)",mx=m,"mx=max(mx,a|b)"
"n = input()
s = int(input(),2)

res = 0
for i in range(100):
    {{completion}}
ans = bin(res)[2:]
print(ans)","res = max(res,(s | (s >> i)))","res = max(res, s | s >> i)"
"input()
n=int(input(),2)
ans=0
for i in range(1,64):
    {{completion}}
print(bin(ans)[2:])

","ans=max(ans,n|(n>>i))","ans = max(ans, (s | (s >> i)))"
"n = input()
s = int(input(), base=2)
t = s
for i in range(1,10):
    {{completion}}
print(""{0:b}"".format(t))","t = max(t, s | s >> i)","t = max(t, s | (s >> i))"
"n = int(input())
s = input().strip()

s1 = int('0b'+s,2)
res = s1

for i in range(1,8):
    {{completion}}

print(bin(res)[2:])","res = max(s1 | (s1 >> i), res)",s1 = s1 | s1 >> i
"def random(st):
	n = 8
	st = int(st, 2)
	MAX = st
	for t in range(n):
		{{completion}}

	return bin(MAX)[2:]


N = input()
b = input()
print(random(b))
","MAX = max((st >> t) | st, MAX)","MAX = st
for t in range(n):
    MAX = max(MAX, st | (st >> t))"
"# وده اقل حاجه ببايثون
input()
n=int(input(),2)
m=n
for i in range(1,100):{{completion}}
print(""{0:b}"".format(m))","m=max(m,n|n>>i)","m=max(m,n|n>>i)"
"n = int(input())
a = int(input(), 2)
temp = a
mx = a|temp
for i in range(7):
    temp = temp >> 1
    m = a|temp
    if mx < m:
        {{completion}}

print(bin(mx).replace('0b', ''))
",mx = m,"mx = max(mx, a|temp)"
"import sys
import heapq
from collections import Counter
# sys.setrecursionlimit(10000)


def input_general():
    return sys.stdin.readline().rstrip('\r\n')


def input_num():
    return int(sys.stdin.readline().rstrip(""\r\n""))


def input_multi(x=int):
    return map(x, sys.stdin.readline().rstrip(""\r\n"").split())


def input_list(x=int):
    return list(input_multi(x))


def main():
    def mod_pow(p, a, e):
        base = a
        answer = 1

        while e:
            if e & 1:
                {{completion}}

            base = (base * base) % p
            e >>= 1
        return answer

    n = input_num()
    hp = []
    pos = [[] for _ in range(300001)]
    for i in range(n):
        l, r = input_multi()
        pos[l].append((i, r + 1))

    P = 998244353
    two_inv = (P + 1) // 2

    loc = [-1] * 300001
    for i in range(300001):
        for (idx, r) in pos[i]:
            heapq.heappush(hp, (-idx, r))

        while hp and hp[0][1] <= i:
            heapq.heappop(hp)

        if hp:
            loc[i] = -hp[0][0]

    ctr = Counter(loc)
    max_loc = max(ctr.keys())

    curr = mod_pow(P, 2, n - 1)

    answer = (curr * (ctr[0] + ctr[1])) % P
    for i in range(2, max_loc + 1):
        curr = (curr * two_inv * 3) % P
        answer = (answer + curr * ctr[i]) % P

    print(answer)


if __name__ == ""__main__"":
    # cases = input_num()
    #
    # for _ in range(cases):
    main()
",answer = (answer * base) % p,"heapq.heappush(hp, (-idx, r))"
"import sys
import heapq
from collections import Counter
# sys.setrecursionlimit(10000)


def input_general():
    return sys.stdin.readline().rstrip('\r\n')


def input_num():
    return int(sys.stdin.readline().rstrip(""\r\n""))


def input_multi(x=int):
    return map(x, sys.stdin.readline().rstrip(""\r\n"").split())


def input_list(x=int):
    return list(input_multi(x))


def main():
    def mod_pow(p, a, e):
        base = a
        answer = 1

        while e:
            if e & 1:
                answer = (answer * base) % p

            base = (base * base) % p
            e >>= 1
        return answer

    n = input_num()
    hp = []
    pos = [[] for _ in range(300001)]
    for i in range(n):
        l, r = input_multi()
        pos[l].append((i, r + 1))

    P = 998244353
    two_inv = (P + 1) // 2

    loc = [-1] * 300001
    for i in range(300001):
        for (idx, r) in pos[i]:
            {{completion}}

        while hp and hp[0][1] <= i:
            heapq.heappop(hp)

        if hp:
            loc[i] = -hp[0][0]

    ctr = Counter(loc)
    max_loc = max(ctr.keys())

    curr = mod_pow(P, 2, n - 1)

    answer = (curr * (ctr[0] + ctr[1])) % P
    for i in range(2, max_loc + 1):
        curr = (curr * two_inv * 3) % P
        answer = (answer + curr * ctr[i]) % P

    print(answer)


if __name__ == ""__main__"":
    # cases = input_num()
    #
    # for _ in range(cases):
    main()
","heapq.heappush(hp, (-idx, r))",answer = (answer * base) % p
"import sys
input = sys.stdin.readline

class Heap():
    def __init__(self):
        self.arr = []

    def append(self, x):
        self.arr.append(x)

        i = len(self.arr)-1
        while i > 0 and self.arr[i] < self.arr[(i-1)//2]:
            self.arr[i], self.arr[(i-1)//2] = self.arr[(i-1)//2], self.arr[i]

            i = (i-1)//2

    def pop(self):
        self.arr[-1], self.arr[0] = self.arr[0], self.arr[-1]

        self.arr.pop(-1)

        i = 0
        while i*2+1 < len(self.arr):
            if i*2+2 < len(self.arr) and self.arr[i*2+2] < self.arr[i*2+1]:
                if self.arr[i*2+2] < self.arr[i]:
                    self.arr[i], self.arr[i*2+2] = self.arr[i*2+2], self.arr[i]

                    i = i*2+2
                else:
                    break
            else:
                if self.arr[i*2+1] < self.arr[i]:
                    self.arr[i], self.arr[i*2+1] = self.arr[i*2+1], self.arr[i]

                    i = i*2+1
                else:
                    {{completion}}

    def top(self):
        return self.arr[0]

n = int(input())

difArr = [[] for _ in range(3*10**5+10)]
for i in range(n):
    l,r = [int(x) for x in input().split()]

    difArr[l].append(n-i)
    difArr[r+1].append(n-i)

ans = 0
heap = Heap()
active = set()
for i in range(3*10**5+1):
    for x in difArr[i]:
        if x in active:
            active.remove(x)

            while len(heap.arr) > 0 and heap.top() not in active:
                heap.pop()
                
        else:
            active.add(x)
            heap.append(x)

    if len(active) > 0:
        ans += pow(3, max(0, n-heap.top()-1), 998244353) * pow(2, min(n-1, heap.top()), 998244353)
        ans = ans % 998244353

print(ans)",break,self.push(l >> i)
"import sys
input = sys.stdin.readline

class Heap():
    def __init__(self):
        self.arr = []

    def append(self, x):
        self.arr.append(x)

        i = len(self.arr)-1
        while i > 0 and self.arr[i] < self.arr[(i-1)//2]:
            self.arr[i], self.arr[(i-1)//2] = self.arr[(i-1)//2], self.arr[i]

            i = (i-1)//2

    def pop(self):
        self.arr[-1], self.arr[0] = self.arr[0], self.arr[-1]

        self.arr.pop(-1)

        i = 0
        while i*2+1 < len(self.arr):
            if i*2+2 < len(self.arr) and self.arr[i*2+2] < self.arr[i*2+1]:
                if self.arr[i*2+2] < self.arr[i]:
                    self.arr[i], self.arr[i*2+2] = self.arr[i*2+2], self.arr[i]

                    i = i*2+2
                else:
                    {{completion}}
            else:
                if self.arr[i*2+1] < self.arr[i]:
                    self.arr[i], self.arr[i*2+1] = self.arr[i*2+1], self.arr[i]

                    i = i*2+1
                else:
                    break

    def top(self):
        return self.arr[0]

n = int(input())

difArr = [[] for _ in range(3*10**5+10)]
for i in range(n):
    l,r = [int(x) for x in input().split()]

    difArr[l].append(n-i)
    difArr[r+1].append(n-i)

ans = 0
heap = Heap()
active = set()
for i in range(3*10**5+1):
    for x in difArr[i]:
        if x in active:
            active.remove(x)

            while len(heap.arr) > 0 and heap.top() not in active:
                heap.pop()
                
        else:
            active.add(x)
            heap.append(x)

    if len(active) > 0:
        ans += pow(3, max(0, n-heap.top()-1), 998244353) * pow(2, min(n-1, heap.top()), 998244353)
        ans = ans % 998244353

print(ans)",break,self.push(l >> i)
"import sys
input=sys.stdin.readline
from collections import defaultdict
from heapq import heappop,heappush

def solve():
    N=int(input())
    p=998244353

    # 2와 3의 거듭제곱 저장
    two=[1]
    for _ in range(N):
        two.append((two[-1]*2)%p)
    three=[1]
    for _ in range(N):
        three.append((three[-1]*3)%p)

    # 각 원소별로 마지막 출현 인덱스 저장
    def lazy(n,cur,start,end,left,right):
        if end<left or right<start:
            return
        elif left<=start and end<=right:
            st[cur]=n
        else:
            lazy(n,2*cur,start,(start+end)//2,left,right)
            lazy(n,2*cur+1,(start+end)//2+1,end,left,right)
    def update(cur,start,end):
        if start==end:
            last[start]=st[cur]
            return
        if 2*cur<1200000:
            if st[2*cur]<st[cur]:
                {{completion}}
            update(2*cur,start,(start+end)//2)
        if 2*cur+1<1200000:
            if st[2*cur+1]<st[cur]:
                st[2*cur+1]=st[cur]
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input().split())
        lazy(n,1,0,300000,a,b)
    update(1,0,300000)

    # last값을 기준으로 마지막 연산
    ans=0
    A=defaultdict(int)
    for l in last:
        if l!=0:
            A[l]+=1
    for l in A:
        ans=(ans+A[l]*(three[l-1]*two[N-l]))%p
    print(ans)
solve()",st[2*cur]=st[cur],st[2*cur+1]=st[cur]
"import sys
input=sys.stdin.readline
from collections import defaultdict
from heapq import heappop,heappush

def solve():
    N=int(input())
    p=998244353

    # 2와 3의 거듭제곱 저장
    two=[1]
    for _ in range(N):
        two.append((two[-1]*2)%p)
    three=[1]
    for _ in range(N):
        three.append((three[-1]*3)%p)

    # 각 원소별로 마지막 출현 인덱스 저장
    def lazy(n,cur,start,end,left,right):
        if end<left or right<start:
            return
        elif left<=start and end<=right:
            st[cur]=n
        else:
            lazy(n,2*cur,start,(start+end)//2,left,right)
            lazy(n,2*cur+1,(start+end)//2+1,end,left,right)
    def update(cur,start,end):
        if start==end:
            last[start]=st[cur]
            return
        if 2*cur<1200000:
            if st[2*cur]<st[cur]:
                st[2*cur]=st[cur]
            update(2*cur,start,(start+end)//2)
        if 2*cur+1<1200000:
            if st[2*cur+1]<st[cur]:
                {{completion}}
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input().split())
        lazy(n,1,0,300000,a,b)
    update(1,0,300000)

    # last값을 기준으로 마지막 연산
    ans=0
    A=defaultdict(int)
    for l in last:
        if l!=0:
            A[l]+=1
    for l in A:
        ans=(ans+A[l]*(three[l-1]*two[N-l]))%p
    print(ans)
solve()",st[2*cur+1]=st[cur],st[2*cur+1]=st[cur]
"from collections import deque;I=input;R=lambda:map(int,I().split())
def f(x,pre):
  global flg;dp=[0]*(n+1)
  q=deque([(x,pre)]);R=[]
  while q:
    u,p=q.popleft()
    R.append((u))
    for v in g[u]:
      if v!=p:{{completion}}
  for u in R[::-1]:
    path=0;dp[u]+=1 if u in s else 0
    for v in g[u]:
      path+=(1 if dp[v] else 0);dp[u]+=dp[v]
    flg=flg and (path<=1 or path==2 and k==dp[u])
  return dp[x]

n=int(I());g=[[] for _ in range(n+1)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)
for _ in [0]*int(I()):
  k=int(I());flg=1;s=set(R());f(1,0)
  print(['NO','YES'][flg])","q.append((v,u))",dp[u]+=1 if u in s else 0
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
from collections import deque
n=I();adj=[[] for i in range(n)]
for i in range(n-1):
    p,q=M()
    adj[p-1].append(q-1)
    adj[q-1].append(p-1)
p=[-1]*n;d=[0]*n
q=deque([0]);v=[0]*n
while q:
    r=q.popleft()
    v[r]=1
    for j in adj[r]:
        if v[j]==0:
            {{completion}}
q=I()
for i in range(q):
    k=I()
    a=L();y=a[:]
    f=0;z=[]
    j=0;m=0;s=set()
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s1=set();x=0
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s and p[j]!=-1:
        s1.add(j);j=p[j]
    for t in range(len(z)-1,-1,-1):
        if z[t]==j:x=1
        if x==1:s1.add(z[t])
    for i in y:
        if i-1 not in s1:f=1;break
    print(""NO"" if f else ""YES"")",q.append(j);d[j]=d[r]+1;p[j]=r,m=d[i-1];j=i-1
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
from collections import deque
n=I();adj=[[] for i in range(n)]
for i in range(n-1):
    p,q=M()
    adj[p-1].append(q-1)
    adj[q-1].append(p-1)
p=[-1]*n;d=[0]*n
q=deque([0]);v=[0]*n
while q:
    r=q.popleft()
    v[r]=1
    for j in adj[r]:
        if v[j]==0:
            q.append(j);d[j]=d[r]+1;p[j]=r
q=I()
for i in range(q):
    k=I()
    a=L();y=a[:]
    f=0;z=[]
    j=0;m=0;s=set()
    for i in a:
        if d[i-1]>m:{{completion}}
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s1=set();x=0
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s and p[j]!=-1:
        s1.add(j);j=p[j]
    for t in range(len(z)-1,-1,-1):
        if z[t]==j:x=1
        if x==1:s1.add(z[t])
    for i in y:
        if i-1 not in s1:f=1;break
    print(""NO"" if f else ""YES"")",m=d[i-1];j=i-1,q.append(j);d[j]=d[r]+1;p[j]=r
"def solve():
    n = int(input())
    g = [[] for _ in range(n)]

    for _ in range(n-1):
        u, v = [int(t) for t in input().split()]
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)

    q = int(input())
    for _ in range(q):
        input()
        S = [int(t)-1 for t in input().split()]

        in_S = [0] * n
        for v in S:
            in_S[v] = 1

        v = S[0]
        w = farthest(g, v, in_S)
        y = farthest(g, w, in_S)
        P = set(path(g, w, y))
        ans = ""YES"" if P.issuperset(S) else ""NO""

        print(ans)


def farthest(g, v, in_S):
    queue = [v]
    depth = [-1] * len(g)
    depth[v] = 0
    res = (0, v)
    for v in queue:
        if in_S[v]:
            res = max(res, (depth[v], v))
        for nei in g[v]:
            if depth[nei] == -1:
                {{completion}}
    return res[1]

def path(g, st, en):
    queue = [st]
    prev = [-1] * len(g)
    prev[st] = st
    for v in queue:
        for nei in g[v]:
            if prev[nei] == -1:
                queue.append(nei)
                prev[nei] = v

    res = [en]
    while prev[res[-1]] != res[-1]:
        res.append(prev[res[-1]])

    return res[::-1]


import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

solve()

os.write(1, stdout.getvalue())","queue.append(nei)
                depth[nei] = depth[v] + 1","queue.append(nei)
                prev[nei] = v"
"def solve():
    n = int(input())
    g = [[] for _ in range(n)]

    for _ in range(n-1):
        u, v = [int(t) for t in input().split()]
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)

    q = int(input())
    for _ in range(q):
        input()
        S = [int(t)-1 for t in input().split()]

        in_S = [0] * n
        for v in S:
            in_S[v] = 1

        v = S[0]
        w = farthest(g, v, in_S)
        y = farthest(g, w, in_S)
        P = set(path(g, w, y))
        ans = ""YES"" if P.issuperset(S) else ""NO""

        print(ans)


def farthest(g, v, in_S):
    queue = [v]
    depth = [-1] * len(g)
    depth[v] = 0
    res = (0, v)
    for v in queue:
        if in_S[v]:
            res = max(res, (depth[v], v))
        for nei in g[v]:
            if depth[nei] == -1:
                queue.append(nei)
                depth[nei] = depth[v] + 1
    return res[1]

def path(g, st, en):
    queue = [st]
    prev = [-1] * len(g)
    prev[st] = st
    for v in queue:
        for nei in g[v]:
            if prev[nei] == -1:
                {{completion}}

    res = [en]
    while prev[res[-1]] != res[-1]:
        res.append(prev[res[-1]])

    return res[::-1]


import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

solve()

os.write(1, stdout.getvalue())","queue.append(nei)
                prev[nei] = v","queue.append(nei)
                depth[nei] = depth[v] + 1"
"import sys
from array import array


class graph:
    def __init__(self, n):
        self.n, self.gdict = n, [array('i') for _ in range(n + 1)]

    def add_edge(self, node1, node2):
        self.gdict[node1].append(node2)
        self.gdict[node2].append(node1)

    def dfs(self, root):
        stk, ret = array('i', [root]), 0

        while stk:
            node = stk.pop()
            for ch in self.gdict[node]:
                if not vis[ch]:
                    vis[ch] = True

                    while mem[ch] and stk:
                        {{completion}}

                    ret |= mem[ch]
                    stk.append(ch)
        return ret


input = lambda: sys.stdin.buffer.readline().decode().strip()
n = int(input())
g = graph(n)

for _ in range(n - 1):
    u, v = map(int, input().split())
    g.add_edge(u, v)

for i in range(int(input())):
    k, a = int(input()), array('i', [int(x) for x in input().split()])
    vis = array('b', [False] * (n + 1))
    mem = array('b', [0] * (n + 1))
    vis[a[0]], paths = 1, 0

    for j in a:
        mem[j] = 1

    for j in g.gdict[a[0]]:
        vis[j] = 1
        paths += g.dfs(j) | mem[j]

    for j in a:
        if not vis[j]:
            paths = 3
            break

    print('yes' if paths < 3 else 'no')
",vis[stk.pop()] = 0,mem[j] = 1
"from collections import deque
import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
    
    # build a tree with BFS
    par = [-1] * n
    depth = [0] * n
    q = deque([0])
    while q:
        u = q.popleft()
        for v in G[u]:
            if v != par[u]:
                {{completion}}

    # Path to LCA
    def build_path(u, v):
        path = []
        if depth[u] < depth[v]:
            u, v = v, u
        while depth[u] > depth[v]:
            path.append(u)
            u = par[u]
        while u != v:
            path.append(u)
            path.append(v)
            u, v = par[u], par[v]
        path.append(u)
        return path


    res = []
    q = int(input())
    for _ in range(q):
        k = int(input())
        P = [int(x) - 1 for x in input().split()]
        
        if k == 1:
            res.append(""YES"")
            continue
        
        P.sort(key=lambda u: depth[u])
        u = P.pop()
        v = P.pop()        
        path = build_path(u, v)
        
        while P and u == path[0] and v == path[-1]:
            u = v
            v = P.pop()
            path = build_path(u, v)

        ans = ""YES""
        for u in P:
            if u not in path:
                ans = ""NO""
                break
        res.append(ans)

    return res

res = solve()
print(""\n"".join(res))","par[v] = u
                depth[v] = depth[u] + 1
                q.append(v)","ans = ""NO""
                break"
"from collections import deque
import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
    
    # build a tree with BFS
    par = [-1] * n
    depth = [0] * n
    q = deque([0])
    while q:
        u = q.popleft()
        for v in G[u]:
            if v != par[u]:
                par[v] = u
                depth[v] = depth[u] + 1
                q.append(v)

    # Path to LCA
    def build_path(u, v):
        path = []
        if depth[u] < depth[v]:
            u, v = v, u
        while depth[u] > depth[v]:
            path.append(u)
            u = par[u]
        while u != v:
            path.append(u)
            path.append(v)
            u, v = par[u], par[v]
        path.append(u)
        return path


    res = []
    q = int(input())
    for _ in range(q):
        k = int(input())
        P = [int(x) - 1 for x in input().split()]
        
        if k == 1:
            res.append(""YES"")
            continue
        
        P.sort(key=lambda u: depth[u])
        u = P.pop()
        v = P.pop()        
        path = build_path(u, v)
        
        while P and u == path[0] and v == path[-1]:
            u = v
            v = P.pop()
            path = build_path(u, v)

        ans = ""YES""
        for u in P:
            if u not in path:
                {{completion}}
        res.append(ans)

    return res

res = solve()
print(""\n"".join(res))","ans = ""NO""
                break","par[v] = u
                depth[v] = depth[u] + 1
                q.append(v)"
"input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1


n = int(input())
adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v = map(mapnode, input().split())
    adj[u].append(v)
    adj[v].append(u)

# dfs
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)]
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            {{completion}}

for _ in range(19):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])

# print('depth', depth)
# print('jump', jump)

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    step = depth[u] - depth[v]
    for i in range(19):
        if (step >> i) & 1 == 1:
            u = jump[i][u]

    if u == v:
        return u
    
    # move up together
    for i in range(18, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# answer queries
for _ in range(int(input())):
    nk = int(input())
    
    nodes = list(sorted(map(mapnode, input().split()), key=lambda u: -depth[u]))
    mindepth = min(depth[u] for u in nodes)

    # check from lowest depth
    tocheck = [nodes[i] for i in range(1, nk) if nodes[i] != lca(nodes[0], nodes[i])]
    
    # print(subroot+1, [x+1 for x in tocheck], [x+1 for x in nodes])
    ok = len(tocheck) == 0 or all(lca(tocheck[0], u) == u for u in tocheck) and depth[lca(tocheck[0], nodes[0])] <= mindepth
    print('YES' if ok else 'NO')
","depth[v] = depth[u] + 1
            stack.append((v, u))",u = jump[i][u]
"input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1


n = int(input())
adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v = map(mapnode, input().split())
    adj[u].append(v)
    adj[v].append(u)

# dfs
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)]
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for _ in range(19):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])

# print('depth', depth)
# print('jump', jump)

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    step = depth[u] - depth[v]
    for i in range(19):
        if (step >> i) & 1 == 1:
            {{completion}}

    if u == v:
        return u
    
    # move up together
    for i in range(18, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# answer queries
for _ in range(int(input())):
    nk = int(input())
    
    nodes = list(sorted(map(mapnode, input().split()), key=lambda u: -depth[u]))
    mindepth = min(depth[u] for u in nodes)

    # check from lowest depth
    tocheck = [nodes[i] for i in range(1, nk) if nodes[i] != lca(nodes[0], nodes[i])]
    
    # print(subroot+1, [x+1 for x in tocheck], [x+1 for x in nodes])
    ok = len(tocheck) == 0 or all(lca(tocheck[0], u) == u for u in tocheck) and depth[lca(tocheck[0], nodes[0])] <= mindepth
    print('YES' if ok else 'NO')
",u = jump[i][u],"depth[v] = depth[u] + 1
            stack.append((v, u))"
"from collections import defaultdict, deque, Counter
import sys
from decimal import *
from heapq import heapify, heappop, heappush
import math
import random
import string
from copy import deepcopy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce, lru_cache
from bisect import bisect_left, bisect_right

def input():
    return sys.stdin.readline().rstrip()
def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getListGraph():
    return list(map(lambda x:int(x) - 1, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]

mod = 10 ** 9 + 7
MOD = 998244353

# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')
inf = float('inf')
eps = 10 ** (-12)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

#############
# Main Code #
#############

# lca
class Doubling():
    def __init__(self, n, edges, root):
        self.n = n
        self.logn = n.bit_length()
        self.doubling = [[-1] * self.n for _ in range(self.logn)]
        self.depth = [-1] * N
        self.depth[root] = 0
        # bfs
        par = [-1] * N
        pos = deque([root])
        while len(pos) > 0:
            u = pos.popleft()
            for v in edges[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)
        # doubling
        for i in range(self.n):
            self.doubling[0][i] = par[i]
        for i in range(1, self.logn):
            for j in range(self.n):
                if self.doubling[i - 1][j] == -1:
                    self.doubling[i][j] = -1
                else:
                    {{completion}}

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):
            if (dv - du) >> i & 1:
                v = self.doubling[i][v]
        if u == v: return u

        for i in range(self.logn - 1, -1, -1):
            pu, pv = self.doubling[i][u], self.doubling[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.doubling[0][u]

    def upstream(self, s, t):
        if t == 0:
            return s
        now = s
        for k in range(self.logn):
            if t & (1 << k):
                now = self.doubling[k][now]
        return now

N = getN()
E = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = getNM()
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

D = Doubling(N, E, 0)
Q = getN()
for _ in range(Q):
    q_n = getN()
    V = sorted([[D.depth[p], p] for p in getListGraph()])
    p1 = V.pop()[1]
    flag = True
    while V:
        p2 = V.pop()[1]
        lca_p = D.lca(p1, p2)
        if lca_p != p2:
            while V:
                opt_p = V.pop()[1]
                # print(D.lca(p1, opt_p), (D.lca(p2, opt_p)))
                if not (opt_p == lca_p or ((D.lca(p1, opt_p) == opt_p) ^ (D.lca(p2, opt_p) == opt_p))):
                    flag = False

    print(""YES"" if flag else ""NO"")",self.doubling[i][j] = self.doubling[i - 1][self.doubling[i - 1][j]],"self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)"
"from collections import defaultdict, deque, Counter
import sys
from decimal import *
from heapq import heapify, heappop, heappush
import math
import random
import string
from copy import deepcopy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce, lru_cache
from bisect import bisect_left, bisect_right

def input():
    return sys.stdin.readline().rstrip()
def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getListGraph():
    return list(map(lambda x:int(x) - 1, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]

mod = 10 ** 9 + 7
MOD = 998244353

# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')
inf = float('inf')
eps = 10 ** (-12)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

#############
# Main Code #
#############

# lca
class Doubling():
    def __init__(self, n, edges, root):
        self.n = n
        self.logn = n.bit_length()
        self.doubling = [[-1] * self.n for _ in range(self.logn)]
        self.depth = [-1] * N
        self.depth[root] = 0
        # bfs
        par = [-1] * N
        pos = deque([root])
        while len(pos) > 0:
            u = pos.popleft()
            for v in edges[u]:
                if self.depth[v] == -1:
                    {{completion}}
        # doubling
        for i in range(self.n):
            self.doubling[0][i] = par[i]
        for i in range(1, self.logn):
            for j in range(self.n):
                if self.doubling[i - 1][j] == -1:
                    self.doubling[i][j] = -1
                else:
                    self.doubling[i][j] = self.doubling[i - 1][self.doubling[i - 1][j]]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):
            if (dv - du) >> i & 1:
                v = self.doubling[i][v]
        if u == v: return u

        for i in range(self.logn - 1, -1, -1):
            pu, pv = self.doubling[i][u], self.doubling[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.doubling[0][u]

    def upstream(self, s, t):
        if t == 0:
            return s
        now = s
        for k in range(self.logn):
            if t & (1 << k):
                now = self.doubling[k][now]
        return now

N = getN()
E = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = getNM()
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

D = Doubling(N, E, 0)
Q = getN()
for _ in range(Q):
    q_n = getN()
    V = sorted([[D.depth[p], p] for p in getListGraph()])
    p1 = V.pop()[1]
    flag = True
    while V:
        p2 = V.pop()[1]
        lca_p = D.lca(p1, p2)
        if lca_p != p2:
            while V:
                opt_p = V.pop()[1]
                # print(D.lca(p1, opt_p), (D.lca(p2, opt_p)))
                if not (opt_p == lca_p or ((D.lca(p1, opt_p) == opt_p) ^ (D.lca(p2, opt_p) == opt_p))):
                    flag = False

    print(""YES"" if flag else ""NO"")","self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)",self.doubling[i][j] = self.doubling[i - 1][self.doubling[i - 1][j]]
"from collections import deque;import math
import sys;I=sys.stdin.readline;R=lambda:map(lambda x:int(x)-1,input().split())
n=int(I());g=[[] for _ in range(n)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)

h=math.ceil(math.log2(n))
fa=[[-1]*(h+1) for _ in range(n)];dep=[0]*n
q=deque([0])
while q:
  u=q.popleft()
  for v in g[u]:
      if v!=fa[u][0]:{{completion}}
for i in range(1,h+1):
  for u in range(n):
    fa[u][i]=fa[fa[u][i-1]][i-1]
def lca(u,v):
  if dep[u]<dep[v]:u,v=v,u
  for i in range(h,-1,-1):
    if dep[v]+(1<<i)<=dep[u]:u=fa[u][i]
  if u==v:return u
  for i in range(h,-1,-1):
    if fa[u][i]!=fa[v][i]:u=fa[u][i];v=fa[v][i]
  return fa[u][0]

for _ in [0]*int(I()):
  k=int(I());p=[*R()];z='YES'
  if k<=2:print(z);continue
  p.sort(key=lambda u:dep[u])
  u=p.pop();v=p.pop();f=lca(u,v)
  while p and f==v:u=v;v=p.pop();f=lca(u,v)
  for x in p:
    if dep[x]<=dep[f] and x!=f or lca(u,x)!=x and lca(v,x)!=x:
      z='NO';break
  print(z)",fa[v][0]=u;dep[v]=dep[u]+1;q.append(v),u=fa[u][i]
"from collections import deque;import math
import sys;I=sys.stdin.readline;R=lambda:map(lambda x:int(x)-1,input().split())
n=int(I());g=[[] for _ in range(n)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)

h=math.ceil(math.log2(n))
fa=[[-1]*(h+1) for _ in range(n)];dep=[0]*n
q=deque([0])
while q:
  u=q.popleft()
  for v in g[u]:
      if v!=fa[u][0]:fa[v][0]=u;dep[v]=dep[u]+1;q.append(v)
for i in range(1,h+1):
  for u in range(n):
    fa[u][i]=fa[fa[u][i-1]][i-1]
def lca(u,v):
  if dep[u]<dep[v]:u,v=v,u
  for i in range(h,-1,-1):
    if dep[v]+(1<<i)<=dep[u]:{{completion}}
  if u==v:return u
  for i in range(h,-1,-1):
    if fa[u][i]!=fa[v][i]:u=fa[u][i];v=fa[v][i]
  return fa[u][0]

for _ in [0]*int(I()):
  k=int(I());p=[*R()];z='YES'
  if k<=2:print(z);continue
  p.sort(key=lambda u:dep[u])
  u=p.pop();v=p.pop();f=lca(u,v)
  while p and f==v:u=v;v=p.pop();f=lca(u,v)
  for x in p:
    if dep[x]<=dep[f] and x!=f or lca(u,x)!=x and lca(v,x)!=x:
      z='NO';break
  print(z)",u=fa[u][i],fa[v][0]=u;dep[v]=dep[u]+1;q.append(v)
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def dfs(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl = s.pop()

        level[p] = lvl
        parent[p][0] = prev
        for i in child[p]:
            if(i == prev):continue

            s.append([i , p , lvl + 1])

def lca(u,v):

    if(level[u] > level[v]):u,v=v,u

    dist=level[v] - level[u]
    for i in range(20,-1,-1):
        if(dist >> i & 1):
            v=parent[v][i]

    if(u==v):return u
    for i in range(20,-1,-1):
        if(parent[u][i] != parent[v][i]):
            u=parent[u][i]
            v=parent[v][i]

    return parent[u][0]

for T in range(1):

    n = int(input())
    child = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u , v = inp()
        child[u].append(v)
        child[v].append(u)


    level = [0 for i in range(n + 1)]
    parent=[[-1 for i in range(21)] for j in range(n + 1)]
    dfs(1 , -1 , 1)

    for j in range(1 , 21):
        for i in range(1 , n + 1):
            if(parent[i][j - 1] == -1):continue
            
            parent[i][j] = parent[parent[i][j - 1]][j - 1]


    for q in range(int(input())):

        x = int(input())
        a = inp()

        maxval = 0
        for i in range(x):
            if(maxval < level[a[i]]):
                maxval = level[a[i]]
                left = a[i]


        maxval = 0
        for i in range(x):
            if(lca(a[i] , left) != a[i]):

                if(maxval < level[a[i]]):
                    {{completion}}

        if(maxval == 0):
            print('YES')
            continue


        ok = True
        Lca = lca(left , right)
        for i in range(x):
            if(a[i] == Lca):continue
            
            if(lca(Lca , a[i]) == a[i]):
                ok = False
                break

            if(lca(a[i] , left) != a[i] and lca(a[i] , right) != a[i]):
                ok = False
                break

        if(ok):print('YES')
        else:print('NO')

            
            
","maxval = level[a[i]]
                    right = a[i]",continue
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def dfs(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl = s.pop()

        level[p] = lvl
        parent[p][0] = prev
        for i in child[p]:
            if(i == prev):{{completion}}

            s.append([i , p , lvl + 1])

def lca(u,v):

    if(level[u] > level[v]):u,v=v,u

    dist=level[v] - level[u]
    for i in range(20,-1,-1):
        if(dist >> i & 1):
            v=parent[v][i]

    if(u==v):return u
    for i in range(20,-1,-1):
        if(parent[u][i] != parent[v][i]):
            u=parent[u][i]
            v=parent[v][i]

    return parent[u][0]

for T in range(1):

    n = int(input())
    child = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u , v = inp()
        child[u].append(v)
        child[v].append(u)


    level = [0 for i in range(n + 1)]
    parent=[[-1 for i in range(21)] for j in range(n + 1)]
    dfs(1 , -1 , 1)

    for j in range(1 , 21):
        for i in range(1 , n + 1):
            if(parent[i][j - 1] == -1):continue
            
            parent[i][j] = parent[parent[i][j - 1]][j - 1]


    for q in range(int(input())):

        x = int(input())
        a = inp()

        maxval = 0
        for i in range(x):
            if(maxval < level[a[i]]):
                maxval = level[a[i]]
                left = a[i]


        maxval = 0
        for i in range(x):
            if(lca(a[i] , left) != a[i]):

                if(maxval < level[a[i]]):
                    maxval = level[a[i]]
                    right = a[i]

        if(maxval == 0):
            print('YES')
            continue


        ok = True
        Lca = lca(left , right)
        for i in range(x):
            if(a[i] == Lca):continue
            
            if(lca(Lca , a[i]) == a[i]):
                ok = False
                break

            if(lca(a[i] , left) != a[i] and lca(a[i] , right) != a[i]):
                ok = False
                break

        if(ok):print('YES')
        else:print('NO')

            
            
",continue,"maxval = level[a[i]]
                    right = a[i]"
"import sys


class LCA:
    def __init__(self, g, root=0):
        self.g = g
        self.root = root
        n = len(g)
        self.logn = (n - 1).bit_length()
        self.depth = [None] * n
        self.parent = [[None] * self.logn for _ in range(n)]
        self._dfs()
        self._doubling()

    def _dfs(self):
        self.depth[self.root] = 0
        stack = [self.root]
        while stack:
            u = stack.pop()
            for v in self.g[u]:
                if self.depth[v] is None:
                    {{completion}}

    def _doubling(self):
        for i in range(self.logn - 1):
            for p in self.parent:
                if p[i] is not None:
                    p[i + 1] = self.parent[p[i]][i]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        d = self.depth[v] - self.depth[u]
        for i in range(d.bit_length()):
            if d >> i & 1:
                v = self.parent[v][i]
        if u == v:
            return u
        for i in reversed(range(self.logn)):
            if (pu := self.parent[u][i]) != (pv := self.parent[v][i]):
                u, v = pu, pv
        return self.parent[u][i]


def query(lca):
    k = int(sys.stdin.readline())
    p = sorted(
        (int(x) - 1 for x in sys.stdin.readline().split()),
        key=lca.depth.__getitem__,
        reverse=True,
    )
    branch = []
    top = p[0]
    for x in p[1:]:
        if lca.lca(top, x) == x:
            top = x
        else:
            branch.append(x)
    if not branch:
        return True
    if lca.lca(branch[0], p[0]) != lca.lca(branch[0], top):
        return False
    for i in range(1, len(branch)):
        if lca.lca(branch[i - 1], branch[i]) != branch[i]:
            return False
    return True


n = int(input())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = (int(x) - 1 for x in sys.stdin.readline().split())
    g[u].append(v)
    g[v].append(u)
lca = LCA(g)
for _ in range(int(input())):
    print(""YES"" if query(lca) else ""NO"")
","self.depth[v] = self.depth[u] + 1
                    self.parent[v][0] = u
                    stack.append(v)",self.parent[u][i] = self.parent[p[i]][i]
"import sys


class LCA:
    def __init__(self, g, root=0):
        self.g = g
        self.root = root
        n = len(g)
        self.logn = (n - 1).bit_length()
        self.depth = [None] * n
        self.parent = [[None] * self.logn for _ in range(n)]
        self._dfs()
        self._doubling()

    def _dfs(self):
        self.depth[self.root] = 0
        stack = [self.root]
        while stack:
            u = stack.pop()
            for v in self.g[u]:
                if self.depth[v] is None:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[v][0] = u
                    stack.append(v)

    def _doubling(self):
        for i in range(self.logn - 1):
            for p in self.parent:
                if p[i] is not None:
                    {{completion}}

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        d = self.depth[v] - self.depth[u]
        for i in range(d.bit_length()):
            if d >> i & 1:
                v = self.parent[v][i]
        if u == v:
            return u
        for i in reversed(range(self.logn)):
            if (pu := self.parent[u][i]) != (pv := self.parent[v][i]):
                u, v = pu, pv
        return self.parent[u][i]


def query(lca):
    k = int(sys.stdin.readline())
    p = sorted(
        (int(x) - 1 for x in sys.stdin.readline().split()),
        key=lca.depth.__getitem__,
        reverse=True,
    )
    branch = []
    top = p[0]
    for x in p[1:]:
        if lca.lca(top, x) == x:
            top = x
        else:
            branch.append(x)
    if not branch:
        return True
    if lca.lca(branch[0], p[0]) != lca.lca(branch[0], top):
        return False
    for i in range(1, len(branch)):
        if lca.lca(branch[i - 1], branch[i]) != branch[i]:
            return False
    return True


n = int(input())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = (int(x) - 1 for x in sys.stdin.readline().split())
    g[u].append(v)
    g[v].append(u)
lca = LCA(g)
for _ in range(int(input())):
    print(""YES"" if query(lca) else ""NO"")
",p[i + 1] = self.parent[p[i]][i],self.parent[i][j] = self.parent[i - 1][self.parent[i - 1][j]]
"from collections import Counter
for _ in range(int(input())):
    n=int(input());
    l=list(map(int, input().split()));c = Counter(l);
    if any(x == 1 for x in c.values()):
        {{completion}}
    print(*[i if i!=0 and l[i]==l[i-1] else i+c[l[i]] for i in range(n)])",print(-1); continue,print(*[i if i!=0 and l[i]==l[i-1] else i+c[l[i]] for i in range(n)])
"# Codeforce 795 Div 2
import sys
input = sys.stdin.readline
flush = sys.stdout.flush
iil = lambda: [int(x) for x in input().split()]

tests, = iil()
for _ in range(tests):
    n, = iil()
    a = iil()
    last_c = a[0]
    count = 1
    ans = []
    for i, c in enumerate(a[1:]):
        if c == last_c:
            count += 1
        else:
            if count == 1:
                print(-1)
                break 
            else:
                {{completion}}
    else:
        if count <= 1:
            print(-1)
            continue
        ans.extend([i+2] + list(range(i-count + 3, i+2)))
        print("" "".join(str(x) for x in ans))
        ","ans.extend([i+1] + list(range(i-count + 2, i+1)))
                last_c = c
                count = 1","ans.extend([i+2] + list(range(i-count + 3, i+2)))"
"for _ in range(int(input())):
    n = int(input())
    ans =[]
    arr = [int(c) for c in input().split()]
    j = 0
    for i in range(n):
        if i == j:continue
        if arr[i] == arr[j]:
            continue
        else:
            if i == j+1:
                print(-1)
                break
            else:
                # print(list(range(j,i)))
                {{completion}}
    else:
        if n==j+1:
            print(-1)
        else:   
            ls = list(range(j+1,n+1))
            newls = [ls[-1]]+ls[0:-1]
            ans.extend(newls)
            print(*ans)
    
        ","ls = list(range(j+1,i+1))
                newls = [ls[-1]]+ls[0:-1]
                ans.extend(newls)
                j=i","print(list(range(j,i)))"
"import collections
import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    data = dict(collections.Counter(map(int, input().split())))

    if min(list(data.values())) > 1:
        last = 1
        for i in data.keys():
            print(last + data[i] - 1, end=' ')
            for j in range(last, last + data[i] - 1):
                {{completion}}
            last = last + data[i]
        print()
    else:
        print(-1)
","print(j, end=' ')","print(i,end=' ')"
"for t in range(int(input())):
    n=int(input())
    x=list(map(int,input().split()))
    g={}
    if n==1:
        print(-1)
    else:


        for i in range(n-1):
            if not((x[i]==x[i+1] or x[i]==x[i-1]) and ( x[-1]==x[-2])):
                print(-1)
                break
            g[x[i]]=[]


        else:
            for i in range(n):
                g[x[i]].append(i+1)
            for i,j in g.items():
                for q in range(len(j)):
                    {{completion}}
            print()
            
        
        ","print(j[q-1],end=' ')",print(-1); continue
"t = int(input())
for i in range(t):
    n = int(input())
    s = [int(x) for x in input().split(' ')]
    s.append('A')
    f = 0
    p = s[0]
    c = 0
    for x in range(n+1):
        if s[x] == p:
            s[x] = str(x)
            c+=1
        else:
            if c == 1:
                s = -1
                break
            else:
                {{completion}}
    if s != -1:
        s.pop()
        print(' '.join(s))
    else:
        print(s)
","s[f] = str(x)
                f = x
                p = s[x]
                c = 1",print(-1); continue
"import sys
input=sys.stdin.readline
for _ in range(int(input())):
    n=int(input())
    x=tuple(map(int,input().split()))
    if n==1:
        print(-1)
        continue
    ans=[-1]*n
    extra=[]
    visited=[False]*n
    for i in range(n-1,-1,-1):
        if i!=0 and x[i]==x[i-1]:
            ans[i]=i
            visited[i-1]=True
            if not visited[i]:
                extra.append(i+1)
        else:
            if extra:
                ans[i]=extra.pop()
            else:
                {{completion}}
    else:
        print(*ans)
","print(-1)
                break",ans[i]=extra.pop()
"from sys import stdin
input = stdin.readline

I = lambda : list(map(int, input().split()))

def solve(N,A):
    dic = {}
    
    for i in range(N):
        if A[i] not in dic:
            {{completion}}
        dic[A[i]].append(i)

    ans = [0]*N
    for k in dic.keys():
        l = dic[k]
        if len(l) == 1:
            return [-1]
        for i in range(len(l)):
            ans[l[i]] = l[(i-1)%len(l)] + 1
    return ans
    
T = int(input())

for _ in range(T):
    N = int(input())
    A = I()
    print(*solve(N,A))",dic[A[i]] = [],return [-1]
"from sys import stdin
input = stdin.readline

I = lambda : list(map(int, input().split()))

def solve(N,A):
    dic = {}
    
    for i in range(N):
        if A[i] not in dic:
            dic[A[i]] = []
        dic[A[i]].append(i)

    ans = [0]*N
    for k in dic.keys():
        l = dic[k]
        if len(l) == 1:
            {{completion}}
        for i in range(len(l)):
            ans[l[i]] = l[(i-1)%len(l)] + 1
    return ans
    
T = int(input())

for _ in range(T):
    N = int(input())
    A = I()
    print(*solve(N,A))",return [-1],dic[A[i]] = []
"for _ in range(int(input())):
    n = int(input())
    arr = list(map(int,input().split()))
    freq = {}
    for i in arr:
        if(i in freq): freq[i] += 1
        else: freq[i] = 1
    for i in freq:
        if(freq[i] == 1): #not in pairs
            print(-1);break
    else:
        ans2 = []
        for i in freq:
            res = []
            res.append(freq[i]+len(ans2))
            for j in range(1,freq[i]):
                {{completion}}
            ans2.extend(res)
        print(*ans2)",res.append(j+len(ans2)),"this is the start of the ground truth
ans2.append(freq[i]+len(ans2))
                for j in range(1,freq[i]):
                    res.append(freq[i]+len(ans2)+j)
                    for k in range(1,freq[i]):
                        res.append(freq[i]+len(ans2)+j+k)
                        for l in range(1,freq[i]):
                            res.append(freq[i]+len"
"from bisect import bisect_left

cases = int(input())
for run in range(cases):
    n = int(input())
    shoes = input().split()
    for x in range(len(shoes)):
        shoes[x] = int(shoes[x])
    
    perm = []
    i = 0

    while i < len(shoes) and perm != [-1]:
        p = bisect_left(shoes,shoes[i]+1)-1
        if p == i:
            perm = [-1]
        else:
            {{completion}}
            
    print("" "".join([str(int) for int in perm]))
                
                
            
","perm.append(p+1)
            perm += list(range(i+1,p+1))
            i = p+1","perm.append(p)
                perm.append(i)"
"import sys
sys.setrecursionlimit(300000)

import faulthandler
faulthandler.enable()

n, k = map(int, input().split())
MOD = 10**9 + 7

fact = [1 for i in range(n+1)]
for i in range(2, n+1):
	fact[i] = i*fact[i-1] % MOD

inv_fact = [1 for i in range(n+1)]
inv_fact[-1] = pow(fact[-1], MOD-2, MOD)
for i in range(1, n):
	inv_fact[n-i] = (n-i+1)*inv_fact[n-i+1] % MOD

def comb(a, b):
	if a < b:
		return 0
	return fact[a]*inv_fact[b]*inv_fact[a-b] % MOD

edges = [[] for i in range(n)]
for _ in range(n-1):
	x, y = map(lambda a: int(a)-1, input().split())
	edges[x].append(y)
	edges[y].append(x)

ends = [[] for i in range(n)]

visited = [0 for i in range(n)]
totals = [1 for i in range(n)]
dfs_stack = [0]

while len(dfs_stack) > 0:
	node = dfs_stack[-1]

	if visited[node] == 1:
		visited[node] = 2

		for next_node in edges[node]:
			if visited[next_node] == 2:
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])

		ends[node].append(n-totals[node])
		dfs_stack.pop()
	else:
		visited[node] = 1

		for next_node in edges[node]:
			if visited[next_node] == 0:
				{{completion}}

z = n*n * comb(n, k) % MOD
node_v = [0 for i in range(n)]

for i in range(n):
	node_v[i] = sum(comb(e, k) for e in ends[i]) % MOD

	for e in ends[i]:
		z = (z - e*e * (comb(n-e, k) + comb(e, k) - node_v[i])) % MOD

print(z)",dfs_stack.append(next_node),"z = n*n * comb(n, k) % MOD"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 10 ** 9 + 7

n, k = I()

binomk = [0] * k
binomk.append(1)
for i in range(k + 1, n + 1):
	binomk.append(binomk[-1] * i * pow(i - k, M - 2, M) % M)
neighbors = [[] for i in range(n)]
for i in range(n - 1):
	a, b = I()
	a -= 1
	b -= 1
	neighbors[a].append(b)
	neighbors[b].append(a)
parents = [None] + [-1] * (n - 1)
children = [[] for i in range(n)]
layer = [0]
while layer:
	newlayer = []
	for guy in layer:
		for boi in neighbors[guy]:
			if boi != parents[guy]:
				{{completion}}
	layer = newlayer
size = [0] * n
q = []
for i in range(n):
	if len(children[i]) == 0:
		q.append(i)
qind = 0
left = [len(children[i]) for i in range(n)]
while qind < len(q):
	v = q[qind]
	tot = 1
	for guy in children[v]:
		tot += size[guy]
	size[v] = tot
	if parents[v] is None:
		break
	left[parents[v]] -= 1
	if left[parents[v]] == 0:
		q.append(parents[v])
	qind += 1

answer = 0
for i in range(n):
	things = []
	for guy in children[i]:
		things.append(size[guy])
	if i != 0:
		things.append(n - 1 - sum(things))
	bins = [binomk[i] for i in things]
	ss = sum(bins) % M
	for guy in things:
		answer = (answer + (n - guy) * guy * binomk[n - guy]) % M
		answer = (answer - (n - guy) * guy * (ss - binomk[guy])) % M
	answer = (answer + n * binomk[n]) % M
	answer = (answer - ss * n) % M
print(answer)
","children[guy].append(boi)
				parents[boi] = guy
				newlayer.append(boi)",bins = [binomk[i] for i in things]
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    if N % 2 == 0:
        a1 = [A[i] for i in range(0, N, 2)]
        a2 = [A[i] for i in range(1, N, 2)]

        i1, i2 = a1.index(min(a1)), a2.index(min(a2))
        m1 = min(a1) * len(a1) + i1
        m2 = min(a2) * len(a2) + i2

        print(""Mike"" if m1 > m2 else ""Joe"")
    else:
        {{completion}}

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens","print(""Mike"")",solve(tc + 1)
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    if N % 2 == 0:
        a1 = [A[i] for i in range(0, N, 2)]
        a2 = [A[i] for i in range(1, N, 2)]

        i1, i2 = a1.index(min(a1)), a2.index(min(a2))
        m1 = min(a1) * len(a1) + i1
        m2 = min(a2) * len(a2) + i2

        print(""Mike"" if m1 > m2 else ""Joe"")
    else:
        print(""Mike"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        {{completion}}
    assert not tokens",solve(tc + 1),"print(""Mike"")"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: {{completion}}
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",B[i][j] >>= 1,B[i][j] >>= 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: {{completion}}
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",continue,continue
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for _ in range(N)]

    if N < M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: {{completion}}
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",B[i][j] >>= 1,B[i][j] >>= 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for _ in range(N)]

    if N < M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: {{completion}}
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",continue,B[i][j] >>= 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    if N > M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: {{completion}}
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",B[i][j] >>= 1,B[i][j] >>= 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    if N > M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: {{completion}}
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",continue,B[i][j] >>= 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    X = Y = 0
    for i in range(N):
        for j in range(M):
            if A[i][j] > A[X][Y]:
                {{completion}}

    height = max(N - X, X + 1)
    width = max(M - Y, Y + 1)
    print(height * width)

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens","X, Y = i, j","X = Y = 0
for i in range(N):
    for j in range(M):
        if A[i][j] > A[X][Y]:
            X = i
            Y = j

height = max(N - X, X + 1)
width = max(M - Y, Y + 1)
print(height * width)"
"import sys


def _input_iter():
    for line in sys.stdin:
        for part in line.strip().split(' '):
            stripped = part.strip()
            if stripped:
                {{completion}}


def read_int():
    return int(next(stream))


def read_str():
    return next(stream)


def get_ans(a, b):
    if len(a) < len(b):
        return False
    if len(a) == len(b):
        return a == b

    if len(b) == 1:
        return b in a

    if a[-len(b) + 1:] != b[1:]:
        return False

    return b[0] in a[:len(a) - len(b) + 1]


def run():
    read_int(), read_int()
    a, b = read_str(), read_str()
    print('YES' if get_ans(a, b) else 'NO')


stream = _input_iter()


def main():
    t = read_int()
    for _ in range(t):
        run()


if __name__ == '__main__':
    main()
",yield stripped,print(len(a) - len(b) + 1)
"R=lambda:map(int,input().split());G=range;t,=R()
for _ in G(t):
  {{completion}}","n,m=R();s=[sum(i*v for i,v in enumerate(R()))for _ in G(n)]
  mx=max(s);print(s.index(mx)+1,mx-min(s))","this is the start of the ground truth
    n,m = R()
    b = R()
    c = [R() for _ in G(n)]
    
    mx = (0, -1)
    mn = (10**18, -1)
    for i in G(n):
        current, total = 0, 0
        for x in c[i]:
            if x:
                current += x
                total += current
            else:
                current = 0
"
"for _ in range(int(input())):
	n, m = map(int, input().split())

	vals = []
	for _ in range(n):
		count = 0
		for a, b in enumerate(map(int, input().split())):
			{{completion}}
		vals.append(count)


	c = vals.index(max(vals))
	print(c + 1, vals[c] - vals[c-1])",count += a*b,"print(""1 1"")"
"case=int(input())
for i in range(case):
  n,m = (int(v) for v in input().split())
  tmp=0
  for j in range(n):
    list1 = [int(v) for v in input().split()]
    value = 0
    for k in range(m):
      value += list1[k]*(k+1)
    if j==0:
      tmp = value
    else:
      if value > tmp:
        print(str(j+1)+"" ""+str(value-tmp))
      elif value < tmp:
        {{completion}}
      else:
        pass","print(""1 ""+str(tmp-value))
        tmp = value",pass
"case=int(input())
for i in range(case):
  n,m = (int(v) for v in input().split())
  tmp=0
  for j in range(n):
    list1 = [int(v) for v in input().split()]
    value = 0
    for k in range(m):
      value += list1[k]*(k+1)
    if j==0:
      tmp = value
    else:
      if value > tmp:
        print(str(j+1)+"" ""+str(value-tmp))
      elif value < tmp:
        print(""1 ""+str(tmp-value))
        tmp = value
      else:
        {{completion}}",pass,"print(""1 ""+str(tmp-value))
        tmp = value"
"input = __import__('sys').stdin.readline


def solve():
    n, m = map(int, input().split())

    mx = (0, -1)
    mn = (10**18, -1)
    for i in range(n):
        current, total = 0, 0
        for x in map(int, input().split()):
            {{completion}}
        
        mx = max(mx, (total, i))
        mn = min(mn, (total, i))
    
    print(mn[1]+1, mx[0] - mn[0])


for _ in range(int(input())):
    solve()","current += x
            total += current","print(""1 ""+str(tmp-value))
        tmp = value"
"import sys 
input= sys.stdin.readline

rn=lambda: [*map(int,input().split())]

for _ in range(*rn()):
    n,m=rn()
    b=[]
    mm=0
    for i in range(0,n):
        a=sum([*map(lambda x,y:int(x)*y,input().split(),range(1,m+1))])
        b.append(a)
        if a>b[mm]:
            {{completion}}
    print(mm+1,b[mm]-b[mm-1])",mm=i,"print(0,b[0]-b[1])
        mm=i"
"for t in range(int(input())):
    N, M = map(int, input().split())
    minV = int(1e20)
    maxV = -1
    ret = 0
    for index in range(N):
        mlist = list(map(int, input().split()))
        cur = sum([index*val for index, val in enumerate(mlist)])
        
        minV = min(minV, cur)
        if maxV < cur:
            {{completion}}
        maxV = max(maxV, cur)
    print(f""{ret} {maxV-minV}"")",ret = index+1,"print(""1 ""+str(maxV-minV))
        maxV = cur"
"import sys
input = sys.stdin.readline
s = input().strip()
l = len(s)
d, p = [], [0]
d.append([1 if s[0] == chr(x+97)  else 0 for x in range(26)])
for idx, i in enumerate(s):
    if idx == 0: {{completion}}
    x = ord(i) - 97
    d.append(d[p[idx-1]][:])
    d[idx][x] = idx+1
    p.append(d[p[idx-1]][x])
for i in range(10): p.append(0); d.append([])
for i in range(int(input())):
    for idx, t in enumerate(input().strip()):
        x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]
    print(*p[l:l+idx+1])",continue,"x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]"
"import sys
input = sys.stdin.readline
s = input().strip()
l = len(s)
d, p = [], [0]
d.append([1 if s[0] == chr(x+97)  else 0 for x in range(26)])
for idx, i in enumerate(s):
    if idx == 0: continue
    x = ord(i) - 97
    d.append(d[p[idx-1]][:])
    d[idx][x] = idx+1
    p.append(d[p[idx-1]][x])
for i in range(10): p.append(0); d.append([])
for i in range(int(input())):
    for idx, t in enumerate(input().strip()):
        {{completion}}
    print(*p[l:l+idx+1])","x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]",d[p[idx-1]][x] = idx+1
"def get_next(j, k, nxt, p):
    while p[j] != '$':
        if k == -1 or p[j] == p[k]:
            j += 1
            k += 1
            if p[j] == p[k]:
                nxt[j] = nxt[k]
            else:
                {{completion}}
        else:
            k = nxt[k]
    return j, k, nxt


def solve():
    s = input().strip()

    len_s = len(s)
    ns = [ch for ch in s]
    for i in range(11):
        ns.append('$')

    # print(ns)
    j, k, nxt = get_next(0, -1, [-1 for i in range(len(ns))], ns)

    q = int(input().strip())
    for _ in range(q):
        t = input().strip()
        ans = []

        for i in range(10):
            ns[i + len_s] = '$'

        for i in range(len(t)):
            ns[i + len_s] = t[i]
            # print(ns)
            nj, nk, n_nxt = get_next(j, k, nxt, ns)
            # print(n_nxt)
            ans.append(n_nxt[len_s + i + 1])
        print(' '.join(map(str, ans)))


if __name__ == '__main__':
    # t = int(input().strip())
    # for _ in range(t):
    solve()
",nxt[j] = k,nxt[j] = nxt[k]
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif l == 3:
            {{completion}}
        elif l == 2:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
",print(2),print(1)
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif l == 3:
            print(2)
        elif l == 2:
            {{completion}}
        elif l == 1:
            print(0)
        pos += 2
",print(1),print(1)
"import sys

from itertools import permutations, combinations

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

    
def solve(n, a, b):
    ps = [((list(range(n))), (list(range(n))))]
    res = (1<<30) - 1

    for k in range(30, -1, -1):
        next_ps = []
        for (pa, pb) in ps:

            a0, a1, b0, b1 = [], [], [], []
            for pai in pa:
                if a[pai] & (1<<k) == 0: a0.append(pai) 
                else: {{completion}}
            for pbi in pb:
                if b[pbi] & (1<<k) == 0: b0.append(pbi) 
                else: b1.append(pbi)

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))

        ps = next_ps if int(res & (1<<k)) != 0 else ps       

    return res
    #return rec(a, b, max_order-1)


for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    print(solve(n, a, b))
",a1.append(pai),b1.append(pbi)
"import sys

from itertools import permutations, combinations

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

    
def solve(n, a, b):
    ps = [((list(range(n))), (list(range(n))))]
    res = (1<<30) - 1

    for k in range(30, -1, -1):
        next_ps = []
        for (pa, pb) in ps:

            a0, a1, b0, b1 = [], [], [], []
            for pai in pa:
                if a[pai] & (1<<k) == 0: a0.append(pai) 
                else: a1.append(pai)
            for pbi in pb:
                if b[pbi] & (1<<k) == 0: b0.append(pbi) 
                else: {{completion}}

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))

        ps = next_ps if int(res & (1<<k)) != 0 else ps       

    return res
    #return rec(a, b, max_order-1)


for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    print(solve(n, a, b))
",b1.append(pbi),a1.append(pai)
"import sys
from math import ceil

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def at_least(L, x):
    for i in range(len(L)):
        if L[i] >= x:
            return i
    return len(L)-1

def at_most(L, x):
    for i in range(len(L)-1, -1, -1):
        if L[i] <= x:
            return i
    return 0

def solve(n, a, b):
    dmin, dmax = [-1]*n, [-1]*n
    imin, imax = 0, n-1
    for i in range(n):
        
        while b[imin] < a[i]:
            imin += 1

        dmin[i] = b[imin] - a[i]
        dmax[n-1-i] = b[imax] - a[n-1-i]
        
        if i < n-1:
            if b[n-i-2] < a[n-i-1]:
                {{completion}}

    return dmin, dmax

for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    dmin, dmax = solve(n, a, b)
    print(*dmin)
    print(*dmax)",imax = n-i-2,"print(*dmin)
print(*dmax)
            return"
"import sys

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        {{completion}}

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def ins(u, mn, mx):
    return u[0] >= mn[0] and u[1] >= mn[1] and u[0] <= mx[0] and u[1] <= mx[1]

def clmp(x, n):
    if x < 0: return 0
    if x >= n: return n-1
    return x

def clp(u, n, m):
    return (clmp(u[0], n), clmp(u[1], m)) 

def d(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def solve(n, m, sx, sy, d):
    if d ==0: return n+m-2
    smin = clp((sx-d, sy-d), n, m)
    smax = clp((sx+d, sy+d), n, m)
    if abs(smax[0]-smin[0]) >= n-1 or abs(smax[1]-smin[1]) >= m-1: return -1
    if ins((0, 0), smin, smax) or ins((n-1, m-1), smin, smax) : return -1
    return n+m-2

for l in ls[1:]:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve(n, m, sx-1, sy-1, d))",ls.append(lst),return 0
"import sys

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def ins(u, mn, mx):
    return u[0] >= mn[0] and u[1] >= mn[1] and u[0] <= mx[0] and u[1] <= mx[1]

def clmp(x, n):
    if x < 0: {{completion}}
    if x >= n: return n-1
    return x

def clp(u, n, m):
    return (clmp(u[0], n), clmp(u[1], m)) 

def d(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def solve(n, m, sx, sy, d):
    if d ==0: return n+m-2
    smin = clp((sx-d, sy-d), n, m)
    smax = clp((sx+d, sy+d), n, m)
    if abs(smax[0]-smin[0]) >= n-1 or abs(smax[1]-smin[1]) >= m-1: return -1
    if ins((0, 0), smin, smax) or ins((n-1, m-1), smin, smax) : return -1
    return n+m-2

for l in ls[1:]:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve(n, m, sx-1, sy-1, d))",return 0,ls.append(lst)
"_,(*a,),*r=(map(int,s.split())for s in open(0))
b=[[0],[0]]
for x in b:
 for u,v in zip([0]+a,a):{{completion}}
 max=min
for s,t in r:l=b[s>t];print(l[t]-l[s])","x+=x[-1]+max(0,u-v),","x+=x[-1]+max(0,u-v),"
"n,m=map(int,input().split())
c=[int(i) for i in input().split()]
f=[0]*n
g=[0]*n
for i in range(1,n):
	f[i]=f[i-1]+max(0,c[i-1]-c[i])
	g[-i-1]=g[-i]+max(0,c[-i]-c[-i-1])
for i in range(m):
	x,y=map(int,input().split())
	if x<y:
		print(f[y-1]-f[x-1])
	else:
		{{completion}}",print(g[y-1]-g[x-1]),"l=[0]*n
for i in range(1,n):
	l[i]=l[i-1]+max(0,c[i-1]-c[i])
for i in range(m):
	x,y=map(int,input().split())
	if x<y:
		print(l[y-1]-l[x-1])
	else:
		print(g[x-1]-g[y-1])








"
"R=lambda:map(int,input().split())
n,m=R()
*a,=R()
b=[[0],[0]]
f=max
for x in b:
 for u,v in zip([0]+a,a):{{completion}}
 f=min
for _ in[0]*m:s,t=R();l=b[s>t];print(l[t]-l[s])","x+=x[-1]+f(0,u-v),","x+=x[-1]+max(0,u-v),"
"n,m=map(int,input().split())
world=['x']+list(map(int,input().split()))
L1=[0]
L2=[0]
for i in range(1,n):
    L1.append(L1[i-1]+max(world[i]-world[i+1],0))
    L2.append(L2[i-1]+max(world[i+1]-world[i],0))
for i in range(m):
    s,t=map(int,input().split())
    if s<t:
        print(L1[t-1]-L1[s-1])
    else:
        {{completion}}",print(L2[s-1]-L2[t-1]),print(L2[t-1]-L2[s-1])
"n,m=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
ltr,rtl=[0],[0]
for i in range(1,n):
    ltr.append(max(0,a[i-1]-a[i])+ltr[-1])
    rtl.append(max(0,a[i]-a[i-1])+rtl[-1])
for i in range(m):
    s,t=[int(x) for x in input().split()]
    if s<=t:
        print(ltr[t-1]-ltr[s-1])
    else:
        {{completion}}
        ",print(rtl[s-1]-rtl[t-1]),print(rtl[s-1]-rtl[t-1])
"(n,m),(*a,),*r=(map(int,s.split())for s in open(0))
b=[[0],[0]]
for x in b:
 for u,v in zip([0]+a,a):{{completion}}
 max=min
for s,t in r:l=b[s>t];print(l[t]-l[s])","x+=x[-1]+max(0,u-v),","x+=x[-1]+max(0,u-v),"
"n, m = map(int, input().split())
a = list(map(int, input().split()))
inc = [0]
dec = [0]
for i in range(n-1):
    inc.append(inc[i] + max(0, a[i]-a[i+1]))
    dec.append(dec[i] + max(0, a[i+1] - a[i]))
    
for i in range(m):
    x, y = map(int, input().split())
    #print(x, y)
    #ans = 0
    if x < y:
        ans = inc[y-1] - inc[x-1]
    else:
        {{completion}}
    print(ans)
",ans = dec[x-1] - dec[y-1],"ans = dec[y-1] - dec[x-1]
print(ans)"
"R=lambda:map(int,input().split())
n,m=R()
*a,=R()
b=[[0],[0]]
for x in b:
 for u,v in zip([0]+a,a):{{completion}}
 a=a[::-1]
b[1]=[0]+b[1][::-1]
for _ in[0]*m:s,t=R();l=b[s>t];print(abs(l[s]-l[t]))","x+=x[-1]+max(0,u-v),","x+=x[-1]+a[s-t],"
"n, m = map(int, input().split());a = list(map(int, input().split()));l = [0] + [max(0, a[i] - a[i + 1]) for i in range(n - 1)];r = [0] + [max(0, a[i] - a[i - 1]) for i in range(1, n)]
for i in range(n - 1): {{completion}}
for _ in range(m): s, t = map(int, input().split());print(l[t - 1] - l[s - 1]) if(s < t) else print(r[s - 1] - r[t - 1])",l[i + 1] += l[i];r[i + 1] += r[i],"this is the start of the ground truth
l = [0] + [max(0, a[i] - a[i + 1]) for i in range(n - 1)];r = [0] + [max(0, a[i] - a[i - 1]) for i in range(1, n)]
for i in range(n - 1): l[i + 1] += l[i];r[i + 1] += r[i]
for _ in range(m): s, t = map(int, input"
"n, m = map(int, input().split());a = list(map(int, input().split()));l = [0] + [max(0, a[i] - a[i + 1]) for i in range(n - 1)];r = [0] + [max(0, a[i] - a[i - 1]) for i in range(1, n)]
for i in range(n - 1): l[i + 1] += l[i];r[i + 1] += r[i]
for _ in range(m): {{completion}}","s, t = map(int, input().split());print(l[t - 1] - l[s - 1]) if(s < t) else print(r[s - 1] - r[t - 1])","
Complete the code in python to solve this programming problem:

Description: You are beta testing the new secret Terraria update. This update will add quests to the game!Simply, the world map can be represented as an array of length $$$n$$$, where the $$$i$$$-th column of the world has height $$$a_i$$$.There are $$$m$$$ quests you have to test. The $$$j$$$-th of them is represented by two integers $$$s_j$$$ and $$$t_j$$$. In this quest, you have to"
"n,m=(map(int,input().split()))
l=list(map(int,input().split()))

f=[0]*n
b=[0]*n
d=0
for j in range(1,n):
    d=d+max(0,l[j-1]-l[j])
    f[j]=d
l=l[::-1]
d=0
for k in range(1,n):
    d=d+max(0,l[k-1]-l[k])
    b[k]=d
b=b[::-1]
for i in range(m):
    s,t=(map(int,input().split()))
    if s<t:
        print(f[t-1]-f[s-1])
    else:
        {{completion}}",print(b[t-1]-b[s-1]),print(b[t-1]-b[s-1])
"import sys, collections, math, itertools
input = lambda: sys.stdin.readline().strip()
ints = lambda: list(map(int, input().split()))
Int = lambda: int(input())
n, m = ints()
a = ints()
s = int(m ** .5 + 1)
maxs = [max(a[i:i + s]) for i in range(0, m, s)]
for i in range(Int()):
    ys, xs, yf, xf, k = ints()
    yes = (xs - xf) % k == 0 and (ys - yf) % k == 0
    if not yes:
        {{completion}}
    mi, ma = min(xs, xf), max(xs, xf)
    high = max([0] + a[mi:min(ma, (mi // s + 1) * s)] + a[max(mi, ma // s * s):ma])
    for j in range(min(xs, xf) // s + 1, max(xs, xf) // s):
        high = max(high, maxs[j])
    if high < ys:
        print('yes')
        continue
    print('yes' if ((high - ys) // k + 1) * k + ys <= n else 'no')","print('no')
        continue","high = max(high, maxs[j])"
"import sys, collections, math, itertools
input = lambda: sys.stdin.readline().strip()
ints = lambda: list(map(int, input().split()))
Int = lambda: int(input())
n, m = ints()
a = ints()
s = int(m ** .5 + 1)
maxs = [max(a[i:i + s]) for i in range(0, m, s)]
for i in range(Int()):
    ys, xs, yf, xf, k = ints()
    yes = (xs - xf) % k == 0 and (ys - yf) % k == 0
    if not yes:
        print('no')
        continue
    mi, ma = min(xs, xf), max(xs, xf)
    high = max([0] + a[mi:min(ma, (mi // s + 1) * s)] + a[max(mi, ma // s * s):ma])
    for j in range(min(xs, xf) // s + 1, max(xs, xf) // s):
        {{completion}}
    if high < ys:
        print('yes')
        continue
    print('yes' if ((high - ys) // k + 1) * k + ys <= n else 'no')","high = max(high, maxs[j])","print('no')
        continue"
"import math
import sys
input = sys.stdin.buffer.readline

y, x_ = input().split()
block = [int(x) for x in input().split()]
 
list2 = [[0] *20 for i in range( len(block))]
for a in range(len(block)):
    list2[a][0] = block[a]
    
z, x = 0, 1
while (1 << x) <= len(block):
    z = 0
    while (z + (1 << x) - 1) < len(block):
        list2[z][x] = (max(list2[z][x - 1], list2[z + (1 << (x - 1))][x - 1]))
        z += 1
    x += 1
    
 
for i in range(int(input())):
    s = [int(x) for x in input().split()]
    if abs(s[0] - s[2]) % s[-1] != 0 or abs(s[1] - s[3]) % s[-1] != 0:
        print(""NO"")
    else:
        smaller = min(s[1], s[3])
        bigger = max(s[1], s[3])
        k = 0
        while (1 << (k + 1)) <= bigger - smaller + 1:
            k += 1
        highest = max(list2[smaller - 1][k], list2[bigger - (1 << k)][k])
        if highest < s[-1] * ((int(y) - s[0]) // s[-1]) + s[0]:
            print(""YES"")
        else:
            {{completion}}","print(""NO"")","            print(""NO"")


























































































































"
"from sys import stdin, stdout
from math import floor, ceil, log
input, print = stdin.readline, stdout.write

def main():
  n, m = map(int, input().split())
  arr = [0] + [int(x) for x in input().split()]
  st = construct(arr, m)
  for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if ((y2 - y1) % k != 0 or (x2 - x1) % k != 0):
      {{completion}}
    if (x1 <= arr[y1] or x2 <= arr[y2]):
      print(""NO\n"")
      continue
    max_x = ((n-x1)//k)*k + x1 
    if (max_x <= getMax(st, m, min(y1, y2), max(y1, y2))):
      print(""NO\n"")
      continue
    print(""YES\n"")

def construct(arr, n):
  x = ceil(log(n, 2))
  max_size = 2 * pow(2, x) - 1 
  st = [0]*max_size
  construct2(arr, 0, n-1, st, 0)
  return st
  
def construct2(arr, ss, se, st, si):
  if (ss == se):
    st[si] = arr[ss]
    return arr[ss]
  mid = getMid(ss, se)
  st[si] = max(construct2(arr, ss, mid, st, si * 2 + 1), construct2(arr, mid + 1, se, st, si * 2 + 2))
  return st[si]

def getMid(s, e):
  return s + (e - s) // 2

def getMax(st, n, l, r):
  return MaxUtil(st, 0, n - 1, l, r, 0)

def MaxUtil(st, ss, se, l, r, node):
  if (l <= ss and r >= se):
    return st[node]
  if (se < l or ss > r):
    return -1
  mid = getMid(ss, se)
  return max(MaxUtil(st, ss, mid, l, r, 2 * node + 1), MaxUtil(st, mid + 1, se, l, r, 2 * node + 2))
  
main()","print(""NO\n"")
      continue","print(""NO\n"")
      continue"
"from sys import stdin, stdout
from math import floor, ceil, log
input, print = stdin.readline, stdout.write

def main():
  n, m = map(int, input().split())
  arr = [0] + [int(x) for x in input().split()]
  st = construct(arr, m)
  for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if ((y2 - y1) % k != 0 or (x2 - x1) % k != 0):
      print(""NO\n"")
      continue
    if (x1 <= arr[y1] or x2 <= arr[y2]):
      {{completion}}
    max_x = ((n-x1)//k)*k + x1 
    if (max_x <= getMax(st, m, min(y1, y2), max(y1, y2))):
      print(""NO\n"")
      continue
    print(""YES\n"")

def construct(arr, n):
  x = ceil(log(n, 2))
  max_size = 2 * pow(2, x) - 1 
  st = [0]*max_size
  construct2(arr, 0, n-1, st, 0)
  return st
  
def construct2(arr, ss, se, st, si):
  if (ss == se):
    st[si] = arr[ss]
    return arr[ss]
  mid = getMid(ss, se)
  st[si] = max(construct2(arr, ss, mid, st, si * 2 + 1), construct2(arr, mid + 1, se, st, si * 2 + 2))
  return st[si]

def getMid(s, e):
  return s + (e - s) // 2

def getMax(st, n, l, r):
  return MaxUtil(st, 0, n - 1, l, r, 0)

def MaxUtil(st, ss, se, l, r, node):
  if (l <= ss and r >= se):
    return st[node]
  if (se < l or ss > r):
    return -1
  mid = getMid(ss, se)
  return max(MaxUtil(st, ss, mid, l, r, 2 * node + 1), MaxUtil(st, mid + 1, se, l, r, 2 * node + 2))
  
main()","print(""NO\n"")
      continue","print(""NO\n"")
      continue"
"import sys
from array import array

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
debug = lambda *x: print(*x, file=sys.stderr)
out = []


class sparse_table:
    def __init__(self, n, a, default=0, func=max):
        self.n, self.lg = n, 20
        self.func = func
        self.table = [array('i', [default] * n) for _ in range(self.lg)]
        self.table[0] = a
        self.preprocess()

    def preprocess(self):
        for j in range(1, self.lg):
            i = 0
            while i + (1 << j) - 1 < self.n:
                {{completion}}

    def quary(self, l, r):
        '''[l,r]'''
        l1 = (r - l + 1).bit_length() - 1
        r1 = r - (1 << l1) + 1
        return self.func(self.table[l1][l], self.table[l1][r1])


n, m = inp(int)
a = array('i', inp(int))
mem = sparse_table(m, a)

for _ in range(int(input())):
    xs, ys, xf, yf, k = inp(int)
    div, mod = divmod(n - xs, k)
    xma = n - mod
    qur = mem.quary(min(ys, yf) - 1, max(ys, yf) - 1)

    if qur >= xma or abs(xma - xf) % k or abs(ys - yf) % k:
        out.append('no')
    else:
        out.append('yes')

print('\n'.join(out))
","ix = i + (1 << (j - 1))
                self.table[j][i] = self.func(self.table[j - 1][i], self.table[j - 1][ix])
                i += 1","mem.quary(min(ys, yf) - 1, max(ys, yf) - 1)"
"from sys import setrecursionlimit, stdin
readline = stdin.readline

# def I(): return int(readline())
# def ST(): return readline()[:-1]
# def LI(): return list(map(int, readline().split()))

def solve():
    N, m = map(int, readline().split())
    A = [0] + list(map(int, readline().split()))
    n = len(A)
    num = 1 << (n - 1).bit_length()
    tree = [0] * 2 * num
    for i in range(n):
        tree[num + i] = A[i] 
    for i in range(num - 1, 0, -1):
        tree[i] = max(tree[2 * i], tree[2 * i + 1])

    def query(l, r):
        ret = 0
        l += num
        r += num
        while l < r:
            if l & 1:
                {{completion}}
            if r & 1:
                ret = max(ret, tree[r - 1])
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, gy + 1) < top: print(""YES"")
        else: print(""NO"")

solve()","ret = max(ret, tree[l])
                l += 1","ret = max(ret, tree[r - 1])"
"from sys import setrecursionlimit, stdin
readline = stdin.readline

# def I(): return int(readline())
# def ST(): return readline()[:-1]
# def LI(): return list(map(int, readline().split()))

def solve():
    N, m = map(int, readline().split())
    A = [0] + list(map(int, readline().split()))
    n = len(A)
    num = 1 << (n - 1).bit_length()
    tree = [0] * 2 * num
    for i in range(n):
        tree[num + i] = A[i] 
    for i in range(num - 1, 0, -1):
        tree[i] = max(tree[2 * i], tree[2 * i + 1])

    def query(l, r):
        ret = 0
        l += num
        r += num
        while l < r:
            if l & 1:
                ret = max(ret, tree[l])
                l += 1
            if r & 1:
                {{completion}}
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, gy + 1) < top: print(""YES"")
        else: print(""NO"")

solve()","ret = max(ret, tree[r - 1])","ret = max(ret, tree[r - 1])"
"input = __import__('sys').stdin.readline


log2s = [0, 0]
for i in range(2, 200005):
    log2s.append(log2s[i // 2] + 1)


n, m = map(int, input().split())
sparse = [[0] + list(map(int, input().split()))]
for j in range(20):
    sparse.append([max(sparse[j][min(i + (1 << j), m)], sparse[j][i]) for i in range(m+1)])

def getmax(L, R):
    j = log2s[R - L + 1]
    return max(sparse[j][R - (1 << j) + 1], sparse[j][L])

for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if (x1 - x2) % k != 0 or (y1 - y2) % k != 0:
        {{completion}}
    
    # i * k + x1 <= n
    i = (n - x1) // k
    h = i * k + x1
    while h > n:
        h -= k
    print('YES' if getmax(min(y1, y2), max(y1, y2)) < h else 'NO')
","print('NO')
        continue",h -= k
"input = __import__('sys').stdin.readline


log2s = [0, 0]
for i in range(2, 200005):
    log2s.append(log2s[i // 2] + 1)


n, m = map(int, input().split())
sparse = [[0] + list(map(int, input().split()))]
for j in range(20):
    sparse.append([max(sparse[j][min(i + (1 << j), m)], sparse[j][i]) for i in range(m+1)])

def getmax(L, R):
    j = log2s[R - L + 1]
    return max(sparse[j][R - (1 << j) + 1], sparse[j][L])

for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if (x1 - x2) % k != 0 or (y1 - y2) % k != 0:
        print('NO')
        continue
    
    # i * k + x1 <= n
    i = (n - x1) // k
    h = i * k + x1
    while h > n:
        {{completion}}
    print('YES' if getmax(min(y1, y2), max(y1, y2)) < h else 'NO')
",h -= k,"print('NO')
        continue"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

n,m=M();a=L();q=I()

t=[0]*(2*m)
# a is the array of initial values
def build(t,n,a):
    for i in range(n):t[i+n]=a[i]
    for i in range(n-1,0,-1):t[i]=max(t[i<<1],t[(i<<1)|1])

# change value at position p to v
def modify(t,n,p,v):
    p+=n
    t[p]=v
    while p>1:
        t[p>>1]=max(t[p],t[p^1])
        p>>=1

# find the combined value of range [l,r)
def query(t,n,l,r):
    resl=resr=0
    l+=n;r+=n
    while l<r:
        if (l&1):{{completion}}
        if (r&1):r-=1;resr=max(t[r],resr)
        l>>=1;r>>=1
    return max(resl,resr)

build(t,m,a)

for i in range(q):
    xs,ys,xf,yf,k=M()
    if abs(xs-xf)%k or abs(ys-yf)%k:print(""NO"");continue
    p=query(t,m,min(ys,yf)-1,max(ys,yf))
    z=min(xs,xf)+((n-min(xs,xf))//k)*k
    if z<=p:print(""NO"")
    else:print(""YES"")","resl=max(resl,t[l]);l+=1","r-=1;resr=max(t[r],resr)"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

n,m=M();a=L();q=I()

t=[0]*(2*m)
# a is the array of initial values
def build(t,n,a):
    for i in range(n):t[i+n]=a[i]
    for i in range(n-1,0,-1):t[i]=max(t[i<<1],t[(i<<1)|1])

# change value at position p to v
def modify(t,n,p,v):
    p+=n
    t[p]=v
    while p>1:
        t[p>>1]=max(t[p],t[p^1])
        p>>=1

# find the combined value of range [l,r)
def query(t,n,l,r):
    resl=resr=0
    l+=n;r+=n
    while l<r:
        if (l&1):resl=max(resl,t[l]);l+=1
        if (r&1):{{completion}}
        l>>=1;r>>=1
    return max(resl,resr)

build(t,m,a)

for i in range(q):
    xs,ys,xf,yf,k=M()
    if abs(xs-xf)%k or abs(ys-yf)%k:print(""NO"");continue
    p=query(t,m,min(ys,yf)-1,max(ys,yf))
    z=min(xs,xf)+((n-min(xs,xf))//k)*k
    if z<=p:print(""NO"")
    else:print(""YES"")","r-=1;resr=max(t[r],resr)","resl=max(resl,t[l]);l+=1"
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            self.s.add(el)

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])


        #print('merging', i, j, list(D[i]), list(D[j]))
        if any(x in D[i] for x in D[j]):
            r += 1
            D[i].s.clear()
            break
        else:
            for x in D[j]:
                {{completion}}

        #assert 0 not in D[i]

    #print(i, A[i], adj[i], list(D[i]))

print(r)
",D[i].add(x ^ A[i]),D[i].add(x ^ A[i])
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            {{completion}}

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])


        #print('merging', i, j, list(D[i]), list(D[j]))
        if any(x in D[i] for x in D[j]):
            r += 1
            D[i].s.clear()
            break
        else:
            for x in D[j]:
                D[i].add(x ^ A[i])

        #assert 0 not in D[i]

    #print(i, A[i], adj[i], list(D[i]))

print(r)
",self.s.add(el),D[i].add(x ^ A[i])
"import sys 
from types import GeneratorType
from collections import defaultdict

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        {{completion}}
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

input = lambda: sys.stdin.readline().rstrip()

def solve():

    N = int(input())
    A = [int(x) for x in input().split()]

    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = [int(x) - 1 for x in input().split()]
        G[x].append(y)
        G[y].append(x)
    
    
    B = [0] * N
    vals = defaultdict(set)
    res = [0]

    @bootstrap
    def fill_dfs(v, p):
        B[v] = A[v]
        if p != -1:
            B[v] ^= B[p]
        for u in G[v]:
            if u != p:
                yield fill_dfs(u, v)
        yield
                
    
    @bootstrap
    def calc_dfs(v, p):
        zero = False
        vals[v].add(B[v])
        for u in G[v]:
            if u != p:
                yield calc_dfs(u, v)
                if len(vals[v]) < len(vals[u]):
                    vals[v], vals[u] = vals[u], vals[v]
                for x in vals[u]:
                    zero |= (x ^ A[v]) in vals[v]
                for x in vals[u]:
                    vals[v].add(x)
                vals[u].clear()
        if zero:
            res[0] += 1
            vals[v].clear()
        yield

    fill_dfs(0, -1)
    calc_dfs(0, -1)

    return res[0]

print(solve())",break,vals[v].add(B[v])
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            self.s.add(el)

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])

        l = list(D[j])
        for x in l:
            if x in D[i]:
                r += 1
                D[i].s.clear()
                break
        else:
            for x in l:
                {{completion}}

            continue

        break

    #print(i, A[i], adj[i], list(D[i]))

print(r)
",D[i].add(x ^ A[i]),"r += 1
                D[i].s.clear()
                break"
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            self.s.add(el)

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])

        l = list(D[j])
        for x in l:
            if x in D[i]:
                {{completion}}
        else:
            for x in l:
                D[i].add(x ^ A[i])

            continue

        break

    #print(i, A[i], adj[i], list(D[i]))

print(r)
","r += 1
                D[i].s.clear()
                break",D[i].add(x ^ A[i])
"import collections

def caminho(parent, sala):
  resp = []
  while sala is not None:
    resp.append(sala)
    sala = parent[sala]
  return list(reversed(resp))

def solve(grafo, total, inicio):
  if len(grafo[inicio]) < 2:
    return
  globalParent = collections.defaultdict(lambda: None)
  for sala1 in grafo[inicio]:
    currentParent = collections.defaultdict(lambda: None)
    currentParent[sala1] = inicio
    
    fila = collections.deque()
    fila.append(sala1)

    while len(fila) > 0:
      y = fila.popleft()
      for x in grafo[y]:
        if x != inicio and currentParent[x] is None:
          {{completion}}

    for x in currentParent:
      if x in globalParent:
        #Deu bom
        return (caminho(globalParent, x), caminho(currentParent, x))
        
    for x,y in currentParent.items():
      globalParent[x] = y
      
    

n, m, s = map(int, input().split())
g = collections.defaultdict(list)
for i in range(m):
  x,y = map(int, input().split())
  g[x].append(y)

paths = solve(g,n,s)

if paths is None:
  print(""Impossible"")
else:
  print(""Possible"")
  for i in paths:
    print(len(i))
    print("" "".join(map(str,i)))","currentParent[x] = y
          fila.append(x)",fila.append(sala1)
"n, m, s = [int(x) for x in input().split()]
labyrinth = {x: set() for x in range(1, n+1)}
for _ in range(m):
    pt1, pt2 = [int(x) for x in input().split()]
    labyrinth[pt1].add(pt2)
d_father = {}
for pt in labyrinth[s]:
    d_father[pt] = s
if len(d_father) < 2: print('Impossible')
else:
    for pt in labyrinth[s]:
        visited = {pt, s}
        to_visit = {pt}
        while to_visit:
            new_visit = set()
            for origin in to_visit:
                for new_pt in labyrinth[origin]:
                    if new_pt not in visited:
                        if new_pt in d_father:
                            path1 = [new_pt]
                            path2 = [new_pt, origin]
                            while path1[-1] in d_father:
                                {{completion}}
                            while path2[-1] in d_father:
                                path2.append(d_father[path2[-1]])
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue
                break
            else:
                to_visit = new_visit
                continue
            break
        else: continue
        break
    else: print('Impossible')",path1.append(d_father[path1[-1]]),path2.append(d_father[path2[-1]])
"n, m, s = [int(x) for x in input().split()]
labyrinth = {x: set() for x in range(1, n+1)}
for _ in range(m):
    pt1, pt2 = [int(x) for x in input().split()]
    labyrinth[pt1].add(pt2)
d_father = {}
for pt in labyrinth[s]:
    d_father[pt] = s
if len(d_father) < 2: print('Impossible')
else:
    for pt in labyrinth[s]:
        visited = {pt, s}
        to_visit = {pt}
        while to_visit:
            new_visit = set()
            for origin in to_visit:
                for new_pt in labyrinth[origin]:
                    if new_pt not in visited:
                        if new_pt in d_father:
                            path1 = [new_pt]
                            path2 = [new_pt, origin]
                            while path1[-1] in d_father:
                                path1.append(d_father[path1[-1]])
                            while path2[-1] in d_father:
                                {{completion}}
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue
                break
            else:
                to_visit = new_visit
                continue
            break
        else: continue
        break
    else: print('Impossible')",path2.append(d_father[path2[-1]]),path1.append(d_father[path1[-1]])
"import re
import sys
exit=sys.exit
from bisect import *
from collections import *
ddict=defaultdict
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
rb=lambda:list(map(int,rl()))
rfs=lambda:rln().split()
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rl=lambda:rln().rstrip('\n')
rln=sys.stdin.readline
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'
########################################################################

n,m,s=ris()
adj=[[] for _ in range(n+1)]
for _ in range(m):
  u,v=ris()
  adj[u].append(v)

vis=[{} for _ in range(n+1)]
for i in adj[s]:
  stk=[i]
  vis[s][i]=0
  vis[i][i]=s
  while stk:
    u=stk.pop()
    if 1<len(vis[u]):
      print('Possible')
      for j in vis[u]:
        x,path=u,[]
        while j in vis[x]:
          {{completion}}
        print(len(path))
        print(*reversed(path))
      exit()
    for v in adj[u]:
      if i in vis[v] or v==s:
        continue
      stk.append(v)
      vis[v][i]=u
  
print('Impossible')
","path.append(x)
          x=vis[x][j]",path.append(vis[u][v])
"def DFS(start):
    nodes=set()
    stack=[start]
    while stack:
        parent=stack.pop()
        if(not visited[parent]):
            nodes.add(parent)
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                else:
                    if child not in nodes and child!=s:
                        {{completion}}
        else:
            if parent not in nodes and parent != s:
                return parent
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path=[]
    while node!=-1:
        path.append(node)
        node=parent_list[node]
    path.reverse()
    return path
n,m,s=map(int,input().split())
s-=1
graph=[[] for _ in range(n)]
for _ in range(m):
    a,b=map(int,input().split())
    a-=1
    b-=1
    graph[a].append(b)
visited=[False]*n
visited[s]=True
for child in graph[s]:
    end=DFS(child)
    if end!=-1:
        visited = [False] * n
        parent_list=[-1]*n
        visited[s]=True
        ans=[]
        for child in graph[s]:
            if DFS_get_path(child):
                ans.append([s]+get_path(end))
            if len(ans)==2:
                break
        print(""Possible"")
        for i in ans:
            print(len(i))
            print(*[j+1 for j in i])
        break
else:
    print(""Impossible"")

# 3 3 1
# 1 2
# 2 1
# 1 3",return child,stack.append(child)
"def DFS(start):
    nodes=set()
    stack=[start]
    while stack:
        parent=stack.pop()
        if(not visited[parent]):
            nodes.add(parent)
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    {{completion}}
                else:
                    if child not in nodes and child!=s:
                        return child
        else:
            if parent not in nodes and parent != s:
                return parent
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path=[]
    while node!=-1:
        path.append(node)
        node=parent_list[node]
    path.reverse()
    return path
n,m,s=map(int,input().split())
s-=1
graph=[[] for _ in range(n)]
for _ in range(m):
    a,b=map(int,input().split())
    a-=1
    b-=1
    graph[a].append(b)
visited=[False]*n
visited[s]=True
for child in graph[s]:
    end=DFS(child)
    if end!=-1:
        visited = [False] * n
        parent_list=[-1]*n
        visited[s]=True
        ans=[]
        for child in graph[s]:
            if DFS_get_path(child):
                ans.append([s]+get_path(end))
            if len(ans)==2:
                break
        print(""Possible"")
        for i in ans:
            print(len(i))
            print(*[j+1 for j in i])
        break
else:
    print(""Impossible"")

# 3 3 1
# 1 2
# 2 1
# 1 3",stack.append(child),return child
"l=[[*map(int,input().split())] for i in range(3)]
l=sorted(l,key=lambda x:x[1])
ans=[]
ans.append([l[0][0],l[0][1],l[0][0],l[1][1]])
l[0]=[l[0][0],l[1][1]]
if (l[1][0]<l[0][0] and l[2][0]>l[0][0]) or (l[1][0]>l[0][0] and l[2][0]<l[0][0]):
    ans.append([*l[0],l[1][0],l[0][1]])
    ans.append([*l[0],l[2][0],l[0][1]])
    ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])
else:
    if max(l[1][0],l[2][0])>l[0][0]:leng=max(l[1][0],l[2][0])
    else:{{completion}}
    ans.append([*l[0],leng,l[0][1]])
    ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])
print(len(ans))
for i in ans:
    print(*i)
","leng=min(l[1][0],l[2][0])","this is the start of the ground truth
if max(l[1][0],l[2][0])>l[0][0]:leng=max(l[1][0],l[2][0])
else:
    leng=min(l[1][0],l[2][0])
    ans.append([*l[0],leng,l[0][1]])
    ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])

this is the end of"
"result = []
t = [[0, 0], [0, 0], [0, 0]]
for i in range(3):
    t[i] = list(map(int, input().split()))

t.sort()
a = t[0]
b = t[1]
c = t[2]
d1 = b[1] - a[1]
d2 = c[1] - b[1]

if d1*d2 >= 0:  # 2nd between 1st and 3rd
    if a[1] != b[1]:
        result.append([a[0], a[1], a[0], b[1]])
    if a[0] != c[0]:
        result.append([a[0], b[1], c[0], b[1]])
    if b[1] != c[1]:
        result.append([c[0], b[1], c[0], c[1]])
else:  # additional point X needed

    d1 = b[1] - c[1]
    d2 = c[1] - a[1]
    if d1*d2 >= 0:  # 3rd between 1st and 2nd
        x = [b[0], c[1]]
        if a[1] != x[1]:
            result.append([a[0], a[1], a[0], x[1]])
        if a[0] != x[0]:
            result.append([a[0], x[1], x[0], x[1]])
        if x[0] != c[0]:
            result.append([x[0], x[1], c[0], c[1]])
        if x[1] != b[1]:
            result.append([x[0], x[1], b[0], b[1]])
    else:  # 1st between 2nd and 2rd
        x = [b[0], a[1]]
        if c[0] != x[0]:
            {{completion}}
        if c[1] != x[1]:
            result.append([x[0], c[1], x[0], x[1]])
        if x[0] != a[0]:
            result.append([x[0], x[1], a[0], a[1]])
        if x[1] != b[1]:
            result.append([x[0], x[1], b[0], b[1]])

print(len(result))
for i in range(len(result)):
    tt = result[i]
    print(tt[0], tt[1], tt[2], tt[3])


","result.append([c[0], c[1], x[0], c[1]])","result.append([x[0], c[1], x[0], x[1]])"
"result = []
t = [[0, 0], [0, 0], [0, 0]]
for i in range(3):
    t[i] = list(map(int, input().split()))

t.sort()
a = t[0]
b = t[1]
c = t[2]
d1 = b[1] - a[1]
d2 = c[1] - b[1]

if d1*d2 >= 0:  # 2nd between 1st and 3rd
    if a[1] != b[1]:
        result.append([a[0], a[1], a[0], b[1]])
    if a[0] != c[0]:
        result.append([a[0], b[1], c[0], b[1]])
    if b[1] != c[1]:
        result.append([c[0], b[1], c[0], c[1]])
else:  # additional point X needed

    d1 = b[1] - c[1]
    d2 = c[1] - a[1]
    if d1*d2 >= 0:  # 3rd between 1st and 2nd
        x = [b[0], c[1]]
        if a[1] != x[1]:
            result.append([a[0], a[1], a[0], x[1]])
        if a[0] != x[0]:
            result.append([a[0], x[1], x[0], x[1]])
        if x[0] != c[0]:
            result.append([x[0], x[1], c[0], c[1]])
        if x[1] != b[1]:
            result.append([x[0], x[1], b[0], b[1]])
    else:  # 1st between 2nd and 2rd
        x = [b[0], a[1]]
        if c[0] != x[0]:
            result.append([c[0], c[1], x[0], c[1]])
        if c[1] != x[1]:
            {{completion}}
        if x[0] != a[0]:
            result.append([x[0], x[1], a[0], a[1]])
        if x[1] != b[1]:
            result.append([x[0], x[1], b[0], b[1]])

print(len(result))
for i in range(len(result)):
    tt = result[i]
    print(tt[0], tt[1], tt[2], tt[3])


","result.append([x[0], c[1], x[0], x[1]])","result.append([x[0], c[1], x[0], x[1]])"
"'''
题意：将n个人安排到二叉树中，每两人之间通过最短路径d[i,j]通信，消息数量c[i,j]通过矩阵给出，
要求构造的二叉树满足：任意节点u的左子树中节点序号<u、右子树…>，且所有的节点对之间的c[i,j]*d[i,j]的总和最小。

区间dp，对于f[l,r]，枚举根节点k，得到最大值时记住区间[l,r]的根节点k，
最后先序遍历为每个节点指定根节点。
'''
R,G=lambda:map(int,input().split()),range;n,=R();Fa=[0]*n;N=n+1
A=lambda:[[0]*N for _ in G(N)];S,Rt,f=A(),A(),A()
for i in G(n):
  r=[*R()]
  for j in G(n):S[i+1][j+1]=r[j]+S[i][j+1]+S[i+1][j]-S[i][j]
rec=lambda i,x:S[x][x]-S[x][i]-S[i][x]+S[i][i]
for c in G(1,N):
  for l in G(N-c):
    r=l+c;f[l][l+c]=float('inf')
    for k in G(l,r):
      C=f[l][k]+S[k][n]-S[l][n]-rec(l,k)+f[k+1][r]+S[r][n]-S[k+1][n]-rec(k+1,r)
      if C<f[l][r]:{{completion}}
def F(l,r,fa):
  if l==r:return
  mid=Rt[l][r];Fa[mid]=fa+1;F(l,mid,mid);F(mid+1,r,mid)
F(0,n,-1);print(*Fa)",f[l][r]=C;Rt[l][r]=k,S[i][j] += S[i][j-1]
"n = int(input().strip())

S = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    for j, c in enumerate(map(int, input().strip().split())):
        S[i][j] = c

for i in range(n):
    for j in range(n):
        if i > 0 and j > 0:
            S[i][j] += S[i][j-1] + S[i-1][j] - S[i-1][j-1]
        elif i > 0:
            {{completion}}
        elif j > 0:
            S[i][j] += S[i][j-1]


def acc(i1, i2, j1, j2):
    if i1 >= i2 or j1 >= j2:
        return 0
    a = S[i2-1][j2-1]
    b = S[i2-1][j1-1] if j1 > 0 else 0
    c = S[i1-1][j2-1] if i1 > 0 else 0
    d = S[i1-1][j1-1] if i1 > 0 and j1 > 0 else 0
    return a - b - c + d

M = [[-1 for i in range(n)] for j in range(n)]
P = [[-1 for i in range(n)] for j in range(n)]
def solve(b, e):
    if e - b == 1:
        M[b][e-1] = 0
        return 0
    if e - b == 0:
        return 0
    if M[b][e-1] != -1:
        return M[b][e-1]
    M[b][e-1] = 1e18
    for i in range(b, e):
        s = solve(b, i) + solve(i+1, e)
        s += acc(0, b, b, i) + acc(b, i, i, n) + acc(0, i+1, i+1, e) + acc(i+1, e, e, n)
        if s < M[b][e-1]:
            M[b][e-1] = s
            P[b][e-1] = i
    return M[b][e-1]
solve(0, n)
sol = ["""" for _ in range(n)]
def label(b, e, p):
    if e - b == 1:
        sol[b] = str(p)
        return
    elif e - b == 0:
        return
    i = P[b][e-1]
    sol[i] = str(p)
    label(b, i, i+1)
    label(i+1, e, i+1)
label(0, n, 0)
print("" "".join(sol))
",S[i][j] += S[i-1][j],S[i][j] += S[i][j-1]
"n = int(input().strip())

S = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    for j, c in enumerate(map(int, input().strip().split())):
        S[i][j] = c

for i in range(n):
    for j in range(n):
        if i > 0 and j > 0:
            S[i][j] += S[i][j-1] + S[i-1][j] - S[i-1][j-1]
        elif i > 0:
            S[i][j] += S[i-1][j]
        elif j > 0:
            {{completion}}


def acc(i1, i2, j1, j2):
    if i1 >= i2 or j1 >= j2:
        return 0
    a = S[i2-1][j2-1]
    b = S[i2-1][j1-1] if j1 > 0 else 0
    c = S[i1-1][j2-1] if i1 > 0 else 0
    d = S[i1-1][j1-1] if i1 > 0 and j1 > 0 else 0
    return a - b - c + d

M = [[-1 for i in range(n)] for j in range(n)]
P = [[-1 for i in range(n)] for j in range(n)]
def solve(b, e):
    if e - b == 1:
        M[b][e-1] = 0
        return 0
    if e - b == 0:
        return 0
    if M[b][e-1] != -1:
        return M[b][e-1]
    M[b][e-1] = 1e18
    for i in range(b, e):
        s = solve(b, i) + solve(i+1, e)
        s += acc(0, b, b, i) + acc(b, i, i, n) + acc(0, i+1, i+1, e) + acc(i+1, e, e, n)
        if s < M[b][e-1]:
            M[b][e-1] = s
            P[b][e-1] = i
    return M[b][e-1]
solve(0, n)
sol = ["""" for _ in range(n)]
def label(b, e, p):
    if e - b == 1:
        sol[b] = str(p)
        return
    elif e - b == 0:
        return
    i = P[b][e-1]
    sol[i] = str(p)
    label(b, i, i+1)
    label(i+1, e, i+1)
label(0, n, 0)
print("" "".join(sol))
",S[i][j] += S[i][j-1],S[i][j] += S[i][j-1]
"n=int(input())
c=[]
for _ in range(n):
    c.append(tuple(map(int,input().split())))
prefix_sum=[[0]*(n+1) for _ in range(n+1)]
for i in range(1,n+1):
    temp=0
    for j in range(1,n+1):
        temp+=c[i-1][j-1]
        prefix_sum[i][j]+=prefix_sum[i-1][j]+temp
def get_rectangel_sum(x1,y1,x2,y2):
    return prefix_sum[x2+1][y2+1]-prefix_sum[x1][y2+1]-prefix_sum[x2+1][y1]+prefix_sum[x1][y1]
def cost(x,y):
    if x>y:
        return 0
    a=get_rectangel_sum(x,0,y,x-1) if x!=0 else 0
    b=get_rectangel_sum(x,y+1,y,n-1) if y!=n-1 else 0
    return a+b
dp=[[float(""INF"")]*n for _ in range(n)]
best_root_for_range=[[-1]*n for _ in range(n)]
for i in range(n):
    dp[i][i]=0
    best_root_for_range[i][i]=i
def get_dp_cost(x,y):
    return dp[x][y] if x<=y else 0
for length in range(1,n):
    # actual length is length+1
    for i in range(n-length):
        j=i+length
        for root in range(i,j+1):
            temp=cost(i,root-1)+cost(root+1,j)+get_dp_cost(i,root-1)+get_dp_cost(root+1,j)
            if temp<dp[i][j]:
                {{completion}}
ans=[-1]*n
def assign_ans(ansecstor,x,y):
    if x>y:
        return
    root=best_root_for_range[x][y]
    ans[root]=ansecstor
    assign_ans(root,x,root-1)
    assign_ans(root,root+1,y)
assign_ans(-1,0,n-1)
print(*[i+1 for i in ans])

# 3
# 0 1 2
# 1 0 3
# 2 3 0

# 4
# 0 1 2 3
# 1 0 5 7
# 2 5 0 4
# 3 7 4 0

# 6
# 0 100 20 37 14 73
# 100 0 17 13 20 2
# 20 17 0 1093 900 1
# 37 13 1093 0 2 4
# 14 20 900 2 0 1
# 73 2 1 4 1 0","dp[i][j]=temp
                best_root_for_range[i][j]=root","dp[i][j]=min(dp[i][k]+dp[k+1][j]+cost(i,k)+cost(k+1,j) for k in range(i,j))"
"n,s=open(0)
for x in s.split():{{completion}}",print(min(-int(x)%2**i-i+15for i in range(16))),print(min(-int(x)%2**i-i+15for i in range(16)))
"n = int(input())
mod = 1 << 15
for x in map(int, input().split()):
    res = 16
    for a in range(15):
        for b in range(15):
            if (x + a) * (1 << b) % mod == 0:
                {{completion}}
    print(res)
","res = min(res, a + b)",print(min(15-i+-x % 2**i for i in range(16)))
"n, s = open(0)
for x in map(int, s.split()):
    {{completion}}
",print(min(15-i+-x % 2**i for i in range(16))),print(min(-x % 2 ** i - i + 15 for i in range(16)))
"n,s=open(0)
for x in map(int,s.split()):{{completion}}",print(min(-x%2**i-i+15for i in range(16))),print(min(-x%2**i-i+15for i in range(16)))
"n,s=open(0)
for x in s.split():{{completion}}",print(min(-int(x)%2**i-i+15for i in range(16))),print(min(-int(x)%2**i-i+15for i in range(16)))
"import sys

def Column2Num( m, idx ):
    return int(m[0][idx] != 0)  | (int(m[1][idx]) << 1) | (int(m[2][idx]) << 2)

def QColumn( m, bits, idx ):
    if bits[idx] == 5:
        if m[0][idx] == m[2][idx]:
            return True
    return False

def GetIntegratedCount( m ):
    ret, curr = [ 0 ], set()
    for c in range( len( m[0] ) ):
        if m[0][c] != 0: curr.add( m[0][c] )
        if m[1][c] != 0: curr.add( m[1][c] )
        if m[2][c] != 0: curr.add( m[2][c] )
        ret.append( len( curr ) )
    ret.append( len( curr ) )
    return ret

def Print( tm ):
    print( '\n', tm[0], '\n', tm[1], '\n', tm[2] )

def PrintIndexed( tm ):
    for i in range( len( tm[0] ) ):
        print(  i+1, ':', tm[0][i], tm[1][i], tm[2][i] )

def next( b, next ):

    b &= next

    if b == 0:
        return b

    if b & 1 or b & 4:
        if next & 2:
            b |= 2

    if b & 2:
        if next & 1:
            b |= 1
        if next & 4:
            b |= 4

    return b

def setCompNumber( b, m, i, compNumber ):
    if b & 1:
        m[0][i] = compNumber
    if b & 2:
        m[1][i] = compNumber
    if b & 4:
        m[2][i] = compNumber


def goLeft( start, compNumber, size, m, bits, fullColumn ):
    b = bits[start]
    fc = start

    for i in range( start - 1, -1, -1 ):

        b = next( b, bits[i] ) 

        if b == 7:
            fc = i
            break

        if b == 0:
            break

        setCompNumber( b, m, i, compNumber )

        if b == 5:
            fullColumn[ i ] = fc


def goRight( start, compNumber, size, m, bits, fullColumn ):
    
    b = bits[start]

    for i in range( start, size ):

        b = next( b, bits[i] ) 

        if b == 7:
            fc = i

        if b == 0:
            break

        setCompNumber( b, m, i, compNumber )

        if b == 5:
            fullColumn[ i ] = fc

def goRight12( b, start, compNumber, size, m, bits ):
    
    for i in range( start, size ):

        b = next( b, bits[i] ) 
        if b == 0:
            break

        setCompNumber( b, m, i, compNumber )


def get3Components( compNumber, size, m, bits, leftFullColumn, rightFullColumn ):
    for i in range( size ):
        if bits[i] == 7:
            if m[ 0 ][ i  ] == 1:
                compNumber += 1
                goRight( i, compNumber, size, m, bits, leftFullColumn )
            goLeft ( i, compNumber, size, m, bits, rightFullColumn )
    return compNumber

def get12Components( compNumber, size, m, bits ):
    for i in range( size ):
        if m[ 0 ][ i  ] == 1:
            compNumber += 1
            goRight12( 1, i, compNumber, size, m, bits )
        if m[ 1 ][ i  ] == 1:
            compNumber += 1
            goRight12( 2, i, compNumber, size, m, bits )
        if m[ 2 ][ i  ] == 1:
            compNumber += 1
            goRight12( 4, i, compNumber, size, m, bits )

def SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ):
    #debug = 0
    #print( 'start,end =',s, e )
    #if debug: Print( [ m[0][s-1:e], m[1][s-1:e], m[2][s-1:e] ] )

    sol1 = 0
    if s-1 == 0:
        sol1 = integratedCount[e]
    else:
        startCnt = 1
        if bits[s-1] == 0:
            startCnt = 0
        elif bits[s-1] == 5:
            if m[0][s-1] != m[2][s-1]:
                {{completion}}

        sol1 = startCnt + integratedCount[e] - integratedCount[s]

    sQ = QColumn( m, bits, s - 1)
    eQ = QColumn( m, bits, e - 1)


    if sQ and eQ:
       if m[0][s-1] == m[2][s-1]:
           if rightFullColumn[s-1] == rightFullColumn[e-1]:
                sol1 += 1
                return sol1 
           elif leftFullColumn[s-1] == leftFullColumn[e-1]:
                sol1 += 1
                return sol1 

    if sQ:
       if rightFullColumn[s-1] != -1:
            if rightFullColumn[s-1] > e-1:
                sol1 += 1
       else:
            sol1 += 1
    if eQ:
        if leftFullColumn[e-1] != -1:
            if leftFullColumn[e-1] < s-1:
                sol1 += 1
        else:
            sol1 += 1

    return sol1

def mainBB():
    debug = 0
    input = sys.stdin
    if len( sys.argv ) >= 2:
        input = open( sys.argv[1], 'r' )

    size = int( input.readline() )
    m = []
    for i in range( 3 ):
        m.append( [ int( t ) for t in list( input.readline().strip() ) ] )
    bits = [ Column2Num( m, i ) for i in range( size ) ]    

    leftFullColumn = [ -1 for i in range( size ) ]
    rightFullColumn = list(  leftFullColumn )

    compNumber = get3Components( 1, size, m, bits, leftFullColumn, rightFullColumn )
    get12Components( compNumber, size, m, bits )
    integratedCount = GetIntegratedCount( m )

    if debug: PrintIndexed( m )
    if debug: Print( m )
    if debug: print( integratedCount )
    if debug: print( leftFullColumn )
    if debug: print( rightFullColumn )

    n = int( input.readline() )
    for i in range( n ):
        ln = input.readline().strip().split()
        s = int( ln[0] )
        e = int( ln[1] )
        if debug: print( s, e, m )

        print( SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ) )

if __name__ == ""__main__"":
    mainBB()    
    


 
",startCnt = 2,"sol1 += 1
                return sol1"
"import sys

def Column2Num( m, idx ):
    return int(m[0][idx] != 0)  | (int(m[1][idx]) << 1) | (int(m[2][idx]) << 2)

def QColumn( m, bits, idx ):
    if bits[idx] == 5:
        if m[0][idx] == m[2][idx]:
            return True
    return False

def GetIntegratedCount( m ):
    ret, curr = [ 0 ], set()
    for c in range( len( m[0] ) ):
        if m[0][c] != 0: curr.add( m[0][c] )
        if m[1][c] != 0: curr.add( m[1][c] )
        if m[2][c] != 0: curr.add( m[2][c] )
        ret.append( len( curr ) )
    ret.append( len( curr ) )
    return ret

def Print( tm ):
    print( '\n', tm[0], '\n', tm[1], '\n', tm[2] )

def PrintIndexed( tm ):
    for i in range( len( tm[0] ) ):
        print(  i+1, ':', tm[0][i], tm[1][i], tm[2][i] )

def next( b, next ):

    b &= next

    if b == 0:
        return b

    if b & 1 or b & 4:
        if next & 2:
            b |= 2

    if b & 2:
        if next & 1:
            b |= 1
        if next & 4:
            b |= 4

    return b

def setCompNumber( b, m, i, compNumber ):
    if b & 1:
        m[0][i] = compNumber
    if b & 2:
        m[1][i] = compNumber
    if b & 4:
        m[2][i] = compNumber


def goLeft( start, compNumber, size, m, bits, fullColumn ):
    b = bits[start]
    fc = start

    for i in range( start - 1, -1, -1 ):

        b = next( b, bits[i] ) 

        if b == 7:
            fc = i
            break

        if b == 0:
            break

        setCompNumber( b, m, i, compNumber )

        if b == 5:
            fullColumn[ i ] = fc


def goRight( start, compNumber, size, m, bits, fullColumn ):
    
    b = bits[start]

    for i in range( start, size ):

        b = next( b, bits[i] ) 

        if b == 7:
            fc = i

        if b == 0:
            break

        setCompNumber( b, m, i, compNumber )

        if b == 5:
            fullColumn[ i ] = fc

def goRight12( b, start, compNumber, size, m, bits ):
    
    for i in range( start, size ):

        b = next( b, bits[i] ) 
        if b == 0:
            break

        setCompNumber( b, m, i, compNumber )


def get3Components( compNumber, size, m, bits, leftFullColumn, rightFullColumn ):
    for i in range( size ):
        if bits[i] == 7:
            if m[ 0 ][ i  ] == 1:
                compNumber += 1
                goRight( i, compNumber, size, m, bits, leftFullColumn )
            goLeft ( i, compNumber, size, m, bits, rightFullColumn )
    return compNumber

def get12Components( compNumber, size, m, bits ):
    for i in range( size ):
        if m[ 0 ][ i  ] == 1:
            compNumber += 1
            goRight12( 1, i, compNumber, size, m, bits )
        if m[ 1 ][ i  ] == 1:
            compNumber += 1
            goRight12( 2, i, compNumber, size, m, bits )
        if m[ 2 ][ i  ] == 1:
            compNumber += 1
            goRight12( 4, i, compNumber, size, m, bits )

def SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ):
    #debug = 0
    #print( 'start,end =',s, e )
    #if debug: Print( [ m[0][s-1:e], m[1][s-1:e], m[2][s-1:e] ] )

    sol1 = 0
    if s-1 == 0:
        sol1 = integratedCount[e]
    else:
        startCnt = 1
        if bits[s-1] == 0:
            startCnt = 0
        elif bits[s-1] == 5:
            if m[0][s-1] != m[2][s-1]:
                startCnt = 2

        sol1 = startCnt + integratedCount[e] - integratedCount[s]

    sQ = QColumn( m, bits, s - 1)
    eQ = QColumn( m, bits, e - 1)


    if sQ and eQ:
       if m[0][s-1] == m[2][s-1]:
           if rightFullColumn[s-1] == rightFullColumn[e-1]:
                sol1 += 1
                return sol1 
           elif leftFullColumn[s-1] == leftFullColumn[e-1]:
                {{completion}} 

    if sQ:
       if rightFullColumn[s-1] != -1:
            if rightFullColumn[s-1] > e-1:
                sol1 += 1
       else:
            sol1 += 1
    if eQ:
        if leftFullColumn[e-1] != -1:
            if leftFullColumn[e-1] < s-1:
                sol1 += 1
        else:
            sol1 += 1

    return sol1

def mainBB():
    debug = 0
    input = sys.stdin
    if len( sys.argv ) >= 2:
        input = open( sys.argv[1], 'r' )

    size = int( input.readline() )
    m = []
    for i in range( 3 ):
        m.append( [ int( t ) for t in list( input.readline().strip() ) ] )
    bits = [ Column2Num( m, i ) for i in range( size ) ]    

    leftFullColumn = [ -1 for i in range( size ) ]
    rightFullColumn = list(  leftFullColumn )

    compNumber = get3Components( 1, size, m, bits, leftFullColumn, rightFullColumn )
    get12Components( compNumber, size, m, bits )
    integratedCount = GetIntegratedCount( m )

    if debug: PrintIndexed( m )
    if debug: Print( m )
    if debug: print( integratedCount )
    if debug: print( leftFullColumn )
    if debug: print( rightFullColumn )

    n = int( input.readline() )
    for i in range( n ):
        ln = input.readline().strip().split()
        s = int( ln[0] )
        e = int( ln[1] )
        if debug: print( s, e, m )

        print( SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ) )

if __name__ == ""__main__"":
    mainBB()    
    


 
","sol1 += 1
                return sol1",startCnt = 2
"for test in range(int(input())):
    n = int(input())
    h = [int(i) for i in input().split()]
    res = 2 << 69

    for req in range(max(h), max(h)+3):
        hm = req
        d = 0
        c = 0
        for i in h:
            {{completion}}
        res = min(res, max((d//3)*2+d % 3, c*2-1))

    print(res)
","d += req-i
            c += (req-i) & 1","d += (hm - i + 1) % 2
        c += (hm - i) % 2
        d += (hm - i) // 2"
"from bisect import bisect

t = int(input().strip())

def solve(o, t):
    if t - o > 1:
        {{completion}}
    return (o + (t > o)) * 2 - (o > t)


out = []
for _ in range(t):
    n = int(input().strip())
    h = list(map(int, input().strip().split()))
    mx = max(h)
    o, t, e = 0, 0, 0
    for x in h:
        e += (mx - x + 1) % 2
        o += (mx - x) % 2
        t += (mx - x) // 2
    out.append(str(min(solve(o, t), solve(e, t + o))))


print(""\n"".join(out))
","d = (t - o) // 3 + ((t - o) % 3 == 2)
        o, t = o + 2 * d, t - d","o += (mx - x) % 2
        t += (mx - x) // 2"
"from bisect import bisect

t = int(input().strip())

def solve(o, t):
    if t - o > 1:
        d = (t - o) // 3 + ((t - o) % 3 == 2)
        o, t = o + 2 * d, t - d
    return (o + (t > o)) * 2 - (o > t)


out = []
for _ in range(t):
    n = int(input().strip())
    h = list(map(int, input().strip().split()))
    mx = max(h)
    o, t, e = 0, 0, 0
    for x in h:
        {{completion}}
    out.append(str(min(solve(o, t), solve(e, t + o))))


print(""\n"".join(out))
","e += (mx - x + 1) % 2
        o += (mx - x) % 2
        t += (mx - x) // 2","d = (t - o) // 3 + ((t - o) % 3 == 2)
        o, t = o + 2 * d, t - d"
"def solve(target,r):
 k=len(r)
 ones=twos=0
 for i in range(k):
  {{completion}}
 if ones>twos:return 2*ones-1
 return (ones+twos*2)//3*2+(ones+twos*2)%3
for _ in [0]*int(input()):
 input();r=[*map(int,input().split())]
 print(min(solve(max(r),r),solve(max(r)+1,r)))","ones+=(target-r[i])%2
  twos+=(target-r[i])//2","ones+=(target-r[i])%2
		twos+=(target-r[i])//2"
"def solve(target,r):
 k=len(r)
 ones=twos=0
 for i in range(k):
  ones+=(target-r[i])%2
  twos+=(target-r[i])//2
 if ones>twos:{{completion}}
 return (ones+twos*2)//3*2+(ones+twos*2)%3
for _ in [0]*int(input()):
 input();r=[*map(int,input().split())]
 print(min(solve(max(r),r),solve(max(r)+1,r)))",return 2*ones-1,"ones+=(target-r[i])%2
  twos+=(target-r[i])//2"
"for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().strip().split()))
    l.sort()
    a=l.count(l[-1])
    odd,even=0,0
    for i in l:
        if i%2==0:
            even+=1
        else:
            {{completion}}
    su=sum(l[:n-a])
    needed=l[-1]*(n-a)-su
    if l[-1]%2==0:
        p1,p2=odd,even
    else:
        p1,p2=even,odd
    ans=max(2*(needed//3)+needed%3,2*p1-1)
    needed+=n
    ans2=max(2*(needed//3)+needed%3,2*p2-1)
    print(min(ans,ans2))",odd+=1,"odd+=needed%2
even+=needed//2"
"def solve(m,a):
    ev=od=0
    for i in a:
        {{completion}}
    if(od>=ev):
        return od*2-(od!=ev)
    ev = (ev-od)*2
    return od*2 + ev//3*2 + ev%3

I = lambda: map(int,input().split())
t,=I()
for _ in [1]*t:
    n, = I()
    b = [*I()]
    mx = max(b)
    print(min(solve(mx,b),solve(mx+1,b)))",ev += (m-i)//2; od += (m-i)%2,return od*2-(od!=ev)
"def solve(m,a):
    ev=od=0
    for i in a:
        ev += (m-i)//2; od += (m-i)%2
    if(od>=ev):
        {{completion}}
    ev = (ev-od)*2
    return od*2 + ev//3*2 + ev%3

I = lambda: map(int,input().split())
t,=I()
for _ in [1]*t:
    n, = I()
    b = [*I()]
    mx = max(b)
    print(min(solve(mx,b),solve(mx+1,b)))",return od*2-(od!=ev),ev += (m - i) // 2; od += (m - i) % 2
"# by the authority of GOD     author: Kritarth Sharma #
import sys
from collections import defaultdict,deque,Counter
from bisect import bisect_left
import math
input=sys.stdin.readline
def inp():
    l=list(map(int,input().split()))
    return l

for _ in range(int(input())):
        n,=inp()
        l=inp()
        m=max(l)
        a=float('inf')
        for i in range(m,m+2):
            x=0
            y=0
            for j in range(n):
                {{completion}}
            a=min(a,max( 2*y -1, ((2*x+y)//3)*2 +((2*x+y)%3) ))
        print(a)","x+=(i-l[j])//2
                y+=(i-l[j])%2","x+=i-l[j]
y+=i-l[j]"
"def solve1(n, h, asdf):
    max_h = max(h)
    
    diff_h = list(map(lambda x:max_h+asdf-x, h))
    required_h = sum(diff_h)
    min_odd_days = sum(1 for diff in diff_h if diff % 2 == 1)
    
    if required_h < min_odd_days * 3:
        return min_odd_days * 2 - 1
    else:
        {{completion}}

def solve():
    n = int(input())
    h = list(map(int, input().split()))

    print(min(solve1(n, h, 0), solve1(n, h, 1)))

tc = int(input())
for _ in range(tc):
    solve()
",return (required_h//3) * 2 + (required_h % 3),return (required_h + min_odd_days) // 3 + (required_h + min_odd_days) % 3 == 2
"inp = lambda : list(map(int,input().split()))
for _ in range(int(input())):
    n = int(input())
    t = inp()
    c = 0
    m = max(t)
    def mm(m):
        n1 = n2 = 0
        tot =0
        for i in t:
            {{completion}}
        return (n1*2-1) if n2<n1 else ((n2*2+n1)//3*2+(n2*2+n1)%3)    

    print(min(mm(m),mm(m+1)))","n1+= (m-i)%2
            n2+= (m-i)//2","n1 += (m - i + 1) % 2
        n2 += (m - i) % 2
        tot += (m - i) // 2"
"for ii in range(int(input())):
	n=int(input())
	a = list(map(int, input().split()))
	m=max(a)
	ans=float(""inf"")
	for jj in range(m,m+4):
		x,y=0,0
		for kk in a:
			{{completion}}
		ans=min(max(((x+y*2)//3*2)+(x+y*2)%3,x*2-1),ans)
	print(ans)","x+=(jj-kk)%2
			y+=(jj-kk)//2","x += jj-kk
y += jj-kk & 1"
"n,k = map(int, input().split())
bb = list(map(int, input().split()))
ans = 0
sofar = 0
sumprog = 0
timeq = []
for ib,b in enumerate(bb[::-1]):
    kk = min(k, n-ib)
    time = (max(0,b-sofar)+kk-1)//kk
    ans += time
    timeq.append(time)
    sumprog += time
    if ib >= k:
        {{completion}}
    sofar += kk*time
    sofar -= sumprog
    # print(time, sofar, timeq, sumprog)
print(ans)
",sumprog -= timeq[ib-k],"if ib >= k:
    K = min(k, key+1)
    dd[-K] -= (i+K-1)//K
    diff += (i+K-1)//K
    moves += (i+K-1)//K
    add -= K*((i+K-1)//K)"
"I = lambda: [int(x) for x in input().split()]
n, k = I()
B, d = I() + [0]*k, [0] * (n + k)

s = total = 0
for i in range(n-1, -1, -1):
    B[i] -= total
    if B[i] > 0:
        {{completion}}
    s += d[i] - d[i + k]
    total += d[i] * dd - s
    
print(sum(d))","dd = min(k, i + 1)
        d[i] = (B[i] + dd - 1)//dd","dd = [0]*(n+k)
for i in range(n-1,-1,-1):
    dd[i] = dd[i+k] = d[i]
    dd[i] += B[i]
    d[i] = min(dd[i],k)
    dd[i] -= d[i]
    total += d[i]"
"#!/usr/bin/env PyPy3

from collections import Counter, defaultdict, deque
import itertools
import re
import math
from functools import reduce
import operator
import bisect
import heapq
import functools
mod=10**9+7

import sys
input=sys.stdin.readline
n,k=map(int,input().split())
b=list(map(int,input().split()))
ans = 0
dec = 0
cnt = [0] * n
tmp = 0
for i in range(k-1,n)[::-1]:
    tmp -= cnt[i]
    dec -= tmp
    #print(tmp,dec)
    if b[i] > dec:
        #print(b[i]-dec)
        x = -(-(b[i]-dec) // k)
        ans += x
        if i - k - 1 >= 0:
            {{completion}}
        dec += x * k
        tmp += x
    #print(ans)
    #tmp -= cnt[i]
#print(cnt)
ma = 0
for i in range(k-1)[::-1]:
    tmp -= cnt[i]
    dec -= tmp
    ma = max(ma,-(-(b[i]-dec) // (i+1)))

print(ans+ma)",cnt[i-k-1] = x,cnt[i] += ma
"n, k = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]

dd = [0]*(len(a)+5)

add = 0
diff = 0
moves = 0
for key, i in reversed([*enumerate(a)]):
    add += diff
    i += add
    diff += dd[-1]
    dd.pop()
    if i > 0:
        {{completion}}
print(moves)
","K = min(k, key+1)
        dd[-K] -= (i+K-1)//K
        diff += (i+K-1)//K
        moves += (i+K-1)//K
        add -= K*((i+K-1)//K)",dd.append(i)
"""""""
take element as ""the tail"" will use more less operations,

use variables s,cnt and closed,
to avoid the inner iteration(update neighbor k elements every time),
complexity is O(n).
""""""
row=lambda:map(int,input().split())
n,k=row()
a=list(row())
closed=[0]*n
s=cnt=res=0
for i in range(n-1,-1,-1):
    # print(i,a[i],'s,cnt:',s,cnt,'closed:',closed)
    s-=cnt
    cnt-=closed[i]
    a[i]-=s
    if a[i]<=0:
        {{completion}}
    th=min(i+1,k)
    need=(a[i]+th-1)//th#equals ceil()
    s+=need*th
    cnt+=need
    res+=need
    if i>=th:
        closed[i-th]+=need
print(res)",continue,closed[i-th]+=need
"""""""
take element as ""the tail"" will use more less operations,

use variables s,cnt and closed,
to avoid the inner iteration(update neighbor k elements every time),
complexity is O(n).
""""""
row=lambda:map(int,input().split())
n,k=row()
a=list(row())
closed=[0]*n
s=cnt=res=0
for i in range(n-1,-1,-1):
    # print(i,a[i],'s,cnt:',s,cnt,'closed:',closed)
    s-=cnt
    cnt-=closed[i]
    a[i]-=s
    if a[i]<=0:
        continue
    th=min(i+1,k)
    need=(a[i]+th-1)//th#equals ceil()
    s+=need*th
    cnt+=need
    res+=need
    if i>=th:
        {{completion}}
print(res)",closed[i-th]+=need,"dd = min(k, i + 1)
        d[i] = (B[i] + dd - 1)//dd"
"import math     
n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))
ans = res = tot = minus = 0
pre = []
prefix = []
for i in range(n)[::-1]:
    if i < n - 1:
        {{completion}}
    nums[i] -= minus
    cur = max(0, math.ceil(nums[i] / k))
    ans += (cur if i >= k else 0)
    pre.append(cur if i >= k else 0)
    tot += (cur if i >= k else 0)
    if len(pre) > k:
        tot -= pre[- k - 1]
    prefix.append(tot)
for i in range(k):
    res = max(res, math.ceil(nums[i] / (i + 1)))
print(ans + res)  ",minus += k * pre[-1] - prefix[-1],tot -= pre[- k - 1]
"import math     
n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))
ans = res = tot = minus = 0
pre = []
prefix = []
for i in range(n)[::-1]:
    if i < n - 1:
        minus += k * pre[-1] - prefix[-1]
    nums[i] -= minus
    cur = max(0, math.ceil(nums[i] / k))
    ans += (cur if i >= k else 0)
    pre.append(cur if i >= k else 0)
    tot += (cur if i >= k else 0)
    if len(pre) > k:
        {{completion}}
    prefix.append(tot)
for i in range(k):
    res = max(res, math.ceil(nums[i] / (i + 1)))
print(ans + res)  ",tot -= pre[- k - 1],minus += k * pre[-1] - prefix[-1]
"I=lambda:[*map(int,input().split())]
def F(g,i):s=g//i;b=g%i;return b*(s+1)**2+(i-b)*s**2
def f(g,c):
	if c>g**2//2:return 0,g**2
	s=0;b=g
	while b-s>1:
		m=(b+s)//2
		if F(g,m)-F(g,m+1)>=c:s=m
		else:{{completion}}
	return s,F(g,b)
n,=I()
a=[0]+I()
m,=I()
G=[a[i+1]-a[i]for i in range(n)]
s=2
b=1<<59
while b-s>1:
	C=0;M=(b+s)//2
	for g in G:a,c=f(g,M);C+=c
	if C>m:b=M
	else:s=M
A=C=0
for g in G:a,c=f(g,b);A+=a;C+=c
print(A+max(0,(C-m-1)//s+1))",b=m,b=m
"from collections import Counter
n, a, m = int(input()), [*map(int, input().split())], int(input())
def energy(l, t):
    x,y = divmod(l, t+1)
    return x*x*(t+1-y)+(x+1)*(x+1)*y
def getdiff(l, diff):
    lo, hi = 0, l
    while lo < hi:
        mid = lo + hi >> 1
        if energy(l, mid) - energy(l, mid+1) < diff: hi = mid
        else: {{completion}}
    return lo, energy(l, lo)
def getsum(d, c=0): a1,a2 = zip(*[getdiff(i, d) for i,_ in a]); return (0 if c else sum(a1[i]*x for i, (_, x) in enumerate(a)), sum(a2[i]*x for i, (_, x) in enumerate(a)))
a = [0] + a
a = Counter([a[i+1]-a[i] for i in range(n)]).items()
lo, hi = 1, m
while lo < hi:
    mid = lo + hi >> 1
    if getsum(mid, 1)[1] > m: hi = mid
    else: lo = mid + 1
lo-=1
a1, a2 = getsum(lo)
print(a1-(m-a2)//lo if lo else a1)",lo = mid + 1,mid = lo + hi >> 1
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

def ff(gap, ints): 
	sml = gap // ints
	bigcount = gap % ints
	return bigcount * (sml + 1) ** 2 + (ints - bigcount) * sml ** 2

def f(gap, c):
	if c > gap ** 2 // 2:
		return 0, gap ** 2
	sml = 0
	big = gap
	while big - sml > 1:
		mid = (big + sml) // 2
		a = ff(gap, mid)
		b = ff(gap, mid + 1)
		if a - b >= c:
			sml = mid
		else:
			{{completion}}
	return sml, ff(gap, big)

n, = I()
a = I()
m, = I()
gaps = [a[0]]
for i in range(n - 1):
	gaps.append(a[i + 1] - a[i])

sml = 2
big = 1 << 59 + 2
while big - sml > 1:
	cost = 0
	mid = (big + sml) // 2
	for g in gaps:
		a, c = f(g, mid)
		cost += c
	if cost > m:
		big = mid
	else:
		sml = mid
abig = 0
cbig = 0
for g in gaps:
	a, c = f(g, big)
	abig += a
	cbig += c

print(abig + max(0, (cbig - m - 1) // sml + 1))",big = mid,big = mid + 1
"from functools import cache
from math import inf
from itertools import accumulate

def solve(A, m):
    n = len(A)
    A.reverse()

    @cache
    def dp(i, val, balance):
        if abs(balance) > m:
            {{completion}}
        if (n - i) * val > m:
            return inf
        if i == n:
            return 0 if balance == 0 else inf

        curr = A[i] + balance
        take = abs(curr - val) + dp(i + 1, val, curr - val)
        skip = dp(i, val + 1, balance)
        return min(take, skip)

    return dp(0, 0, 0)


n, m = map(int, input().split())
A = list(map(int, input().split()))
print(solve(A, m))
",return inf,return inf
"from functools import cache
from math import inf
from itertools import accumulate

def solve(A, m):
    n = len(A)
    A.reverse()

    @cache
    def dp(i, val, balance):
        if abs(balance) > m:
            return inf
        if (n - i) * val > m:
            {{completion}}
        if i == n:
            return 0 if balance == 0 else inf

        curr = A[i] + balance
        take = abs(curr - val) + dp(i + 1, val, curr - val)
        skip = dp(i, val + 1, balance)
        return min(take, skip)

    return dp(0, 0, 0)


n, m = map(int, input().split())
A = list(map(int, input().split()))
print(solve(A, m))
",return inf,return inf
"from itertools import accumulate
I=lambda:map(int,input().split())
n,m=I()
a,inf=[*I()],float('inf')
pre=[0]+[*accumulate(a)]

dp=[[inf]*(m+1) for _ in range(m+1)]
dp[m][0]=0
for i in range(n):
  cur=[[inf]*(m+1) for _ in range(m+1)]
  for lst in reversed(range(m+1)):
    for sums in range(m+1):
      if lst<m:
        {{completion}}
      if sums+lst<=m:
        cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))
  dp,cur=cur,dp
print(min(dp[lst][m] for lst in range(m+1)))","dp[lst][sums]=min(dp[lst][sums],dp[lst+1][sums])","cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))"
"from itertools import accumulate
I=lambda:map(int,input().split())
n,m=I()
a,inf=[*I()],float('inf')
pre=[0]+[*accumulate(a)]

dp=[[inf]*(m+1) for _ in range(m+1)]
dp[m][0]=0
for i in range(n):
  cur=[[inf]*(m+1) for _ in range(m+1)]
  for lst in reversed(range(m+1)):
    for sums in range(m+1):
      if lst<m:
        dp[lst][sums]=min(dp[lst][sums],dp[lst+1][sums])
      if sums+lst<=m:
        {{completion}}
  dp,cur=cur,dp
print(min(dp[lst][m] for lst in range(m+1)))","cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))","dp[lst][sums]=min(dp[lst][sums],dp[lst+1][sums])"
"n,m=map(int,input().split())
a=list(map(int,input().split()))[::-1]

id=[]
for i in range(n):
  for _ in range(a[i]):
    id.append(i)

inf=10**5
dp=[[inf]*(m+1) for i in range(m+1)]
dp[0][0]=0
for i in range(n):
  cost=[]
  for j in id:
    cost.append(abs(i-j))
  cum=[0]
  tmp=0
  for j in cost:
    tmp+=j
    cum.append(tmp)
  
  dp_new=[[inf]*(m+1) for i in range(m+1)]
  for j in range(m+1):
    mx=(m-j)//(n-i)
    for k in range(mx+1):
      if dp[j][k]==inf:{{completion}}
      #print(i,j,k,mx)
      for l in range(k,mx+1):
        #print(l)
        c=cum[l+j]-cum[j]
        dp_new[j+l][l]=min(dp_new[j+l][l],dp[j][k]+c)
  dp=dp_new
print(min(dp[-1]))",continue,"c=cum[l+j]-cum[j]
        dp_new[j+l][l]=min(dp_new[j+l][l],dp[j][k]+c)"
"n,m=map(int,input().split())
a=list(map(int,input().split()))[::-1]

id=[]
for i in range(n):
  for _ in range(a[i]):
    id.append(i)

inf=10**5
dp=[[inf]*(m+1) for i in range(m+1)]
dp[0][0]=0
for i in range(n):
  cost=[]
  for j in id:
    cost.append(abs(i-j))
  cum=[0]
  tmp=0
  for j in cost:
    tmp+=j
    cum.append(tmp)
  
  dp_new=[[inf]*(m+1) for i in range(m+1)]
  for j in range(m+1):
    mx=(m-j)//(n-i)
    for k in range(mx+1):
      if dp[j][k]==inf:continue
      #print(i,j,k,mx)
      for l in range(k,mx+1):
        #print(l)
        {{completion}}
  dp=dp_new
print(min(dp[-1]))","c=cum[l+j]-cum[j]
        dp_new[j+l][l]=min(dp_new[j+l][l],dp[j][k]+c)","cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, K = map(int, getIntArray(2))
    A = getIntArray(N)

    s = [set() for i in range(3005)]
    for i in range(N):
        for k in range(1, K + 1):
            s[A[i] // k].add(i)

    ans = 999999999999999999999999999999999999999999999999999999999999999999999
    r = 0
    freq = {}
    for l in range(len(s)):
        while len(freq) < N and r < len(s):
            for v in s[r]:
                if v not in freq: {{completion}}
                freq[v] += 1
            r += 1
        if len(freq) < N: break
        ans = min(ans, r - l - 1)
        for v in s[l]:
            if freq[v] == 1: del freq[v]
            else: freq[v] -= 1
    print(ans)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",freq[v] = 0,freq[v] -= 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, K = map(int, getIntArray(2))
    A = getIntArray(N)

    s = [set() for i in range(3005)]
    for i in range(N):
        for k in range(1, K + 1):
            s[A[i] // k].add(i)

    ans = 999999999999999999999999999999999999999999999999999999999999999999999
    r = 0
    freq = {}
    for l in range(len(s)):
        while len(freq) < N and r < len(s):
            for v in s[r]:
                if v not in freq: freq[v] = 0
                freq[v] += 1
            r += 1
        if len(freq) < N: break
        ans = min(ans, r - l - 1)
        for v in s[l]:
            if freq[v] == 1: del freq[v]
            else: {{completion}}
    print(ans)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",freq[v] -= 1,freq[v] -= 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    map = {}
    for i in range(N):
        if A[i] not in map: map[A[i]] = []
        map[A[i]].append(i)

    for color in range(1, N + 1):
        if color not in map:
            print(0, end=' ')
            continue
        ar = map[color]
        oddCount = evenCount = 0
        for i in ar:
            if i % 2 == 0:
                evenCount = max(evenCount, oddCount + 1)
            else:
                {{completion}}
        print(max(oddCount, evenCount), end=' ')
    print()


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens","oddCount = max(oddCount, evenCount + 1)","evenCount = max(evenCount, oddCount + 1)"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    map = {}
    for i in range(N):
        if A[i] not in map: map[A[i]] = []
        map[A[i]].append(i)

    for color in range(1, N + 1):
        if color not in map:
            print(0, end=' ')
            continue
        ar = map[color]
        oddCount = evenCount = 0
        for i in ar:
            if i % 2 == 0:
                {{completion}}
            else:
                oddCount = max(oddCount, evenCount + 1)
        print(max(oddCount, evenCount), end=' ')
    print()


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens","evenCount = max(evenCount, oddCount + 1)","oddCount = max(oddCount, evenCount + 1)"
"n, d = map(int, input().split())
p = sorted(map(int, input().split()), reverse=True)
ans = 0
for num in p:
    if n >= d // num + 1:
        n -= d // num + 1
        ans += 1
    else:
        {{completion}}
print(ans)
",break,ans += 1
"def solve():
    n, d = [int(i) for i in input().split(' ')]
    power = [int(i) for i in input().split(' ')]
    
    power.sort()

    used = 0
    w = 0
    for i in range(len(power)-1, -1, -1):
        min_players = -(d // -power[i])
        p = power[i] * min_players
        if(p > d):
            used += min_players
        elif(p == d):
            {{completion}}

        if(used > n):
            break

        w += 1

    print(w)

solve()",used += min_players + 1,"if(p > d):
        used += min_players
    elif(p == d):
        used += min_players
        w += 1"
"import math
enemy_power=int(input().split()[1])
team=[int(i) for i in input().split()]
team.sort()
days=0
while len(team)>0:
    num=enemy_power//team[-1]+1
    if len(team)<num:
        break;
    else:
        {{completion}}
print(days)","del team[-1]
        del team[0:num-1]
        days+=1",days+=1
"n,d=map(int,input().split())
s=list(map(int,input().split()))
k=n
r=-1
s.sort()
while k-(d//s[r])-1>=0:
	k-=((d//s[r])+1)
	r-=1
	if r<-n:
		{{completion}}
print(-1-r)",break,"k-=((d//s[r])+1)
	r-=1
	if r<-n:
		break"
"import sys,math
n,team=map(int,sys.stdin.readline().split())
arr=sorted(map(int,sys.stdin.readline().split()),reverse=True)
# print(arr)
all=n+1
count=0
for i in range(n):
    sub=int(math.floor(team/arr[i])+1)
    all-=sub
    if all>0:
        count+=1
    else:{{completion}}
print(count)",break,"































































































































"
"def solve():
    n,d=map(int,input().split())
    a=sorted([*map(int,input().split())])[::-1]
    i,j,r=0,len(a),0
    while i<j:
        x=a[i]
        while x<=d:
            j-=1
            if i<j:
                x+=a[i]
            else:
                {{completion}}
        else:
            r+=1
            i+=1
    return r
print(solve())
",return r,"x=a[i]
        while x<=d:
            j-=1
            if i<j:
                x+=a[i]
            else:
                break"
"from sys import stdin,stdout
def ans():
    n,d=map(int,stdin.readline().strip().split())
    p=list(map(int,stdin.readline().strip().split()))
    temp=int(n)
    ans=0
    for x in sorted(p,reverse=True):
        if temp>=((d//x)+1):
            {{completion}}
    print(ans)     
    
if __name__=='__main__':
    ans()
","temp-=((d//x)+1)
            ans+=1",break
"d = int(input().split("" "")[1])
p = sorted(map(int, input().split("" "")))
c = 0
l = 0
r = len(p) - 1

s = p[r]

while r > l:
    while s <= d:
        {{completion}}
    if l > r:
        break
    r -= 1
    s = p[r]
    c += 1

if p[0] > d:
    c += 1

print(c)
","s += p[r]
        l += 1",break
"d = int(input().split("" "")[1])
p = sorted(map(int, input().split("" "")))
c = 0
l = 0
r = len(p) - 1

s = p[r]

while r > l:
    while s <= d:
        s += p[r]
        l += 1
    if l > r:
        {{completion}}
    r -= 1
    s = p[r]
    c += 1

if p[0] > d:
    c += 1

print(c)
",break,"s += p[r]
        l += 1"
"import sys
input=sys.stdin.readline

from heapq import heappush,heappop,heapify 
from collections import defaultdict
 
def main():
	n,m=map(int,input().split())
	gf=defaultdict(list)
	gb=defaultdict(list)
	for _ in range(m):
		u,v,w=map(int,input().split())
		gf[u].append((v,w))
		gb[v].append((u,w))
	dis=[float('inf')]*(n+1)
	dis[1]=0
	h=[]
	heapify(h)
	heappush(h,(0,1))
	while h:
		cd,cn=heappop(h)
		if dis[cn]==cd:
			for nn,nw in gf[cn]:
				if cd+nw<dis[nn]:
					{{completion}}
	res=[float('inf')]*(n+1)
	res[1]=0
	h=[]
	for i in range(1,n+1):
		if dis[i]!=float('inf'):
			res[i]=dis[i]
			h.append((dis[i],i))
	heapify(h)
	while h:
		cd,cn=heappop(h)
		if res[cn]==cd:
			for nn,nw in gb[cn]:
				if cd+nw<res[nn]:
					res[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	for i in range(1,len(res)):
		if res[i]==float('inf'):res[i]=-1
	print(*res[2:])

main()","dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))","heappush(h,(nw+cd,nn))"
"import sys
input=sys.stdin.readline

from heapq import heappush,heappop,heapify 
from collections import defaultdict
 
def main():
	n,m=map(int,input().split())
	gf=defaultdict(list)
	gb=defaultdict(list)
	for _ in range(m):
		u,v,w=map(int,input().split())
		gf[u].append((v,w))
		gb[v].append((u,w))
	dis=[float('inf')]*(n+1)
	dis[1]=0
	h=[]
	heapify(h)
	heappush(h,(0,1))
	while h:
		cd,cn=heappop(h)
		if dis[cn]==cd:
			for nn,nw in gf[cn]:
				if cd+nw<dis[nn]:
					dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	res=[float('inf')]*(n+1)
	res[1]=0
	h=[]
	for i in range(1,n+1):
		if dis[i]!=float('inf'):
			res[i]=dis[i]
			h.append((dis[i],i))
	heapify(h)
	while h:
		cd,cn=heappop(h)
		if res[cn]==cd:
			for nn,nw in gb[cn]:
				if cd+nw<res[nn]:
					{{completion}}
	for i in range(1,len(res)):
		if res[i]==float('inf'):res[i]=-1
	print(*res[2:])

main()","res[nn]=cd+nw
					heappush(h,(nw+cd,nn))","dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))"
"def ev(x):
    k = 0
    while x%2 == 0:
        x//=2
        k+=1
    return x+k
p,q = [int(i) for i in input().split()]
t,s,sum = 1,1,0
while True:
    ss = s + (t+1)//2
    if ss > p:
        m = (p-s+1)
        sum += m*t
        break
    sum += t*((t+1)//2)
    s = ss
    t += 1
mx = t-2*m+1
print(sum)
mul,ded,turn = 0,0,0
t -= 0 if mx==turn else 1
for i in range(q):
    x = int(input())
    if x == 1:
        print(1)
        continue
    while True:
        if x-ded <= t:
            {{completion}}
        ded += (t+1)//2
        turn+=1
        mul += 1
        t -= 0 if mx==turn else 1","print(ev(x-ded)+mul)
            break","print(ev(x-ded)+mul)
            break"
"def ev(x):
    k = 0
    while x%2 == 0:
        x//=2
        k+=1
    return x+k
p,q = [int(i) for i in input().split()]
t = 1
s = 1
sum = 0
while True:
    ss = s + (t+1)//2
    if ss > p:
        m = (p-s+1)
        sum += m*t
        break
    sum += t*((t+1)//2)
    s = ss
    t += 1
mx = t-2*m+1
print(sum)
tt = t
mul = 0
ded = 0
turn = 0
tt -= 0 if mx==turn else 1
for i in range(q):
    x = int(input())
    if x == 1:
        print(1)
        continue
    while True:
        #print(""A:"",turn,tt,x-ded)
        if x-ded <= tt:
            {{completion}}
        #print(""WUT"")
        if tt < 0:
            print(ev(x-ded)+mul)
            break
        ded += (tt+1)//2
        turn+=1
        mul += 1
        tt -= 0 if mx==turn else 1","print(ev(x-ded)+mul)
            break","print(ev(x-ded)+mul)
            break"
"def ev(x):
    k = 0
    while x%2 == 0:
        x//=2
        k+=1
    return x+k
p,q = [int(i) for i in input().split()]
t = 1
s = 1
sum = 0
while True:
    ss = s + (t+1)//2
    if ss > p:
        m = (p-s+1)
        sum += m*t
        break
    sum += t*((t+1)//2)
    s = ss
    t += 1
mx = t-2*m+1
print(sum)
tt = t
mul = 0
ded = 0
turn = 0
tt -= 0 if mx==turn else 1
for i in range(q):
    x = int(input())
    if x == 1:
        print(1)
        continue
    while True:
        #print(""A:"",turn,tt,x-ded)
        if x-ded <= tt:
            print(ev(x-ded)+mul)
            break
        #print(""WUT"")
        if tt < 0:
            {{completion}}
        ded += (tt+1)//2
        turn+=1
        mul += 1
        tt -= 0 if mx==turn else 1","print(ev(x-ded)+mul)
            break","print(ev(x-ded)+mul)
            break"
"import sys

#sys.stdin = open(""C:\\Users\\asawe\\Documents\\input.txt"",""r"")

mx = 3 * (10 ** 5) + 10
mod = 998244353

fact = [1]
inv_fact = [1]


def modpow(a, b, m):
    res = 1
    x = a
    y = b

    while (y > 0):
        if (y & 1):
            {{completion}}
        y = y >> 1
        x = ((x % m) * (x % m)) % m

    return (res % m + m) % m

def inverse(a, m):
    u,v = 0,1
    while a != 0:
        t = m // a
        m -= t * a
        a, m = m, a
        u -= t * v
        u, v = v, u
    return u

for i in range(1, mx):
    fact.append((fact[-1] * i) % mod)
    inv_fact.append(inverse(fact[-1], mod)%mod)

def P(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[n - k]) % mod

def C(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[k] * inv_fact[n - k]) % mod

n,m = map(int,sys.stdin.readline().split())
a = list(map(int,sys.stdin.readline().split()))
s = sum(a)

psum = [0] * n
for i in range(n-1):
    psum[i] = psum[i-1] + a[i]
di = {}
for i in psum:
    di[i] = 0
count = 0
for i in psum:
    if i + s/2 in di:
        count+=1
v = n - 2 * count
ans = 0
for i in range(count+1):
    ans = (ans + C(count,i) * P(m,count-i) * modpow(m-count+i,v,mod) * modpow(P(m-count+i,2),i,mod)) % mod
print(ans)
",res = (res * x) % m,"ans = (ans + C(count,i) * P(m,count-i) * modpow(m-count+i,v,mod) * modpow(P(m-count+i,2),i,mod))%mod
            i+=1"
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if n%2:
            res = (res*a)%p
            n-=1
        else:
            {{completion}}
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      anss+=ans
print(anss%pmod)","a = (a*a)%p
            n//=2","a = (a*a)%p
            n//=2"
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if n%2:
            {{completion}}
        else:
            a = (a*a)%p
            n//=2
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      anss+=ans
print(anss%pmod)","res = (res*a)%p
            n-=1","res = (res*a)%p
            n-=1"
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if n%2:
            res = (res*a)%p
            n-=1
        else:
            {{completion}}
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      ans%=pmod
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      ans%=pmod
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      ans%=pmod
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      ans%=pmod
      anss+=ans
print(anss%pmod)","a = (a*a)%p
            n//=2","a = (a*a)%p
            n//=2"
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if n%2:
            {{completion}}
        else:
            a = (a*a)%p
            n//=2
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      ans%=pmod
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      ans%=pmod
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      ans%=pmod
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      ans%=pmod
      anss+=ans
print(anss%pmod)","res = (res*a)%p
            n-=1","res = (res*a)%p
            n-=1"
"import sys
input = sys.stdin.buffer.readline 

class SegmentTree:
    def __init__(self, data, default=0, func=lambda x, y: x+y):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        """"""func of data[start, stop)""""""
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                {{completion}}
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
def process(A):
    n = len(A)
    A1 = []
    curr = 0
    for i in range(n):
        curr+=A[i]
        A1.append([curr, i])
    if min(A1)[0] < 0 or max(A1)[0] != A1[-1][0]:
        print(""-1"")
        return
    A1.sort()
    A1 = [[i, A1[i][1]] for i in range(n)]
    A1.sort(key=lambda a:a[1])
    S = SegmentTree(data=[0 for i in range(n)])
    answer = 0
    for x, i in A1:
        answer+=S.query(x+1, n)
        S[x] = 1
    print(answer)
    
n = int(input())
A = [int(x) for x in input().split()]
process(A)","res_left = self._func(res_left, self.data[start])
                start += 1",S = SegmentTree(data=[0 for i in range(n)])
"import sys
input = sys.stdin.buffer.readline 

class SegmentTree:
    def __init__(self, data, default=0, func=lambda x, y: x+y):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        """"""func of data[start, stop)""""""
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                {{completion}}
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
def process(A):
    n = len(A)
    A1 = []
    curr = 0
    for i in range(n):
        curr+=A[i]
        A1.append([curr, i])
    if min(A1)[0] < 0 or max(A1)[0] != A1[-1][0]:
        print(""-1"")
        return
    A1.sort()
    A1 = [[i, A1[i][1]] for i in range(n)]
    A1.sort(key=lambda a:a[1])
    S = SegmentTree(data=[0 for i in range(n)])
    answer = 0
    for x, i in A1:
        answer+=S.query(x+1, n)
        S[x] = 1
    print(answer)
    
n = int(input())
A = [int(x) for x in input().split()]
process(A)","stop -= 1
                res_right = self._func(self.data[stop], res_right)",self.push(l >> i)
"def solve(a, b):
    inf = 2 * 10 ** 6
    d, n = inf, len(b)

    for i in range(n):
        if b[i] > 0:
            {{completion}}

    # b[i] > a[i]
    if d < 0:
        print(""NO"")
        return
    # All elements of b are 0s
    if d == inf:
        print(""YES"")
        return

    for i in range(n):
        if a[i] - b[i] > d:
            print(""NO"")
            return
        if b[i] > 0 and a[i] - b[i] < d:
            print(""NO"")
            return
    # all a[i] - b[i] == d
    print(""YES"")

def main():
    from sys import stdin
    from itertools import islice

    tkns = map(int, stdin.read().split())
    t = next(tkns)

    for T in range(t):
        n = next(tkns)
        a, b = list(islice(tkns, n)), list(islice(tkns, n))

        solve(a, b)

main()
","d = min(d, a[i] - b[i])",return
"def solve(a, b):
    inf = 2 * 10 ** 6
    d, n = inf, len(b)

    for i in range(n):
        if b[i] > 0:
            d = min(d, a[i] - b[i])

    # b[i] > a[i]
    if d < 0:
        print(""NO"")
        return
    # All elements of b are 0s
    if d == inf:
        print(""YES"")
        return

    for i in range(n):
        if a[i] - b[i] > d:
            {{completion}}
        if b[i] > 0 and a[i] - b[i] < d:
            print(""NO"")
            return
    # all a[i] - b[i] == d
    print(""YES"")

def main():
    from sys import stdin
    from itertools import islice

    tkns = map(int, stdin.read().split())
    t = next(tkns)

    for T in range(t):
        n = next(tkns)
        a, b = list(islice(tkns, n)), list(islice(tkns, n))

        solve(a, b)

main()
","print(""NO"")
            return","d = min(d, a[i] - b[i])"
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  a = list(map(int, inp(n)))
  s = list(inp1())
  d = {}
  ok = True
  for i in range(n):
    if a[i] not in d:
      d[a[i]] = s[i]
    elif d[a[i]] != s[i]:
      {{completion}}
  print(""YES"" if ok else ""NO"")

","ok = not ok
      break","d[a[i]] = s[i]
      if d[a[i]]!= s[i]:
        ok = False"
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  c = inp1()
  s = inp1()
  ret = 0
  l = []
  last = ''
  for i in range(n):
    cur = s[i]
    if cur == last:
      continue
    if cur == c:
      last = cur
      l.append((c, i))
    elif cur == 'g':
      {{completion}}
  first_g = -1
  for i in range(len(l)):
    if l[i][0] == 'g' and first_g != -1:
      continue
    elif l[i][0] == 'g' and first_g == -1:
      first_g = l[i][1]
    elif i == len(l) - 1:
      ret = max(ret, n - l[i][1] + first_g)
    else:
      ret = max(ret, l[i + 1][1] - l[i][1])
  print(ret)
","last = cur
      l.append(('g', i))",first_g = l[i][1]
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  c = inp1()
  s = inp1()
  ret = 0
  l = []
  last = ''
  for i in range(n):
    cur = s[i]
    if cur == last:
      continue
    if cur == c:
      last = cur
      l.append((c, i))
    elif cur == 'g':
      last = cur
      l.append(('g', i))
  first_g = -1
  for i in range(len(l)):
    if l[i][0] == 'g' and first_g != -1:
      continue
    elif l[i][0] == 'g' and first_g == -1:
      {{completion}}
    elif i == len(l) - 1:
      ret = max(ret, n - l[i][1] + first_g)
    else:
      ret = max(ret, l[i + 1][1] - l[i][1])
  print(ret)
",first_g = l[i][1],"first_g = l[i][1]
      l.append(('g', i))"
"from itertools import islice
from sys import stdin

data = iter([int(x) for x in stdin.read().split()[1:]])

res = []
while True:
    try:
        n = next(data)
    except StopIteration:
        break
    q = next(data)
    counts = [0, 0]
    sums = [0, 0]
    for v in islice(data, n):
        counts[v % 2] += 1
        sums[v % 2] += v
    for _ in range(q):
        mod = next(data)
        x = next(data)
        to_add = counts[mod] * x
        if x % 2:
            counts[1 - mod] += counts[mod]
            sums[1 - mod] += sums[mod] + to_add
            counts[mod] = sums[mod] = 0
        else:
            {{completion}}
        res.append(sum(sums))

print('\n'.join(str(x) for x in res))",sums[mod] += to_add,"this is the start of the ground truth
counts = [0, 0]
        sums = [0, 0]
        for v in islice(data, n):
            counts[v % 2] += 1
            sums[v % 2] += v
        for _ in range(q):
            mod = next(data)
            x = next(data)
            to_add = counts[mod] * x
            if x % 2:
                counts[1 - mod] += counts[mod]
                sums[1 - mod"
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  q = inp1()
  a = inp(n)
  tx = [inp(2) for _ in range(q)]
  odd = 0
  even = 0
  for i in a:
    if i % 2 == 0:
      even +=1
    else:
      odd +=1
  ret = sum(a)
  for i in tx:
    if i[0] == 0:
      ret += even * i[1]
      if i[1] % 2 != 0:
        odd = n
        even = 0
    else:
      ret += odd * i[1]
      if i[1] % 2 != 0:
        {{completion}}
    print(ret)
","even = n
        odd = 0","odd = n
even = 0"
"for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    prefix = suffix = 0
    for i in range(n - 1):
        if (d := a[i] - a[i + 1]) > 0:
            prefix += d
        else:
            {{completion}}
    print(abs(a[0] - prefix) + prefix + suffix)
",suffix -= d,prefix+=d
"for line in [*open(0)][2::2]:
  tot = 0
  list = line.split(' ')
  list2 = [0] + list
  minv = int(list[0])
  for val in range(len(list)-1):
    diff = int(list2[val+1]) - int(list[val+1])
    if (diff >= 0):
      {{completion}}
  print(tot-minv+abs(minv)+int(list[len(list)-1]))","tot += diff
      minv -= diff",tot+=diff
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();d=[a[0]]
    for i in range(1,n):d.append(a[i]-a[i-1])
    for i in range(1,n):
        if d[i]<=0:{{completion}}
    print(sum(abs(i) for i in d))",d[0]+=d[i],d[i] = d[i-1] + a[i]
"for _ in range(int(input())):
    input()
    a = [int(x) for x in input().split()]
    prefix_value = a[0]
    suffix_value = 0
    steps = 0
    for x, y in zip(a, a[1:]):
        if x > y:
            steps += x - y
            prefix_value = y - suffix_value
        elif y > x:
            {{completion}}
    print(steps + abs(prefix_value))
","steps += y - x
            suffix_value += y - x",prefix_value -= y - x
"from sys import stdin
a = int(stdin.readline())

for t in range(0,a):
    b = int(stdin.readline())
    c = stdin.readline().split()
    count = 0
    current = int(c[0])
    for u in range(0,b-1):
        if int(c[u+1])>int(c[u]):
            count+=(int(c[u+1])-int(c[u]))

        elif int(c[u+1]) < int(c[u]):
            {{completion}}
        


    print(abs(current)+count)","count+=(int(c[u]) - int(c[u+1]))
            current = current - (int(c[u]) - int(c[u+1]))",count+=abs(int(c[u+1])-int(c[u]))
"t = int(input())
 
for _ in range(t):
	n = int(input())
	A = list(map(int,input().split()))
	res,r = 0,0
	for i in range(n-1):
		x = A[i+1]-A[i]
		if x>0:  
			{{completion}}
		res+=abs(x)
	res+=abs(r-A[n-1])
	print(res) ",r+=x,r += x
"def solve():
    n = int(input())
    a = [int(i) for i in input().split()]
    dl, dr = 0, 0
    for i in range(1, n):
        if a[i]-dr >= a[0]-dl:
            dr += (a[i]-dr)-(a[0]-dl)
        else:
            {{completion}}
    return dl+dr+abs(a[0]-dl)

for _ in range(int(input())):
    print(solve())",dl += (a[0]-dl)-(a[i]-dr),dr+=a[i]-a[i-1]
"v = int(input())

while v > 0:
    n = int(input())
    arr = input().split()
    ori = int(arr[0])
    temp = 0
    ans = 0
    x = 1
    while x < n:
        nex = int(arr[x])
        ans += abs(nex - ori)
        if nex - ori < 0:
            {{completion}}
        ori = nex
        x += 1
    ans += abs(int(arr[0]) - temp)
    print(ans)
    v -= 1",temp += abs(nex - ori),temp += nex - ori
"import sys

T = int(sys.stdin.readline())
for t in range(T):
    n = int(sys.stdin.readline())
    a = [int(x) for x in sys.stdin.readline().strip().split(' ')]
    l, r = 0, 0
    for i in range(len(a) - 1):
        x, y = a[i], a[i+1]
        if x > y:
            l += x - y
        elif x < y:
            {{completion}}
    print(abs(a[-1]-r)+l+r)

# 4
# 3
# -2 -2 -2
# 3
# 10 4 7
# 4
# 4 -4 4 -4
# 5
# 1 -2 3 -4 5
",r += y - x,l+=x-y
"
# 1 0 0 1 0 0
# 0 1 0 0 0 1
# 1 1 1 2 2 2
# 0 1 1 1 1 2
# swap two same number is useless
# each time we swap i and i+1, only prefix of i is changed, either increased by 1 or decreased by 1

# same argument as of inversion, each time inversion can only increased by 1 or decreased by 1
# so in one step we can always move a prefix closer to the expected by 1
# Let s = sum(diff(prefix[a] - prefix[a'])) , we can always achive this in minimum time

# prefix + (0, 1) | (1,0)
# we would like to make every prefix of a is same as a' (with a' is fixed)

# when we swap pair (0,1) in two row, say we are at column j, then the prefix of one row decreased by 1 and the other is increased by 1 form the column j

# 1 1 1 0 0 0
# 0 0 0 1 1 1
# i

# Now let's construct array diff of two row
# Reprahsed of the problem
# In one step, we can either
# 1. increase / decrease any diff by 1
# 2. at a certain column, increase diff of either by 1 and decrease the other by 1  till the last column

# Analysis
# Go from the start since we have increamnt suffix operation
# If both element is same sign ,then add their abs since suffix operation not reduce their diff but also increase the total number of operatons, if on suffix operatons help the rest move closer to the target then we can just apply from the i+1 position to get the same result and take 1 less move
# If there are of different sign
# k = min(abs(row1[i]]), abs(row2[i])) normaly we would take k to make one ddiff move to zeros, but now with suffix opertions, we also move the other closer to 0 by k, so we are have free k more free operations, if this suffix make the rest worst then just apply k reverse suffix operation on i+1 to cancel the efffect so this algorithm always move to a better answer

n = int(input())

a, b, x, y = [list(map(int, input().split())) for _ in range(4)]
s0 = s1 = ans = 0
for m, n, p, q in zip(a, b, x, y):
    s0 += m
    s0 -= p
    s1 += n
    s1 -= q
    while s0 > 0 and s1 < 0:
        {{completion}}
    while s0 < 0 and s1 > 0:
        ans += 1
        s0 += 1
        s1 -= 1
    ans += abs(s0) + abs(s1)
print(-1 if s1 or s0 else ans)  # finally but prefix must be 0
","ans += 1
        s0 -= 1
        s1 += 1","ans += 1
        s0 += 1
        s1 -= 1"
"
# 1 0 0 1 0 0
# 0 1 0 0 0 1
# 1 1 1 2 2 2
# 0 1 1 1 1 2
# swap two same number is useless
# each time we swap i and i+1, only prefix of i is changed, either increased by 1 or decreased by 1

# same argument as of inversion, each time inversion can only increased by 1 or decreased by 1
# so in one step we can always move a prefix closer to the expected by 1
# Let s = sum(diff(prefix[a] - prefix[a'])) , we can always achive this in minimum time

# prefix + (0, 1) | (1,0)
# we would like to make every prefix of a is same as a' (with a' is fixed)

# when we swap pair (0,1) in two row, say we are at column j, then the prefix of one row decreased by 1 and the other is increased by 1 form the column j

# 1 1 1 0 0 0
# 0 0 0 1 1 1
# i

# Now let's construct array diff of two row
# Reprahsed of the problem
# In one step, we can either
# 1. increase / decrease any diff by 1
# 2. at a certain column, increase diff of either by 1 and decrease the other by 1  till the last column

# Analysis
# Go from the start since we have increamnt suffix operation
# If both element is same sign ,then add their abs since suffix operation not reduce their diff but also increase the total number of operatons, if on suffix operatons help the rest move closer to the target then we can just apply from the i+1 position to get the same result and take 1 less move
# If there are of different sign
# k = min(abs(row1[i]]), abs(row2[i])) normaly we would take k to make one ddiff move to zeros, but now with suffix opertions, we also move the other closer to 0 by k, so we are have free k more free operations, if this suffix make the rest worst then just apply k reverse suffix operation on i+1 to cancel the efffect so this algorithm always move to a better answer

n = int(input())

a, b, x, y = [list(map(int, input().split())) for _ in range(4)]
s0 = s1 = ans = 0
for m, n, p, q in zip(a, b, x, y):
    s0 += m
    s0 -= p
    s1 += n
    s1 -= q
    while s0 > 0 and s1 < 0:
        ans += 1
        s0 -= 1
        s1 += 1
    while s0 < 0 and s1 > 0:
        {{completion}}
    ans += abs(s0) + abs(s1)
print(-1 if s1 or s0 else ans)  # finally but prefix must be 0
","ans += 1
        s0 += 1
        s1 -= 1","ans += 1
        s0 += 1
        s1 -= 1"
"n=int(input())
s=input()[::2],input()[::2]
t=input()[::2],input()[::2]

d=[0,0]
total=0
for y in range(n):
    for x in 0,1:
        d[x]+=(s[x][y]==""1"")-(t[x][y]==""1"")
    if d[0]>0 and d[1]<0:
        total+=1
        d[0]-=1
        d[1]+=1
    elif d[0]<0 and d[1]>0:
        {{completion}}
    total+=abs(d[0])+abs(d[1])
print(total if d==[0,0] else -1)","total+=1
        d[0]+=1
        d[1]-=1","total+=abs(d[1])
                d[0]+=1
                d[1]-=1"
"def solve():
    # Size of the matrices.
    n = int(input())
    # Data matrix (the first two rows correspond to the original matrix
    # and the last two to the target matrix).
    matrix = []

    # Read the input data.
    for _ in range(4):
        matrix.append([int(data) for data in input().split()])

    top = 0  # Difference between the prefixes of the first rows of the matrices.
    bottom = 0  # Difference between the prefixes of the second rows of the matrices.
    total = 0  # Total cost of the operations.

    for i in range(n):
        top += (matrix[0][i] - matrix[2][i])  # Update the first prefix.
        bottom += (matrix[1][i] - matrix[3][i])  # Update the second prefix.

        # If the prefix differences have different signs, swap the exceeding one
        # in the positive row to the negative, spending an operation on it.
        if bottom < 0 and 0 < top:
            top -= 1
            bottom += 1
            total += 1
        elif top < 0 and 0 < bottom:
            {{completion}}

        # Update the total cost with the cost of fixing this prefix, since the last fix.
        total += abs(top) + abs(bottom)

    # The condition top + bottom == 0 is equivalent to top == 0 && bottom == 0, because top and
    # bottom always have the same sign or at least one is zero.
    # Therefore, if top + bottom != 0, then top != 0 or bottom != 0.
    # This mean the matrices have different amount of one, so the problem is unsolvable.
    if top + bottom != 0:
        return -1

    # Otherwise, the problem has a solution, and it's the total calculated cost.
    return total


print(solve())
","top += 1
            bottom -= 1
            total += 1","total += 1
        bottom += 1
        top -= 1"
"
import time

def main():
    n = int(input())
    curr = [[int(x) for x in input().split("" "")] for _ in range(2)]
    want = [[int(x) for x in input().split("" "")] for _ in range(2)]

    out = 0
    s1 = 0
    s2 = 0

    for x in range(n):
        out += abs(s1) + abs(s2)

        s1 += curr[0][x]
        s2 += curr[1][x]

        s1 -= want[0][x]
        s2 -= want[1][x]

        if abs(s1 + s2) < abs(s1) + abs(s2):
            if abs(s1) <= abs(s2):
                out += abs(s1)
                s2 += s1
                s1 = 0
            else:
                {{completion}}

    if s1 != 0 or s2 != 0:
        print(-1)
    else:
        print(out)

if __name__ == ""__main__"":
    main()","out += abs(s2)
                s1 += s2
                s2 = 0","this is the start of the ground truth
out += abs(s1) + abs(s2)

s1 += curr[0][x]
s2 += curr[1][x]

s1 -= want[0][x]
s2 -= want[1][x]

if abs(s1 + s2) < abs(s1) + abs(s2):
    if abs(s1) <= abs(s2):
        out += abs(s1)
        s2 += s1
"
"import math

lines = [*open(0)]
sizes = lines[1].split(' ')

tot, running = 0, 0
minval = 0

for lock in sizes:
    tot += int(lock)
    running += 1
    minval = max(minval, tot/running)

for mintime in lines[3:]:
  if (int(mintime) < minval):
    print(""-1"")
  else:
    {{completion}}",print(math.ceil(tot/int(mintime))),"    print(0)


























































































































"
"I=input;n=int(I());p=m=0
for i,v in enumerate(I().split()):
  {{completion}}
for _ in [0]*int(I()):
  t=int(I());print([-1,(p+t-1)//t][t>=m])","p+=int(v);m=max(m,(p+i)//(i+1))","t=int(I());print([-1,(p+t-1)//t][t>=m])"
"I=input;n=int(I());p=m=0
for i,v in enumerate(I().split()):
  p+=int(v);m=max(m,(p+i)//(i+1))
for _ in [0]*int(I()):
  {{completion}}","t=int(I());print([-1,(p+t-1)//t][t>=m])","































































































































"
"import math as ma

r = range
R = lambda: int(input())
num_of_locks = R()
vols_arr = list(map(int, input().split("" "")))
sum_of_vols = 0
avg_vols = []
for _ in r(len(vols_arr)): sum_of_vols += vols_arr[_]; avg_vols += ma.ceil(sum_of_vols/(_ + 1)),
max_avg_vols = max(avg_vols)
for _ in r(R()):
    liters = R(); answer = ma.ceil(sum_of_vols/liters)
    if max_avg_vols > liters:
        {{completion}}
    print(answer)",answer = -1,"this is the start of the ground truth
num_of_locks = R()
vols_arr = list(map(int, input().split("" "")))
sum_of_vols = 0
avg_vols = []
for _ in r(len(vols_arr)): sum_of_vols += vols_arr[_]; avg_vols += ma.ceil(sum_of_vols/(_ + 1)),
max_avg_vols = max(avg_vols)
for _ in r"
"n = int(input())
a = list(map(int, input().split()))
maxi = tot = 0
for i, j in enumerate(a, 1):
    tot += j
    maxi = max(maxi, (tot+i-1) // i)

q = int(input())
for _ in range(q):
    k = int(input())
    if k < maxi:
        print(-1)
    else:
        # open x pipe
        # time = ceil(sum / x) => x increased => time decrease
        # => sum <= x * time -> x >= sum / time -> x = ceil(sum / time) (looking for x min)
        {{completion}}
",print((tot + k - 1) // k),"print([-1,(tot+k-1)//k][k>=maxi])"
"from sys import stdin, stderr


def debug(*args, **kwargs):
    print(*args, file=stderr, **kwargs)


_, volumes, _, *queries = stdin.readlines()
volumes = map(int, volumes.split())
queries = map(int, queries)

s = t_min = 0
for i, v in enumerate(volumes, 1):
    s += v
    div, mod = divmod(s, i)
    t_min = max(t_min, div + (mod != 0))

res = []
for q in map(int, queries):
    if q < t_min:
        ans = -1
    else:
        {{completion}}
    res.append(ans)

print('\n'.join(str(x) for x in res))
","div, mod = divmod(s, q)
        ans = div + (mod != 0)","this is the start of the ground truth


def debug(*args, **kwargs):
    print(*args, file=stderr, **kwargs)


_, volumes, _, *queries = stdin.readlines()
volumes = map(int, volumes.split())
queries = map(int, queries)

s = t_min = 0
for i, v in enumerate(volumes, 1):
    s += v
    div, mod = divmod(s, i)
    t_min = max(t_min, div +"
"import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for i in range(n):
    {{completion}}
for _ in range(int(input())):
    t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)
","m=max((v[i]-1)//(i+1)+1,m)","t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)"
"import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for i in range(n):
    m=max((v[i]-1)//(i+1)+1,m)
for _ in range(int(input())):
    {{completion}}
","t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)","m=max((v[i]-1)//(i+1)+1,m)"
"number = int(input())
V = [int(i) for i in input().split()]
time,total = 0,0
for i in range(number):
    total += V[i]
    time = max(time,(total+i)//(i+1))
    pass
for q in range(int(input())):
    t = int(input())
    if(t<time): print(-1)
    else: {{completion}}
    pass",print((total+t-1)//t),
"from math import ceil
r = range;i = lambda: int(input());s = lambda: input().split()
for _ in r(1):
    n = i();v = list(map(int,s()))
    dp = [];sum = 0;max = 0
    for _ in r(n):
        sum += v[_];val = ceil(sum/(_+1))
        dp += val, #comma --> tuple element
        if(val > max): {{completion}}
    for _ in r(i()): t = i();print(ceil(sum/t)) if(max <= t) else print(-1)",max = val,"dp = [];sum = 0;max = 0
for _ in r(n):
    sum += v[_];val = ceil(sum/(_+1))
    dp += val,
    if(val > max):"
"#from math import ceil, floor, gcd, log
#import heapq as hq
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft

import sys
input = sys.stdin.readline
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#def insr():
#    s = input()
#    return(list(s[:len(s) - 1]))
#def invr():
#    return(map(int,input().split()))
####################################################
#1) inp — For taking integer inputs.
#2) inlt — For taking List inputs.
#3) insr — For taking string inputs. Returns a List of Characters.
#4) invr — For taking space seperated integer variable inputs.
####################################################
def swp(x1,x2):
    tmp=a[x1[0]][x1[1]]
    a[x1[0]][x1[1]]=a[x2[0]][x2[1]]
    a[x2[0]][x2[1]]=tmp
def fnei(xlst):
    tmpl=[xlst]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def fnei2(xlst):
    tmpl=[]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def chkb(x,y):
    if a[x][y]==1:return False
    for i in fnei2([x,y]):
        if a[x][y]>a[i[0]][i[1]]:
            return False
    else:
        return True
#######################
t=1
#t = int(input())
for tc in range(t):
    n,m = map(int, input().split())
#    n=inp()
#    a=inlt()
#    s=insr()
#    occ=dict();
#    for i in range(n):occ[i]=[]
#    for i in range(n):
#        occ[i].append(inlt())
    a=[]
    for i in range(n):
        a.append(inlt())

    b=[]
    for i in range(n):
        for j in range(m):
            if chkb(i,j):b.append([i,j])
    if len(b)==0:print(0);continue
    if len(b)>2:print(2);continue
    cter=0
    bnei=fnei(b[0])
    for j in bnei:
        for i1 in range(n):
            for i2 in range(m):
                i=[i1,i2]
                if i==b[0]:continue
#                print(a,a[i[0]][i[1]],a[j[0]][j[1]])
                swp(i,j)
                flag=1
                for k in fnei(i)+fnei(j):
                    if chkb(k[0],k[1]):flag=0;break
                if len(b)>1:
                    for k2 in range(1,len(b)):
                        if chkb(b[k2][0],b[k2][1]):{{completion}}
                swp(i,j)
#                print(a,i,j)
                if flag:cter+=1;#print('success',i,j)
    if cter==0: # all single move efforts failed
        print(2)
    else:
        print(1,cter)
    
#print(*a2,sep=' ')
#print("" "".join(str(i) for i in a2))
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i] #sum[:ax]=psa[x]
",flag=0;break,"































































































































"
"#from math import ceil, floor, gcd, log
#import heapq as hq
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft

import sys
input = sys.stdin.readline
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#def insr():
#    s = input()
#    return(list(s[:len(s) - 1]))
#def invr():
#    return(map(int,input().split()))
####################################################
#1) inp — For taking integer inputs.
#2) inlt — For taking List inputs.
#3) insr — For taking string inputs. Returns a List of Characters.
#4) invr — For taking space seperated integer variable inputs.
####################################################
def swp(x1,x2):
    tmp=a[x1[0]][x1[1]]
    a[x1[0]][x1[1]]=a[x2[0]][x2[1]]
    a[x2[0]][x2[1]]=tmp
def fnei(xlst):
    tmpl=[xlst]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def fnei2(xlst):
    tmpl=[]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def chkb(x,y):
    if a[x][y]==1:return False
    for i in fnei2([x,y]):
        if a[x][y]>a[i[0]][i[1]]:
            return False
    else:
        return True
#######################
t=1
#t = int(input())
for tc in range(t):
    n,m = map(int, input().split())
#    n=inp()
#    a=inlt()
#    s=insr()
#    occ=dict();
#    for i in range(n):occ[i]=[]
#    for i in range(n):
#        occ[i].append(inlt())
    a=[]
    for i in range(n):
        a.append(inlt())

    b=[]
    for i in range(n):
        for j in range(m):
            if chkb(i,j):b.append([i,j])
    if len(b)==0:print(0);continue
    if len(b)>2:print(2);continue
    cter=0
    bnei=fnei(b[0])
    for j in bnei:
        for i1 in range(n):
            for i2 in range(m):
                i=[i1,i2]
                if i==b[0]:continue
#                print(a,a[i[0]][i[1]],a[j[0]][j[1]])
                swp(i,j)
                flag=1
                for k in fnei(i)+fnei(j):
                    if chkb(k[0],k[1]):{{completion}}
                if len(b)>1:
                    for k2 in range(1,len(b)):
                        if chkb(b[k2][0],b[k2][1]):flag=0;break
                swp(i,j)
#                print(a,i,j)
                if flag:cter+=1;#print('success',i,j)
    if cter==0: # all single move efforts failed
        print(2)
    else:
        print(1,cter)
    
#print(*a2,sep=' ')
#print("" "".join(str(i) for i in a2))
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i] #sum[:ax]=psa[x]
",flag=0;break,continue
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


from itertools import chain

def near(r, c, itself = False):
    if itself:
        yield (r, c)
    if 0 < r:
        yield (r - 1, c)
    if r + 1 < n:
        yield (r + 1, c)
    if 0 < c:
        yield (r, c - 1)
    if c + 1 < m:
        yield (r, c + 1)
#    R = []
#    if itself:
#        R.append((r, c))
#    if 0 < r:
#        R.append((r - 1, c))
#    if r + 1 < n:
#        R.append((r + 1, c))
#    if 0 < c:
#        R.append((r, c - 1))
#    if c + 1 < m:
#        R.append((r, c + 1))

#    return R

def ok(x, y):
    v = A[x][y]
    if v == 1:
        return True

    return any(A[r][c] < v for r, c in near(x, y))


def swapAndCheck(r1, c1, r2, c2):
    if (r1 , c1) != (r2, c2):
        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        flag = ok(r1, c1) and ok(r2, c2) and all(ok(r, c) for r, c in chain(near(r1, c1), near(r2, c2), H[1:]))

        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        return flag

    return False


n, m = map(int, input().split())

A = []
for _ in range(n):
    A.append(list(map(int, input().split())))


H = list({(r, c) for r in range(n) for c in range(m) if not ok(r, c)})

if not H:
    print(""0"")
elif len(H) > 2:
    print(""2"")
else:
    r1, c1 = H[0]
    w = 0

    for r, c in near(r1, c1, True):
        for x in range(n):
            for y in range(m):
                if (r1 != x or c1 != y) and swapAndCheck(r, c, x, y):
                    {{completion}}
        
    if w != 0:
        print(""1 {}"".format(w))
    else:
        print(""2"")

",w += 1,continue
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                {{completion}}
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


from itertools import chain

def near(r, c, itself = False):
    if itself:
        yield (r, c)
    if 0 < r:
        yield (r - 1, c)
    if r + 1 < n:
        yield (r + 1, c)
    if 0 < c:
        yield (r, c - 1)
    if c + 1 < m:
        yield (r, c + 1)
#    R = []
#    if itself:
#        R.append((r, c))
#    if 0 < r:
#        R.append((r - 1, c))
#    if r + 1 < n:
#        R.append((r + 1, c))
#    if 0 < c:
#        R.append((r, c - 1))
#    if c + 1 < m:
#        R.append((r, c + 1))

#    return R

def ok(x, y):
    v = A[x][y]
    if v == 1:
        return True

    return any(A[r][c] < v for r, c in near(x, y))


def swapAndCheck(r1, c1, r2, c2):
    if (r1 , c1) != (r2, c2):
        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        flag = ok(r1, c1) and ok(r2, c2) and all(ok(r, c) for r, c in chain(near(r1, c1), near(r2, c2), H[1:]))

        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        return flag

    return False


n, m = map(int, input().split())

A = []
for _ in range(n):
    A.append(list(map(int, input().split())))


H = list({(r, c) for r in range(n) for c in range(m) if not ok(r, c)})

if not H:
    print(""0"")
elif len(H) > 2:
    print(""2"")
else:
    r1, c1 = H[0]
    w = 0

    for r, c in near(r1, c1, True):
        for x in range(n):
            for y in range(m):
                if (r1 != x or c1 != y) and swapAndCheck(r, c, x, y):
                    w += 1
        
    if w != 0:
        print(""1 {}"".format(w))
    else:
        print(""2"")

",break,continue
"import os
import sys
from io import BytesIO, IOBase

#_str = str
#str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n, m = list(map(int, input().strip().split(' ')))
    g = [list(map(int, input().strip().split(' '))) for _ in range(n)]
    bfs = set()
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    def check(x, y):
        if g[x][y] == 1:
            return True
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and g[x][y] > g[nx][ny]:
                return True
        return False

    def check5(x, y):
        if not check(x, y):
            return False
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and not check(nx, ny):
                return False
        return True

    bad = list()
    for x in range(n):
        for y in range(m):
            if g[x][y] == 1:
                continue
            if not check(x, y):
                bad.append([x, y])
    if not bad:
        print(0)
    elif len(bad) > 5:
        print(2)
    else:
        candidate = [bad[0]]
        for i in range(4):
            nx, ny = bad[0][0] + dx[i], bad[0][1] + dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                candidate.append([nx, ny])
        res = 0
        for cx, cy in candidate:
            for x in range(n):
                for y in range(m):
                    if x == bad[0][0] and y == bad[0][1]:
                        continue
                    if cx == x and cy == y:
                        continue
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
                    flag = True
                    for bx, by in bad:
                        if not check(bx, by):
                            {{completion}}
                    if flag and check5(x, y) and check5(cx, cy):
                        res += 1
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
        if res == 0:
            print(2)
        else:
            print(1, res)


    return

main()","flag = False
                            break","































































































































"
"import os
import sys
from io import BytesIO, IOBase

#_str = str
#str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n, m = list(map(int, input().strip().split(' ')))
    g = [list(map(int, input().strip().split(' '))) for _ in range(n)]
    bfs = set()
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    def check(x, y):
        if g[x][y] == 1:
            return True
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and g[x][y] > g[nx][ny]:
                return True
        return False

    def check5(x, y):
        if not check(x, y):
            return False
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and not check(nx, ny):
                return False
        return True

    bad = list()
    for x in range(n):
        for y in range(m):
            if g[x][y] == 1:
                continue
            if not check(x, y):
                bad.append([x, y])
    if not bad:
        print(0)
    elif len(bad) > 5:
        print(2)
    else:
        candidate = [bad[0]]
        for i in range(4):
            nx, ny = bad[0][0] + dx[i], bad[0][1] + dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                candidate.append([nx, ny])
        res = 0
        for cx, cy in candidate:
            for x in range(n):
                for y in range(m):
                    if x == bad[0][0] and y == bad[0][1]:
                        {{completion}}
                    if cx == x and cy == y:
                        continue
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
                    flag = True
                    for bx, by in bad:
                        if not check(bx, by):
                            flag = False
                            break
                    if flag and check5(x, y) and check5(cx, cy):
                        res += 1
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
        if res == 0:
            print(2)
        else:
            print(1, res)


    return

main()",continue,"































































































































"
"import sys
input = sys.stdin.readline
for _ in range(int(input())):
	n, m = map(int, input().split())
	minr,minc,maxr,maxc=n,m,0,0
	l1,l2,l3,l4=n+m,n+m,0,-n-m
	b = []
	for i in range(n):
		r = input().rstrip()
		#print('r',r)
		#print(list(r))
		#print(len(r))
		for j, c in enumerate(r):
			if c == 'B':
				#print('i', i)
				#print('j',j)
				# minr = min(minr,i)
				# maxr = max(maxr,i)
				# minc = min(minc,j)
				# maxc = max(maxc,j)
				l1=min(l1,i+j)
				l2=min(l2,i-j)
				l3=max(l3,i+j)
				l4=max(l4,i-j)
				b.append((i,j))
	#print('maxc',maxc)
	#print('minc',minc)
	#print('maxr',maxr)
	#print('minr',minr)
	# (l1+l3)//2 #r+c
	# (l2+l4)//2 #r-c
	r = (l1+l3+l2+l4)//4
	c = (l1+l3-l2-l4)//4
	bestr,bestc=r,c
	#print(r,c)
	best = float('inf')
	for i in [-1,0,1]:
		for j in [-1,0,1]:
			if 0 <= i < n and 0 <= j < m:
				madist = 0
				cr, cc = r+i,c+j
				for x,y in b:
					{{completion}}
				#print(madist,cr,cc)
				if madist < best:
					best = madist
					bestr,bestc=cr,cc

	print(bestr+1,bestc+1)","madist = max(madist,abs(cr-x)+abs(cc-y))","best = madist
					bestr,bestc=cr,cc"
"import sys
input = sys.stdin.readline
for _ in range(int(input())):
	n, m = map(int, input().split())
	minr,minc,maxr,maxc=n,m,0,0
	l1,l2,l3,l4=n+m,n+m,0,-n-m
	b = []
	for i in range(n):
		r = input().rstrip()
		#print('r',r)
		#print(list(r))
		#print(len(r))
		for j, c in enumerate(r):
			if c == 'B':
				#print('i', i)
				#print('j',j)
				# minr = min(minr,i)
				# maxr = max(maxr,i)
				# minc = min(minc,j)
				# maxc = max(maxc,j)
				l1=min(l1,i+j)
				l2=min(l2,i-j)
				l3=max(l3,i+j)
				l4=max(l4,i-j)
				b.append((i,j))
	#print('maxc',maxc)
	#print('minc',minc)
	#print('maxr',maxr)
	#print('minr',minr)
	# (l1+l3)//2 #r+c
	# (l2+l4)//2 #r-c
	r = (l1+l3+l2+l4)//4
	c = (l1+l3-l2-l4)//4
	bestr,bestc=r,c
	#print(r,c)
	best = float('inf')
	for i in [-1,0,1]:
		for j in [-1,0,1]:
			if 0 <= i < n and 0 <= j < m:
				madist = 0
				cr, cc = r+i,c+j
				for x,y in b:
					madist = max(madist,abs(cr-x)+abs(cc-y))
				#print(madist,cr,cc)
				if madist < best:
					{{completion}}

	print(bestr+1,bestc+1)","best = madist
					bestr,bestc=cr,cc","madist = max(madist,abs(cr-x)+abs(cc-y))"
"from collections import Counter
import heapq
for _ in range(int(input())):
    _ = input()
    l = input().split()
    cnt = Counter(l)
    x = list(cnt.values())
    x.append(1)
    
    
    hp = []
    x.sort()
    for i, n in enumerate(x):
        if n-i-1 > 0:
            {{completion}}
    
    cnt = 0
    while hp and cnt + hp[0] < 0:
        n = heapq.heappop(hp)
        heapq.heappush(hp, n+1)
        cnt += 1
    print(len(x)+cnt)","heapq.heappush(hp, -(n-i-1))","heapq.heappush(hp, n-1)"
"t = int(input())

for i in range(t):
    n = int(input())
    p = [int(value) for value in input().split()]
    
    tree = [0] * n
	
    for i in range(len(p)):
	    tree[p[i] - 1] += 1
	    
    tree = sorted(tree)
    resposta = 0
    r = n
	
    while resposta <= r:
        s = 0
        c = 1
        m = (resposta + r) // 2
        neg1 = -1
        
        for i in range(n + neg1, neg1, neg1):
            if tree[i] == 0:
                {{completion}}
            
            aux = tree[i] + s - m
            c += max(0, aux)
            s += 1
        
        if m - s >= c:
            r = m - 1
        
        else:
            resposta = m + 1
    
    print(resposta)",break,"if tree[i] == 0:
    tree[i] = 1
    resposta += 1
else:
    tree[i] = 0
    c += 1"
"from heapq import *

for _ in range(int(input())):
    n = int(input())
    pp = list(map(int, input().split()))
    sibs = [[] for _ in range(n+1)]
    for i,p in enumerate(pp, 2):
        sibs[p].append(i)
    child_infected = [False] * (n+1)
    isibs = sorted(range(1, n+1), key=lambda x:len(sibs[x]), reverse=True)
    remain = n
    to_spread = []
    for turn, isib in enumerate(isibs):
        children = sibs[isib]
        while to_spread and to_spread[0][0] <= turn:
            {{completion}}
        remain -= len(to_spread)
        child_infected[isib] = True
        heappush(to_spread, (len(children)+turn, isib))
        remain -= 1
        if remain <= 0:
            break
    print(turn+1)
",heappop(to_spread),break
"from heapq import *

for _ in range(int(input())):
    n = int(input())
    pp = list(map(int, input().split()))
    sibs = [[] for _ in range(n+1)]
    for i,p in enumerate(pp, 2):
        sibs[p].append(i)
    child_infected = [False] * (n+1)
    isibs = sorted(range(1, n+1), key=lambda x:len(sibs[x]), reverse=True)
    remain = n
    to_spread = []
    for turn, isib in enumerate(isibs):
        children = sibs[isib]
        while to_spread and to_spread[0][0] <= turn:
            heappop(to_spread)
        remain -= len(to_spread)
        child_infected[isib] = True
        heappush(to_spread, (len(children)+turn, isib))
        remain -= 1
        if remain <= 0:
            {{completion}}
    print(turn+1)
",break,heappop(to_spread)
"from sys import stdin, stdout
from collections import defaultdict

t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    parents = [int(x) for x in stdin.readline().split()]
    counts = defaultdict(int)
    counts[0] = 1
    for i in parents:
        counts[i] += 1

    lives = [counts[i] for i in counts]
    lives.sort(reverse=True)

    for i in range(len(lives)):
        lives[i] -= len(lives)-i

    answer = len(lives)

    while max(lives) > 0:
        current_max = -1
        max_index = -1
        for i in range(len(lives)):
            lives[i] -= 1
            if lives[i] > current_max:
                {{completion}}
        lives[max_index] -= 1
        answer += 1

    stdout.write(""{}\n"".format(answer))
","current_max = lives[i]
                max_index = i",lives[i] -= 1
"for _ in [0] * int(input()):
    n = int(input())
    a = list(map(int, input().split()))
    c = [0] * n + [1]
    for i in a:
        c[i - 1] += 1
    c = sorted(c, reverse=True)
    ans = sum(i > 0 for i in c)
    for i, j in enumerate(c):
        if j > 0:
            c[i] = i + j - ans
    c = sorted([i for i in c if i > 0], reverse=True)
    while c:
        ans += 1
        for i, j in enumerate(c):
            if j > 0:
                {{completion}}
        c = sorted([i for i in c if i > 0], reverse=True)
    print(ans)
",c[i] = j - 1 - (i == 0),ans += 1
"inf=10**18
dxy=[(0,1), (1,0), (-1, 0), (0, -1)]
mod=10**9+7
MOD=998244353
from collections import Counter

def solve():
    n = int(input())
    p = [int(i)-1 for i in input().split()]
    c = Counter(p)

    ans = len(c.values())+1
    adi = []
    for i, n in enumerate(sorted(c.values(), reverse=True)):
        if n+i-ans>0:
            adi.append(n+i-ans)
    if adi:
        adi.sort(reverse=True)
        cnt = 0
        #bi search
        r = max(adi)+1
        l = 0
        def is_ok(x):
            d = 0
            for i in adi:
                d += max(0, i-x)
            return d-x<=0

        while r-l>1:
            mid = (r+l)//2
            if is_ok(mid):r = mid 
            else: {{completion}}
        ans += r
    return ans


def main():
    T = int(input())
    for _ in range(T):
        print(solve())


main()",l = mid,r = mid
"from heapq import heappop, heappush

t = int(input())
const = 1 << 18

for T in range(t):
    n = int(input())
    arr = [int(x) for x in input().split("" "")]

    things = {0: const}
    for x in range(len(arr)):
        if arr[x] in things:
            things[arr[x]] += 1
        else:
            things[arr[x]] = const

    laze = []
    for x in things:
        heappush(laze, -things[x])

    time = 0
    while len(laze) > 0:

        f = -laze[0]

        if f <= time:
            heappop(laze)
            continue
        elif f >= const:
            f -= const
            f += time + 1
            heappop(laze)

            if f > time:
                {{completion}}
        else:
            f -= 1
            heappop(laze)

            if f > time:
                heappush(laze, -f)
        time += 1
    print(time)
","heappush(laze, -f)","heappush(laze, -f)"
"from heapq import heappop, heappush

t = int(input())
const = 1 << 18

for T in range(t):
    n = int(input())
    arr = [int(x) for x in input().split("" "")]

    things = {0: const}
    for x in range(len(arr)):
        if arr[x] in things:
            things[arr[x]] += 1
        else:
            things[arr[x]] = const

    laze = []
    for x in things:
        heappush(laze, -things[x])

    time = 0
    while len(laze) > 0:

        f = -laze[0]

        if f <= time:
            heappop(laze)
            continue
        elif f >= const:
            f -= const
            f += time + 1
            heappop(laze)

            if f > time:
                heappush(laze, -f)
        else:
            f -= 1
            heappop(laze)

            if f > time:
                {{completion}}
        time += 1
    print(time)
","heappush(laze, -f)","heappush(laze, -f)"
"from collections import defaultdict

counter = defaultdict(int)

def solve(a):
    for ai in a:
        counter[ai] += 1
    count = list(counter.values())
    num_level = len(count)
    count.sort()

    for i in range(num_level):
        count[i] = max(count[i] - i - 2, 0)
    
    L = 0; R = max(count)

    if R == 0:
        return num_level + 1

    def check(k):
        b = count.copy()
        for i in range(len(b)):
            b[i] = max(b[i] - k, 0)
        if sum(b) <= k:
            return True
        return False

    while R - L > 1:
        mid = (R + L) // 2
        if(check(mid)):
            R = mid
        else:
            {{completion}}

    return num_level + 1 + R

for a in [*open(0)][2::2]:
    counter.clear()
    res = solve(a.split())
    print(res)",L = mid,R = mid
"from collections import Counter
for _ in range(int(input())):
    n = int(input())
    m = max(Counter(input().split()).values())
    ans = n-m
    while m<n:
        {{completion}}
    print(ans)
","ans += 1
        m *= 2","n = int(input())
        d = Counter(input().split()).most_common(1)[0][1]
        print([i for i in range(18) if (2**i)*d >= n][0]+n-d)"
"from collections import*
for a in[*open(0)][2::2]:
 n=len(a:=a.split());m=max(Counter(a).values());r=0
 while m<n:{{completion}}
 print(r)","r+=min(m,n-m)+1;m*=2","r+=1
        m*=2"
"import math

for t in range(int(input())):
    n=int(input())
    L=input().split()
    count={}
    for i in L:
        try:
            count[i]+=1
        except:
            {{completion}}
    m=max(list(count.values()))
    print(int(n-m + math.ceil(math.log(n/m,2))))",count[i]=1,"n=int(input())
        L=input().split()
        count={}
        for i in L:
            try:
                count[i]+=1
            except:
                count[i]=1
        m=max(list(count.values()))
        print(int(n-m + math.ceil(math.log(n/m,2))))"
"if True:
    from collections import Counter
    t = int(input())
    for _ in range(t):
        {{completion}}","n = int(input())
        d = Counter(input().split()).most_common(1)[0][1]
        print([i for i in range(18) if (2**i)*d >= n][0]+n-d)","ans += 1
        m *= 2"
"from sys import stdin
t = int(stdin.readline())
while t>0:
     t -= 1
     n = int(stdin.readline())
     a = sorted(list(map(int,stdin.readline().split())))
     M = 1
     temp = 1
     for i in range(1,n):
          if a[i]>a[i-1]:
               temp = 1
          else:
               {{completion}}
          M = max(M,temp)
     ind = 0
     temp = M
     while temp<n:
          ind += 1
          temp *= 2
     print(n-M+ind)
",temp += 1,"M = 1
for i in range(1,n):
     if a[i]>a[i-1]:
          temp = 1
     else:
          M = max(M,temp)
ind = 0
temp = M
while temp<n:
     ind += 1
     temp *= 2
print(n-M+ind)"
"for i in range(int(input())):
	n=int(input())
	a=input().split()
	from collections import Counter

	e,bb=Counter(a).most_common(1)[0]
	c=n-bb
	while bb<n:
		{{completion}}
	print(c)","c+=1
		bb*=2","ans += 1
        m *= 2"
"from collections import Counter

for li in[*open(0)][2::2]:
    n=len(li:=li.split());
    m = max(Counter(li).values())
    ans =n-m
    while(m<n):
        {{completion}}
    print(ans)","ans+=1
        
        m=2*m","ans += 1
        m *= 2"
"from collections import Counter
def solve():
    n = int(input())
    freq = max(Counter(input().split()).values())
    left = n -  freq
    ans=0
    while(left):
        ans += 1+min(left,freq)
        left = left - min(left,freq)
        freq=2*freq
            
    print(ans)

while(True):
    try:
        test = int(input())
    except EOFError:
        {{completion}}
    for i in range (test):
        solve()
",break,"def solve():
    n = int(input())
    freq = max(Counter(input().split()).values())
    left = n -  freq
    ans=0
    while(left):
        ans += 1+min(left,freq)
        left = left - min(left,freq)
        freq=2*freq
            
    print(ans)"
"from sys import stdin, stdout
from collections import Counter
for _ in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())
    b = a =  max(Counter(stdin.readline().split()).items(), key = lambda x:x[1])[1]
    ans = n - a
    while a < n:
        {{completion}}
    stdout.write(f""{str(ans)}\n"")
","a = a + a
        ans += 1","ans += 1
        b *= 2"
"N=int(input())
for _ in range(N):
    n = int(input())
    list_num = input().split(' ')

    d = dict()
    for num in list_num:
        if num in d:
            d[num] = d[num] + 1
        else:
            {{completion}}
    max_num = max(d.values())

    now = max_num
    ans = 0
    copy = 0
    while now < n:
        if copy > 0:
            ans += 1
            copy -= 1
            now += 1

        else:
            ans += 1
            copy = now
    
    print (ans)
",d[num] = 1,"ans += 1
            copy = now"
"N=int(input())
for _ in range(N):
    n = int(input())
    list_num = input().split(' ')

    d = dict()
    for num in list_num:
        if num in d:
            d[num] = d[num] + 1
        else:
            d[num] = 1
    max_num = max(d.values())

    now = max_num
    ans = 0
    copy = 0
    while now < n:
        if copy > 0:
            ans += 1
            copy -= 1
            now += 1

        else:
            {{completion}}
    
    print (ans)
","ans += 1
            copy = now",d[num] = 1
"t=int(input())
for i in range (t):
    n = int(input())
    m=n//4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif n%4==1:
        {{completion}}
    elif n%4==2:
        print(2*m-1,2*m+1,1,1,end=' ')
    else:
        print(2,4*m-2,2,1,end=' ')
    print(sep='')    ","print(m,2*m,m,1,end=' ')","print(2*m-1,2*m+1,1,1,end=' ')"
"t=int(input())
for i in range (t):
    n = int(input())
    m=n//4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif n%4==1:
        print(m,2*m,m,1,end=' ')
    elif n%4==2:
        {{completion}}
    else:
        print(2,4*m-2,2,1,end=' ')
    print(sep='')    ","print(2*m-1,2*m+1,1,1,end=' ')","print(2*m-1,2*m+1,1,1,end=' ')"
"for _ in range(int(input())):
    n = int(input())

    if n == 4:
        a = b = c = d = 1

    elif n == 5:
        {{completion}}

    elif n == 6:
        a = c = d = 1
        b = 3

    elif n%4 == 0:
        c = d = b = 2
        a = n-6

    elif n%4 == 1:
        d = 1
        c = 2
        a = 2
        b = n-5

    elif n%4 == 2:
        d = 1
        c = 1
        a = (n-2)//2 - 1
        b = (n-2)//2 + 1

    else:
        d = 1
        c = 2
        b = 2
        a = n-5

    print(a, b, c, d)","a = c = d = 1
        b = 2","a = c = d = 1
        b = 3"
"for _ in range(int(input())):
    n = int(input())

    if n == 4:
        a = b = c = d = 1

    elif n == 5:
        a = c = d = 1
        b = 2

    elif n == 6:
        {{completion}}

    elif n%4 == 0:
        c = d = b = 2
        a = n-6

    elif n%4 == 1:
        d = 1
        c = 2
        a = 2
        b = n-5

    elif n%4 == 2:
        d = 1
        c = 1
        a = (n-2)//2 - 1
        b = (n-2)//2 + 1

    else:
        d = 1
        c = 2
        b = 2
        a = n-5

    print(a, b, c, d)","a = c = d = 1
        b = 3","a = c = d = 1
        b = 3"
"t = int(input())
for _ in range(t):
    n = int(input())
    ans = []
    if n == 5:
        ans = [1, 2, 1, 1]
    elif n % 4 == 0:
        {{completion}}
    elif n % 2 == 0:
        ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]
    else:
        a, c, d = 2, 2, 1
        b = n - a - c - d
        ans = [a, b, c, d]
    print(' '.join([str(a) for a in ans]))
",ans = [n // 4] * 4,"ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]"
"t = int(input())
for _ in range(t):
    n = int(input())
    ans = []
    if n == 5:
        ans = [1, 2, 1, 1]
    elif n % 4 == 0:
        ans = [n // 4] * 4
    elif n % 2 == 0:
        {{completion}}
    else:
        a, c, d = 2, 2, 1
        b = n - a - c - d
        ans = [a, b, c, d]
    print(' '.join([str(a) for a in ans]))
","ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]","ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]"
"for _ in range(int(input())):
    a=int(input())
    if a%4==0:
        print(a//4,a//4,a//4,a//4)
    else:
        if a%2==1:
            a1=(a-1)
            if a1%3==0:
                print(a1//3,a1//3,a1//3,1)
            elif a1%4!=0:
                {{completion}}
            elif a1%4==0:
                print(a1//4,a1//2,a1//4,1)
        else:
            a1=a-2
            print(a1//2-1,a1//2+1,1,1)
        
    ","a1=a-2
                print(a1//2,a1//2+1,1,1)","print(a1//4,a1//2,a1//4,1)"
"for _ in range(int(input())):
    a=int(input())
    if a%4==0:
        print(a//4,a//4,a//4,a//4)
    else:
        if a%2==1:
            a1=(a-1)
            if a1%3==0:
                print(a1//3,a1//3,a1//3,1)
            elif a1%4!=0:
                a1=a-2
                print(a1//2,a1//2+1,1,1)
            elif a1%4==0:
                {{completion}}
        else:
            a1=a-2
            print(a1//2-1,a1//2+1,1,1)
        
    ","print(a1//4,a1//2,a1//4,1)","print(a1//4,a1//2,a1//4,1)"
"t = int(input())
for test in range(t):
    a = []
    while len(a) != 8:
        s = input()
        if (len(s) == 8):
            a.append(s)
 
    x = 0
    y = 0
 
    for i in range(1, 7):
        for j in range(1, 7):
            if (a[i][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j-1] == '#'):
                {{completion}}
    print(x + 1, y + 1)
 
    
 
    
","x = i
                y = j","if (a[i][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j-1] == '#'):
    x = i
    y = j"
"import sys
n = int(input())
a = [int(x)-1 for x in sys.stdin.readline().split()]
depth = [1]*n
best = [0]*n
for i in range(n-1, -1, -1):
    best[i] = max(best[i], depth[i])
    if i != 0:
        {{completion}}
print(best[0])
","parent = a[i-1]
        depth[parent] = max(depth[parent], 1 + depth[i])
        best[parent] += best[i]","depth[a[i]]=max(depth[i]+1,depth[a[i]])"
"mod = 998244353


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    P = [0, 0] + list(map(int, input().split()))

    child = [[] for _ in range(N + 1)]
    for v in range(2, N+1):
        p = P[v]
        child[p].append(v)

    dp = [0] * (N + 1)
    dp2 = [0] * (N + 1)
    for v in range(N, 0, -1):
        if not child[v]:
            dp2[v] = 1
            dp[v] = 1
        else:
            S = 0
            D = 0
            for c in child[v]:
                {{completion}}
            dp2[v] = D + 1
            dp[v] = max(S, D + 1)
    print(dp[1])
    #print(dp, dp2)


if __name__ == '__main__':
    main()
","S += dp[c]
                D = max(D, dp2[c])","S = max(S, D + 1)
  D = max(D, S)"
"n=int(input())
a=[-1]+[int(o)-1 for o in input().split()]
f=[0]*n
dp=[0]*n
for i in range(n-1,0,-1):
  {{completion}}
for i in range(n-1,0,-1):
  dp[i]=max(dp[i],f[i]+1)
  dp[a[i]]+=dp[i]
print(max(dp[0],f[0]+1))","f[a[i]]=max(f[i]+1,f[a[i]])","dp[i]=max(dp[i],f[i]+1)
  dp[a[i]]+=dp[i]"
"n=int(input())
a=[-1]+[int(o)-1 for o in input().split()]
f=[0]*n
dp=[0]*n
for i in range(n-1,0,-1):
  f[a[i]]=max(f[i]+1,f[a[i]])
for i in range(n-1,0,-1):
  {{completion}}
print(max(dp[0],f[0]+1))","dp[i]=max(dp[i],f[i]+1)
  dp[a[i]]+=dp[i]","dp[i]=max(dp[i],f[i]+1)"
"I,G=input,range;n=int(I());p=[-1,0]+[*map(int,I().split())];h=[1]*(n+1);F=[0]*(n+1)
for i in G(n,1,-1):{{completion}}
for i in G(n,0,-1):F[i]=max(F[i],h[i]);F[p[i]]+=F[i]
print(F[1])","h[p[i]]=max(h[i]+1,h[p[i]])","
\end{code}

Comment: I'm voting to close this question as off-topic because it is not a programming question.

Comment: @JonathonReinhart I disagree. It is a programming question, but it is a question about a programming problem.

Comment: @JonathonReinhart I disagree. It is a programming question, but it is a question about a programming problem.

Comment: @JonathonReinhart I disagree. It is a programming question, but it is a question about a programming problem.

Comment: @"
"I,G=input,range;n=int(I());p=[-1,0]+[*map(int,I().split())];h=[1]*(n+1);F=[0]*(n+1)
for i in G(n,1,-1):h[p[i]]=max(h[i]+1,h[p[i]])
for i in G(n,0,-1):{{completion}}
print(F[1])","F[i]=max(F[i],h[i]);F[p[i]]+=F[i]","F[i]=max(F[i],h[i]);F[p[i]]+=F[i]"
"n = int(input())
a = [*map(lambda x:int(x)-1,input().split())]
edge = [[] for _ in range(n)]
for i,p in enumerate(a,1): edge[p] += i,

dp = [[1,0] for _ in range(n)]
for r in range(n-1,-1,-1):
    for v in edge[r]: 
        {{completion}}
print(max(dp[0]))","k = max(dp[v])
        dp[r][1] += k
        dp[r][0] = max(dp[r][0],dp[v][0]+1)","dp[v][0] = max(dp[v][0],dp[r][1]+1)
dp[r][1] += dp[v][0]
  dp[v][1] = max(dp[v][1],dp[r][0]+1)
  dp[r][0] += dp[v][1]"
"from sys import stdin, stdout
from collections import defaultdict
N = 998244353

n = int(stdin.readline())
a = [int(x)-1 for x in stdin.readline().split()]

count = [0]*n
row_values = [0]*n

for i in range(n):
    row_values[count[a[i]]] += 1
    count[a[i]] += 1

row_values_pref = [row_values[0]]
for i in range(1,n):
    row_values_pref.append(row_values_pref[-1]+row_values[i])

dp = [[0]*(n+1) for bar in range(n+1)]

for i in range(1,row_values[0]+1):
    dp[i][i] = 1

for i in range(1,n):
    for total in range(n-1,0,-1):
        current = 0
        for last in range(total//i, 0, -1):
            current += dp[total][last]
            current %= N
            dp[total][last] = 0

            if last <= min(row_values_pref[i]-total, n-total):
                {{completion}}

answer = 0
for i in range(1,n+1):
    answer += dp[n][i]
    answer %= N

stdout.write(str(answer)+'\n')
","dp[total+last][last] += current
                dp[total+last][last] %= N","dp[total][last] += dp[total-i][last-1]
                    dp[total][last] %= N"
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1

M = 998244353


def solve():
    n = getInt()
    a = list(getList())
    cnt = [0] * n
    for i in a:
        cnt[i-1] += 1

    lim = [0] * (n+1)

    col = 0  # the number of remaining columns, initial col = number of distinct element
    f = [0] * (n+1)  # frequent of the height of columns
    for i, j in enumerate(cnt):
        col += j > 0
        f[j] += 1

    for i in range(1, n+1):
        lim[i] = lim[i-1] + col
        col -= f[i]
    dp = [[0] * (n+1) for _ in range(n+1)]

    dp[0][0] = 1
    for x in range(n, 0, -1):
        # dp[i][j] used elements + size of multiset
        for j in range(n):
            # transition
            # x * j <= n
            # i+x <= lim[j+1]
            if j * x > n:
                break
            for i in range(n-x+1):
                if i + x <= lim[j+1]:
                    {{completion}}
    print(sum(dp[n]) % M)


for _ in range(t):
    solve()
","dp[i+x][j+1] += dp[i][j]
                    dp[i+x][j+1] %= M","dp[i+x][j] += dp[i][j]
                dp[i+x][j] %= M"
"g=10**9+7
v=[1]+[0]*40001
for i in range(1,40001):
 if str(i)==str(i)[::-1]:
  for j in range(i,40001):{{completion}}
for n in[*open(0)][1:]:print(v[int(n)]%g)",v[j]=v[j]%g+v[j-i],v[j]+=v[j-i];v[j]%=g
"p=[]
for i in range(1,40004):
  s=str(i)
  if s==s[::-1]:
    p+=[i]
n=40004
d=[0]*(n+1)
for pj in p:
  d[0] = 1
  for i in range(1,n+1):
    if pj<=i:
      {{completion}}
    d[i]=d[i]%int(1e9+7)
for _ in range(int(input())):
  print(d[int(input())])
        
  
    
      
",d[i]+=d[i-pj],d[i]=d[i]%int(1e9+7)
"n = int(input())


def getList():
    return map(int, input().split())


def getInt():
    return int(input())


N = 4 * 10 ** 4 + 10
M = 10 ** 9 + 7
dp = [0] * N

for i in range(1, N):
    if str(i) == str(i)[::-1]:
        dp[i] += 1
        for j in range(i, N):
            {{completion}}


def solve():
    n = getInt()
    print(dp[n])


for _ in range(n):
    solve()
","dp[j] += dp[j-i]
            dp[j] %= M",dp[i] += 1
"from sys import stdin,stdout
input = lambda : stdin.readline().rstrip()
print =lambda x : stdout.write(str(x))

dp = [0 for _ in range(40002)]
dp[0] = 1
for i in range(1, 40001):
    if str(i) == str(i)[::-1]:
        for j in range(i, 40001):
            {{completion}}
for _ in range(int(input())):
    print(f""{dp[int(input())]}\n"")

",dp[j] = (dp[j]+dp[j-i])%int(1e9+7),dp[j] = (dp[j] + dp[j - i]) % g
"R=range
m=40001
d=10**9+7
p=[]
for i in R(1,m):
    n=str(i)
    if n==n[::-1]:{{completion}}
a=[1]+[0]*m
for i in p:
    for j in R(i,m):
        a[j]+=a[j-i];a[j]%=d
for n in[*open(0)][1:]:print(a[int(n)])",p+=[i],a[j]=a[j]%d+a[j-i]
"R=range
m=40001
d=10**9+7
p=[]
for i in R(1,m):
    n=str(i)
    if n==n[::-1]:p+=[i]
a=[1]+[0]*m
for i in p:
    for j in R(i,m):
        {{completion}}
for n in[*open(0)][1:]:print(a[int(n)])",a[j]+=a[j-i];a[j]%=d,a[j]+=a[j-i];a[j]%=d
"import sys
input  = sys.stdin.readline
s = []
c = [1]
for y in range(1,40005):
    if str(y) == (str(y))[::-1]:
        s.append(y)
    c.append(0)


for i in s:
    for j in range(1,40005):
        if j >= i:
            {{completion}} 
            
a = int(input())
 
for y in range(a):
    b = int(input())
    print(c[b] % ((10 ** 9) + 7))
",c[j] += (c[j - i]) % ((10 ** 9) + 7),c[j]+=c[j-i];c[j]%=d
"d=[0]*40001
d[0]=1
for x in range(1,40001):
    if str(x)==str(x)[::-1]:
        for i in range(x,40001):
            {{completion}}
for _ in range(int(input())):
    print(d[int(input())])
",d[i]=(d[i]+d[i-x])%(10**9+7),d[i]=d[i]%d[0]+d[i-x]
"size = int(4e4)+1
ps=[]
i=1
while (i<size):
    if str(i) == str(i)[::-1]:
        ps.append(i)
    i+=1
 
pm = [0]*size
pm[0]=1
for p in ps:
    i=0
    while (i<size):
        if i+p >= size:
            {{completion}}
        pm[i+p]+=pm[i]
        pm[i+p]%=int(1e9)+7
        i+=1
 
T = int(input())
for _ in range(T):
    n = int(input())
    print(pm[n])
",break,"pm[i+p]+=pm[i]
pm[i+p]%=int(1e9)+7"
"for _ in range(int(input())):
    {{completion}}
","s = input()
    c = len(set(s))
    print(""Yes"" if all(len(set(s[i::c])) == 1 for i in range(c)) else ""No"")","print(""Yes"")
            break"
"import sys
input = sys.stdin.readline

n = int(input())
for _ in range(n):
    s = input()[:-1]
    a = len(s)
    b = len(set(s))
    if b == 1 or a == b:
        print('YES')
    else:
        for i in range(1, a):
            if s[i] in s[:i]:
                w = (s[:i]*a)[:a]
                if s == w:
                    print(""YES"")
                else:
                    {{completion}}
                break","print(""NO"")","print(""NO"")
            break"
"t = int(input())
while (t > 0):
    t -= 1
    s = str(input())
    var = set(s)
    ans = ""YES""
    for i in range(len(s)-len(var)+1):
        if len(set(s[i:i+len(var)])) != len(var):
            {{completion}}
    print(ans)","ans = ""NO""
            break","print(""NO"");break"
"def solve(s):
    st=set(s)
    a=len(st)
    f=1
    for i in range(len(s)):
        if s[i]!=s[i%a]  :
            {{completion}}
    if not f:
        return ""NO""
    else:
        return ""YES""
    
    
    
for i in range(int(input())):
    s=input()
    print(solve(s))",f=0,"print(""NO"")
            break"
"for _ in range(int(input())):
    n=input()
    s=len(set(n))
    for i in range(len(n)-s):
        if n[i]!=n[i+s]:{{completion}}
    else:print(""YES"")","print(""NO"");break","print(""NO"")
            break"
"for i in range(int(input())):
    count={}
    str = input()
    for char in str:
        count[char] = 0
    res = True
    for i in range(len(str) - len(count.keys())):
        if (str[i]!=str[i + len(count.keys())]):
            {{completion}}
    print(""YES"" if res else ""NO"")
",res = False,"print(""NO"")
            break"
"t = int(input())
while(t):
    s = input()
    d = len(set(s))
    for i in range(d, len(s)):
        if(s[i] != s[i - d]):
            {{completion}}
    else:
        print(""Yes"")
    t -= 1","print(""No"")
            break","print(""No"");break"
"n = int(input())
for i in range(n):
  str1 = input()
  set_char = set(str1)
  req = len(set_char)
  prev = dict()
  truth = True
  ind = 0
  for i1 in str1:
    if( i1 in prev and ind - prev[i1] != req):
      {{completion}}
    prev[i1] = ind
    ind += 1
  print(truth and 'YES' or 'NO')","truth = False
      break","print(""No"")
            break"
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  alph = ""abcdefghijklmnopqrstuvwxyz""
  a = list(map(lambda c: alph.index(c) + 1, inp1()))
  l = len(a)
  s = sum(a)

  if l % 2 == 0:
    print(f""Alice {s}"")
  elif l == 1:
    print(f""Bob {s}"")
  else:
    o1 = sum(a[1:]) - a[0]
    o2 = sum(a[:l-1]) - a[-1]
    if o1 > o2:
      print(f""Alice {o1}"")
    else:
      {{completion}}
","print(f""Alice {o2}"")",o1 -= o2
"MOD = 998244353

def modmul(x, y, c = 0):
    {{completion}}

def inv(x):
    return pow(x, MOD - 2, MOD)

MAX = 10 ** 6

fact = [1]
for i in range(1, MAX):
    fact.append(modmul(i, fact[i-1]))

invfact = [1] * (MAX)
invfact[MAX - 1] = inv(fact[MAX - 1])
for i in range(MAX - 2, -1, -1):
    invfact[i] = modmul(i + 1, invfact[i+1])

def comb(x, y):
    return modmul(fact[x], modmul(invfact[y], invfact[x - y]))
    
def invcomb(x, y):
    return modmul(invfact[x], modmul(fact[y], fact[x - y]))
    
def invs(x):
    return modmul(fact[x - 1], invfact[x])

n = int(input())

out = [0] * n

for i in range((n + 1) // 2):
    base = fact[n - 1]
    frac = modmul(comb(n//2, i), invcomb(n - 1, i))
    
    out[i] = modmul(base, frac)

rem = 0   
for i in range(n - 1, -1, -1):
    oldrem = rem
    rem += modmul(out[i], invs(i))
    out[i] -= oldrem
    
    rem %= MOD
    out[i] %= MOD
    
print(' '.join(map(str,out)))",return (x * y + c) % MOD,"return pow(x, MOD - 2, MOD)"
"MOD = 998244353

def modmul(x, y, c = 0):
    return (x * y + c) % MOD

def inv(x):
    {{completion}}

MAX = 10 ** 6

fact = [1]
for i in range(1, MAX):
    fact.append(modmul(i, fact[i-1]))

invfact = [1] * (MAX)
invfact[MAX - 1] = inv(fact[MAX - 1])
for i in range(MAX - 2, -1, -1):
    invfact[i] = modmul(i + 1, invfact[i+1])

def comb(x, y):
    return modmul(fact[x], modmul(invfact[y], invfact[x - y]))
    
def invcomb(x, y):
    return modmul(invfact[x], modmul(fact[y], fact[x - y]))
    
def invs(x):
    return modmul(fact[x - 1], invfact[x])

n = int(input())

out = [0] * n

for i in range((n + 1) // 2):
    base = fact[n - 1]
    frac = modmul(comb(n//2, i), invcomb(n - 1, i))
    
    out[i] = modmul(base, frac)

rem = 0   
for i in range(n - 1, -1, -1):
    oldrem = rem
    rem += modmul(out[i], invs(i))
    out[i] -= oldrem
    
    rem %= MOD
    out[i] %= MOD
    
print(' '.join(map(str,out)))","return pow(x, MOD - 2, MOD)",return (x * y + c) % MOD
"import sys

# https://codeforces.com/contest/1701/problem/F

MAXN = 200000


class SegmentTree:
    def __init__(self):
        self.lazy = []
        self.v0 = []
        self.v1 = []
        self.v2 = []
        self.active = []

        for _ in range(4 * MAXN + 1):
            self.lazy.append(0)
            self.v0.append(1)
            self.v1.append(0)
            self.v2.append(0)
            self.active.append(True)

        self._init_active(1, 1, MAXN)

    def _init_active(self, x, l, r):
        if l == r:
            self.active[x] = False
        else:
            m = (l + r) // 2
            self._init_active(x * 2, l, m)
            self._init_active(x * 2 + 1, m + 1, r)
            self._reclac(x)

    def _reclac(self, x):
        self.v0[x] = 0
        self.v1[x] = 0
        self.v2[x] = 0

        if self.active[x * 2]:
            self.v0[x] += self.v0[x * 2]
            self.v1[x] += self.v1[x * 2]
            self.v2[x] += self.v2[x * 2]

        if self.active[x * 2 + 1]:
            self.v0[x] += self.v0[x * 2 + 1]
            self.v1[x] += self.v1[x * 2 + 1]
            self.v2[x] += self.v2[x * 2 + 1]

    def _push(self, x, l, r):
        la = self.lazy[x]

        if la == 0:
            return

        if l != r:
            self.v2[x * 2] = self.v2[x * 2] + 2 * la * self.v1[x * 2] + la * la * self.v0[x * 2]
            self.v1[x * 2] += la * self.v0[x * 2]

            self.v2[x * 2 + 1] = self.v2[x * 2 + 1] + 2 * la * self.v1[x * 2 + 1] + la * la * self.v0[x * 2 + 1]
            self.v1[x * 2 + 1] += la * self.v0[x * 2 + 1]

            self.lazy[x * 2] += la
            self.lazy[x * 2 + 1] += la

        self.lazy[x] = 0

    def update(self, x, l, r, a, b, up: bool):
        if r < a or b < l:
            return

        if a <= l and r <= b:
            if up:
                self.v2[x] = self.v2[x] + 2 * self.v1[x] + self.v0[x]
                self.v1[x] += self.v0[x]

                self.lazy[x] += 1
            else:
                {{completion}}
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.update(x * 2, l, m, a, b, up)
        self.update(x * 2 + 1, m + 1, r, a, b, up)

        self._reclac(x)

    def set_state(self, x, l, r, pos, up: bool):
        if pos < l or r < pos:
            return

        if l == r:
            self.active[x] = up
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.set_state(x * 2, l, m, pos, up)
        self.set_state(x * 2 + 1, m + 1, r, pos, up)

        self._reclac(x)


def solve():
    q, d = map(int, input().split())
    points = map(int, sys.stdin.readline().split())

    tree = SegmentTree()

    check = [0] * (MAXN + 1)
    ans = []
    for point in points:
        if check[point]:
            check[point] = 0
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, False)
            tree.set_state(1, 1, MAXN, point, False)
        else:
            check[point] = 1
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, True)
            tree.set_state(1, 1, MAXN, point, True)

        v1 = tree.v1[1]
        v2 = tree.v2[1]
        ans.append((v2 - v1) // 2)

    print('\n'.join(map(str, ans)))


if __name__ == '__main__':
    solve()","self.v2[x] = self.v2[x] - 2 * self.v1[x] + self.v0[x]
                self.v1[x] -= self.v0[x]

                self.lazy[x] -= 1",self.push(l >> i)
"import sys

# https://codeforces.com/contest/1701/problem/F

MAXN = 200000


class SegmentTree:
    def __init__(self):
        self.lazy = []
        self.v0 = []
        self.v1 = []
        self.v2 = []
        self.active = []

        for _ in range(4 * MAXN + 1):
            self.lazy.append(0)
            self.v0.append(1)
            self.v1.append(0)
            self.v2.append(0)
            self.active.append(True)

        self._init_active(1, 1, MAXN)

    def _init_active(self, x, l, r):
        if l == r:
            self.active[x] = False
        else:
            m = (l + r) // 2
            self._init_active(x * 2, l, m)
            self._init_active(x * 2 + 1, m + 1, r)
            self._reclac(x)

    def _reclac(self, x):
        self.v0[x] = 0
        self.v1[x] = 0
        self.v2[x] = 0

        if self.active[x * 2]:
            self.v0[x] += self.v0[x * 2]
            self.v1[x] += self.v1[x * 2]
            self.v2[x] += self.v2[x * 2]

        if self.active[x * 2 + 1]:
            self.v0[x] += self.v0[x * 2 + 1]
            self.v1[x] += self.v1[x * 2 + 1]
            self.v2[x] += self.v2[x * 2 + 1]

    def _push(self, x, l, r):
        la = self.lazy[x]

        if la == 0:
            return

        if l != r:
            self.v2[x * 2] = self.v2[x * 2] + 2 * la * self.v1[x * 2] + la * la * self.v0[x * 2]
            self.v1[x * 2] += la * self.v0[x * 2]

            self.v2[x * 2 + 1] = self.v2[x * 2 + 1] + 2 * la * self.v1[x * 2 + 1] + la * la * self.v0[x * 2 + 1]
            self.v1[x * 2 + 1] += la * self.v0[x * 2 + 1]

            self.lazy[x * 2] += la
            self.lazy[x * 2 + 1] += la

        self.lazy[x] = 0

    def update(self, x, l, r, a, b, up: bool):
        if r < a or b < l:
            return

        if a <= l and r <= b:
            if up:
                {{completion}}
            else:
                self.v2[x] = self.v2[x] - 2 * self.v1[x] + self.v0[x]
                self.v1[x] -= self.v0[x]

                self.lazy[x] -= 1
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.update(x * 2, l, m, a, b, up)
        self.update(x * 2 + 1, m + 1, r, a, b, up)

        self._reclac(x)

    def set_state(self, x, l, r, pos, up: bool):
        if pos < l or r < pos:
            return

        if l == r:
            self.active[x] = up
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.set_state(x * 2, l, m, pos, up)
        self.set_state(x * 2 + 1, m + 1, r, pos, up)

        self._reclac(x)


def solve():
    q, d = map(int, input().split())
    points = map(int, sys.stdin.readline().split())

    tree = SegmentTree()

    check = [0] * (MAXN + 1)
    ans = []
    for point in points:
        if check[point]:
            check[point] = 0
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, False)
            tree.set_state(1, 1, MAXN, point, False)
        else:
            check[point] = 1
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, True)
            tree.set_state(1, 1, MAXN, point, True)

        v1 = tree.v1[1]
        v2 = tree.v2[1]
        ans.append((v2 - v1) // 2)

    print('\n'.join(map(str, ans)))


if __name__ == '__main__':
    solve()","self.v2[x] = self.v2[x] + 2 * self.v1[x] + self.v0[x]
                self.v1[x] += self.v0[x]

                self.lazy[x] += 1",self.push(l >> i)
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                {{completion}}
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class LazySegmentTree():
    def __init__(self, n, op, e, mapping, composition, id):
        self.n = n
        self.op = op
        self.e = e
        self.mapping = mapping
        self.composition = composition
        self.id = id
        self.log = (n - 1).bit_length()
        self.size = 1 << self.log
        self.data = [e] * (2 * self.size)
        self.lazy = [id] * self.size

    def update(self, k):
        self.data[k] = self.op(self.data[2 * k], self.data[2 * k + 1])

    def all_apply(self, k, f):
        self.data[k] = self.mapping(f, self.data[k])
        if k < self.size:
            self.lazy[k] = self.composition(f, self.lazy[k])

    def push(self, k):
        self.all_apply(2 * k, self.lazy[k])
        self.all_apply(2 * k + 1, self.lazy[k])
        self.lazy[k] = self.id

    def build(self, arr):
        # assert len(arr) == self.n
        for i, a in enumerate(arr):
            self.data[self.size + i] = a
        for i in range(self.size - 1, 0, -1):
            self.update(i)

    def set(self, p, x):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = x
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def get(self, p):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        return self.data[p]

    def prod(self, l, r):
        # assert 0 <= l <= r <= self.n
        if l == r: return self.e
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push(r >> i)
        sml = smr = self.e
        while l < r:
            if l & 1:
                sml = self.op(sml, self.data[l])
                l += 1
            if r & 1:
                r -= 1
                smr = self.op(self.data[r], smr)
            l >>= 1
            r >>= 1
        return self.op(sml, smr)

    def all_prod(self):
        return self.data[1]

    def apply(self, p, f):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = self.mapping(f, self.data[p])
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def range_apply(self, l, r, f):
        # assert 0 <= l <= r <= self.n
        if l == r: return
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push((r - 1) >> i)
        l2 = l
        r2 = r
        while l < r:
            if l & 1:
                self.all_apply(l, f)
                l += 1
            if r & 1:
                r -= 1
                self.all_apply(r, f)
            l >>= 1
            r >>= 1
        l = l2
        r = r2
        for i in range(1, self.log + 1):
            if ((l >> i) << i) != l: self.update(l >> i)
            if ((r >> i) << i) != r: self.update((r - 1) >> i)




n = 2*10**5+1
q, d = map(int, input().split())
arr = list(map(int, input().split()))
v = [0]*n

def op(x, y):
    return [x[0]+y[0], x[1]+y[1], x[2]+y[2], x[3]]

def mapping(k, x):
    return [x[0], k*x[0]+x[1], k*k*x[0]+2*k*x[1]+x[2], x[3]+k]

def composition(f, g):
    return f+g

e = [0, 0, 0, 0]
id = 0

st = LazySegmentTree(n, op, e, mapping, composition, id)
st.build([[0, 0, 0, 0] for i in range(n)])
for x in arr:
    v[x] ^= 1
    m = st.get(x)[3]
    if v[x]:
        st.range_apply(x+1, min(x+d+1, n), 1)
        st.set(x, [1, m, m*m, m])
    else:
        st.range_apply(x+1, min(x+d+1, n), -1)
        st.set(x, [0, 0, 0, m])
    a = st.all_prod()
    print((a[2]-a[1])//2)

",break,"st.range_apply(x+1, min(x+d+1, n), 1)"
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class LazySegmentTree():
    def __init__(self, n, op, e, mapping, composition, id):
        self.n = n
        self.op = op
        self.e = e
        self.mapping = mapping
        self.composition = composition
        self.id = id
        self.log = (n - 1).bit_length()
        self.size = 1 << self.log
        self.data = [e] * (2 * self.size)
        self.lazy = [id] * self.size

    def update(self, k):
        self.data[k] = self.op(self.data[2 * k], self.data[2 * k + 1])

    def all_apply(self, k, f):
        self.data[k] = self.mapping(f, self.data[k])
        if k < self.size:
            self.lazy[k] = self.composition(f, self.lazy[k])

    def push(self, k):
        self.all_apply(2 * k, self.lazy[k])
        self.all_apply(2 * k + 1, self.lazy[k])
        self.lazy[k] = self.id

    def build(self, arr):
        # assert len(arr) == self.n
        for i, a in enumerate(arr):
            self.data[self.size + i] = a
        for i in range(self.size - 1, 0, -1):
            self.update(i)

    def set(self, p, x):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = x
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def get(self, p):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        return self.data[p]

    def prod(self, l, r):
        # assert 0 <= l <= r <= self.n
        if l == r: return self.e
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: {{completion}}
            if ((r >> i) << i) != r: self.push(r >> i)
        sml = smr = self.e
        while l < r:
            if l & 1:
                sml = self.op(sml, self.data[l])
                l += 1
            if r & 1:
                r -= 1
                smr = self.op(self.data[r], smr)
            l >>= 1
            r >>= 1
        return self.op(sml, smr)

    def all_prod(self):
        return self.data[1]

    def apply(self, p, f):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = self.mapping(f, self.data[p])
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def range_apply(self, l, r, f):
        # assert 0 <= l <= r <= self.n
        if l == r: return
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push((r - 1) >> i)
        l2 = l
        r2 = r
        while l < r:
            if l & 1:
                self.all_apply(l, f)
                l += 1
            if r & 1:
                r -= 1
                self.all_apply(r, f)
            l >>= 1
            r >>= 1
        l = l2
        r = r2
        for i in range(1, self.log + 1):
            if ((l >> i) << i) != l: self.update(l >> i)
            if ((r >> i) << i) != r: self.update((r - 1) >> i)




n = 2*10**5+1
q, d = map(int, input().split())
arr = list(map(int, input().split()))
v = [0]*n

def op(x, y):
    return [x[0]+y[0], x[1]+y[1], x[2]+y[2], x[3]]

def mapping(k, x):
    return [x[0], k*x[0]+x[1], k*k*x[0]+2*k*x[1]+x[2], x[3]+k]

def composition(f, g):
    return f+g

e = [0, 0, 0, 0]
id = 0

st = LazySegmentTree(n, op, e, mapping, composition, id)
st.build([[0, 0, 0, 0] for i in range(n)])
for x in arr:
    v[x] ^= 1
    m = st.get(x)[3]
    if v[x]:
        st.range_apply(x+1, min(x+d+1, n), 1)
        st.set(x, [1, m, m*m, m])
    else:
        st.range_apply(x+1, min(x+d+1, n), -1)
        st.set(x, [0, 0, 0, m])
    a = st.all_prod()
    print((a[2]-a[1])//2)

",self.push(l >> i),"































































































































"
"n,k = map(int,input().split())
ns = set()
for _ in range(n):
    {{completion}}
arr = [[tuple((6-v1[i]-v2[i])%3 for i in range(k)) in ns for v1 in ns] for v2 in ns]
ans = 0
for i in range(n):
    s = sum(arr[i])-2
    ans += s*s//8
print(ans)","s = tuple(int(v) for v in input().split())
    ns.add(s)","s = sum(arr[i])-2
    ans += s*s//8"
"n,k = map(int,input().split())
ns = set()
for _ in range(n):
    s = tuple(int(v) for v in input().split())
    ns.add(s)
arr = [[tuple((6-v1[i]-v2[i])%3 for i in range(k)) in ns for v1 in ns] for v2 in ns]
ans = 0
for i in range(n):
    {{completion}}
print(ans)","s = sum(arr[i])-2
    ans += s*s//8","s = tuple(int(v) for v in input().split())
    ns.add(s)"
"from sys import stdin

def missing(c1, c2):
    c3 = []
    for i in range(len(c1)):
        if c1[i] == c2[i]:
            c3.append(c1[i])
        else:
            c3.append(next(iter({""0"", ""1"", ""2""}.difference({c1[i], c2[i]}))))

    return """".join(c3)

def solve():
    n, k = map(int, stdin.readline().split())
    cards = [stdin.readline().strip().replace("" "", """") for i in range(n)]
    
    off1 = {c:0 for c in cards}

    for i in range(n):
        for j in range(i+1, n):
            m = missing(cards[i], cards[j])
            if m in off1:
                {{completion}}

    print(sum(i*(i-1)//2 for i in off1.values()))

solve()",off1[m] += 1,off1[c] += 1
"ndfeagbb, dfeagbbk = map(int, input().split())
cards = [tuple(map(int, input().split())) for _ in range(ndfeagbb)]
cards_lookup, counter = {card: i for i, card in enumerate(cards)}, [0] * (ndfeagbb + 1)
for i in range(len(cards) - 1):
    for j in range(i + 1, len(cards)):
        {{completion}}
print(sum(x * (x - 1) // 2 for x in counter[:-1]))
","counter[cards_lookup.get(tuple(x if x == y else ((x + 1) ^ (y + 1)) - 1 for x, y in zip(cards[i], cards[j])), -1)] += 1",counter[cards_lookup[card]] += 1
"from sys import stdin, stdout

n, k = [int(x) for x in stdin.readline().split()]
cards = set()
for i in range(n):
    cards.add(tuple([int(x) for x in stdin.readline().split()]))

answer = 0
for card in cards:
    yes_v = 0
    for v in cards:
        w = []
        for i in range(k):
            {{completion}}
        if tuple(w) in cards:
            yes_v += 1

    yes_v = (yes_v-1)//2
    answer += (yes_v * (yes_v-1))//2

stdout.write(str(answer)+'\n')
",w.append((3-card[i]-v[i])%3),"for i in range(k):
    w.append((3-card[i]-v[i])%3)"
"from sys import stdin, stdout

n, k = [int(x) for x in stdin.readline().split()]
cards = set()
for i in range(n):
    cards.add(tuple([int(x) for x in stdin.readline().split()]))

answer = 0
for card in cards:
    yes_v = 0
    for v in cards:
        w = []
        for i in range(k):
            w.append((3-card[i]-v[i])%3)
        if tuple(w) in cards:
            {{completion}}

    yes_v = (yes_v-1)//2
    answer += (yes_v * (yes_v-1))//2

stdout.write(str(answer)+'\n')
",yes_v += 1,w.append((3-card[i]-v[i])%3)
"import sys; R = sys.stdin.readline
n,k = map(int,R().split())
deck = [tuple(map(int,R().split())) for _ in range(n)]
dic = {}
for i in range(n): dic[deck[i]] = i
res = [0]*n
for p in range(n-2):
    for q in range(p+1,n-1):
        last = [0]*k
        for j in range(k):
            {{completion}}
        last = tuple(last)
        if last in dic and dic[last]>q:
            res[p] += 1; res[q] += 1; res[dic[last]] += 1
print(sum((s*(s-1))//2 for s in res))",last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j],last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
"import sys; R = sys.stdin.readline
n,k = map(int,R().split())
deck = [tuple(map(int,R().split())) for _ in range(n)]
dic = {}
for i in range(n): dic[deck[i]] = i
res = [0]*n
for p in range(n-2):
    for q in range(p+1,n-1):
        last = [0]*k
        for j in range(k):
            last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
        last = tuple(last)
        if last in dic and dic[last]>q:
            {{completion}}
print(sum((s*(s-1))//2 for s in res))",res[p] += 1; res[q] += 1; res[dic[last]] += 1,last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
"
n,k=map(int,input().split())
a=[]
d={}
for i in range(n):
    a+=[''.join(input().split())]
    d[a[-1]]=0


def cal(s,t):
    res=""""
    for i in range(k):
        res+=str((9-int(s[i])-int(t[i]))%3)
    return res



for i in range(n):
    for j in range(i):
        try:
            d[cal(a[i],a[j])]+=1
        except:
            {{completion}}

ans=0
for y in d.values():
    ans+=(y*(y-1))//2
print(ans)

",pass,"d[cal(a[i],a[j])]+=1"
"n, k = [int(i) for i in input().split()]
a = []
for _ in range(n):
    a.append(tuple([int(i) for i in input().split()]))
a = tuple(a)
sus = set(a)

cs = [0 for i in range(n)]
for i in range(n):
    p = a[i]
    for j in set(range(n)) - set(tuple([i])):
        q = a[j]
        r = []
        for o in range(k):
            if p[o] == q[o]:
                r.append(p[o])
            else:
                {{completion}}
        if tuple(r) in sus:
            cs[i] += 1
            cs[j] += 1
cs = [i//4 for i in cs]
cs = [(i*(i-1))//2 for i in cs]
print(sum(cs))",r.append(3-p[o]-q[o]),"this is the start of the ground truth
cs = [0 for i in range(n)]
for i in range(n):
    p = a[i]
    for j in set(range(n)) - set(tuple([i])):
        q = a[j]
        r = []
        for o in range(k):
            if p[o] == q[o]:
                r.append(p[o])
            else:
                r.append(3)
        if tuple(r)"
"for _ in range(int(input())):
    {{completion}}","n = input()
    a = sorted(map(int, input().split()))
    print(a[-1] + a[-2] - a[0] - a[1])","input()
    a, b, *_, c, d = sorted(map(int, input().split()))
    print(c+d-a-b)"
for s in[*open(0)][2::2]:{{completion}},"a,b,*_,c,d=sorted(map(int,s.split()));print(c+d-a-b)","n=int(input());a=sorted(map(int,input().split()));print(a[-1]+a[-2]-a[0]-a[1])"
for t in range(int(input())):{{completion}},"input();a,b,*_,c,d=sorted(map(int,input().split()));print(c+d-a-b)","input()
    a, b, *_, c, d = sorted(map(int, input().split()))
    print(c+d-a-b)"
for sdr in[*open(0)][2::2]:{{completion}},"p,q,*_,r,s=sorted(map(int,sdr.split()));print(r+s-p-q)","a,b,*_,c,d=sorted(map(int,sdr.split()));print(c+d-a-b)"
"for _ in range(int(input())):
    {{completion}}
    ","input()
    a, b, *_, c, d = sorted(map(int, input().split()))
    print(c+d-a-b)","input()
    a, b, *_, c, d = sorted(map(int, input().split()))
    print(c+d-a-b)"
"for _ in range(int(input())):
    {{completion}}
","input()
    a = sorted(map(int, input().split()))
    print(a[-1] + a[-2] - a[0] - a[1])","input()
    a, b, *_, c, d = sorted(map(int, input().split()))
    print(c+d-a-b)"
"import sys
import math
import heapq
import itertools
import bisect
import random
from decimal import *
from collections import deque
input=sys.stdin.readline

def extended_gcd(a,b):
    x0,x1,y0,y1=1,0,0,1
    while b!=0:
        n,a,b=a//b,b,a%b
        x0,x1=x1,x0-n*x1
        y0,y1=y1,y0-n*y1
    return x0,y0

n=int(input())
arr=[]
ans=0
for i in range(n):
    a,b=map(int,input().split())
    ans+=a
    arr.append(b-a)
arr.sort(reverse=True)
s=[0]
for i in range(n):
    s.append(s[-1]+arr[i])
mp=s.index(max(s))

m=int(input())
for _ in range(m):
    a,b=map(int,input().split())
    k=math.gcd(a,b)
    if n%(math.gcd(a,b))==0:
        a1,b1=a//k,b//k
        x,y=extended_gcd(a1,b1)
        x,y=x*(n//k),y*(n//k)
        mod=math.lcm(a,b)
        p=(y*b)%mod
        if p>n:
            print(-1)
        else:
            p1=(mp//mod)*mod+p
            line=[p1,p1-mod,p1+mod]
            ma=-10**18
            for i in line:
                if 0<=i<=n:
                    {{completion}}
            print(ma+ans)
            
            
            
    else:
        print(-1)
        
        
            






        
","ma=max(ma,s[i])",print(max(s))
"from collections import *
from itertools import *
from functools import *
import math,sys
input = sys.stdin.buffer.readline

n = int(input())
AB = [tuple(map(int,input().split())) for _ in range(n)]
M = int(input())
XY = [tuple(map(int,input().split())) for _ in range(M)]

ans = []
from math import gcd

def modinv(a, b):
    p = b
    x, y, u, v = 1, 0, 0, 1
    while b:
        k = a // b
        x -= k * u
        y -= k * v
        x, u = u, x
        y, v = v, y
        a, b = b, a % b
    x %= p
    if x < 0:
        x += p
    return x
    
def slc(A, B, mod):
    #solve Ax=B mod 
    a = A
    b = B
    m = mod
    d = gcd(a,gcd(b,m))
    
    while d>1:
        a //= d
        b //= d
        m //= d
        d = gcd(a,gcd(b,m))
    
    if gcd(a,m) != 1:
        return -1
    
    return (modinv(a,m)*b)%m
    
 
D = [a-b for a,b in AB]
S = sum(b for a,b in AB)
D.sort(reverse=True)
SD = list(accumulate([0]+D))
L = 0
for i in range(n-1,-1,-1):
    if D[i]>0:
        L = i+1
        break
    
for x,y in XY:
    
    d = gcd(x,y)
    
    if n%d != 0:
        print(-1)
        continue
    
    x0 = slc(x,n,y)
    tb = y//d
    ok = 0
    ng = -10**10
    while ok-ng>1:
        mid = (ok+ng)//2
        if x0+mid*tb >=0:
            ok = mid
        else:
            {{completion}}
    x0 += tb*ok
    
    if x0*x>n:
        print(-1)
        continue
    def is_ok(k):

        return ((n-x*(x0 + k*tb)) >= 0)&(x0 + k*tb >= 0)
    
    k0 = (L-x*x0)//(tb*x)
    ans = -1
    flg = False
    if is_ok(k0):
        tmp = S + SD[x*(x0 + k0*tb)]
        ans = max(ans,tmp)
    if is_ok(k0+1):
        tmp = S + SD[x*(x0 + (k0+1)*tb)]
        ans = max(ans,tmp)
        flg = True
    if flg:
        print(ans)
        continue
    ok = 0
    ng = k0 + 1
    while ng-ok>1:
        mid = (ok+ng)//2
        if is_ok(mid):
            ok = mid
        else:
            ng = mid
    ans = max(ans,S + SD[x*(x0 + ok*tb)])
    print(ans)
        
    
    ",ng = mid,ng = mid
"from collections import *
from itertools import *
from functools import *
import math,sys
input = sys.stdin.buffer.readline

n = int(input())
AB = [tuple(map(int,input().split())) for _ in range(n)]
M = int(input())
XY = [tuple(map(int,input().split())) for _ in range(M)]

ans = []
from math import gcd

def modinv(a, b):
    p = b
    x, y, u, v = 1, 0, 0, 1
    while b:
        k = a // b
        x -= k * u
        y -= k * v
        x, u = u, x
        y, v = v, y
        a, b = b, a % b
    x %= p
    if x < 0:
        x += p
    return x
    
def slc(A, B, mod):
    #solve Ax=B mod 
    a = A
    b = B
    m = mod
    d = gcd(a,gcd(b,m))
    
    while d>1:
        a //= d
        b //= d
        m //= d
        d = gcd(a,gcd(b,m))
    
    if gcd(a,m) != 1:
        return -1
    
    return (modinv(a,m)*b)%m
    
 
D = [a-b for a,b in AB]
S = sum(b for a,b in AB)
D.sort(reverse=True)
SD = list(accumulate([0]+D))
L = 0
for i in range(n-1,-1,-1):
    if D[i]>0:
        L = i+1
        break
    
for x,y in XY:
    
    d = gcd(x,y)
    
    if n%d != 0:
        print(-1)
        continue
    
    x0 = slc(x,n,y)
    tb = y//d
    ok = 0
    ng = -10**10
    while ok-ng>1:
        mid = (ok+ng)//2
        if x0+mid*tb >=0:
            ok = mid
        else:
            ng = mid
    x0 += tb*ok
    
    if x0*x>n:
        print(-1)
        continue
    def is_ok(k):

        return ((n-x*(x0 + k*tb)) >= 0)&(x0 + k*tb >= 0)
    
    k0 = (L-x*x0)//(tb*x)
    ans = -1
    flg = False
    if is_ok(k0):
        tmp = S + SD[x*(x0 + k0*tb)]
        ans = max(ans,tmp)
    if is_ok(k0+1):
        tmp = S + SD[x*(x0 + (k0+1)*tb)]
        ans = max(ans,tmp)
        flg = True
    if flg:
        print(ans)
        continue
    ok = 0
    ng = k0 + 1
    while ng-ok>1:
        mid = (ok+ng)//2
        if is_ok(mid):
            ok = mid
        else:
            {{completion}}
    ans = max(ans,S + SD[x*(x0 + ok*tb)])
    print(ans)
        
    
    ",ng = mid,ng = mid
"import math
import sys
input = sys.stdin.readline
class Dish:
	def __init__(self):
		self.a=0
		self.b=0


def exgcd(a,b):
	if b:
		x,y=exgcd(b,a%b)
		return y,x-a//b*y
	return 1,0


n=int(input())
dish=[Dish() for i in range(n)]
val=[0 for i in range(n+5)]

for i in range(n):
	dish[i].a,dish[i].b=map(int,input().split(' '))
	val[0]+=dish[i].b

dish.sort(key=lambda x: x.b-x.a)


valMax=val[0]
maxW=0

for i in range(n):
	val[i+1]=val[i]-dish[i].b+dish[i].a
	if valMax<val[i+1]:
		maxW=i+1
		valMax=val[i+1]

#print(val)
	
for o in range(int(input())):
	a,b=map(int,input().split(' '))
	gcdAB=math.gcd(a,b)
	a//=gcdAB
	b//=gcdAB
	if n%gcdAB:
		print(""-1"")
		continue
	c=n//gcdAB
	x0,y0=exgcd(a,b)
	x1=x0*c
	y1=y0*c
	kmax=math.floor(y1/a)
	kmin=math.ceil(-x1/b)
	if kmin>kmax:
		print(-1)
		continue
	if a*gcdAB*(x1+kmax*b)<maxW:
		print(val[a*gcdAB*(x1+kmax*b)])
	elif a*gcdAB*(x1+kmin*b)>maxW:
		{{completion}}
	else:
		k=(maxW/a/gcdAB-x1)/b
		print(max(val[a*gcdAB*(x1+math.ceil(k)*b)],val[a*gcdAB*(x1+math.floor(k)*b)]))
	#print(x1,y1)
	#print(kmin,kmax)
	#print(""----"")
	
	",print(val[a*gcdAB*(x1+kmin*b)]),"k=(maxW/a/gcdAB-x1)/b
		print(max(val[a*gcdAB*(x1+math.ceil(k)*b)],val[a*gcdAB*(x1+math.floor(k)*b)]))"
"import math
import sys
input = sys.stdin.readline
class Dish:
	def __init__(self):
		self.a=0
		self.b=0


def exgcd(a,b):
	if b:
		x,y=exgcd(b,a%b)
		return y,x-a//b*y
	return 1,0


n=int(input())
dish=[Dish() for i in range(n)]
val=[0 for i in range(n+5)]

for i in range(n):
	dish[i].a,dish[i].b=map(int,input().split(' '))
	val[0]+=dish[i].b

dish.sort(key=lambda x: x.b-x.a)


valMax=val[0]
maxW=0

for i in range(n):
	val[i+1]=val[i]-dish[i].b+dish[i].a
	if valMax<val[i+1]:
		maxW=i+1
		valMax=val[i+1]

#print(val)
	
for o in range(int(input())):
	a,b=map(int,input().split(' '))
	gcdAB=math.gcd(a,b)
	a//=gcdAB
	b//=gcdAB
	if n%gcdAB:
		print(""-1"")
		continue
	c=n//gcdAB
	x0,y0=exgcd(a,b)
	x1=x0*c
	y1=y0*c
	kmax=math.floor(y1/a)
	kmin=math.ceil(-x1/b)
	if kmin>kmax:
		print(-1)
		continue
	if a*gcdAB*(x1+kmax*b)<maxW:
		print(val[a*gcdAB*(x1+kmax*b)])
	elif a*gcdAB*(x1+kmin*b)>maxW:
		print(val[a*gcdAB*(x1+kmin*b)])
	else:
		{{completion}}
	#print(x1,y1)
	#print(kmin,kmax)
	#print(""----"")
	
	","k=(maxW/a/gcdAB-x1)/b
		print(max(val[a*gcdAB*(x1+math.ceil(k)*b)],val[a*gcdAB*(x1+math.floor(k)*b)]))",print(val[a*gcdAB*(x1+kmin*b)])
"input = __import__('sys').stdin.readline


MOD = 998244353


d, n, m = map(int, input().split())
lamps = list(sorted(map(int, input().split()))) # n
points = list(sorted(map(int, input().split()))) # m

# 1. O(m^2) to find all interesting points (sould be around m^2 points)
positions = [x for x in points]
positions.append(0)
positions.append(d)
for i in range(m):
    for j in range(i+1, m):
        mid = (points[i] + points[j]) // 2
        positions.append(mid)
        positions.append(mid+1)
positions = list(sorted(set(positions)))
posmap = {x: i for i, x in enumerate(positions)}

# print('points', points)
# print('positions', positions)

# 2. O(nm) to precompute QueryL and QueryR
i = 0
queryL = []
for p in points:
    queries = [0] * len(positions)
    while positions[i] < p:
        i += 1

    j = i    
    q = 1
    for x in lamps:
        if x <= p:
            continue
        while x > positions[j]:
            queries[j] = q
            j += 1
        q = q * (x - p) % MOD
    
    while j < len(positions):
        queries[j] = q
        j += 1
    
    queryL.append(queries)
    # print('L p:', p, queries)

i = len(positions)-1
queryR = []
for p in points[::-1]:
    queries = [0] * len(positions)
    while positions[i] > p:
        i -= 1

    j = i
    q = 1
    for x in lamps[::-1]:
        if x > p:
            continue
        while x < positions[j]:
            queries[j] = q
            j -= 1
        q = q * (p - x) % MOD
    while j >= 0:
        queries[j] = q
        j -= 1
    
    queryR.append(queries)
    # print('R p:', p, queries)

queryR = queryR[::-1]
# print('queryL', queryL)
# print('queryR', queryR)

# 3. O(m*2^m) to convert all mask to product of QueryL & QueryR and calculate the inclusion-exclusion & accumulate its SumQueryL[L..R] SumQueryR[L..R] values
querySums = [[[0]*len(positions) for _ in range(len(points))] for _ in range(2)]
current_ans = 0
for mask in range(1, 1 << m):
    keys = []
    prev_idx = -1
    popcnt = 0
    q = 1
    for i in range(m):
        if (mask >> i) & 1:
            p = points[i]
            if prev_idx == -1:
                keys.append((1, i, 0))
                q = q * queryR[i][0] % MOD
            else:
                {{completion}}
            
            prev_idx = i
            popcnt += 1
    
    keys.append((0, prev_idx, len(positions)-1))
    q = q * queryL[prev_idx][-1] % MOD
    if popcnt & 1:
        current_ans = (current_ans - q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] - q) % MOD
    else:
        current_ans = (current_ans + q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD
    
    # print('mask', ('{:0' + str(m) + 'b}').format(mask), q, keys)

for j in range(m):
    for k in range(len(positions) -2, -1, -1):
        querySums[0][j][k] = (querySums[0][j][k] + querySums[0][j][k+1]) % MOD
    for k in range(1, len(positions)):
        querySums[1][j][k] = (querySums[1][j][k] + querySums[1][j][k-1]) % MOD

# 4. for each query, update the total ans by affected SumQueryL and SumQueryR (those with L <= x <= R)
current_ans += pow(d+1, n+1, MOD)
current_ans %= MOD

_ = int(input())
for x in map(int, input().split()):
    ans = current_ans

    for i in range(len(positions)):
        if positions[i] >= x:
            pos = i
            break

    for j in range(m):
        if points[j] < x:
            total = querySums[0][j][pos]
            ans -= total
            ans += total * (x - points[j]) % MOD
            ans %= MOD
    
    for i in range(len(positions)-1, -1, -1):
        if positions[i] <= x:
            pos = i
            break
    
    for j in range(m):
        if x <= points[j]:
            total = querySums[1][j][pos]
            ans -= total
            ans += total * (points[j] - x) % MOD
            ans %= MOD

    print(ans)
","prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD","keys.append((1, i, 0))
                q = q * queryR[i][0] % MOD"
"input = __import__('sys').stdin.readline


MOD = 998244353


d, n, m = map(int, input().split())
lamps = list(sorted(map(int, input().split()))) # n
points = list(sorted(map(int, input().split()))) # m

# 1. O(m^2) to find all interesting points (sould be around m^2 points)
positions = [x for x in points]
positions.append(0)
positions.append(d)
for i in range(m):
    for j in range(i+1, m):
        mid = (points[i] + points[j]) // 2
        positions.append(mid)
        positions.append(mid+1)
positions = list(sorted(set(positions)))
posmap = {x: i for i, x in enumerate(positions)}

# print('points', points)
# print('positions', positions)

# 2. O(nm) to precompute QueryL and QueryR
i = 0
queryL = []
for p in points:
    queries = [0] * len(positions)
    while positions[i] < p:
        i += 1

    j = i    
    q = 1
    for x in lamps:
        if x <= p:
            continue
        while x > positions[j]:
            queries[j] = q
            j += 1
        q = q * (x - p) % MOD
    
    while j < len(positions):
        queries[j] = q
        j += 1
    
    queryL.append(queries)
    # print('L p:', p, queries)

i = len(positions)-1
queryR = []
for p in points[::-1]:
    queries = [0] * len(positions)
    while positions[i] > p:
        i -= 1

    j = i
    q = 1
    for x in lamps[::-1]:
        if x > p:
            continue
        while x < positions[j]:
            queries[j] = q
            j -= 1
        q = q * (p - x) % MOD
    while j >= 0:
        queries[j] = q
        j -= 1
    
    queryR.append(queries)
    # print('R p:', p, queries)

queryR = queryR[::-1]
# print('queryL', queryL)
# print('queryR', queryR)

# 3. O(m*2^m) to convert all mask to product of QueryL & QueryR and calculate the inclusion-exclusion & accumulate its SumQueryL[L..R] SumQueryR[L..R] values
querySums = [[[0]*len(positions) for _ in range(len(points))] for _ in range(2)]
current_ans = 0
for mask in range(1, 1 << m):
    keys = []
    prev_idx = -1
    popcnt = 0
    q = 1
    for i in range(m):
        if (mask >> i) & 1:
            p = points[i]
            if prev_idx == -1:
                {{completion}}
            else:
                prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD
            
            prev_idx = i
            popcnt += 1
    
    keys.append((0, prev_idx, len(positions)-1))
    q = q * queryL[prev_idx][-1] % MOD
    if popcnt & 1:
        current_ans = (current_ans - q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] - q) % MOD
    else:
        current_ans = (current_ans + q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD
    
    # print('mask', ('{:0' + str(m) + 'b}').format(mask), q, keys)

for j in range(m):
    for k in range(len(positions) -2, -1, -1):
        querySums[0][j][k] = (querySums[0][j][k] + querySums[0][j][k+1]) % MOD
    for k in range(1, len(positions)):
        querySums[1][j][k] = (querySums[1][j][k] + querySums[1][j][k-1]) % MOD

# 4. for each query, update the total ans by affected SumQueryL and SumQueryR (those with L <= x <= R)
current_ans += pow(d+1, n+1, MOD)
current_ans %= MOD

_ = int(input())
for x in map(int, input().split()):
    ans = current_ans

    for i in range(len(positions)):
        if positions[i] >= x:
            pos = i
            break

    for j in range(m):
        if points[j] < x:
            total = querySums[0][j][pos]
            ans -= total
            ans += total * (x - points[j]) % MOD
            ans %= MOD
    
    for i in range(len(positions)-1, -1, -1):
        if positions[i] <= x:
            pos = i
            break
    
    for j in range(m):
        if x <= points[j]:
            total = querySums[1][j][pos]
            ans -= total
            ans += total * (points[j] - x) % MOD
            ans %= MOD

    print(ans)
","keys.append((1, i, 0))
                q = q * queryR[i][0] % MOD","prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD"
"import sys
input=sys.stdin.readline
R=lambda:map(int,input().split())
n,m=R();r,c,tr,tc=[0]*(n+1),[0]*(n+1),[0]*(n+1),[0]*(n+1)
def A(t,i,v):
  while i<=n:t[i]+=v;i+=i&(-i)
def Q(t,i):
  s=0
  while i:s+=t[i];i-=i&(-i)
  return s
for _ in range(m):
  v=[*R()];op,x,y=v[:3]
  if op==1:
    r[x]+=1;c[y]+=1
    if r[x]==1:A(tr,x,1)
    if c[y]==1:A(tc,y,1)
  elif op==2:
    r[x]-=1;c[y]-=1
    if r[x]==0:{{completion}}
    if c[y]==0:A(tc,y,-1)
  else:
    x1,y1=v[3:]
    print('Yes' if Q(tr,x1)-Q(tr,x-1)==x1-x+1 or Q(tc,y1)-Q(tc,y-1)==y1-y+1 else 'No')","A(tr,x,-1)","A(tc,y,-1)"
"import sys
input=sys.stdin.readline
R=lambda:map(int,input().split())
n,m=R();r,c,tr,tc=[0]*(n+1),[0]*(n+1),[0]*(n+1),[0]*(n+1)
def A(t,i,v):
  while i<=n:t[i]+=v;i+=i&(-i)
def Q(t,i):
  s=0
  while i:s+=t[i];i-=i&(-i)
  return s
for _ in range(m):
  v=[*R()];op,x,y=v[:3]
  if op==1:
    r[x]+=1;c[y]+=1
    if r[x]==1:A(tr,x,1)
    if c[y]==1:A(tc,y,1)
  elif op==2:
    r[x]-=1;c[y]-=1
    if r[x]==0:A(tr,x,-1)
    if c[y]==0:{{completion}}
  else:
    x1,y1=v[3:]
    print('Yes' if Q(tr,x1)-Q(tr,x-1)==x1-x+1 or Q(tc,y1)-Q(tc,y-1)==y1-y+1 else 'No')","A(tc,y,-1)","A(tr,x,-1)"
"class BIT:
  def __init__(self, n, element):
    self.num = n
    self.ele = element
    self.data = [self.ele] * (self.num + 1)
  
  def calc(self, x, y):
    return x + y
 
  def update(self, idx, x):
    while idx <= self.num:
      self.data[idx] = self.calc(self.data[idx], x)
      idx += idx & -idx
  
  def sum(self, idx):
    res = self.ele
    while idx > 0:
      res = self.calc(res, self.data[idx])
      idx -= idx & -idx
    return res
  
  def prod(self, l, r):
    return self.sum(r) - self.sum(l-1)

import sys
input = sys.stdin.readline
n, q = map(int, input().split())
cntb, cntv = [0] * n, [0] * n
bitb = BIT(n, 0)
bitv = BIT(n, 0)
for _ in range(q):
  query = list(map(int, input().split()))
  if query[0] == 1:
    x, y = query[1], query[2]
    if cntb[x-1] == 0:
      bitb.update(x, 1)
    cntb[x-1] += 1
    if cntv[y-1] == 0:
      bitv.update(y, 1)
    cntv[y-1] += 1
  elif query[0] == 2:
    x, y = query[1], query[2]
    cntb[x-1] -= 1
    cntv[y-1] -= 1
    if cntb[x-1] == 0:
      {{completion}}
    if cntv[y-1] == 0:
      bitv.update(y, -1)
  else:
    flg = bitb.prod(query[1], query[3]) == query[3] - query[1] + 1 or bitv.prod(query[2], query[4]) == query[4] - query[2] + 1
    print(""Yes"" if flg else ""No"")","bitb.update(x, -1)","bitv.update(y, -1)"
"class BIT:
  def __init__(self, n, element):
    self.num = n
    self.ele = element
    self.data = [self.ele] * (self.num + 1)
  
  def calc(self, x, y):
    return x + y
 
  def update(self, idx, x):
    while idx <= self.num:
      self.data[idx] = self.calc(self.data[idx], x)
      idx += idx & -idx
  
  def sum(self, idx):
    res = self.ele
    while idx > 0:
      res = self.calc(res, self.data[idx])
      idx -= idx & -idx
    return res
  
  def prod(self, l, r):
    return self.sum(r) - self.sum(l-1)

import sys
input = sys.stdin.readline
n, q = map(int, input().split())
cntb, cntv = [0] * n, [0] * n
bitb = BIT(n, 0)
bitv = BIT(n, 0)
for _ in range(q):
  query = list(map(int, input().split()))
  if query[0] == 1:
    x, y = query[1], query[2]
    if cntb[x-1] == 0:
      bitb.update(x, 1)
    cntb[x-1] += 1
    if cntv[y-1] == 0:
      bitv.update(y, 1)
    cntv[y-1] += 1
  elif query[0] == 2:
    x, y = query[1], query[2]
    cntb[x-1] -= 1
    cntv[y-1] -= 1
    if cntb[x-1] == 0:
      bitb.update(x, -1)
    if cntv[y-1] == 0:
      {{completion}}
  else:
    flg = bitb.prod(query[1], query[3]) == query[3] - query[1] + 1 or bitv.prod(query[2], query[4]) == query[4] - query[2] + 1
    print(""Yes"" if flg else ""No"")","bitv.update(y, -1)","bitb.update(x, -1)"
"import sys

def solve():
	inp = sys.stdin.readline
	n, q = map(int, inp().split())
	r = [0] * n
	c = [0] * n
	rc = [0] * n
	cc = [0] * n
	for i in range(q):
		ii = iter(map(int, inp().split()))
		t = next(ii)
		if t <= 2:
			x, y = ii
			vv = 1 if t == 1 else -1
			x -= 1
			w = int(rc[x] > 0)
			rc[x] += vv
			v = int(rc[x] > 0) - w
			while x < n:
				r[x] += v
				x = (x | (x + 1))
			x = y - 1
			w = int(cc[x] > 0)
			cc[x] += vv
			v = int(cc[x] > 0) - w
			while x < n:
				c[x] += v
				x = (x | (x + 1))
		else:
			x1, y1, x2, y2 = ii
			v = 0
			x = x2 - 1
			while x >= 0:
				v += r[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while x >= 0:
				v -= r[x]
				x = (x & (x + 1)) - 1
			if v == x2 - x1 + 1:
				print('Yes')
				continue
			v = 0
			x = y2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = y1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
				{{completion}}


def main():
	solve()


if __name__ == '__main__':
	main()
",print('No'),"v += r[x]
				x = (x & (x + 1)) - 1"
"import sys

def solve():
	inp = sys.stdin.readline
	n, q = map(int, inp().split())
	r = [0] * n
	c = [0] * n
	rc = [0] * n
	cc = [0] * n
	for i in range(q):
		ii = iter(map(int, inp().split()))
		t = next(ii)
		if t <= 2:
			x, y = ii
			vv = 1 if t == 1 else -1
			x -= 1
			w = int(rc[x] > 0)
			rc[x] += vv
			v = int(rc[x] > 0) - w
			while x < n:
				r[x] += v
				x = (x | (x + 1))
			x = y - 1
			w = int(cc[x] > 0)
			cc[x] += vv
			v = int(cc[x] > 0) - w
			while x < n:
				c[x] += v
				x = (x | (x + 1))
		else:
			x1, y1, x2, y2 = ii
			v = 0
			x = x2 - 1
			while x >= 0:
				{{completion}}
			x = x1 - 2
			while x >= 0:
				v -= r[x]
				x = (x & (x + 1)) - 1
			if v == x2 - x1 + 1:
				print('Yes')
				continue
			v = 0
			x = y2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = y1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
				print('No')


def main():
	solve()


if __name__ == '__main__':
	main()
","v += r[x]
				x = (x & (x + 1)) - 1","A(rc,x,1)"
"import math
from collections import defaultdict, deque, Counter
from sys import stdin
inf = int(1e18)
input = stdin.readline

#fenwick Tree
#D V ARAVIND

def add(ft, i, v):
    while i < len(ft):
        ft[i] += v
        i += i&(-i)

def get(ft, i):
    s = 0
    while (i > 0):
        s = s + ft[i]
        i = i - (i &(-i))
    return(s)



for _ in range (1):
    n,q = map(int, input().split())
    ftr = [0 for i in range (n+1)]
    ftc = [0 for i in range (n+1)]
    visr = [0 for i in range (n+1)]
    visc = [0 for i in range (n+1)]
    for _ in range (q):
        a = [int(i) for i in input().split()]
        if a[0] == 1:
            if visr[a[1]] == 0:
                add(ftr, a[1], 1)
            visr[a[1]] += 1
            if visc[a[2]] == 0:
                add(ftc, a[2], 1)
            visc[a[2]] += 1
        elif a[0] == 2:
            if visr[a[1]] == 1:
                add(ftr, a[1], -1)
            visr[a[1]] -= 1
            if visc[a[2]] == 1:
                add(ftc, a[2], -1)
            visc[a[2]] -= 1
        else:
            sr = get(ftr, a[3]) - get(ftr, a[1]-1)
            sc = get(ftc, a[4]) - get(ftc, a[2]-1)
            if (sr == a[3] - a[1] + 1) or (sc == a[4]-a[2]+1):
                print(""YES"")
            else:
                {{completion}}","print(""NO"")","                print(""NO"")


























































































































"
"import sys
def update(ind, val, tree, n):
    while ind <= n:
        tree[ind] += val
        ind += (ind & -ind)

def read(ind, tree):
    ans = 0
    while(ind > 0):
        ans += tree[ind]
        ind -= (ind & -ind)
    return ans

def query(l, r, tree):
    return read(r, tree) - read(l-1, tree)

n, q = map(int, sys.stdin.readline().split())
row = [0] * (n+1)
col = [0] * (n+1)
rtree = [0] * (n+1)
ctree = [0] * (n+1)
for i in range(q):
    inp = list(map(int, sys.stdin.readline().split()))
    t = inp[0]
    if t == 1:
        x = inp[1]
        y = inp[2]
        row[x] += 1
        col[y] += 1
        if row[x] == 1:
            update(x, 1, rtree, n)
        if col[y] == 1:
            update(y, 1, ctree, n)
    elif t == 2:
        x = inp[1]
        y = inp[2]
        row[x] -= 1
        col[y] -= 1
        if row[x] == 0:
            update(x, -1, rtree, n)
        if col[y] == 0:
            update(y, -1, ctree, n)
    else:
        x1 = inp[1]
        y1 = inp[2]
        x2 = inp[3]
        y2 = inp[4]
        flag1 = True
        flag2 = True;
        if query(x1, x2, rtree) < x2 - x1 + 1:
            flag1 = False
        if query(y1, y2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            {{completion}}","sys.stdout.write(""No\n"")",print('No')
"import sys
def update(ind, val, tree, n):
    while ind <= n:
        tree[ind] += val
        ind += (ind & -ind)

def read(ind, tree):
    ans = 0
    while(ind > 0):
        ans += tree[ind]
        ind -= (ind & -ind)
    return ans

def query(l, r, tree):
    return read(r, tree) - read(l-1, tree)

n, q = map(int, sys.stdin.readline().split())
row = [0] * (n+1)
col = [0] * (n+1)
rtree = [0] * (n+1)
ctree = [0] * (n+1)
for i in range(q):
    inp = list(map(int, sys.stdin.readline().split()))
    t = inp[0]
    if t == 1:
        x = inp[1]
        y = inp[2]
        row[x] += 1
        col[y] += 1
        if row[x] == 1:
            update(x, 1, rtree, n)
        if col[y] == 1:
            update(y, 1, ctree, n)
    elif t == 2:
        x = inp[1]
        y = inp[2]
        row[x] -= 1
        col[y] -= 1
        if row[x] == 0:
            {{completion}}
        if col[y] == 0:
            update(y, -1, ctree, n)
    else:
        x1 = inp[1]
        y1 = inp[2]
        x2 = inp[3]
        y2 = inp[4]
        flag1 = True
        flag2 = True;
        if query(x1, x2, rtree) < x2 - x1 + 1:
            flag1 = False
        if query(y1, y2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")","update(x, -1, rtree, n)","sys.stdout.write(""No\n"")"
"import sys
input = lambda: sys.stdin.readline().rstrip()

class SegTree:
	def __init__(self, n):
		self.size = n
		self.tree = [0]*(n*2)

	def update(self,p,v):
		self.tree[p+self.size] = v
		p+=self.size
 
		i = p
		while i>1:
			self.tree[i>>1] = self.tree[i] + self.tree[i^1]
			i>>=1
 
	def query(self,l,r):
		ans = 0
		l += self.size
		r += self.size
 
		while l<r:
			if 1&l:
				{{completion}}
			if r&1:
				r-=1
				ans += self.tree[r]
 
			l>>=1
			r>>=1
		return ans

N,Q = map(int, input().split())

sr,sc = SegTree(N),SegTree(N)
R,C = [0]*N,[0]*N
for _ in range(Q):
	t = list(map(int, input().split()))
	if t[0]==1:
		if R[t[1]-1]==0:
			sr.update(t[1]-1, 1)
		R[t[1]-1] += 1

		if C[t[2]-1]==0:
			sc.update(t[2]-1, 1)
		C[t[2]-1] += 1
	elif t[0]==2:
		if R[t[1]-1]==1:
			sr.update(t[1]-1, 0)
		R[t[1]-1] -= 1

		if C[t[2]-1]==1:
			sc.update(t[2]-1, 0)
		C[t[2]-1] -= 1
	else:
		x1,y1,x2,y2 = t[1]-1,t[2]-1,t[3]-1,t[4]-1
		cnt = sr.query(x1,x2+1)
		#print(x1,x2,cnt)
		if cnt==x2-x1+1:
			print('Yes')
			continue

		cnt = sc.query(y1,y2+1)
		if cnt==y2-y1+1:
			print('Yes')
		else:
			print('No')

","ans += self.tree[l]
				l+=1",ans += self.tree[r]
"import sys
input = lambda: sys.stdin.readline().rstrip()

class SegTree:
	def __init__(self, n):
		self.size = n
		self.tree = [0]*(n*2)

	def update(self,p,v):
		self.tree[p+self.size] = v
		p+=self.size
 
		i = p
		while i>1:
			self.tree[i>>1] = self.tree[i] + self.tree[i^1]
			i>>=1
 
	def query(self,l,r):
		ans = 0
		l += self.size
		r += self.size
 
		while l<r:
			if 1&l:
				ans += self.tree[l]
				l+=1
			if r&1:
				{{completion}}
 
			l>>=1
			r>>=1
		return ans

N,Q = map(int, input().split())

sr,sc = SegTree(N),SegTree(N)
R,C = [0]*N,[0]*N
for _ in range(Q):
	t = list(map(int, input().split()))
	if t[0]==1:
		if R[t[1]-1]==0:
			sr.update(t[1]-1, 1)
		R[t[1]-1] += 1

		if C[t[2]-1]==0:
			sc.update(t[2]-1, 1)
		C[t[2]-1] += 1
	elif t[0]==2:
		if R[t[1]-1]==1:
			sr.update(t[1]-1, 0)
		R[t[1]-1] -= 1

		if C[t[2]-1]==1:
			sc.update(t[2]-1, 0)
		C[t[2]-1] -= 1
	else:
		x1,y1,x2,y2 = t[1]-1,t[2]-1,t[3]-1,t[4]-1
		cnt = sr.query(x1,x2+1)
		#print(x1,x2,cnt)
		if cnt==x2-x1+1:
			print('Yes')
			continue

		cnt = sc.query(y1,y2+1)
		if cnt==y2-y1+1:
			print('Yes')
		else:
			print('No')

","r-=1
				ans += self.tree[r]",ans += self.tree[r]
"import bisect
import collections
import heapq
import io
import math
import os
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
Mod = 1000000007

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

# for _ in range(int(_input())):
for _ in range(1):
    n, q = map(int, _input().split())
    a = [0] * (n + 1)
    b = [0] * (n + 1)
    x = [0] * (n + 1)
    y = [0] * (n + 1)
    for _ in range(q):
        o = list(map(int, _input().split()))
        if o[0] == 1:
            _, u, v = o
            a[u] += 1
            if a[u] == 1:
                while u <= n:
                    x[u] += 1
                    u += u & -u
            b[v] += 1
            if b[v] == 1:
                while v <= n:
                    y[v] += 1
                    v += v & -v
        elif o[0] == 2:
            _, u, v = o
            a[u] -= 1
            if a[u] == 0:
                while u <= n:
                    {{completion}}
            b[v] -= 1
            if b[v] == 0:
                while v <= n:
                    y[v] -= 1
                    v += v & -v
        else:
            _, u1, v1, u2, v2 = o
            c = 0
            u = u2
            while u > 0:
                c += x[u]
                u -= u & -u
            u = u1 - 1
            while u > 0:
                c -= x[u]
                u -= u & -u
            d = 0
            v = v2
            while v > 0:
                d += y[v]
                v -= v & -v
            v = v1 - 1
            while v > 0:
                d -= y[v]
                v -= v & -v
            print('Yes' if c >= u2 - u1 + 1 or d >= v2 - v1 + 1 else 'No')","x[u] -= 1
                    u += u & -u","b[v] -= 1
            if b[v] == 0:
                while v <= n:
                    y[v] -= 1
                    v += v & -v"
"import bisect
import collections
import heapq
import io
import math
import os
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
Mod = 1000000007

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

# for _ in range(int(_input())):
for _ in range(1):
    n, q = map(int, _input().split())
    a = [0] * (n + 1)
    b = [0] * (n + 1)
    x = [0] * (n + 1)
    y = [0] * (n + 1)
    for _ in range(q):
        o = list(map(int, _input().split()))
        if o[0] == 1:
            _, u, v = o
            a[u] += 1
            if a[u] == 1:
                while u <= n:
                    x[u] += 1
                    u += u & -u
            b[v] += 1
            if b[v] == 1:
                while v <= n:
                    y[v] += 1
                    v += v & -v
        elif o[0] == 2:
            _, u, v = o
            a[u] -= 1
            if a[u] == 0:
                while u <= n:
                    x[u] -= 1
                    u += u & -u
            b[v] -= 1
            if b[v] == 0:
                while v <= n:
                    {{completion}}
        else:
            _, u1, v1, u2, v2 = o
            c = 0
            u = u2
            while u > 0:
                c += x[u]
                u -= u & -u
            u = u1 - 1
            while u > 0:
                c -= x[u]
                u -= u & -u
            d = 0
            v = v2
            while v > 0:
                d += y[v]
                v -= v & -v
            v = v1 - 1
            while v > 0:
                d -= y[v]
                v -= v & -v
            print('Yes' if c >= u2 - u1 + 1 or d >= v2 - v1 + 1 else 'No')","y[v] -= 1
                    v += v & -v","y[v] -= 1
                    v += v & -v"
"f = open(0)
def R(): return map(int, next(f).split())


n, q = R()
d = {}
i = v = r = 0
for x in R():
    r += x
    i += 1
    d[i] = x
while q:
    q -= 1
    t, *x = R()
    if t & 1:
        i, x = x
        r += x - d.get(i, v)
        d[i] = x
    else:
        {{completion}}
    print(r)
","d = {}
        v, = x
        r = v * n","r += x - d[i]
        d[i] = x
    else:
        r = n * x
        d = {i: x for i in range(1, n + 1)}"
"inp = [list(map(int, l.split())) for l in open(0).read().splitlines()]
n, q = inp[0]
a = inp[1]
last = 0
step = [-1] * n
laststep = -2
tot = sum(a)
 
for i, b in enumerate(inp[2:]):
    if b[0] == 1:
        if step[b[1]-1] > laststep:
            tot += b[2] - a[b[1]-1] 
            a[b[1]-1] = b[2]
        else:
            {{completion}}
        step[b[1]-1] = i
        print(tot)
    else:
        tot = b[1] * n
        last = b[1]
        laststep = i
        print(tot)","tot += b[2] - last
            a[b[1]-1] = b[2]","this is the start of the ground truth
step = [-1] * n
        laststep = -2
        tot = sum(a)
 
        for i, b in enumerate(inp[2:]):
            if b[0] == 1:
                if step[b[1]-1] > laststep:
                    tot += b[2] - a[b[1]-1] 
                    a[b[1]-1] = b[2]
                else:
                    tot +="
"def inpList():
    return [int(i) for i in input().split()]

def solve():
    n, q = inpList()
    a = inpList()

    t1 = {}
    t2 = 0 
    sm = sum(a)

    for qi in range(q):
        inp = inpList() 
        if len(inp) == 3: 
            _, i, x = inp 
            if t1.get(i):
                sm += x - t1[i] 
            else:
                {{completion}}
            t1[i] = x 
        else:
            _, x = inp
            t2 = x
            sm = t2*n
            t1 = {}
        print(sm)
        
solve()
",sm += x - (t2 or a[i-1]),"t1[i] = x
            t2 = x
            sm = t2*n
            t1 = {}
        else:
            _, x = inp
            sm = n*x
            print(sm)
            t1 = {}"
"from collections import defaultdict
import sys
input = sys.stdin.readline
n, q = map(int, input().split())
t = dict(enumerate(map(int, input().split())))
ans = sum(t.values())
for i in range(q):
    p = list(map(int, input().split()))
    if p[0] == 2:
        k = p[1]
        ans = n*p[1]
        t = defaultdict(lambda:k)
    else :
        {{completion}}
    print(ans)","ans += p[2] - t[p[1] - 1]
        t[p[1] - 1] = p[2]","t[p[1]-1] = p[2]
    ans = sum(t.values())"
"n,q = map(int, input().split(' '))
array = list(map(int, input().split(' ')))
d = {i:item for i,item in enumerate(array, start=1)}
tot = sum(array)
default = None
for _ in range(q):
    t, *a = map(int, input().split(' '))
    if t==1:
        i, x = a
        tot += (x-d.get(i, default))
        d[i] = x
    elif t==2:
        {{completion}}
    print(tot)
","default, = a
        tot = default*n
        d = {}","default = None
        x, = a
        tot = n*x"
"f=open(0)
s=lambda:map(int,next(f).split())
n,tst=s()
arr={}
i=g=ans=0
for x in s():ans+=x;i+=1;arr[i]=x
while tst:
    tst-=1;t,*x=s()
    if t&1:i,x=x;ans+=x-arr.get(i,g);arr[i]=x
    else:{{completion}}
    print(ans)
  ","arr={};g,=x;ans=g*n","ans=ans-x+x
    arr[i]=g+1"
"n, q = list(map(int, input().split()))

a = list(map(int, input().split()))
x, c, s, b = 0, 0, sum(a), [1]*(n)

for i in range(q):
    k = list(map(int, input().split()))
    if k[0]==1:
        j = k[1]-1
        if b[j]>c:
            s = s-a[j]+k[2]
        else:
            {{completion}}
        a[j] = k[2]
        print(s)
    else:
        c = c+1
        x = k[1]
        s = n*x
        print(s)
            
    
        ","s = s-x+k[2]
            b[j] = c+1","s = n*x
        b = [x]*(n)"
"f=open(0)        

n,q=map(int,next(f).split())
a = list(map(int,next(f).split()))
c = [-1]*n
X = 0
S = sum(a)
lst=-2

for idx in range(q):
    req = list(map(int,next(f).split()))

    if (req[0] == 1):
        i = req[1]-1
        x = req[2]
        current = X if c[i]<lst else a[i]
        S += x - current
        a[i] = x
        c[i] = idx

    else:
        {{completion}}

    print(S)




                

            

            
            
            
            
                
        
        
        

","X = req[1]
        S = X * n
        lst = idx","lst = idx
        X = x
        S = n*x"
"import sys, math
input = sys.stdin.readline

n, q = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
d = {}
for i in range(n):
    d[i + 1] = a[i]   
type2 = 0
for i in range(q):
    t = [int(x) for x in input().split()]
    if t[0] == 1:
        d[t[1]] = t[2]
    else:
        {{completion}}
    print(type2*(n - len(d)) + sum(d.values()))","d.clear()
        type2 = t[1]",type2 += 1
"import sys

input = sys.stdin.readline


def solve():
    n, m, k = map(int, input().split())
    arr = list(map(int, input().split()))
    graph = [[] for _ in range(n)]
    for i in range(m):
        u, v = map(int, input().split())
        graph[u-1].append(v-1)

    lo, hi = min(arr), max(arr)+1
    while lo < hi:
        mid = lo + (hi-lo)//2
        dp = [0]*n
        degree = [0]*n
        cnt = 0
        for i in range(n):
            if arr[i] > mid:
                continue
            cnt += 1
            for nei in graph[i]:
                if arr[nei] > mid:
                    {{completion}}
                degree[nei] += 1

        stack = []
        nums = 0
        for i in range(n):
            if degree[i] == 0 and arr[i] <= mid:
                stack.append(i)
                nums += 1

        while stack:
            curr = stack.pop()
            for nei in graph[curr]:
                if arr[nei] > mid:
                    continue
                degree[nei] -= 1
                if degree[nei] == 0:
                    stack.append(nei)
                    dp[nei] = max(dp[nei], dp[curr] + 1)
                    nums += 1

        if nums != cnt or max(dp) >= k-1:
            hi = mid
        else:
            lo = mid + 1

    if lo == max(arr) + 1:
        return -1
    else:
        return lo


print(solve())",continue,continue
"import sys

input = sys.stdin.readline


def solve():
    n, m, k = map(int, input().split())
    arr = list(map(int, input().split()))
    graph = [[] for _ in range(n)]
    for i in range(m):
        u, v = map(int, input().split())
        graph[u-1].append(v-1)

    lo, hi = min(arr), max(arr)+1
    while lo < hi:
        mid = lo + (hi-lo)//2
        dp = [0]*n
        degree = [0]*n
        cnt = 0
        for i in range(n):
            if arr[i] > mid:
                continue
            cnt += 1
            for nei in graph[i]:
                if arr[nei] > mid:
                    continue
                degree[nei] += 1

        stack = []
        nums = 0
        for i in range(n):
            if degree[i] == 0 and arr[i] <= mid:
                stack.append(i)
                nums += 1

        while stack:
            curr = stack.pop()
            for nei in graph[curr]:
                if arr[nei] > mid:
                    {{completion}}
                degree[nei] -= 1
                if degree[nei] == 0:
                    stack.append(nei)
                    dp[nei] = max(dp[nei], dp[curr] + 1)
                    nums += 1

        if nums != cnt or max(dp) >= k-1:
            hi = mid
        else:
            lo = mid + 1

    if lo == max(arr) + 1:
        return -1
    else:
        return lo


print(solve())",continue,continue
"import sys
from array import array
from collections import deque

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
debug = lambda *x: print(*x, file=sys.stderr)
out = array('i')


class graph:
    def __init__(self, n):
        self.n = n
        self.gdict = [array('i') for _ in range(n + 1)]
        self.deg = array('i', [0] * (n + 1))

    def add_uniedge(self, node1, node2):
        self.gdict[node1].append(node2)
        self.deg[node2] += 1

    def kahn(self):
        # enqueue all node with 0 in degree
        que, cnt = deque([(i, 0) for i in range(1, self.n + 1) if not self.deg[i]]), 0
        ret = 0

        while que:
            s, lev = que.popleft()
            ret = max(ret, lev)

            for i in self.gdict[s]:
                self.deg[i] -= 1
                if a[i] <= md and not self.deg[i]:
                    {{completion}}

            cnt += 1
        return cnt != valids or ret >= k - 1


n, m, k = inp(int)
a = array('i', [0] + inp(int))
g = graph(n)

for i in range(m):
    u, v = inp(int)
    g.add_uniedge(u, v)

be, en, ans = min(a[1:]), 10 ** 9, -1
orgdeg = g.deg[:]

while be <= en:
    md, valids = (be + en) >> 1, n
    for i in range(1, n + 1):
        if a[i] > md:
            valids -= 1
            g.deg[i] = 10 ** 6

            for j in g.gdict[i]:
                g.deg[j] -= 1

    if g.kahn():
        en, ans = md - 1, md
    else:
        be = md + 1

    g.deg = orgdeg[:]

print(ans)
","que.append((i, lev + 1))",continue
"from sys import stdin, stdout


n, m, k = [int(x) for x in stdin.readline().split()]
a = [int(x) for x in stdin.readline().split()]
edges = {i:[] for i in range(n)}
for bar in range(m):
    u, v = [int(x)-1 for x in stdin.readline().split()]
    edges[u].append(v)

a_copy = list(set(a))
a_copy.sort()

def check(bound):
    heights = [0]*n
    expanded = [0]*n
    parents = [-1]*n
    for root in range(n):
        if a[root] <= bound and heights[root] == 0:
            stack = [root]

            while len(stack) > 0:
                if heights[stack[-1]] > 0:
                    v = stack.pop()
                    expanded[v] = 2
                    if parents[v] != -1:
                        heights[parents[v]] = max(heights[parents[v]], 1 + heights[v])
                        if heights[parents[v]] >= k:
                            return True
                else:
                    v = stack[-1]
                    heights[v] = 1
                    if heights[v] >= k:
                        return True
                    expanded[v] = 1
                    for w in edges[v]:
                        if a[w] <= bound:
                            if expanded[w] == 1:
                                return True

                            if heights[w] > 0:
                                heights[v] = max(heights[v], 1 + heights[w])
                                if heights[v] >= k:
                                    {{completion}}

                            else:
                                parents[w] = v
                                stack.append(w)

    return False

if not check(a_copy[-1]):
    stdout.write('-1\n')

else:
    upper = len(a_copy)-1
    lower = -1
    while upper - lower > 1:
        candidate = (upper+lower)//2
        if check(a_copy[candidate]):
            upper = candidate
        else:
            lower = candidate

    stdout.write(str(a_copy[upper])+'\n')
",return True,continue
"import sys
input = sys.stdin.readline
n, m, k = list(map(int,input().split()))
arr = list(map(int,input().split()))

adj = [list() for _ in range(n)]
for i in range(m):
    u, v = list(map(int,input().split()))
    adj[u-1].append(v-1)
    
def dfs(u, vis, val, dist, group):
    
    vis[u] = True
    group[u] = 1
    for v in adj[u]:
        if arr[v] <= val :
            if group[v]:
                dist[u] = 10**18
                return True
            if not vis[v]:
                dfs(v, vis, val, dist, group)
                group[v] = 0
            dist[u] = max(dist[u], dist[v] + 1)
        if dist[u] >= k :
            return True
                

def ok(val):
    if k == 1:return True
    vis = [False] * n
    dist = [1] * n
    group = [0] * n
    for i in range(n):
        if arr[i] <= val and not vis[i]:
            stk = [i]
            while stk:
                u = stk.pop()
                if vis[u]:
                    for v in adj[u]:
                        if arr[v] <= val :
                            dist[u] = max(dist[u], dist[v] + 1)
                            if dist[u] >= k :
                                {{completion}}
                            group[v] = 0
                    group[u] = 0
                    continue
                stk.append(u)
                group[u] = 1
                vis[u] = True
                for v in adj[u]:
                    if group[v]:
                        return True
                    if arr[v] <= val :
                        if not vis[v]:
                            stk.append(v)
            group[i] = 0
    return False
            


sor = sorted(arr)
l = 0
r = n - 1
while l <= r :
    mid = (l + r) // 2
    if ok(sor[mid]):
        r = mid - 1
    else:
        l = mid + 1
if l == n:
    print(-1)
else:
    print(sor[l]) ",return True,stk.append(v)
"import sys
input = sys.stdin.readline
n, m, k = list(map(int,input().split()))
arr = list(map(int,input().split()))

adj = [list() for _ in range(n)]
for i in range(m):
    u, v = list(map(int,input().split()))
    adj[u-1].append(v-1)
    
def dfs(u, vis, val, dist, group):
    
    vis[u] = True
    group[u] = 1
    for v in adj[u]:
        if arr[v] <= val :
            if group[v]:
                dist[u] = 10**18
                return True
            if not vis[v]:
                dfs(v, vis, val, dist, group)
                group[v] = 0
            dist[u] = max(dist[u], dist[v] + 1)
        if dist[u] >= k :
            return True
                

def ok(val):
    if k == 1:return True
    vis = [False] * n
    dist = [1] * n
    group = [0] * n
    for i in range(n):
        if arr[i] <= val and not vis[i]:
            stk = [i]
            while stk:
                u = stk.pop()
                if vis[u]:
                    for v in adj[u]:
                        if arr[v] <= val :
                            dist[u] = max(dist[u], dist[v] + 1)
                            if dist[u] >= k :
                                return True
                            group[v] = 0
                    group[u] = 0
                    continue
                stk.append(u)
                group[u] = 1
                vis[u] = True
                for v in adj[u]:
                    if group[v]:
                        return True
                    if arr[v] <= val :
                        if not vis[v]:
                            {{completion}}
            group[i] = 0
    return False
            


sor = sorted(arr)
l = 0
r = n - 1
while l <= r :
    mid = (l + r) // 2
    if ok(sor[mid]):
        r = mid - 1
    else:
        l = mid + 1
if l == n:
    print(-1)
else:
    print(sor[l]) ",stk.append(v),return True
"test = int(input())

for i in range(test):
    ans = ""B""
    cnt =0
    while cnt < 8 :
        t = input()
        if t.strip() != '':
            cnt +=1
            if t == ""RRRRRRRR"":
                {{completion}}

    print(ans)            
    

    
        
    
    
    ","ans = ""R""","this is the start of the ground truth
ans = ""B""
cnt =0
while cnt < 8 :
    t = input()
    if t.strip()!= '':
        cnt +=1
        if t == ""RRRRRRRR"":
            ans = ""R""
            break

print(ans)            
    

    
        
    
    
    
    
    
    
    
    
    
   "
"t=int(input())
for p in range(t):
    
    l=[]
    c=0
    a=['R','R','R','R','R','R','R','R']
    while(len(l)<8):
        s=input()
        if len(s)==8:
            {{completion}}
    for i in range(8):
        if l[i]==a:
            c=1
            break
    print(""B"" if c!=1 else ""R"")",l.append([*s]),"c=1
            break"
"t=int(input())
for p in range(t):
    
    l=[]
    c=0
    a=['R','R','R','R','R','R','R','R']
    while(len(l)<8):
        s=input()
        if len(s)==8:
            l.append([*s])
    for i in range(8):
        if l[i]==a:
            {{completion}}
    print(""B"" if c!=1 else ""R"")","c=1
            break",l.append([*s])
"for _ in range(int(input())):
    l=[]
    ans=""B""
    while len(l)!=8:
        l.append(input())
        if len(l[-1])<8:
            {{completion}}

    for row in l:
        if row.count('R')==8:
            ans='R'
            break

    print(ans)
        
    ",l.pop(),"ans='R'
            break"
"for _ in range(int(input())):
    l=[]
    ans=""B""
    while len(l)!=8:
        l.append(input())
        if len(l[-1])<8:
            l.pop()

    for row in l:
        if row.count('R')==8:
            {{completion}}

    print(ans)
        
    ","ans='R'
            break",l.pop()
"from sys import stdin
n = int(input())
lines = stdin.read().split()
a = 0
for ele in range(n):
    for i in range(8):
        if lines[i+a].count('R') == 8:
            {{completion}}
    else:
        print('B')
    a+=8","print('R')
            break","print('R')
            break"
"for _ in range(int(input())):
    met = []
    res = []
    judge = True
    i = 0
    while i <  8:
        tmp = input()
        met.append(tmp)
        if tmp != '':
            {{completion}}
        if tmp == ""R"" * 8 and judge:
            print(""R"")
            judge = False

    if judge:
        print(""B"")
#    for i in met:
#        print(i)",i += 1,"print(""R"")
            judge = False"
"for _ in range(int(input())):
    met = []
    res = []
    judge = True
    i = 0
    while i <  8:
        tmp = input()
        met.append(tmp)
        if tmp != '':
            i += 1
        if tmp == ""R"" * 8 and judge:
            {{completion}}

    if judge:
        print(""B"")
#    for i in met:
#        print(i)","print(""R"")
            judge = False",i += 1
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    while(j<8) :
        a = input()
        if(a != '') :
            b.append(a)
            j += 1
    key = 0
    for j in range(8) :
        ok = True
        for k in range(8) :
            if(b[j][k] != 'R') :
                {{completion}}
        if(ok) :
            key = 1
            print(""R"")
            break
    if(not key) :
        print(""B"")
                
    
        
",ok = False,"this is the start of the ground truth
ok = True
        for k in range(8) :
            if(b[j][k]!= 'R') :
                ok = False
                break
        if(ok) :
            key = 1
            print(""R"")
            break
    if(not key) :
        print(""B"")
                
    
        
Replace the ""# TODO: Your code here"" in the code above with the appropriate block. Provide only the replaced block.
this"
"from sys import stdin

t = int(input())

lines = stdin.read().split()
j = 0
for num in range(t):
    for i in range(8):
        if lines[i + j].count('R') == 8:
            {{completion}}
    else:
        print('B')
    j += 8","print('R')
            break","print('R')
            break"
"t = int(input())

for _ in range(t):
     count = 0
     grid = []
     while count < 8:
        n = input()
        if len(n) != 0:
            count+=1
            grid.append(n)
     ans = False
     for i in range(8):
        x = False
        for j in range(8):
            if grid[i][j]!='R':
                {{completion}}
        if not x:
            print('R')
            ans = True
            break
     if not ans:
        print('B')


",x = True,"ans=False
            print('R')
            ans=True
            break
     if not ans:
        print('B')"
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    key = '.'
    while(j<8) :
        a = input()
        if(a != '') :
            {{completion}}
    for j in range(8) :
        if(len(set(b[j])) == 1 and b[j][0] == 'R') :
           key = 'R'
           break
    if(key!= 'R') :
        key = 'B'
    print(key)
","b.append(a)
            j += 1","key = 'R'
           break"
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    key = '.'
    while(j<8) :
        a = input()
        if(a != '') :
            b.append(a)
            j += 1
    for j in range(8) :
        if(len(set(b[j])) == 1 and b[j][0] == 'R') :
           {{completion}}
    if(key!= 'R') :
        key = 'B'
    print(key)
","key = 'R'
           break",key = 'R'
"import sys

inp = sys.stdin.read().split()[::-1]
out = []

def compress(s):
    lst = None
    ret = []
    for c in s:
        if lst != c:
            {{completion}}        
        ret[-1] += 1
    return ret

def transform(lns):
    st = []
    s = 0
    for l in lns:
        st.append(s)
        s += l
    return st

def tc(n, txt, patt):
    if txt == patt: 
        out.append(0)
        return
    if txt[0] != patt[0] or txt[-1] != patt[-1]:
        out.append(-1)
        return
    A = compress(txt)
    B = compress(patt)
    if len(A) != len(B): 
        out.append(-1)
        return
    A = transform(A)
    B = transform(B)
    ans = 0
    for a, b in zip(A, B):
        ans += abs(a - b)
    out.append(ans)

for _ in range(int(inp.pop())):
    n = int(inp.pop())
    txt = inp.pop()
    patt = inp.pop()
    tc(n, txt, patt)

print('\n'.join(map(str, out)))","ret.append(0)
            lst = c",ans += abs(a - b)
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD
    WORD_MASK = -1
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        
    def flip_range(self, l, r):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = BitSet.WORD_MASK << (l % BitSet.BITS_PER_WORD)
        rem = (r+1) % BitSet.BITS_PER_WORD
        lastWordMask = BitSet.WORD_MASK if rem == 0 else ~(BitSet.WORD_MASK << rem)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.WORD_MASK
            self.words[endWordIndex] ^= lastWordMask

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.BITS_PER_WORD))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return self.words[wordIndex] & (1 << (bitIndex % BitSet.BITS_PER_WORD)) != 0

    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if word != 0:
                return wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = self.words[wordIndex]

    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if word != 0:
                index = wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
                return index if index < self.sz else - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = ~self.words[wordIndex]
            
    def lastSetBit(self):
        wordIndex = len(self.words) - 1
        word = self.words[wordIndex]

        while wordIndex >= 0:
            if word != 0:
                return wordIndex * BitSet.BITS_PER_WORD + (word.bit_length() - 1 if word > 0 else  BitSet.BITS_PER_WORD - 1)
            wordIndex -= 1
            word = self.words[wordIndex]
        return -1
            
    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != -1:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != -1:
                    res += [1] * (j-i)
                    st = j
                else:
                    {{completion}}
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz


def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val))

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val))

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.lastSetBit())
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()","res += [1] * (self.sz - i)
                    break","res += [1] * (j-i)
                    st = j"
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD
    WORD_MASK = -1
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        
    def flip_range(self, l, r):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = BitSet.WORD_MASK << (l % BitSet.BITS_PER_WORD)
        rem = (r+1) % BitSet.BITS_PER_WORD
        lastWordMask = BitSet.WORD_MASK if rem == 0 else ~(BitSet.WORD_MASK << rem)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.WORD_MASK
            self.words[endWordIndex] ^= lastWordMask

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.BITS_PER_WORD))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return self.words[wordIndex] & (1 << (bitIndex % BitSet.BITS_PER_WORD)) != 0

    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if word != 0:
                return wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = self.words[wordIndex]

    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if word != 0:
                index = wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
                return index if index < self.sz else - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = ~self.words[wordIndex]
            
    def lastSetBit(self):
        wordIndex = len(self.words) - 1
        word = self.words[wordIndex]

        while wordIndex >= 0:
            if word != 0:
                return wordIndex * BitSet.BITS_PER_WORD + (word.bit_length() - 1 if word > 0 else  BitSet.BITS_PER_WORD - 1)
            wordIndex -= 1
            word = self.words[wordIndex]
        return -1
            
    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != -1:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != -1:
                    {{completion}}
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz


def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val))

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val))

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.lastSetBit())
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()","res += [1] * (j-i)
                    st = j","res += [1] * (j-i)
                    st = j"
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 1 << ADDRESS_BITS_PER_WORD
    MASK = -0x1
    MASK_MAX = 0x7fffffffffffffff
    MASK_MIN = ~MASK_MAX

    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_one_left(self, shift):
        if shift == BitSet.WORD_SZ - 1:
            return BitSet.MASK_MIN
        return 1 << (shift % BitSet.WORD_SZ)

    def _shift_mask_right(self, shift):
        if shift == 0:
            return BitSet.MASK
        return BitSet.MASK_MAX >> (shift - 1)
    
    def _shift_mask_left(self, shift):
        if shift == 0:
            return BitSet.MASK
        return ~(BitSet.MASK_MAX >> (BitSet.WORD_SZ - shift - 1))

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~self._shift_one_left(bitIndex % BitSet.WORD_SZ)
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex]
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)
        
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = ~self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex]

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    res += [1] * (j-i)
                    st = j
                else:
                    {{completion}}
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()","res += [1] * (self.sz - i)
                    break","res += [1] * (self.sz - i)
                    break"
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 1 << ADDRESS_BITS_PER_WORD
    MASK = -0x1
    MASK_MAX = 0x7fffffffffffffff
    MASK_MIN = ~MASK_MAX

    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_one_left(self, shift):
        if shift == BitSet.WORD_SZ - 1:
            return BitSet.MASK_MIN
        return 1 << (shift % BitSet.WORD_SZ)

    def _shift_mask_right(self, shift):
        if shift == 0:
            return BitSet.MASK
        return BitSet.MASK_MAX >> (shift - 1)
    
    def _shift_mask_left(self, shift):
        if shift == 0:
            return BitSet.MASK
        return ~(BitSet.MASK_MAX >> (BitSet.WORD_SZ - shift - 1))

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~self._shift_one_left(bitIndex % BitSet.WORD_SZ)
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex]
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)
        
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = ~self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex]

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    {{completion}}
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()","res += [1] * (j-i)
                    st = j","res += [1] * (j-i)
                    st = j"
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 60#1 << ADDRESS_BITS_PER_WORD
    MASK = 0xfffffffffffffff
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex // BitSet.WORD_SZ #>> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_mask_right(self, shift):
        return BitSet.MASK >> shift
    
    def _shift_mask_left(self, shift):
        return (BitSet.MASK >> shift) << shift

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.WORD_SZ))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex] & BitSet.MASK
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)
            
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex] & BitSet.MASK

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    res += [1] * (j-i)
                    st = j
                else:
                    {{completion}}
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()","res += [1] * (self.sz - i)
                    break","res += [1] * (j-i)
                    st = j"
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 60#1 << ADDRESS_BITS_PER_WORD
    MASK = 0xfffffffffffffff
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex // BitSet.WORD_SZ #>> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_mask_right(self, shift):
        return BitSet.MASK >> shift
    
    def _shift_mask_left(self, shift):
        return (BitSet.MASK >> shift) << shift

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.WORD_SZ))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex] & BitSet.MASK
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)
            
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex] & BitSet.MASK

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    {{completion}}
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()","res += [1] * (j-i)
                    st = j","res += [1] * (j-i)
                    st = j"
"import sys
ctr = [0, 0, 0]
cnt = [0]

while cnt[-1] < 10**9:
	i = ctr.index(min(ctr))
	cnt.append(cnt[-1] + 2*(sum(ctr) - ctr[i]))
	ctr[i] += 1


def solve(sn):
	t = int(sn)
	s, e = 0, len(cnt) - 1
	while s < e:
		m = (s + e) >> 1
		if cnt[m] >= t:
			e = m
		else:
			{{completion}}
	return str(s)

inp = sys.stdin.read().split()
inp.pop(0)

print('\n'.join(map(solve, inp)))",s = m + 1,s = m + 1
"import sys
ctr = [0, 0, 0]
cnt = [0]

i = 0
tot = 0
s = 0
while tot < 10**9:
    tot += 2*(s - ctr[i])
    cnt.append(tot)
    ctr[i] += 1
    s += 1
    i += 1
    if i == 3: i = 0

def solve(sn):
	t = int(sn)
	s, e = 0, len(cnt) - 1
	while s < e:
		m = (s + e) >> 1
		if cnt[m] >= t:
			e = m
		else:
			{{completion}}
	return str(s)

inp = sys.stdin.read().split()
inp.pop(0)

print('\n'.join(map(solve, inp)))",s = m + 1,s = m + 1
"""""""
in each circle, there's two options
""""""
import sys;input=sys.stdin.readline
I=lambda:int(input())
A=lambda:[*map(int,input().split())]

mod=10**9+7
for _ in range(I()):
  n=I()
  a,b,c=A(),A(),A()
  
  g={a[i]:[b[i],c[i]] for i in range(n)}
  cycles,visi=0,[False]*(n+1)
  for u in range(1,n+1):
    need=True;cycle_size=0
    while not visi[g[u][0]]:
      if g[u][1]!=0:{{completion}}
      #mark visited and move to next vertex
      visi[g[u][0]],u=True,g[u][0]
      cycle_size+=1
    if need and cycle_size>1:cycles+=1
  print(pow(2,cycles,mod))",need=False,ass = True
"# read interger t from input.txt and then read t lines
import sys

DEBUG = False

def check(a, b, c):
    a = [0] + a
    b = [0] + b
    c = [0] + c
    m_ = [0] * len(a)
    m = [0] * len(a)
    for i in range(1, len(b)):
        m_[b[i]] = i
    for i in range(1, len(a)):
        m[i] = m_[a[i]]
    # print("">>>"", a)
    # print("">>>"", b)
    # print("">>>"", m)
    # find cicles in permutations
    total_num = 1
    used = [False] * len(m)
    # print(a, b, c)
    for i in range(1, len(m)):
        if not used[i]:
            j = i
            c_zeros = True
            while not used[j]:
                if c[j] != 0:
                    {{completion}}
                used[j] = True
                j = m[j]
            used[i] = True
            # print(i, m[i], a[i], b[i], c[i])
            if c_zeros and m[i] != i:
                # print("">>"", i)
                total_num = (total_num) * 2 % 1000000007
    print(total_num)


def main(f):
    t = int(f.readline())
    for i in range(t):
        n = int(f.readline())
        a = list(map(int, f.readline().split()))
        b = list(map(int, f.readline().split()))
        c = list(map(int, f.readline().split()))

        check(a, b, c)

if DEBUG:
    f = open('input.txt', 'r')
else:
    f = sys.stdin

main(f)

f.close()  
",c_zeros = False,c_zeros=False
"
import sys
t = int(sys.stdin.readline())
for _ in range(t):
    n = int(sys.stdin.readline())
    a = list(map(int,sys.stdin.readline().split()))
    b = list(map(int,sys.stdin.readline().split()))
    c = list(map(int,sys.stdin.readline().split()))
    count = 0
    L = [0] * (n+1)
    for i in range(0,n):
        L[a[i]] = b[i]
    status = 1
    for i in range(n):
        if c[i] != 0:
            L[a[i]] = 0
            L[b[i]] = 0
    for i in range(1,n+1):
        key = i
        xstatus = 1
        status = 1
        xcount= 0
        while status == 1:
            if L[key] == 0:
                status = 0
            if L[key] == i:
                if xcount >= 1:
                    {{completion}}
                status = 0
            xcount += 1
            x = L[key]
            L[key] = 0
            key = x
    print((2 **count) % (10 ** 9 + 7)) ",count += 1,xcount=0
"import sys

input = sys.stdin.readline

class Solver1670C:

    def __init__(self):
        self.n = int(input())
        self.a = list(map(int, input().split(' ')))
        self.b = list(map(int, input().split(' ')))
        self.d = list(map(int, input().split(' ')))

        self.pos_a = [0 for _ in range(self.n+1)]
        self.pos_b = [0 for _ in range(self.n+1)]

        self.been = [0 for _ in range(self.n+1)]

        self.mod = (10**9)+7

    def solve(self):

        for i in range(0, self.n):
            self.pos_a[self.a[i]] = i
            self.pos_b[self.b[i]] = i

        for i in range(0, self.n):
            if self.d[i] and self.been[i] == 0:

                if self.d[i] == self.a[i]:
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

                else:
                    j = i
                    while self.been[j] == 0:
                        {{completion}}

        outp = 1

        for i in range(0, self.n):
            if self.been[i] == 0:
                cnt = 0
                j = i
                while self.been[j] == 0:
                    self.been[j] = 1
                    j = self.pos_a[self.b[j]]

                    cnt += 1

                if cnt >= 2:
                    outp = outp * 2 % self.mod

        return outp


t = int(input())

while t:

    t -= 1

    cur = Solver1670C()

    print(cur.solve())
","self.been[j] = 1
                        j = self.pos_b[self.a[j]]",self.push(l >> i)
"m = 10**9+7
for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    c = list(map(int,input().split()))
    d={i:0 for i in range(1,n+1)}
    for i in range(n):
        d[c[i]]=1
    dd={}
    for i in range(n):
        dd[a[i]]=i
    ans = 1
    for i in range(n):
        if(c[i] != 0 or a[i]==b[i] or d[a[i]] == 1 or d[b[i]]==1):continue
        j=dd[b[i]]; f=2
        while(j!=i):
            if(c[j]!=0):{{completion}}
            c[j]=1
            j=dd[b[j]]
        ans=(ans*f)%m
        k=1
    print(ans)

",f=1,ass = True
"from sys import stdin, stdout
from functools import reduce

M = int(10**9 + 7)
def solve(a, b, c, n):
    vis = [False]*n
    ans = []
    g = {a[i]:(b[i], c[i]) for i in range(n)}
    for i in range(n):
        t, ass, j = 0, False, i
        while not vis[j]:
            vis[j] = True
            if g[j + 1][1] != 0: {{completion}} 
            j = g[j + 1][0] - 1
            t += 1
            #print(t, ass, j)
        if not ass and t > 1: ans.append(2)
        else: ans.append(1)
        #print(ans)
    if not ans: return 0
    #print(reduce(lambda x, y: (x*y)%M, ans, 1) % M)
    return reduce(lambda x, y: (x*y)%M, ans, 1) % M

for i in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())
    a = list(map(int, stdin.readline().strip().split()))
    b = list(map(int, stdin.readline().strip().split()))
    c = list(map(int, stdin.readline().strip().split()))
    out_ = solve(a, b, c, n)
    stdout.write(f""{out_}\n"")",ass = True,out_=0
"from sys import stdin, setrecursionlimit
input = stdin.readline

from bisect import bisect_left, bisect_right
from collections import deque
from functools import lru_cache, reduce
from heapq import heappush, heappop
from math import sqrt, ceil, floor, log2

T = int(input())

def rl(t = int):
    return list(map(t, input().split()))

MOD = 10**9 + 7
for t in range(1, T + 1):
    n = int(input())
    a = rl()
    b = rl()
    d = rl()

    m = {v:i for i,v in enumerate(a)}

    for i in range(n):
        if a[i] == b[i]:
            d[i] = a[i]

    ret = 1
    seen = set()
    for i,cur in enumerate(a): 
        if cur in seen:
            continue
        
        mul = 2
        while cur not in seen:
            if d[i] != 0:
                {{completion}}
            seen.add(cur)
            #print(i, cur)
            cur = b[i]
            i = m[cur]

        #print(seen, mul)
        ret = (ret * mul) % MOD

    print(ret)
",mul = 1,f=1
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();b=L();d=L();l=[]
    for i in range(n):l.append([a[i],b[i],d[i]])
    l.sort(key=lambda x:x[0]);s=set();ans=1
    for i in range(n):
        if i not in s:
            d={};cur=i;f=0
            while True:
                d[l[cur][0]]=d.get(l[cur][0],0)+1
                d[l[cur][1]]=d.get(l[cur][1],0)+1
                s.add(cur)
                if l[cur][2]!=0 or l[cur][1]==l[cur][0]:{{completion}}
                if d[l[cur][1]]==2:break
                cur=l[cur][1]-1
            if f!=1:ans=(ans*2)%mod1
    print(ans)",f=1,mul = 1
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();b=L();d=L();l=[]
    for i in range(n):l.append([a[i],b[i],d[i]])
    l.sort(key=lambda x:x[0]);s=set();ans=1
    for i in range(n):
        if i not in s:
            d={};cur=i;f=0
            while True:
                d[l[cur][0]]=d.get(l[cur][0],0)+1
                d[l[cur][1]]=d.get(l[cur][1],0)+1
                s.add(cur)
                if l[cur][2]!=0 or l[cur][1]==l[cur][0]:f=1
                if d[l[cur][1]]==2:{{completion}}
                cur=l[cur][1]-1
            if f!=1:ans=(ans*2)%mod1
    print(ans)",break,f=1
"import sys

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def solve(n, a):
    k = sum([0 if ai > 0 else 1 for ai in a])
    b = [abs(a[i]) if i >= k else -abs(a[i]) for i in range(n)]
    for i in range(n-1):
        if b[i] > b[i+1]:
            {{completion}}
    return ""YES""

for i in range(1, len(ls)-1, 2):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    print(solve(n, a))","return ""NO""","print(""NO"")
            return"
"
 
n,l,r,z=map(int,input().split())
mod=10**9+7
 
 
#############################
#############
cnb_max=10**5
#############
 
kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod
 
rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod
 
def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod
 
 
def inv(n):
    return kai[n-1]*rkai[n]%mod
 
##################################
 
 
 
def f(r,z):
    dp=[0]*(2*n+10)
    dp[0]=1
    for i in range(65):
        newdp=[0]*(2*n+10)
        for j in range(2*n+5):
            dp[j]%=mod
            if dp[j]==0:continue
            for cnt in range(z&1,n+1,2):
                if j+cnt>r:{{completion}}
                d=0
                if (r&1)==0 and (j+cnt)%2==1:d=1
                newdp[(j+cnt)//2+d]+=dp[j]*cnb(n,cnt)%mod
        z//=2
        r//=2
        dp=newdp[:]
    return dp[0]%mod
 
print((f(r,z)-f(l-1,z))%mod)
 ",break,d=1
"
 
n,l,r,z=map(int,input().split())
mod=10**9+7
 
 
#############################
#############
cnb_max=10**5
#############
 
kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod
 
rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod
 
def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod
 
 
def inv(n):
    return kai[n-1]*rkai[n]%mod
 
##################################
 
 
 
def f(r,z):
    dp=[0]*(2*n+10)
    dp[0]=1
    for i in range(65):
        newdp=[0]*(2*n+10)
        for j in range(2*n+5):
            dp[j]%=mod
            if dp[j]==0:continue
            for cnt in range(z&1,n+1,2):
                if j+cnt>r:break
                d=0
                if (r&1)==0 and (j+cnt)%2==1:{{completion}}
                newdp[(j+cnt)//2+d]+=dp[j]*cnb(n,cnt)%mod
        z//=2
        r//=2
        dp=newdp[:]
    return dp[0]%mod
 
print((f(r,z)-f(l-1,z))%mod)
 ",d=1,break
"import sys
input = sys.stdin.readline
MOD = 10 ** 9 + 7
N = 10000
fact = [0 for _ in range(N)]
invfact = [0 for _ in range(N)]
fact[0] = 1
for i in range(1, N):
    fact[i] = fact[i - 1] * i % MOD

invfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)

for i in range(N - 2, -1, -1):
    invfact[i] = invfact[i + 1] * (i + 1) % MOD

def nCk(n, k):
    if k < 0 or n < k:
        return 0
    else:
        return (fact[n] * invfact[k] % MOD) * invfact[n - k] % MOD

def nHk(n, k):
    return nCk(n + k - 1, k)


def main():
    n, l, r, z = map(int, input().split())
    bit = [0] * 60
    for i in range(60):
        if z >> i & 1:
            bit[i] = 1
            r -= 1 << i
            l -= 1 << i
    if r < 0:
        print(0)
        return
    
    ma = [0] * 60
    for i in range(60):
        if n % 2 == bit[i]:
            nn = n
        else:
            nn = n - 1
        ma[i] = (1 << (i + 1)) * nn
        if i != 0:
            ma[i] += ma[i - 1]

    tot = [0] * 60
    for i in range(60):
        for j in range(bit[i], n + 1, 2):
            tot[i] += nCk(n, j)
            tot[i] %= MOD
        if i != 0:
            tot[i] *= tot[i - 1]
            tot[i] %= MOD

    memo = {}
    d = r - l
    bi = [1 << i for i in range(61)]

    def solve(i, l):
        r = l + d
        if l <= 0 and ma[i] <= r:
            return tot[i]
        elif ma[i] < l:
            return 0
        elif i == -1:
            return l <= 0
        elif i + 60 * l in memo:
            return memo[i + 60 * l]
        
        ret = 0
        mi = bi[i + 1]
        ll = l
        rr = r
        for j in range(bit[i], n + 1, 2):
            ret += solve(i - 1, ll) * nCk(n, j) % MOD
            if ret >= MOD: {{completion}}
            ll -= mi
            rr -= mi
            if rr < 0:
                break

        memo[i + 60 * l] = ret
        return ret
    
    ans = solve(59, l)
    
    print(ans)
    
    
for _ in range(1):
    main()",ret -= MOD,break
"import sys
input = sys.stdin.readline
MOD = 10 ** 9 + 7
N = 10000
fact = [0 for _ in range(N)]
invfact = [0 for _ in range(N)]
fact[0] = 1
for i in range(1, N):
    fact[i] = fact[i - 1] * i % MOD

invfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)

for i in range(N - 2, -1, -1):
    invfact[i] = invfact[i + 1] * (i + 1) % MOD

def nCk(n, k):
    if k < 0 or n < k:
        return 0
    else:
        return (fact[n] * invfact[k] % MOD) * invfact[n - k] % MOD

def nHk(n, k):
    return nCk(n + k - 1, k)


def main():
    n, l, r, z = map(int, input().split())
    bit = [0] * 60
    for i in range(60):
        if z >> i & 1:
            bit[i] = 1
            r -= 1 << i
            l -= 1 << i
    if r < 0:
        print(0)
        return
    
    ma = [0] * 60
    for i in range(60):
        if n % 2 == bit[i]:
            nn = n
        else:
            nn = n - 1
        ma[i] = (1 << (i + 1)) * nn
        if i != 0:
            ma[i] += ma[i - 1]

    tot = [0] * 60
    for i in range(60):
        for j in range(bit[i], n + 1, 2):
            tot[i] += nCk(n, j)
            tot[i] %= MOD
        if i != 0:
            tot[i] *= tot[i - 1]
            tot[i] %= MOD

    memo = {}
    d = r - l
    bi = [1 << i for i in range(61)]

    def solve(i, l):
        r = l + d
        if l <= 0 and ma[i] <= r:
            return tot[i]
        elif ma[i] < l:
            return 0
        elif i == -1:
            return l <= 0
        elif i + 60 * l in memo:
            return memo[i + 60 * l]
        
        ret = 0
        mi = bi[i + 1]
        ll = l
        rr = r
        for j in range(bit[i], n + 1, 2):
            ret += solve(i - 1, ll) * nCk(n, j) % MOD
            if ret >= MOD: ret -= MOD
            ll -= mi
            rr -= mi
            if rr < 0:
                {{completion}}

        memo[i + 60 * l] = ret
        return ret
    
    ans = solve(59, l)
    
    print(ans)
    
    
for _ in range(1):
    main()",break,ret -= MOD
"a,b=map(int,input().split())
arr=[0]*500001
for i in map(int,input().split()):
    arr[i]+=1
for i in range(1,500000):
    arr[i+1]+=arr[i]//(i+1)
    arr[i]%=i+1
if sum(arr[:b])==0:
    print('Yes')
else:
    {{completion}}",print('No'),"print(""No"")"
"import sys
from collections import Counter

input = sys.stdin.readline
n, x = map(int, input().split())
a = list(map(int, input().split()))
cnt = Counter(a)
rest, base = 0, 1
for t in range(x, 0, -1):
    if t in cnt:
        {{completion}}
    rest %= base
    rest *= t
    base *= t
    if n == 0 or base - rest > n * t:
        break
print('Yes' if n == 0 and rest % base == 0 else 'No')","n -= cnt[t]
        rest += cnt[t] % base",break
"import sys
from collections import Counter

input = sys.stdin.readline
n, x = map(int, input().split())
a = list(map(int, input().split()))
cnt = Counter(a)
rest, base = 0, 1
for t in range(x, 0, -1):
    if t in cnt:
        n -= cnt[t]
        rest += cnt[t] % base
    rest %= base
    rest *= t
    base *= t
    if n == 0 or base - rest > n * t:
        {{completion}}
print('Yes' if n == 0 and rest % base == 0 else 'No')",break,"n -= cnt[t]
        rest += cnt[t] % base"
"def rl():
	return [int(i) for i in input().split()]

def solve():
	[n,x]=rl()
	a=rl()
	nax=500000+5
	ct=[0 for i in range(nax)]
	for b in a:
		ct[b]+=1
	for i in range(x):
		if ct[i]%(i+1):
			{{completion}}
		ct[i+1]+=ct[i]/(i+1)
	return ""Yes""

print(solve())
","return ""No""","return ""No""
        break"
"# your code goes here

if __name__ == '__main__':
	n, x = map(int, input('').split(' '))
	a = list(map(int, input('').split(' ')))
	cnt = [0] * (x+2)
	for w in a:
		cnt[w] += 1
	for i in range(x):
		while cnt[i] > i:
			{{completion}}
	print('No' if sum(cnt[:x]) else 'Yes')
			
	","cnt[i] -= (i+1)
			cnt[i+1] += 1","cnt[i] = cnt[i] - i
			cnt[i+1] += cnt[i]
			cnt[i] = 0"
"def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    while True:
        k = a[-1]
        a.pop() 
        cnt = 1
        while len(a) > 0 and k == a[-1]:
            {{completion}}
        if cnt < k + 1:
            return ('Yes' if k >= x else 'No' )
        for i in range(cnt // (k + 1)):
            a.append(k + 1) 
        for i in range(cnt % (k + 1)):
            a.append(k)

n, x = tuple(map(int, input().split(' ')))
a = input().split(' ')
a = list(map(int, a))

print(factorial_divisibility(n, x, a))



","cnt += 1
            a.pop()","cnt[i] -= (i+1)
			cnt[i+1] += 1"
"def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    while True:
        k = a[-1]
        a.pop() 
        cnt = 1
        while len(a) > 0 and k == a[-1]:
            cnt += 1
            a.pop()
        if cnt < k + 1:
            {{completion}}
        for i in range(cnt // (k + 1)):
            a.append(k + 1) 
        for i in range(cnt % (k + 1)):
            a.append(k)

n, x = tuple(map(int, input().split(' ')))
a = input().split(' ')
a = list(map(int, a))

print(factorial_divisibility(n, x, a))



",return ('Yes' if k >= x else 'No' ),"cnt += 1
            a.pop()"
"n , x = [int(x) for x in input().split()]
l = [int(x) for x in input().split()]
s = [0] * (x+1)
for i in l:
    s[i] += 1
for i in range(1,x):
    if s[i] % (i+1) == 0:
        s[i+1] += s[i]//(i+1)
    else:
        {{completion}}
else:
    print('Yes')","print('NO')
        break","print('No')
        break"
"
ex = [0]
arr = [0]
for i in range(1):
    a = list(map(int, input().split()))
    ex = a[1]
    b = list(map(int, input().split()))
    arr = b

for i in range(1):
    dp = [0]*ex
    for a in arr:
        dp[a-1]+=1
    for m in range(len(dp)-1):
        while dp[m]>=m+2:
            {{completion}}
    dp = dp[:-1]
    A = sum(dp)
    if A == 0:
        ans='Yes'
    else:
        ans='No'
print(ans)
","dp[m] = dp[m] - m - 2
            dp[m+1]+=1","dp = dp[:-1]
A = sum(dp)
if A == 0:
    ans='Yes'
else:
    ans='No'
print(ans)"
"n,x=map(int,input().split())
s={i:0 for i in range(1,x+1)}
def f(x,a):
    s[x]=s[x]+a
an=map(int,input().split())
for b in an:
    f(b,1)
l=1
i=1
while i < x:
    if s[i]%(i+1)==0:
        f(i+1,s[i]//(i+1))
        i+=1
    else:
        {{completion}}
print(['no','yes'][l])
","l=0
        break","print('No')
        break"
"b=[0]*500001
l=list(map(int,input("""").split()))
n=l[0]
m=l[1]
a=list(map(int,input("""").split()))
e=1
for i in a:
    b[i]+=1
for i in range(1,l[1]):
    if b[i]%(i+1)==0:
        b[i+1]+=(b[i]//(i+1))
    else:
        {{completion}}
if e==1:
    if b[m]!=0 :
        print(""Yes"")
    else:
        print(""No"")
","print(""No"")
        e=0
        break","print(""No"")"
"b=[0]*500001
l=list(map(int,input("""").split()))
n=l[0]
m=l[1]
a=list(map(int,input("""").split()))
e=1
for i in a:
    b[i]+=1
for i in range(1,l[1]):
    if b[i]%(i+1)==0:
        b[i+1]+=(b[i]//(i+1))
    else:
        print(""No"")
        e=0
        break
if e==1:
    if b[m]!=0 :
        print(""Yes"")
    else:
        {{completion}}
","print(""No"")","print(""No"")
        e=0
        break"
"from bisect import bisect

import sys
input = sys.stdin.readline

n, b, p, m = map(int, input().split())


adds = []
curr = []
mults = []

i = 0
for _ in range(n):
    t, v = input().split()
    v = int(v)
    
    if t == '*':
        if v == 1:
            continue
        curr.sort()

        adds.append(curr)
        mults.append(v)
        curr = []
    else:
        curr.append(v)
        
curr.sort()
adds.append(curr)

pref = []
for l in adds:  
    np = [0]
    for v in l[::-1]:
        np.append(v + np[-1])
    pref.append(np)

y = len(mults)
un_m = sorted(set(mults))
z = len(un_m)
ct_m = [0] * z
for v in mults:
    for i in range(z):
        if un_m[i] == v:
            ct_m[i] += 1

from itertools import product
poss = []

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            seg_mult.append(seg_mult[-1] * mults[i])
        else:
            seg_mult.append(seg_mult[-1])
    seg_mult.reverse()

    exc = [seg_mult[0] - v for v in seg_mult]

    init_tot = 0
    for j in range(y + 1):
        if exc[j] != 0:
            init_tot += len(adds[j])

    lo = 0 #Ct value provided >= lo >= rem_adds
    hi = 10 ** 18 + 100 #Too high
    while hi - lo > 1:
        mid = lo + (hi - lo) // 2

        tot = init_tot
        for j in range(y + 1):
            if exc[j] == 0:
                {{completion}}
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - 1) // exc[j]

        s_ct = len(adds[j]) - bisect(adds[j], limit)

        tot += pref[j][s_ct] * exc[j]
        ct += s_ct

    if lo != 0:
        assert ct >= rem_adds
        tot -= lo * (ct - rem_adds)

    #print(tup, lo, tot, end)
    poss.append(tot * end)
    #break
    




print(max(poss))

    
",continue,seg_mult.append(seg_mult[-1])
"from bisect import bisect

import sys
input = sys.stdin.readline

n, b, p, m = map(int, input().split())


adds = []
curr = []
mults = []

i = 0
for _ in range(n):
    t, v = input().split()
    v = int(v)
    
    if t == '*':
        if v == 1:
            continue
        curr.sort()

        adds.append(curr)
        mults.append(v)
        curr = []
    else:
        curr.append(v)
        
curr.sort()
adds.append(curr)

pref = []
for l in adds:  
    np = [0]
    for v in l[::-1]:
        np.append(v + np[-1])
    pref.append(np)

y = len(mults)
un_m = sorted(set(mults))
z = len(un_m)
ct_m = [0] * z
for v in mults:
    for i in range(z):
        if un_m[i] == v:
            ct_m[i] += 1

from itertools import product
poss = []

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            seg_mult.append(seg_mult[-1] * mults[i])
        else:
            {{completion}}
    seg_mult.reverse()

    exc = [seg_mult[0] - v for v in seg_mult]

    init_tot = 0
    for j in range(y + 1):
        if exc[j] != 0:
            init_tot += len(adds[j])

    lo = 0 #Ct value provided >= lo >= rem_adds
    hi = 10 ** 18 + 100 #Too high
    while hi - lo > 1:
        mid = lo + (hi - lo) // 2

        tot = init_tot
        for j in range(y + 1):
            if exc[j] == 0:
                continue
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - 1) // exc[j]

        s_ct = len(adds[j]) - bisect(adds[j], limit)

        tot += pref[j][s_ct] * exc[j]
        ct += s_ct

    if lo != 0:
        assert ct >= rem_adds
        tot -= lo * (ct - rem_adds)

    #print(tup, lo, tot, end)
    poss.append(tot * end)
    #break
    




print(max(poss))

    
",seg_mult.append(seg_mult[-1]),continue
"n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m

half = [0, 0, 1] + [0] * (3 * n)
pref = [0, 0, 1] + [0] * (3 * n)
good = [-1, 1]
bad =  [-1, 0]

for i in range(2, n + 1):
    nb = 0
    
    for j in range(1, i):
        prev = i - 2 * j - 1
        if prev < 0:
            {{completion}}

        add = modmul(pref[prev], good[j])
        nb += add

        half[j + i] += add
        half[j + i] %= m

    pref[i] = (pref[i - 1] + half[i]) % m
    nb %= m
    
    bad.append(nb)
    tot = pow(2, i-2, m)
    good.append((tot - nb) % m)

    half[2 * i] += good[i]
print(good[n] % m)
",continue,half[i] += good[i-1]
"n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if rem[j] == 0:
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if spec[d]:
                {{completion}}

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))
",out[base][sq + 1] += ct,diff[d] += 1
"n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if rem[j] == 0:
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            {{completion}}

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if spec[d]:
                out[base][sq + 1] += ct

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))
",diff[d] += 1,out[base][sq + 1] += ct
"# Problem - https://codeforces.com/contest/1714/problem/E
# Editorial - https://codeforces.com/blog/entry/105549
# Tags - brute force, math, number theory, *1400

import sys
import typing

# Read stdin and remove newline elements
stdin = [line.strip() for line in sys.stdin.readlines() if line != '\n']
stdin_counter = 0

cycle_for_2 = 20 # 2 => 2 + 2 => 4 + 4 => 8 + 8 => 16 + 6 => 22 - 2 = 20

def take_from_stdin():
    global stdin_counter
    result = stdin[stdin_counter]
    stdin_counter += 1
    return result

def solve(arr: typing.List[int]):
    has_2 = False
    has_0 = False
    
    for i in range(len(arr)):
        mod_10 = arr[i] % 10
        
        if mod_10 == 2:
            has_2 = True
            
        if mod_10 == 0:
            has_0 = True
                
        while mod_10 != 2 and mod_10 != 0:
            arr[i] += mod_10
            mod_10 = arr[i] % 10
            
            if mod_10 == 2:
                {{completion}}
            
            if mod_10 == 0:
                has_0 = True
    
    if has_0 and has_2:
        return ""NO""
    
    if has_2:
        for i in range(len(arr)):
            arr[i] = arr[i] % 20
           
    if len(set(arr)) == 1:
        return ""YES""
    return ""NO""
        
       
def main():
    test_count = int(take_from_stdin())
    
    for _ in range(test_count):
        _ = int(take_from_stdin())
        arr = [int(x) for x in take_from_stdin().split()]
        print(solve(arr))

main()",has_2 = True,has_0 = True
"# Problem - https://codeforces.com/contest/1714/problem/E
# Editorial - https://codeforces.com/blog/entry/105549
# Tags - brute force, math, number theory, *1400

import sys
import typing

# Read stdin and remove newline elements
stdin = [line.strip() for line in sys.stdin.readlines() if line != '\n']
stdin_counter = 0

cycle_for_2 = 20 # 2 => 2 + 2 => 4 + 4 => 8 + 8 => 16 + 6 => 22 - 2 = 20

def take_from_stdin():
    global stdin_counter
    result = stdin[stdin_counter]
    stdin_counter += 1
    return result

def solve(arr: typing.List[int]):
    has_2 = False
    has_0 = False
    
    for i in range(len(arr)):
        mod_10 = arr[i] % 10
        
        if mod_10 == 2:
            has_2 = True
            
        if mod_10 == 0:
            has_0 = True
                
        while mod_10 != 2 and mod_10 != 0:
            arr[i] += mod_10
            mod_10 = arr[i] % 10
            
            if mod_10 == 2:
                has_2 = True
            
            if mod_10 == 0:
                {{completion}}
    
    if has_0 and has_2:
        return ""NO""
    
    if has_2:
        for i in range(len(arr)):
            arr[i] = arr[i] % 20
           
    if len(set(arr)) == 1:
        return ""YES""
    return ""NO""
        
       
def main():
    test_count = int(take_from_stdin())
    
    for _ in range(test_count):
        _ = int(take_from_stdin())
        arr = [int(x) for x in take_from_stdin().split()]
        print(solve(arr))

main()",has_0 = True,has_2 = True
"input = __import__('sys').stdin.readline


class DisjointSetUnion(object):
    def __init__(self, n):
        self.n = n
        self.par = [i for i in range(n)]
    
    def find(self, x):
        toupdate = []
        while x != self.par[x]:
            {{completion}}
        
        for u in toupdate:
            self.par[u] = x
        return x
    
    def merge(self, u, v):
        u = self.find(u)
        v = self.find(v)
        if u != v:
            self.par[u] = v
        return u != v


n, m = map(int, input().split())

dsu = DisjointSetUnion(n)
adj = [[] for _ in range(n)] # adjlist of the MST
outOfTrees = [] # outside the MST
for _ in range(m):
    u, v = map(lambda x: int(x)-1, input().split())
    if dsu.merge(u, v):
        adj[u].append(v)
        adj[v].append(u)
    else:
        outOfTrees.append((u, v))

# print('outOfTrees', outOfTrees)

# init lca
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for j in range(20):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])


def moveTo(u, step):
    for i in range(20):
        if (step >> i) & 1 == 1:
            u = jump[i][u]
    return u


def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    u = moveTo(u, depth[u] - depth[v])
    if u == v:
        return u
    
    for i in range(19, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# check each edges out of the tree
psum = [0] * n
for u, v in outOfTrees:
    # nodes in the path (and its subtrees) u to v (not including u & v) will select edge u-v in their dfs process
    r = lca(u, v)
    # print('lca', u+1, v+1, r+1)
    if r == u:
        psum[moveTo(v, depth[v] - depth[u] - 1)] += 1
        psum[v] -= 1
    elif r == v:
        psum[moveTo(u, depth[u] - depth[v] - 1)] += 1
        psum[u] -= 1
    else:
        psum[0] += 1
        psum[u] -= 1
        psum[v] -= 1

# print('psum_initial', psum)
# print('applyToChild', applyToChild)

stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    for v in adj[u]:
        if v != par:
            psum[v] += psum[u]
            stack.append((v, u))

# print('psum', psum)
print(''.join('1' if psum[u] == 0 else '0' for u in range(n)))","toupdate.append(x)
            x = self.par[x]",u = jump[i][u]
"input = __import__('sys').stdin.readline


class DisjointSetUnion(object):
    def __init__(self, n):
        self.n = n
        self.par = [i for i in range(n)]
    
    def find(self, x):
        toupdate = []
        while x != self.par[x]:
            toupdate.append(x)
            x = self.par[x]
        
        for u in toupdate:
            {{completion}}
        return x
    
    def merge(self, u, v):
        u = self.find(u)
        v = self.find(v)
        if u != v:
            self.par[u] = v
        return u != v


n, m = map(int, input().split())

dsu = DisjointSetUnion(n)
adj = [[] for _ in range(n)] # adjlist of the MST
outOfTrees = [] # outside the MST
for _ in range(m):
    u, v = map(lambda x: int(x)-1, input().split())
    if dsu.merge(u, v):
        adj[u].append(v)
        adj[v].append(u)
    else:
        outOfTrees.append((u, v))

# print('outOfTrees', outOfTrees)

# init lca
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for j in range(20):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])


def moveTo(u, step):
    for i in range(20):
        if (step >> i) & 1 == 1:
            u = jump[i][u]
    return u


def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    u = moveTo(u, depth[u] - depth[v])
    if u == v:
        return u
    
    for i in range(19, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# check each edges out of the tree
psum = [0] * n
for u, v in outOfTrees:
    # nodes in the path (and its subtrees) u to v (not including u & v) will select edge u-v in their dfs process
    r = lca(u, v)
    # print('lca', u+1, v+1, r+1)
    if r == u:
        psum[moveTo(v, depth[v] - depth[u] - 1)] += 1
        psum[v] -= 1
    elif r == v:
        psum[moveTo(u, depth[u] - depth[v] - 1)] += 1
        psum[u] -= 1
    else:
        psum[0] += 1
        psum[u] -= 1
        psum[v] -= 1

# print('psum_initial', psum)
# print('applyToChild', applyToChild)

stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    for v in adj[u]:
        if v != par:
            psum[v] += psum[u]
            stack.append((v, u))

# print('psum', psum)
print(''.join('1' if psum[u] == 0 else '0' for u in range(n)))",self.par[u] = x,u = jump[i][u]
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        {{completion}}
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
 		    	   	    	  		 	 						",i+=1,i+=1
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        {{completion}}
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
 		    	   	    	  		 	 						",j-=1,i+=1
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  a = deque(inp(n))
  ret = 0
  sm = sum(a)
  if list(a) != sorted(a):
    while len(a) > 1 and sm > 0:
      if a.pop() == 0:
        ret += 1
        while len(a) > 0 and a.popleft() == 0:
          {{completion}}
        sm -= 1
      else: sm -= 1
  print(ret)
",continue,a.pop()
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        {{completion}}
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
	  	 	    						 	 		 	 	 	 	 	",i+=1,i+=1
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        {{completion}}
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
	  	 	    						 	 		 	 	 	 	 	",j-=1,j-=1
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    {{completion}}
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  k = inp1()
  a = set(inp(n))
  print(""YES"" if 1 in a else ""NO"")
","global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret",return inp()[0]
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    {{completion}}

t = inp1()
for _ in range(t):
  n = inp1()
  k = inp1()
  a = set(inp(n))
  print(""YES"" if 1 in a else ""NO"")
",return inp()[0],"global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret"
"import os
import sys 
from io import BytesIO, IOBase
 
BUFSIZE = 8192
   
class FastIO(IOBase):
    newlines = 0
  
    def __init__(self, file):
        self._fd = file.fileno() 
        self.buffer = BytesIO()  
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True: 
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break  
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0 
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) 
            self.newlines = b.count(b""\n"") + (not b)  
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1    
        return self.buffer.readline()
 
    def flush(self): 
        if self.writable: 
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)   
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

import random

class Bit:
    def __init__(self, n):
        self.size = n
        self.n0 = 1 << (n.bit_length() - 1)
        self.tree = [0] * (n + 1)
    
    def range_sum(self, l, r):
        return self.sum(r - 1) - self.sum(l - 1)
        
    def sum(self, i):
        i += 1
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s
        
    def get(self, i):
        return self.sum(i) - self.sum(i - 1)
 
    def add(self, i, x):
        i += 1
        while i <= self.size:
            self.tree[i] += x
            i += i & -i
         
    def lower_bound(self, x):
        pos = 0
        plus = self.n0
        while plus > 0:
            if pos + plus <= self.size and self.tree[pos + plus] < x:
                x -= self.tree[pos + plus]
                pos += plus
            plus //= 2
        return pos

def solve():
    n, Q = map(int, input().split())
    A = list(map(int, input().split()))
    query = []
    se = set(A)
    ind = 0
    ans = [""YES""] * Q
    for _ in range(Q):
        q = list(map(int, input().split()))
        if q[0] == 2:
            l, r, k = q[1:]
            if (r - l + 1) % k != 0:
                ans[ind] = ""NO""
                ind += 1
                continue
            q.append(ind)
            ind += 1
        else:
            q[1] -= 1
        query.append(q)
        if q[0] == 1:
            se.add(q[2])
    ans = ans[:ind]
    dic = {a:i for i, a in enumerate(sorted(se))}
    A = [dic[a] for a in A]
    for q in query:
        if q[0] == 1:
            q[2] = dic[q[2]]
    
    m = len(se)
    itr = 12
    for _ in range(itr):
        P = random.choices(range(4), k=m)
        bit = Bit(n)
        B = A[:]
        for i, a in enumerate(A):
            add = 0
            if P[a] & 1:
                add |= 1
            if P[a] & 2:
                add |= 1 << 30
            if add != 0:
                bit.add(i, add)
        for q in query:
            if q[0] == 1:
                i, x = q[1:]
                b = B[i]
                B[i] = x
                add = 0
                if P[b] & 1:
                    add -= 1
                if P[b] & 2:
                    add -= 1 << 30
                if P[x] & 1:
                    add += 1
                if P[x] & 2:
                    add += 1 << 30
                if add != 0:
                    bit.add(i, add)
            else:
                l, r, k, i = q[1:]
                if ans[i] == ""NO"":
                    continue
                c = bit.range_sum(l - 1, r)
                if c % k != 0:
                    ans[i] = ""NO""
                elif (c >> 30) % k != 0:
                    {{completion}}

    print(*ans, sep=""\n"")
    
    

T = 1
# T = int(input())
for t in range(1, T + 1):
    solve()   ","ans[i] = ""NO""",self.push(l >> i)
"import os
import sys 
from io import BytesIO, IOBase
 
BUFSIZE = 8192
   
class FastIO(IOBase):
    newlines = 0
  
    def __init__(self, file):
        self._fd = file.fileno() 
        self.buffer = BytesIO()  
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True: 
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break  
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0 
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) 
            self.newlines = b.count(b""\n"") + (not b)  
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1    
        return self.buffer.readline()
 
    def flush(self): 
        if self.writable: 
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)   
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

import random

class Bit:
    def __init__(self, n):
        self.size = n
        self.n0 = 1 << (n.bit_length() - 1)
        self.tree = [0] * (n + 1)
    
    def range_sum(self, l, r):
        return self.sum(r - 1) - self.sum(l - 1)
        
    def sum(self, i):
        i += 1
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s
        
    def get(self, i):
        return self.sum(i) - self.sum(i - 1)
 
    def add(self, i, x):
        i += 1
        while i <= self.size:
            self.tree[i] += x
            i += i & -i
         
    def lower_bound(self, x):
        pos = 0
        plus = self.n0
        while plus > 0:
            if pos + plus <= self.size and self.tree[pos + plus] < x:
                x -= self.tree[pos + plus]
                pos += plus
            plus //= 2
        return pos

def solve():
    n, Q = map(int, input().split())
    A = list(map(int, input().split()))
    query = []
    se = set(A)
    ind = 0
    ans = [""YES""] * Q
    for _ in range(Q):
        q = list(map(int, input().split()))
        if q[0] == 2:
            l, r, k = q[1:]
            if (r - l + 1) % k != 0:
                ans[ind] = ""NO""
                ind += 1
                continue
            q.append(ind)
            ind += 1
        else:
            q[1] -= 1
        query.append(q)
        if q[0] == 1:
            se.add(q[2])
    ans = ans[:ind]
    dic = {a:i for i, a in enumerate(sorted(se))}
    A = [dic[a] for a in A]
    for q in query:
        if q[0] == 1:
            q[2] = dic[q[2]]
    
    m = len(se)
    itr = 12
    for _ in range(itr):
        P = random.choices(range(4), k=m)
        bit = Bit(n)
        B = A[:]
        for i, a in enumerate(A):
            add = 0
            if P[a] & 1:
                add |= 1
            if P[a] & 2:
                add |= 1 << 30
            if add != 0:
                bit.add(i, add)
        for q in query:
            if q[0] == 1:
                i, x = q[1:]
                b = B[i]
                B[i] = x
                add = 0
                if P[b] & 1:
                    add -= 1
                if P[b] & 2:
                    add -= 1 << 30
                if P[x] & 1:
                    add += 1
                if P[x] & 2:
                    add += 1 << 30
                if add != 0:
                    bit.add(i, add)
            else:
                l, r, k, i = q[1:]
                if ans[i] == ""NO"":
                    {{completion}}
                c = bit.range_sum(l - 1, r)
                if c % k != 0:
                    ans[i] = ""NO""
                elif (c >> 30) % k != 0:
                    ans[i] = ""NO""

    print(*ans, sep=""\n"")
    
    

T = 1
# T = int(input())
for t in range(1, T + 1):
    solve()   ",continue,self.push(l >> i)
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def solve():
    n = getInt()
    a = list(getList())
    j = res = 0
    p = [0] * n
    P = [0] * n
    from bisect import bisect_left
    f = {}
    for i, x in enumerate(a):
        j = max(j, i)
        while j < n and a[j] >= j+1 - i:
            j += 1
        res += j - i
        if j-1 not in f:
            f[j-1] = i
            J = j + 1  # further extends
        while J < n and a[J] >= J + 1 - i:
            J += 1
        p[i] = p[i-1] + j - 1
        P[i] = P[i-1] + J - j
    q = getInt()

    def calc(l, r, p):
        if l > r:
            return 0
        res = p[r]
        if l:
            res -= p[l-1]
        return res

    keys = sorted(f.keys())
    for _ in range(q):
        u, v = getList()
        u -= 1
        ans = res
        it = bisect_left(keys, u)
        if v < a[u]:
            it = keys[it]
            l = max(f[it], u + 1 - v)
            ans -= calc(f[it], l-1, p) - (u-1) * (l-f[it])
        elif v > a[u]:
            if it and keys[it-1] + 1 == u:
                {{completion}}
        print(ans)


for _ in range(t):
    solve()
","l = max(f[keys[it-1]], u+1-v)
                ans += calc(l, f[keys[it]]-1, P)",j += 1
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def solve():
    n = getInt()
    a = list(getList())
    j = res = 0
    p = [0] * n
    P = [0] * n
    from bisect import bisect_left
    f = {}
    for i, x in enumerate(a):
        j = max(j, i)
        while j < n and a[j] >= j+1 - i:
            {{completion}}
        res += j - i
        if j-1 not in f:
            f[j-1] = i
            J = j + 1  # further extends
        while J < n and a[J] >= J + 1 - i:
            J += 1
        p[i] = p[i-1] + j - 1
        P[i] = P[i-1] + J - j
    q = getInt()

    def calc(l, r, p):
        if l > r:
            return 0
        res = p[r]
        if l:
            res -= p[l-1]
        return res

    keys = sorted(f.keys())
    for _ in range(q):
        u, v = getList()
        u -= 1
        ans = res
        it = bisect_left(keys, u)
        if v < a[u]:
            it = keys[it]
            l = max(f[it], u + 1 - v)
            ans -= calc(f[it], l-1, p) - (u-1) * (l-f[it])
        elif v > a[u]:
            if it and keys[it-1] + 1 == u:
                l = max(f[keys[it-1]], u+1-v)
                ans += calc(l, f[keys[it]]-1, P)
        print(ans)


for _ in range(t):
    solve()
",j += 1,"l = max(f[keys[it-1]], u+1-v)
                ans += calc(l, f[keys[it]]-1, P)"
"from sys import stdin, stdout
from collections import defaultdict

n = int(stdin.readline())
a = [int(x) for x in stdin.readline().split()]

left = 0
right = 0
right_array = []
right_prefix = [0]
answer = 0

second_right = 0
second_right_array = []
second_right_prefix = [0]

while left < n:
    if right < left:
        right = left
    while right < n and a[right] >= right-left+1:
        right += 1
    right_array.append(right)
    right_prefix.append(right_prefix[-1]+right_array[-1])
    answer += right - left

    if second_right <= right:
        second_right = right + 1
        if second_right > n:
            second_right = n
    while second_right < n and a[second_right] >= second_right-left+1:
        second_right += 1
    second_right_array.append(second_right)
    second_right_prefix.append(second_right_prefix[-1]+second_right_array[-1])

    left += 1

p_to_right = defaultdict(list)
for i in range(n):
    p_to_right[right_array[i]].append(i)

q = int(stdin.readline())
for _ in range(q):
    p, x = [int(z) for z in stdin.readline().split()]
    p -= 1
    if x == a[p]:
        adjustment = 0
    elif x < a[p]:
        if right_array[-1] <= p:
            adjustment = 0
        else:
            upper = n-1
            lower = -1
            while upper - lower > 1:
                candidate = (upper + lower)//2
                if right_array[candidate] > p:
                    upper = candidate
                else:
                    {{completion}}

            if upper > p-x:
                adjustment = 0
            else:
                adjustment = -(right_prefix[p-x+1] - right_prefix[upper] - p*(p-x-upper+1))

    else:
        if len(p_to_right[p]) == 0:
            adjustment = 0
        elif p_to_right[p][0] > p-a[p] or p_to_right[p][-1] < p-x+1:
            adjustment = 0
        else:
            lower = max(p-x+1, p_to_right[p][0])
            upper = min(p-a[p], p_to_right[p][-1])
            adjustment = second_right_prefix[upper+1] - second_right_prefix[lower] - p*(upper-lower+1)

    stdout.write(str(answer+adjustment)+'\n')
",lower = candidate,upper = candidate
"from sys import stdin, stdout
from collections import defaultdict

n = int(stdin.readline())
a = [int(x) for x in stdin.readline().split()]

left = 0
right = 0
right_array = []
right_prefix = [0]
answer = 0

second_right = 0
second_right_array = []
second_right_prefix = [0]

while left < n:
    if right < left:
        right = left
    while right < n and a[right] >= right-left+1:
        right += 1
    right_array.append(right)
    right_prefix.append(right_prefix[-1]+right_array[-1])
    answer += right - left

    if second_right <= right:
        second_right = right + 1
        if second_right > n:
            second_right = n
    while second_right < n and a[second_right] >= second_right-left+1:
        second_right += 1
    second_right_array.append(second_right)
    second_right_prefix.append(second_right_prefix[-1]+second_right_array[-1])

    left += 1

p_to_right = defaultdict(list)
for i in range(n):
    p_to_right[right_array[i]].append(i)

q = int(stdin.readline())
for _ in range(q):
    p, x = [int(z) for z in stdin.readline().split()]
    p -= 1
    if x == a[p]:
        adjustment = 0
    elif x < a[p]:
        if right_array[-1] <= p:
            adjustment = 0
        else:
            upper = n-1
            lower = -1
            while upper - lower > 1:
                candidate = (upper + lower)//2
                if right_array[candidate] > p:
                    {{completion}}
                else:
                    lower = candidate

            if upper > p-x:
                adjustment = 0
            else:
                adjustment = -(right_prefix[p-x+1] - right_prefix[upper] - p*(p-x-upper+1))

    else:
        if len(p_to_right[p]) == 0:
            adjustment = 0
        elif p_to_right[p][0] > p-a[p] or p_to_right[p][-1] < p-x+1:
            adjustment = 0
        else:
            lower = max(p-x+1, p_to_right[p][0])
            upper = min(p-a[p], p_to_right[p][-1])
            adjustment = second_right_prefix[upper+1] - second_right_prefix[lower] - p*(upper-lower+1)

    stdout.write(str(answer+adjustment)+'\n')
",upper = candidate,upper = n-1
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        n, k, r, c = list(map(int, input_arr[pos:pos + 4]))
        pos += 4
        mat = [[""."" for _ in range(n)] for j in range(n)]
        r = r - 1
        c = c - 1
        l = n // k
        for j in range(n):
            for ll in range(l):
                {{completion}}
            r -= 1
            c += 1
        for i in mat:
            for j in i:
                print(j, end="""")
            print("""")
# '3 3 3 3 2 2 1 1 2 6 3 4 2'","mat[(r+ll*k) % n][c % n] = 'X'
                mat[r][(c + ll*k) % n] = 'X'","print(j, end="""")"
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        n, k, r, c = list(map(int, input_arr[pos:pos + 4]))
        pos += 4
        mat = [[""."" for _ in range(n)] for j in range(n)]
        r = r - 1
        c = c - 1
        l = n // k
        for j in range(n):
            for ll in range(l):
                mat[(r+ll*k) % n][c % n] = 'X'
                mat[r][(c + ll*k) % n] = 'X'
            r -= 1
            c += 1
        for i in mat:
            for j in i:
                {{completion}}
            print("""")
# '3 3 3 3 2 2 1 1 2 6 3 4 2'","print(j, end="""")","mat[(r+ll*k) % n][c % n] = 'X'
                mat[r][(c + ll*k) % n] = 'X'"
"import fileinput

def f(n):
    i = 0
    while i<len(n):
        if n[i] == ""Q"":
            found = False
            for j in range(i,len(n)):
                if n[j] == ""A"":
                    {{completion}}
            if not found:
                print(""NO"")
                return
        i += 1
    print(""YES"")

for line in fileinput.input():
    if len(line) > 0 and line[0] == ""Q"":
        f(line)","n = n[:j] + n[j+1:]
                    found = True
                    break","print(""YES"")"
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6):{{completion}}
for z in map(int,input().split()):d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1
print(d%m)",f.append(f[-1]*i%m),"d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1"
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6):f.append(f[-1]*i%m)
for z in map(int,input().split()):{{completion}}
print(d%m)","d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1","d+=f[z+x]*pow(f[x+1]*f[z-1],m-2,m)*(z!=0)
    x+=1"
"from math import gcd

mod=1_000_000_007
maxn=400_100
fac=[1]*maxn
for i in range(2,maxn):
  fac[i]=(fac[i-1]*i)%mod

def inv(b,m):
  return pow(b, m - 2, m)

n=int(input())
a=list(map(int,input().split()))
o=0
for i in range(n+1):
  if a[i]==0: {{completion}}
  c=fac[a[i]+i]*inv(fac[i+1]*fac[a[i]-1],mod)
  o=(o+c)%mod
print(o)",break,o=(o+c)%mod
"N = 4 * 10**5 + 5
MOD = 10**9 + 7

fact = [1]
invf = [1]

for i in range(1, N):
    fact.append(fact[i-1] * i % MOD)
    invf.append(pow(fact[-1], MOD-2, MOD))


def C(m, n):
    if n < 0 or m < n:
        {{completion}}
    return fact[m] * invf[n] % MOD * invf[m-n] % MOD


n = int(input())
a = list(map(int, input().split()))
ans = sum(C(v+i, i+1) for i, v in enumerate(a)) % MOD
print(ans)
",return 0,"ans = (ans + C(a[i] + i, i + 1) * pow(C(i + 1, a[i] - 1), -1, MOD)) % MOD"
"import sys
input = sys.stdin.readline
MOD = 10 ** 9 + 7
n = int(input())
a = [int(x) for x in input().split()]
fac = [1]
for i in range(8 * 10 ** 5 - 1):
    fac.append((fac[-1] * (i + 1)) % MOD)
ans = 0
for i in range(n + 1):
    if a[i] != 0:
        {{completion}}
print(int(ans % MOD))","ans = (ans + fac[a[i] + i] * pow((fac[i + 1] * fac[a[i] - 1]), -1, MOD))",ans += fac[a[i] - 1] * fac[a[i] - 1 - i] * fac[i] % MOD
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6): {{completion}}
for z in list(map(int,input().split())):
    d+=f[z+x]*pow(f[x+1]*f[z-1],m-2,m)*(z!=0)
    x+=1
print(d%m)",f.append(f[-1]*i%m),f.append(f[-1]*i%m)
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6): f.append(f[-1]*i%m)
for z in list(map(int,input().split())):
    {{completion}}
print(d%m)","d+=f[z+x]*pow(f[x+1]*f[z-1],m-2,m)*(z!=0)
    x+=1","d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1"
"import math

pi = 3.14159265358979323846264338327950288419716939937510
eps, sq2 = 1e-13, math.sqrt(2)
x, y = [], []
n = 0


def binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab):
    while math.fabs(cy - fy) > eps:
        mid_y = cy / 2.0 + fy / 2.0
        la = lb = 0.0
        ra, rb = pi - alpha_1, pi - alpha_2
        while math.fabs(ra - la) > eps:
            mid_a = ra / 2.0 + la / 2.0
            yy = - pow(math.sin(mid_a), 2) * math.cos(alpha_1 + mid_a) / math.sin(alpha_1)
            if yy < mid_y:
                {{completion}}
            if yy > mid_y:
                ra = mid_a
        while math.fabs(rb - lb) > eps:
            mid_b = rb / 2.0 + lb / 2.0
            yy = - pow(math.sin(mid_b), 2) * math.cos(alpha_2 + mid_b) / math.sin(alpha_2)
            if yy < mid_y:
                lb = mid_b
            if yy > mid_y:
                rb = mid_b
        x1 = (2.0 * math.sin(la / 2.0 + ra / 2.0 + alpha_1) +
              math.sin(la + ra) * math.cos(la / 2.0 + ra / 2.0 + alpha_1)) / (2 * math.sin(alpha_1))
        x2 = ab - (2.0 * math.sin(lb / 2.0 + rb / 2.0 + alpha_2) +
                   math.sin(lb + rb) * math.cos(lb / 2.0 + rb / 2.0 + alpha_2)) / (2 * math.sin(alpha_2))
        if x1 < x2:
            cy = mid_y
        if x1 > x2:
            fy = mid_y
    return la, lb, ra, rb, cy, fy


def get_area(_i, ni, i_, i_2):
    ans = 0.00
    ab = math.sqrt(pow((x[i_] - x[ni]), 2) + pow((y[i_] - y[ni]), 2))
    ad = math.sqrt(pow((x[_i] - x[ni]), 2) + pow((y[_i] - y[ni]), 2))
    bc = math.sqrt(pow((x[i_2] - x[i_]), 2) + pow((y[i_2] - y[i_]), 2))
    ux, uy = x[_i] - x[ni], y[_i] - y[ni]
    vx, vy = x[i_] - x[ni], y[i_] - y[ni]
    alpha_1 = math.acos((ux * vx + uy * vy) / ab / ad)
    if math.fabs(ab - sq2) < eps or math.fabs(ab - 1.00) < eps:
        wx, wy = x[i_2] - x[i_], y[i_2] - y[i_]
        alpha_2 = math.acos((-vx * wx - wy * vy) / ab / bc)
        la, lb, ra, rb, cy, fy = 0.0, 0.0, pi - alpha_1, pi - alpha_2, min(alpha_1, alpha_2), 0.0000
        la, lb, ra, rb, cy, fy = binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab)

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_1)) * la - 2.0 * math.sin(la * 2.0 + ra * 2.0) +
                     4.0 * math.sin(2.0 * alpha_1 + la + ra) - math.sin(2.0 * alpha_1 + 3.0 * la + 3.0 * ra)
                     - 5.0 * math.sin(2.0 * alpha_1)+ math.sin(2.0 * alpha_1 - la - ra)
                     + math.sin(2.0 * (ra + la + alpha_1))) / (64.0 * math.sin(alpha_1) * math.sin(alpha_1))

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_2)) * lb - 2.0 * math.sin(lb * 2.0 + rb * 2.0) +
                     4.0 * math.sin(2.0 * alpha_2 + lb + rb) - math.sin(2.0 * alpha_2 + 3.0 * lb + 3.0 * rb)
                     - 5.0 * math.sin(2.0 * alpha_2) + math.sin(2.0 * alpha_2 - lb - rb)
                     + math.sin(2.0 * (rb + lb + alpha_2))) / (64.0 * math.sin(alpha_2) * math.sin(alpha_2))

    ans -= math.sin(pi - alpha_1) * math.cos(pi - alpha_1) * 0.500000
    ans += ((4.0 - 2.0 * math.cos(2.0 * alpha_1)) * (pi - alpha_1) + 2.0 * math.sin(4.0 * alpha_1)
                 - 3.0 * math.sin(2.0 * alpha_1)) / (32.0 * math.sin(alpha_1) * math.sin(alpha_1))
    return ans


if __name__ == ""__main__"":

    n = eval(input())
    for i in range(1, n + 1):
        a, b = input().split()
        a, b = eval(a), eval(b)
        x.append(a), y.append(b)
    if n == 4:
        Ax, Ay = x[0], y[0]
        Bx, By = x[1], y[1]
        Cx, Cy = x[2], y[2]
        Dx, Dy = x[3], y[3]
        ABx, ABy = Bx - Ax, By - Ay
        ADx, ADy = Dx - Ax, Dy - Ay
        CBx, CBy = Bx - Cx, By - Cy
        CDx, CDy = Dx - Cx, Dy - Cy
        LenAB, LenAD = math.sqrt(ABx * ABx + ABy * ABy), math.sqrt(ADx * ADx + ADy * ADy)
        LenCB, LenCD = math.sqrt(CBx * CBx + CBy * CBy), math.sqrt(CDx * CDx + CDy * CDy)
        a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)
        b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)
        c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)
        d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)
        if math.fabs(a - pi / 2.0) < eps and math.fabs(b - pi / 2.0) < eps and \
                math.fabs(c - pi / 2.0) < eps and math.fabs(d - pi / 2.0) < eps and \
                ((math.fabs(LenAB - 1.00) < eps and math.fabs(LenAB - LenCD) < eps) or
                 (math.fabs(LenCB - 1.00) < eps and math.fabs(LenCB - LenAD) < eps)):
            print('%.11Lf' % (LenAB * LenCB)), exit(0)
    res = 0.0000
    for i in range(1, n + 1):
        res += get_area((i - 1 + n) % n, i % n, (i + 1) % n, (i + 2) % n)
    if math.fabs(res-1.02638863065) < 100*eps:
        print('1.04719792254'), exit(0)
    if math.fabs(res-1.04692745180) < 100*eps:
        print('1.04720015894'), exit(0)

    print('%.11Lf' % res)",la = mid_a,"this is the start of the ground truth
a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)
		b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)
		c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)
		d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)
		if math."
"import math

pi = 3.14159265358979323846264338327950288419716939937510
eps, sq2 = 1e-13, math.sqrt(2)
x, y = [], []
n = 0


def binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab):
    while math.fabs(cy - fy) > eps:
        mid_y = cy / 2.0 + fy / 2.0
        la = lb = 0.0
        ra, rb = pi - alpha_1, pi - alpha_2
        while math.fabs(ra - la) > eps:
            mid_a = ra / 2.0 + la / 2.0
            yy = - pow(math.sin(mid_a), 2) * math.cos(alpha_1 + mid_a) / math.sin(alpha_1)
            if yy < mid_y:
                la = mid_a
            if yy > mid_y:
                {{completion}}
        while math.fabs(rb - lb) > eps:
            mid_b = rb / 2.0 + lb / 2.0
            yy = - pow(math.sin(mid_b), 2) * math.cos(alpha_2 + mid_b) / math.sin(alpha_2)
            if yy < mid_y:
                lb = mid_b
            if yy > mid_y:
                rb = mid_b
        x1 = (2.0 * math.sin(la / 2.0 + ra / 2.0 + alpha_1) +
              math.sin(la + ra) * math.cos(la / 2.0 + ra / 2.0 + alpha_1)) / (2 * math.sin(alpha_1))
        x2 = ab - (2.0 * math.sin(lb / 2.0 + rb / 2.0 + alpha_2) +
                   math.sin(lb + rb) * math.cos(lb / 2.0 + rb / 2.0 + alpha_2)) / (2 * math.sin(alpha_2))
        if x1 < x2:
            cy = mid_y
        if x1 > x2:
            fy = mid_y
    return la, lb, ra, rb, cy, fy


def get_area(_i, ni, i_, i_2):
    ans = 0.00
    ab = math.sqrt(pow((x[i_] - x[ni]), 2) + pow((y[i_] - y[ni]), 2))
    ad = math.sqrt(pow((x[_i] - x[ni]), 2) + pow((y[_i] - y[ni]), 2))
    bc = math.sqrt(pow((x[i_2] - x[i_]), 2) + pow((y[i_2] - y[i_]), 2))
    ux, uy = x[_i] - x[ni], y[_i] - y[ni]
    vx, vy = x[i_] - x[ni], y[i_] - y[ni]
    alpha_1 = math.acos((ux * vx + uy * vy) / ab / ad)
    if math.fabs(ab - sq2) < eps or math.fabs(ab - 1.00) < eps:
        wx, wy = x[i_2] - x[i_], y[i_2] - y[i_]
        alpha_2 = math.acos((-vx * wx - wy * vy) / ab / bc)
        la, lb, ra, rb, cy, fy = 0.0, 0.0, pi - alpha_1, pi - alpha_2, min(alpha_1, alpha_2), 0.0000
        la, lb, ra, rb, cy, fy = binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab)

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_1)) * la - 2.0 * math.sin(la * 2.0 + ra * 2.0) +
                     4.0 * math.sin(2.0 * alpha_1 + la + ra) - math.sin(2.0 * alpha_1 + 3.0 * la + 3.0 * ra)
                     - 5.0 * math.sin(2.0 * alpha_1)+ math.sin(2.0 * alpha_1 - la - ra)
                     + math.sin(2.0 * (ra + la + alpha_1))) / (64.0 * math.sin(alpha_1) * math.sin(alpha_1))

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_2)) * lb - 2.0 * math.sin(lb * 2.0 + rb * 2.0) +
                     4.0 * math.sin(2.0 * alpha_2 + lb + rb) - math.sin(2.0 * alpha_2 + 3.0 * lb + 3.0 * rb)
                     - 5.0 * math.sin(2.0 * alpha_2) + math.sin(2.0 * alpha_2 - lb - rb)
                     + math.sin(2.0 * (rb + lb + alpha_2))) / (64.0 * math.sin(alpha_2) * math.sin(alpha_2))

    ans -= math.sin(pi - alpha_1) * math.cos(pi - alpha_1) * 0.500000
    ans += ((4.0 - 2.0 * math.cos(2.0 * alpha_1)) * (pi - alpha_1) + 2.0 * math.sin(4.0 * alpha_1)
                 - 3.0 * math.sin(2.0 * alpha_1)) / (32.0 * math.sin(alpha_1) * math.sin(alpha_1))
    return ans


if __name__ == ""__main__"":

    n = eval(input())
    for i in range(1, n + 1):
        a, b = input().split()
        a, b = eval(a), eval(b)
        x.append(a), y.append(b)
    if n == 4:
        Ax, Ay = x[0], y[0]
        Bx, By = x[1], y[1]
        Cx, Cy = x[2], y[2]
        Dx, Dy = x[3], y[3]
        ABx, ABy = Bx - Ax, By - Ay
        ADx, ADy = Dx - Ax, Dy - Ay
        CBx, CBy = Bx - Cx, By - Cy
        CDx, CDy = Dx - Cx, Dy - Cy
        LenAB, LenAD = math.sqrt(ABx * ABx + ABy * ABy), math.sqrt(ADx * ADx + ADy * ADy)
        LenCB, LenCD = math.sqrt(CBx * CBx + CBy * CBy), math.sqrt(CDx * CDx + CDy * CDy)
        a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)
        b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)
        c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)
        d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)
        if math.fabs(a - pi / 2.0) < eps and math.fabs(b - pi / 2.0) < eps and \
                math.fabs(c - pi / 2.0) < eps and math.fabs(d - pi / 2.0) < eps and \
                ((math.fabs(LenAB - 1.00) < eps and math.fabs(LenAB - LenCD) < eps) or
                 (math.fabs(LenCB - 1.00) < eps and math.fabs(LenCB - LenAD) < eps)):
            print('%.11Lf' % (LenAB * LenCB)), exit(0)
    res = 0.0000
    for i in range(1, n + 1):
        res += get_area((i - 1 + n) % n, i % n, (i + 1) % n, (i + 2) % n)
    if math.fabs(res-1.02638863065) < 100*eps:
        print('1.04719792254'), exit(0)
    if math.fabs(res-1.04692745180) < 100*eps:
        print('1.04720015894'), exit(0)

    print('%.11Lf' % res)",ra = mid_a,"this is the start of the ground truth
a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)
		b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)
		c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)
		d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)
		if math."
"for _ in range(int(input())):
    {{completion}}
","p = list(map(int, input()))
    print('YES' if sum(p[:3]) == sum(p[3:]) else 'NO')","a = [int(j) for j in input()]
    print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")"
for _ in [*open(0)][1:]:{{completion}},print('yes' if int(_[0]) + int(_[1]) + int(_[2]) == int(_[3]) + int(_[4]) + int(_[5]) else 'NO'),"a = [int(j) for j in input()]
    print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")"
"t = int(input())
for i in range(1, t + 1):
   summa = 0
   a = int(input())
   a6 = a % 10
   a5 = (a // 10) % 10
   a4 = (a // 100) % 10
   a3 = (a // 1000) % 10
   a2 = (a // 10000) % 10
   a1 = (a // 100000) % 10
   if a1 + a2 + a3 == a4 + a5 + a6:
      print('YES')
   else:
      {{completion}}","print(""NO"")",print('NO')
for c in [input() for i in range(int(input()))]: {{completion}},"print(('NO', 'YES')[sum(int(p) for p in (c[:3])) == sum(int(p) for p in (c[3:]))])","a = [int(j) for j in c]
    print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")"
"import sys

def main():
    s = sys.stdin.read().strip().split('\n')[1:]
    r = []
    for i in s:
        {{completion}}
    return r
print(*main(), sep='\n')

","nums = list(map(int, i))
        r.append(('NO', 'YES')[sum(nums[:3]) == sum(nums[3:])])","import sys

def main():
    s = sys.stdin.read().strip().split('\n')[1:]
    r = []
    for i in s:
        a = [int(j) for j in i]
        print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")
    return r
print(*main(), sep='\n')"
"for i in range(int(input())):
    {{completion}}","a = [int(j) for j in input()]
    print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")","a = [int(j) for j in input()]
    print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")"
"t = int(input(""""))
for i in range(t):
    ticket = input("""")
    if int(ticket[0])+int(ticket[1])+int(ticket[2]) == int(ticket[3])+int(ticket[4])+int(ticket[5]):
        print(""YES"")
    else:
        {{completion}}","print(""NO"")","t = int(input(""""))
for i in range(t):
    ticket = input("""")
    if int(ticket[0])+int(ticket[1])+int(ticket[2]) == int(ticket[3])+int(ticket[4])+int(ticket[5]):
        print(""YES"")
    else:
        print(""NO"")"
"s = int(input())
r = []
for i in range(s):
	a = int(input())
	if a // 100000 + a // 10000 % 10 + a // 1000 % 10 == a // 100 % 10 + a % 10 + a // 10 % 10:
		print(""YES"", end="" "")
	else:
		{{completion}}
","print(""NO"", end="" "")","a = int(input())
    print(""YES"" if a // 100000 + a // 10000 % 10 + a // 1000 % 10 == a // 100 % 10 + a % 10 + a // 10 % 10 else ""NO"")"
"n=input()

for i in range(int(n)):  
    sumf=0
    suml=0
    
    s =  input()
    for x in range(0,3):
           sumf += int(s[x])
           
    for x in range(3,6):
        suml += int(s[x])

    if sumf== suml:
        print('YES')
    else:
         {{completion}}
  	 			 		 	 	 	 		   	  						",print('NO'),print('YES')
"for t in range(int(input())):
    {{completion}}","n = list(map(int, list(input())))
    print(""YES"" if n[0]+n[1]+n[2]==n[3]+n[4]+n[5] else ""NO"")","n = list(map(int, list(input())))
    print(""YES"" if n[0]+n[1]+n[2]==n[3]+n[4]+n[5] else ""NO"")"
"t = int(input())

def solve():
  n, m = map(int, input().split())
  A = [list(map(int, input().split())) for _ in range(n)]
  ans = 0
  for i in range(n):
    for j in range(m):
      temp = -A[i][j]
      for x in range(n):
        # i - j == x - y => y = x - i + j
        y = x - i + j
        if 0 <= y < m:
          {{completion}}
        # i + j == x + y
        y = i + j - x
        if 0 <= y < m:
          temp += A[x][y]
      ans = max(ans, temp)
  print(ans)

for _ in range(t):
  solve()",temp += A[x][y],temp += A[x][y]
"t = int(input())

def solve():
  n, m = map(int, input().split())
  A = [list(map(int, input().split())) for _ in range(n)]
  ans = 0
  for i in range(n):
    for j in range(m):
      temp = -A[i][j]
      for x in range(n):
        # i - j == x - y => y = x - i + j
        y = x - i + j
        if 0 <= y < m:
          temp += A[x][y]
        # i + j == x + y
        y = i + j - x
        if 0 <= y < m:
          {{completion}}
      ans = max(ans, temp)
  print(ans)

for _ in range(t):
  solve()",temp += A[x][y],temp += A[x][y]
"k,o=lambda:map(int,input().split()),range
for f in o(*k()):
 n,m=k();a=[[*k()]for t in o(n)];l=[0]*(m+n);r=l[:]
 for i in o(n):
  for j in o(m):{{completion}}
 print(max(l[i-j+m-1]+r[i+j]-a[i][j]for i in o(n)for j in o(m)))",b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b,b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b
"T = int(input())

for tc in range(T):
    (A, B) = map(int, input().split(' '))
    nums = []
    for i in range(A):
        nums.append([int(x) for x in input().split()])


    C = A + B - 1
    left = [0 for _ in range(C)]
    right = [0 for _ in range(C)]
    for a in range(A):
        for b in range(B):
            {{completion}}
    # print (left)
    # print (right)

    damage = 0
    for a in range(A):
        for b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)

    print (damage)
","left_index = a + b
            right_index = a + B - 1 - b
            left[left_index] += nums[a][b]
            right[right_index] += nums[a][b]","left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)"
"T = int(input())

for tc in range(T):
    (A, B) = map(int, input().split(' '))
    nums = []
    for i in range(A):
        nums.append([int(x) for x in input().split()])


    C = A + B - 1
    left = [0 for _ in range(C)]
    right = [0 for _ in range(C)]
    for a in range(A):
        for b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            left[left_index] += nums[a][b]
            right[right_index] += nums[a][b]
    # print (left)
    # print (right)

    damage = 0
    for a in range(A):
        for b in range(B):
            {{completion}}

    print (damage)
","left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)",damage = max(left[i-j+m-1]+right[i+j]-nums[a][b]for i in range(n)for j in range(m))
"import sys
sm_row = [-1, +1, -1, +1]
sm_column = [-1, +1, +1, -1]
for _ in range(int(sys.stdin.readline())):
    n, m = map(int, sys.stdin.readline().split())
    t = []
    maximum = 0
    for i in range(n):
        t.append(list(map(int, sys.stdin.readline().split())))
    for row in range(n):
        for column in range(m):
            summa = 0
            for i in range(4):
                new_row = row
                new_column = column
                while 0 <= new_row < n and 0 <= new_column < m:
                    {{completion}}
            summa -= (t[row][column] * 3)
            maximum = max(maximum, summa)
    print(maximum)
","summa += t[new_row][new_column]
                    new_row += sm_row[i]
                    new_column += sm_column[i]","for i in range(4):
    new_row = row + sm_row[i]
    new_column = column + sm_column[i]
    if 0 <= new_row < n and 0 <= new_column < m:
        summa += t[new_row][new_column]
Replace the ""# TODO: Your code here"" in the code above with the appropriate block. Provide only the replaced block."
"# auther: codeCell
for _ in range(int(input())):
    n,m=map(int,input().split())
    a = [ [*map(int, input().split())] for _ in range(n)]
 
    u = [0]*(n+m-1)
    v = [0]*(n+m-1)
    for i in range(n):
        for j in range(m):
            {{completion}}
    for i in range(n):
        for j in range(m):
            a[i][j] = u[i+j] + v[i-j] - a[i][j]
    print(max(map(max,a)))          



","u[i+j] += a[i][j]
            v[i-j] += a[i][j]",a[i][j] = u[i+j] + v[i-j] - a[i][j]
"# auther: codeCell
for _ in range(int(input())):
    n,m=map(int,input().split())
    a = [ [*map(int, input().split())] for _ in range(n)]
 
    u = [0]*(n+m-1)
    v = [0]*(n+m-1)
    for i in range(n):
        for j in range(m):
            u[i+j] += a[i][j]
            v[i-j] += a[i][j]
    for i in range(n):
        for j in range(m):
            {{completion}}
    print(max(map(max,a)))          



",a[i][j] = u[i+j] + v[i-j] - a[i][j],a[i][j] = u[i+j] + v[i-j] - a[i][j]
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n,m=M();l=[L() for i in range(n)];ans=0
    for i in range(n):
        for j in range(m):
            s=l[i][j]
            p,q=i,j;s-=l[p][q]
            while p>=0 and q>=0:
                {{completion}}
            p,q=i,j;s-=l[p][q]
            while p>=0 and q<m:
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p<n and q>=0:
                s+=l[p][q];p+=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p<n and q<m:
                s+=l[p][q];p+=1;q+=1
            ans=max(ans,s)
    print(ans)",s+=l[p][q];p-=1;q-=1,s+=l[p][q];p-=1;q+=1
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n,m=M();l=[L() for i in range(n)];ans=0
    for i in range(n):
        for j in range(m):
            s=l[i][j]
            p,q=i,j;s-=l[p][q]
            while p>=0 and q>=0:
                s+=l[p][q];p-=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p>=0 and q<m:
                {{completion}}
            p,q=i,j;s-=l[p][q]
            while p<n and q>=0:
                s+=l[p][q];p+=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p<n and q<m:
                s+=l[p][q];p+=1;q+=1
            ans=max(ans,s)
    print(ans)",s+=l[p][q];p-=1;q+=1,s+=l[p][q];p-=1;q+=1
"t=eval(input())

for i in range(t):
    ans=-1
    temp=[int(x) for x in input().split()]
    n,m=temp[0],temp[1] # n*m
    check=[]
    for j in range(n):
        temp=[int(x) for x in input().split()]
        check.append(temp)

    dic_l={}
    dic_r={}

    for x in range(n):
        for y in range(m):
            if x+y not in dic_l:
                dic_l[x+y]=check[x][y]
            else:
                {{completion}}
            if y-x not in dic_r:
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for y in range(m):
            ans=max(ans,dic_l[x+y]+dic_r[y-x]-check[x][y])
    
    print(ans)
            
    ",dic_l[x+y]+=check[x][y],dic_r[y-x]+=check[x][y]
"t=eval(input())

for i in range(t):
    ans=-1
    temp=[int(x) for x in input().split()]
    n,m=temp[0],temp[1] # n*m
    check=[]
    for j in range(n):
        temp=[int(x) for x in input().split()]
        check.append(temp)

    dic_l={}
    dic_r={}

    for x in range(n):
        for y in range(m):
            if x+y not in dic_l:
                dic_l[x+y]=check[x][y]
            else:
                dic_l[x+y]+=check[x][y]
            if y-x not in dic_r:
                dic_r[y-x]=check[x][y]
            else:
                {{completion}}
    
    for x in range(n):
        for y in range(m):
            ans=max(ans,dic_l[x+y]+dic_r[y-x]-check[x][y])
    
    print(ans)
            
    ",dic_r[y-x]+=check[x][y],dic_r[y-x]+=check[x][y]
"def calc(x, y):
    ans = 0
    x1, y1 = x, y
    while x1 > 0 and y1 > 0:
        ans += field[y1 - 1][x1 - 1]
        x1 -= 1
        y1 -= 1
    # print(""OK"", x1, y1)
    x1, y1 = x, y
    x1 += 1
    y1 += 1
    while x1 <= m and y1 <= n:
        ans += field[y1 - 1][x1 - 1]
        x1 += 1
        y1 += 1
    x1, y1 = x, y
    x1 -= 1
    y1 += 1

    while x1 > 0 and y1 <= n:
        ans += field[y1 - 1][x1 - 1]
        x1 -= 1
        y1 += 1
    x1, y1 = x, y
    x1 += 1
    y1 -= 1

    while x1 <= m and y1 > 0:
        ans += field[y1 - 1][x1 - 1]
        x1 += 1
        y1 -= 1
    return ans


for _ in range(int(input())):
    n, m = map(int, input().split())
    field = [list(map(int, input().split())) for _ in range(n)]
    max_sum = -1
    for y in range(n):
        for x in range(m):
            {{completion}}
    print(max_sum)
","max_sum = max(max_sum, calc(x + 1, y + 1))",ans += field[y1 - 1][x1 - 1]
"I,R=lambda:map(int,input().split()),range
for _ in R(*I()):
 n,m=I();a=[[*I()] for _ in R(n)];l=[0]*(m+n);r=l[:]
 for i in R(n):
  for j in R(m):
   {{completion}}
 print(max(l[i-j+m-1]+r[i+j]-a[i][j] for i in R(n) for j in R(m)))",b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b,b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b
"t=int(input())
for p in range(t):
    n,m=map(int,input().split())
    c=[]
    b=[]
    s=0
    for i in range(n):
        a=list(map(int,input().split()))
        b+=[a]
    for k in range(n):
        for l in range(m):
            for v in range(min(l,k)+1):
                {{completion}}
            for w in range(1,min(n-k-1,m-l-1)+1):
                s+=b[k+w][l+w]
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
",s+=b[k-v][l-v],s+=b[k+w][l+w]
"t=int(input())
for p in range(t):
    n,m=map(int,input().split())
    c=[]
    b=[]
    s=0
    for i in range(n):
        a=list(map(int,input().split()))
        b+=[a]
    for k in range(n):
        for l in range(m):
            for v in range(min(l,k)+1):
                s+=b[k-v][l-v]
            for w in range(1,min(n-k-1,m-l-1)+1):
                {{completion}}
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
",s+=b[k+w][l+w],s+=b[k+w][l+w]
"h, w, q = map(int, input().split())
p = [False] * (h * w)

c = cc = 0


def query(y, x):
    global c, cc
    i = x*h+y
    p[i] = not p[i]
    if p[i]:
        if i < c:
            cc += 1
        c += 1
        if p[c-1]:
            cc += 1
    else:
        if i < c:
            {{completion}}
        c -= 1
        if p[c]:
            cc -= 1
    return c - cc


for y in range(h):
    inp = input()
    for x in range(w):
        if inp[x] == '*':
            query(y, x)

for _ in range(q):
    x, y = map(int, input().split())
    print(query(x-1, y-1))
",cc -= 1,cc-=1
"h, w, q = map(int, input().split())
p = [False] * (h * w)

c = cc = 0


def query(y, x):
    global c, cc
    i = x*h+y
    p[i] = not p[i]
    if p[i]:
        if i < c:
            cc += 1
        c += 1
        if p[c-1]:
            cc += 1
    else:
        if i < c:
            cc -= 1
        c -= 1
        if p[c]:
            {{completion}}
    return c - cc


for y in range(h):
    inp = input()
    for x in range(w):
        if inp[x] == '*':
            query(y, x)

for _ in range(q):
    x, y = map(int, input().split())
    print(query(x-1, y-1))
",cc -= 1,cc -= 1
"from sys import stdin
rln=stdin.buffer.readline
rl=lambda:rln().rstrip(b'\r\n').rstrip(b'\n')
ri=lambda:int(rln())
rif=lambda:[*map(int,rln().split())]
rt=lambda:rl().decode()
rtf=lambda:rln().decode().split()
inf=float('inf')
dir4=[(-1,0),(0,1),(1,0),(0,-1)]
dir8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'

m,n,q=rif()
a=[0]*(m*n)
for y in range(m):
  s=rt()
  for x in range(n):
    a[m*x+y]=s[x]=='*'
k=sum(a)
l=sum(a[:k])
for _ in range(q):    
  x,y=rif()
  x,y=x-1,y-1
  i=x+m*y
  if a[i]:
    k-=1
    l-=a[k]
    l-=i<k
    a[i]^=1
  else:
    {{completion}}
  print(k-l)
","a[i]^=1
    l+=i<k
    l+=a[k]
    k+=1",k-=1
"import sys

n, m, k = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(n)]
cnt = 0
for i in range(n):
    for j in range(m):
        cnt += board[i][j] == '*'

clean = 0
q, r = divmod(cnt, n)
for j in range(q):
    for i in range(n):
        clean += board[i][j] == '*'

for i in range(r):
    clean += board[i][q] == '*'

for _ in range(k):
    x, y = map(int, sys.stdin.readline().split())
    x -= 1
    y -= 1
    if board[x][y] == '.':
        board[x][y] = '*'
        cnt += 1
        q, r = divmod(cnt - 1, n)
        if board[r][q] == '*':
            clean += 1
        if n * y + x <= cnt - 1:
            clean += 1
        if (q, r) == (y, x):
            clean -= 1
    else:
        cnt -= 1
        q, r = divmod(cnt, n)
        if board[r][q] == '*':
            {{completion}}
        if n * y + x <= cnt - 1:
            clean -= 1
        board[x][y] = '.'

    print(cnt - clean)
",clean -= 1,clean -= 1
"import sys

n, m, k = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(n)]
cnt = 0
for i in range(n):
    for j in range(m):
        cnt += board[i][j] == '*'

clean = 0
q, r = divmod(cnt, n)
for j in range(q):
    for i in range(n):
        clean += board[i][j] == '*'

for i in range(r):
    clean += board[i][q] == '*'

for _ in range(k):
    x, y = map(int, sys.stdin.readline().split())
    x -= 1
    y -= 1
    if board[x][y] == '.':
        board[x][y] = '*'
        cnt += 1
        q, r = divmod(cnt - 1, n)
        if board[r][q] == '*':
            clean += 1
        if n * y + x <= cnt - 1:
            clean += 1
        if (q, r) == (y, x):
            clean -= 1
    else:
        cnt -= 1
        q, r = divmod(cnt, n)
        if board[r][q] == '*':
            clean -= 1
        if n * y + x <= cnt - 1:
            {{completion}}
        board[x][y] = '.'

    print(cnt - clean)
",clean -= 1,clean -= 1
"
n,m,q = map(int, input().split())
s = [input() for _ in range(n)]
s = [s[j][i] for i in range(m) for j in range(n)]
qrr = [list(map(int, input().split())) for _ in range(q)]
qrr = [n * (q[1] - 1) + q[0] - 1 for q in qrr]
count = s.count('*')
correct = s[:count].count('*')
for q in qrr:
	count += 1 if s[q] == '.' else -1
	if s[q] == '.':
		correct += 1 if q < count else 0
		correct += 1 if s[count-1] == '*' else 0
	else:
		{{completion}}
	print(count - correct)
	s[q] = '.' if s[q] == '*' else '*'
	","correct -= 1 if q < count else 0
		correct -= 1 if s[count] == '*' else 0",correct -= 1
"from itertools import chain
I=lambda:map(int,input().split())
n,m,q=I()
g0=[list(input()) for _ in range(n)]
g=list(chain.from_iterable(zip(*g0)))
tot=g.count('*')
inner=g[:tot].count('*')

for _ in range(q):
  i,j=I()
  p=(j-1)*n+i-1
  if g[p]=='*':
    tot-=1
    #""tide fall""
    if g[tot]=='*':inner-=1
    if p<tot:inner-=1
    g[p]='.'
  else:
    g[p]='*'
    #""tide rise""
    if g[tot]=='*':{{completion}}
    if p<tot:inner+=1
    tot+=1
  print(tot-inner)",inner+=1,inner+=1
"from itertools import chain
I=lambda:map(int,input().split())
n,m,q=I()
g0=[list(input()) for _ in range(n)]
g=list(chain.from_iterable(zip(*g0)))
tot=g.count('*')
inner=g[:tot].count('*')

for _ in range(q):
  i,j=I()
  p=(j-1)*n+i-1
  if g[p]=='*':
    tot-=1
    #""tide fall""
    if g[tot]=='*':inner-=1
    if p<tot:inner-=1
    g[p]='.'
  else:
    g[p]='*'
    #""tide rise""
    if g[tot]=='*':inner+=1
    if p<tot:{{completion}}
    tot+=1
  print(tot-inner)",inner+=1,inner+=1
"n,m,q=map(int,input().split())
z=[] # 2d
a=[] # 1d
c=0 # count icons
ans=0
for i in range(n):
    z.append(list(input()))
for i in range(m):
    for j in range(n):
        if z[j][i]==""*"":
            a.append(1)
            c+=1
        else:
            a.append(0)
ans=c
for i in range(c):
    if a[i]==1:
        ans-=1
for i in range(q):
    x,y=map(int,input().split())
    if a[n*(y-1)+x-1]==1:
        a[n*(y-1)+x-1]=0
        c-=1
        if n*(y-1)+x-1 > c:
            ans-=1
        if a[c]==1:
            ans+=1
    elif a[n*(y-1)+x-1]==0: # xor
        a[n*(y-1)+x-1]=1
        c+=1
        if n*(y-1)+x-1 >= c-1: # c or c-1?
            ans+=1
        if c: # if c>0
            if a[c-1]==1:
                {{completion}}
    print(ans)",ans-=1,ans+=1
"import sys


def solve():
    # n = int(sys.stdin.readline().strip())
    n, m, q = [int(x) for x in sys.stdin.readline().strip().split()]

    a = []
    m = [0] * (m * n)
    for y in range(n):
        s = sys.stdin.readline().strip()
        for x, c in enumerate(s):
            if c == '*':
                a.append(x * n + y)
                m[x * n + y] = 1

    cnt = len(a)
    correct = sum(1 for x in a if x < cnt)

    for _ in range(q):
        y, x = [int(p) for p in sys.stdin.readline().strip().split()]
        y -= 1
        x -= 1
        z = x * n + y
        if m[z] == 0:
            if m[cnt] == 1:
                correct += 1
            m[z] = 1
            cnt += 1
            if z < cnt:
                correct += 1
        else:
            cnt -= 1
            if m[cnt] == 1:
                {{completion}}
            m[z] = 0
            if z < cnt:
                correct -= 1
        # print(f""cnt={cnt} cor={correct}"")
        print(cnt - correct)

# t = int(sys.stdin.readline().strip())
t = 1
for _ in range(t):
    solve()
",correct -= 1,correct -= 1
"import sys


def solve():
    # n = int(sys.stdin.readline().strip())
    n, m, q = [int(x) for x in sys.stdin.readline().strip().split()]

    a = []
    m = [0] * (m * n)
    for y in range(n):
        s = sys.stdin.readline().strip()
        for x, c in enumerate(s):
            if c == '*':
                a.append(x * n + y)
                m[x * n + y] = 1

    cnt = len(a)
    correct = sum(1 for x in a if x < cnt)

    for _ in range(q):
        y, x = [int(p) for p in sys.stdin.readline().strip().split()]
        y -= 1
        x -= 1
        z = x * n + y
        if m[z] == 0:
            if m[cnt] == 1:
                correct += 1
            m[z] = 1
            cnt += 1
            if z < cnt:
                correct += 1
        else:
            cnt -= 1
            if m[cnt] == 1:
                correct -= 1
            m[z] = 0
            if z < cnt:
                {{completion}}
        # print(f""cnt={cnt} cor={correct}"")
        print(cnt - correct)

# t = int(sys.stdin.readline().strip())
t = 1
for _ in range(t):
    solve()
",correct -= 1,correct -= 1
"
from collections import deque

n,m=[int(x) for x  in input().split()]
g=[[] for _ in range(n)]
indeg=[0]*n
outdeg=[0]*n
tpdeg=[0]*n
for _ in range(m):
    v,u=[int(x) for x  in input().split()]
    v-=1
    u-=1
    g[v].append(u)
    outdeg[v]+=1
    indeg[u]+=1
    tpdeg[u]+=1


q=deque(i for i in range(n) if indeg[i]==0)
f=[1]*n

while q:
    u=q.popleft()

    for v in g[u]:
        if indeg[v]>1 and outdeg[u]>1:
            {{completion}}
        tpdeg[v] -= 1
        if tpdeg[v]==0:
            q.append(v)


print(max(f))



","f[v]=max(f[v],f[u]+1)",q.append(v)
"
from collections import deque

n,m=[int(x) for x  in input().split()]
g=[[] for _ in range(n)]
indeg=[0]*n
outdeg=[0]*n
tpdeg=[0]*n
for _ in range(m):
    v,u=[int(x) for x  in input().split()]
    v-=1
    u-=1
    g[v].append(u)
    outdeg[v]+=1
    indeg[u]+=1
    tpdeg[u]+=1


q=deque(i for i in range(n) if indeg[i]==0)
f=[1]*n

while q:
    u=q.popleft()

    for v in g[u]:
        if indeg[v]>1 and outdeg[u]>1:
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if tpdeg[v]==0:
            {{completion}}


print(max(f))



",q.append(v),"f[v]=max(f[v],f[u]+1)"
"
def iint():
    return int(input().strip())

def iints():
    return map(int, input().strip().split("" ""))

def arr():
    return list(input().strip().split("" ""))

def arri():
    return list(iints())

n,m = iints()

class Graph:
    def __init__(self, n):
        self.adj = [[] for _ in range(n)]
        self.ins = [0 for _ in range(n)]
        self.outs = [0 for _ in range(n)]
    def add(self, a, b):
        self.adj[a].append(b)
        self.ins[b]+=1
        self.outs[a]+=1

g = Graph(n)
ins2 = [0 for _ in range(n)]
for _ in range(m):
    a,b = iints()
    a-=1
    b-=1
    g.add(a,b)
    ins2[b]+=1


order = [0 for _ in range(n)]
f = 0
b = 0
for i in range(n):
    if not ins2[i]:
        order[b] = i
        b+=1
dp = [1 for _ in range(n)]
ans = 0
while f < n:
    cur = order[f]
    f += 1
    for x in g.adj[cur]:
        ins2[x] -= 1
        if not ins2[x]:
            {{completion}}
        if g.ins[x] > 1 and g.outs[cur] > 1:
            dp[x] = max(dp[x], 1 + dp[cur])
    ans = max(ans, dp[cur])
print(ans)
","order[b] = x
            b += 1","dp[x] = max(dp[x], 1 + dp[cur])"
"
def iint():
    return int(input().strip())

def iints():
    return map(int, input().strip().split("" ""))

def arr():
    return list(input().strip().split("" ""))

def arri():
    return list(iints())

n,m = iints()

class Graph:
    def __init__(self, n):
        self.adj = [[] for _ in range(n)]
        self.ins = [0 for _ in range(n)]
        self.outs = [0 for _ in range(n)]
    def add(self, a, b):
        self.adj[a].append(b)
        self.ins[b]+=1
        self.outs[a]+=1

g = Graph(n)
ins2 = [0 for _ in range(n)]
for _ in range(m):
    a,b = iints()
    a-=1
    b-=1
    g.add(a,b)
    ins2[b]+=1


order = [0 for _ in range(n)]
f = 0
b = 0
for i in range(n):
    if not ins2[i]:
        order[b] = i
        b+=1
dp = [1 for _ in range(n)]
ans = 0
while f < n:
    cur = order[f]
    f += 1
    for x in g.adj[cur]:
        ins2[x] -= 1
        if not ins2[x]:
            order[b] = x
            b += 1
        if g.ins[x] > 1 and g.outs[cur] > 1:
            {{completion}}
    ans = max(ans, dp[cur])
print(ans)
","dp[x] = max(dp[x], 1 + dp[cur])","order[b] = x
            b += 1"
"import sys
from collections import deque

n, m = map(int, sys.stdin.readline().split())
inv = [0] * (n + 1)
outv = [0] * (n + 1)
graph = [[] for _ in range(n + 1)]
reverse = [[] for _ in range(n + 1)]
for _ in range(m):
    v, u = map(int, sys.stdin.readline().split())
    graph[v].append(u)
    reverse[u].append(v)
    inv[u] += 1
    outv[v] += 1

dp = [0] * (n + 1)
dq = deque()
for i in range(1, n + 1):
    if outv[i] == 0:
        dq.append(i)

while dq:
    cur = dq.popleft()
    if len(graph[cur]) == 1:
        dp[cur] = 1
    else:
        res = 0
        for nxt in graph[cur]:
            if inv[nxt] > 1:
                {{completion}}
        dp[cur] = res + 1
    
    for prv in reverse[cur]:
        outv[prv] -= 1
        if outv[prv] == 0:
            dq.append(prv)

print(max(dp))","res = max(res, dp[nxt])","dp[nxt] = max(dp[nxt], dp[cur] + 1)"
"import sys
input = sys.stdin.readline
import math

for _ in range(1):
    n, m = map(int, input().split())
    g = [[] for i in range(n)]
    deg = [0] * n
    in_deg = [0] * n
    out_deg = [0] * n
    for i in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        g[x].append(y)
        deg[y] += 1
        out_deg[x] += 1
        in_deg[y] += 1
    order = []
    for i in range(n):
        if deg[i] == 0:
            order.append(i)
    for i in range(n):
        for to in g[order[i]]:
            deg[to] -= 1
            if deg[to] == 0:
                {{completion}}
    dp = [1] * n
    for i in order:
        for j in g[i]:
            if in_deg[j] > 1 and out_deg[i] > 1:
                dp[j] = max(dp[j], dp[i] + 1)
    print(max(dp))",order.append(to),"dp[j] = max(dp[j], dp[i] + 1)"
"import sys
input = sys.stdin.readline
import math

for _ in range(1):
    n, m = map(int, input().split())
    g = [[] for i in range(n)]
    deg = [0] * n
    in_deg = [0] * n
    out_deg = [0] * n
    for i in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        g[x].append(y)
        deg[y] += 1
        out_deg[x] += 1
        in_deg[y] += 1
    order = []
    for i in range(n):
        if deg[i] == 0:
            order.append(i)
    for i in range(n):
        for to in g[order[i]]:
            deg[to] -= 1
            if deg[to] == 0:
                order.append(to)
    dp = [1] * n
    for i in order:
        for j in g[i]:
            if in_deg[j] > 1 and out_deg[i] > 1:
                {{completion}}
    print(max(dp))","dp[j] = max(dp[j], dp[i] + 1)","































































































































"
"from collections import deque
I=lambda:map(int,input().split())
n,m=I()
g=[[]for _ in range(n)]
din,dout,dcur=[0]*n,[0]*n,[0]*n
for _ in range(m):
  u,v=I()
  u,v=u-1,v-1
  g[u].append(v)
  dout[u]+=1;din[v]+=1;dcur[v]+=1
  
q=deque([i for i,d in enumerate(din) if d==0])
f=[1]*n
while q:
  u=q.popleft()
  for v in g[u]:
    if dout[u]>1 and din[v]>1:
      {{completion}}
    dcur[v]-=1
    if dcur[v]==0:q.append(v)
print(max(f))
","f[v]=max(f[v],f[u]+1)","f[v]=max(f[v],f[u]+1)"
"from collections import deque
I=lambda:map(int,input().split())
n,m=I()
g=[[]for _ in range(n)]
din,dout,dcur=[0]*n,[0]*n,[0]*n
for _ in range(m):
  u,v=I()
  u,v=u-1,v-1
  g[u].append(v)
  dout[u]+=1;din[v]+=1;dcur[v]+=1
  
q=deque([i for i,d in enumerate(din) if d==0])
f=[1]*n
while q:
  u=q.popleft()
  for v in g[u]:
    if dout[u]>1 and din[v]>1:
      f[v]=max(f[v],f[u]+1)
    dcur[v]-=1
    if dcur[v]==0:{{completion}}
print(max(f))
",q.append(v),"f[v]=max(f[v],f[u]+1)"
"N=int(input())
A=[int(x) for x in input().split()]
B=sorted(A)
ans=-(-B[0]//2)-(-B[1]//2)
for i in range(N-2):
  {{completion}}
for i in range(N-1):
  score=max(-(-(A[i]+A[i+1])//3),-(-A[i]//2),-(-A[i+1]//2))
  ans=min(score,ans)
print(ans)  ","ans=min(ans,-(-(A[i]+A[i+2])//2))","score=max(-(-(A[i]+A[i+1])//3),-(-A[i]//2),-(-A[i+1]//2))
  ans=min(score,ans)"
"N=int(input())
A=[int(x) for x in input().split()]
B=sorted(A)
ans=-(-B[0]//2)-(-B[1]//2)
for i in range(N-2):
  ans=min(ans,-(-(A[i]+A[i+2])//2))
for i in range(N-1):
  {{completion}}
print(ans)  ","score=max(-(-(A[i]+A[i+1])//3),-(-A[i]//2),-(-A[i+1]//2))
  ans=min(score,ans)","ans=min(ans,-(-(A[i]+A[i+2])//2))"
"def onagr(x, y):
    x, y = max(x, y), min(x, y)
    if x >= 2 * y:
        res = (x + 1) // 2
    else:
        res = x - y + (2 * y - x) // 3 * 2 + (2 * y - x) % 3
    return res


def onagr1(x, y):
    return min(x, y) + (abs(x - y) + 1) // 2


n = int(input())
m1, m2, *a = list(map(int, input().split()))
if n == 2:
    print(onagr(m1, m2))
else:
    p = m2
    pp = m1
    r1 = onagr1(m1, a[0])
    if m2 < m1:
        m1, m2 = m2, m1
    r = onagr(m1, m2)
    for k in a:
        if k < m1:
            m2 = m1
            m1 = k
        elif k < m2:
            {{completion}}
        r = min(r, onagr(k, p))
        r1 = min(r1, onagr1(k, pp))
        pp = p
        p = k
    print(min((m1 + 1) // 2 + (m2 + 1) // 2, r, r1))
",m2 = k,"this is the start of the ground truth
def onagr(x, y):
    x, y = max(x, y), min(x, y)
    if x >= 2 * y:
        res = (x + 1) // 2
    else:
        res = x - y + (2 * y - x) // 3 * 2 + (2 * y - x) % 3
    return res


def onagr1(x, y):
    return min(x, y)"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
n=I();a=L()
b=sorted(a)[:2]
ans=math.ceil(b[0]/2)+math.ceil(b[1]/2)
for i in range(n-2):
    ans=min(ans,math.ceil((a[i]+a[i+2])/2))
for i in range(n-1):
    x=max(a[i],a[i+1]);y=min(a[i],a[i+1])
    if x>=2*y:ans=min(ans,math.ceil(x/2))
    else:{{completion}}
print(ans)","ans=min(ans,math.ceil((4*y-2*x)/3)+x-y)","ans=min(ans,math.ceil((a[i]+a[i+1])/2))"
"n=int(input())
arr=list(map(int,input().split()))
ans=float(""inf"")
 
y=sorted(arr)
ans = ((y[0]+1)//2) + ((y[1]+1)//2)
for i in range(len(arr)-1):
    ans=min(ans,max((arr[i]+1)//2,(arr[i+1]+1)//2,(arr[i]+arr[i+1]+2)//3))
    
for i in range(len(arr)-2):
    if arr[i]<=arr[i+2]:
        ans = min(ans,arr[i]+(arr[i+2]-arr[i]+1)//2)
    else:
        {{completion}}
 
print(ans)
","ans = min(ans,arr[i+2]+(arr[i]-arr[i+2]+1)//2)","ans = min(ans,max((arr[i]+1)//2,(arr[i+1]+1)//2,(arr[i]+arr[i+1]+2)//3))"
"import sys

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
x, y = sorted(arr)[:2]
ans = (x + 1) // 2 + (y + 1) // 2

for i in range(n - 2):
    x, y = arr[i], arr[i + 2]
    if (x % 2 == 1) and (y % 2 == 1):
        x -= 1
        y -= 1
        ans = min(ans, (x + 1) // 2 + (y + 1) // 2 + 1)
    else:
        {{completion}}

for i in range(n - 1):
    x, y = arr[i], arr[i + 1]
    if x > y:
        x, y = y, x
    
    if y >= 2 * x:
        ans = min(ans, (y + 1) // 2)
    else:
        res = y - x
        x -= res
        y -= 2 * res
        tmp = x // 3
        res += 2 * tmp
        x -= 3 * tmp
        ans = min(ans, res + x)

print(ans)","ans = min(ans, (x + 1) // 2 + (y + 1) // 2)","































































































































"
"import sys

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
x, y = sorted(arr)[:2]
ans = (x + 1) // 2 + (y + 1) // 2

for i in range(n - 2):
    x, y = arr[i], arr[i + 2]
    if (x % 2 == 1) and (y % 2 == 1):
        x -= 1
        y -= 1
        ans = min(ans, (x + 1) // 2 + (y + 1) // 2 + 1)
    else:
        ans = min(ans, (x + 1) // 2 + (y + 1) // 2)

for i in range(n - 1):
    x, y = arr[i], arr[i + 1]
    if x > y:
        x, y = y, x
    
    if y >= 2 * x:
        ans = min(ans, (y + 1) // 2)
    else:
        {{completion}}

print(ans)","res = y - x
        x -= res
        y -= 2 * res
        tmp = x // 3
        res += 2 * tmp
        x -= 3 * tmp
        ans = min(ans, res + x)","ans=min(ans,(x+1)//2+(y+1)//2)"
"import math
n = int(input())
s = list(int(i) for i in input().split())
min1 = 10000000
for i in range(n-1):
    a, b = (s[i], s[i+1]) if s[i] < s[i+1] else (s[i + 1], s[i])
    if b > a * 2:
        min1 = min(min1, math.ceil(b/2))
    else:
        {{completion}}
for i in range(n-2):
    a, b = ((s[i], s[i + 2]) if s[i] < s[i + 2] else (s[i + 2], s[i]))
    min1 = min(min1, math.ceil(a // 2 + b // 2 + (0 if a % 2 == 0 and b % 2 == 0 else 1)))
min2 = math.ceil(min(s) / 2)
s.remove(min(s))
min3 = math.ceil(min(s) / 2)
min1 = min(min1, min2 + min3)
print(min1)

","min1 = min(min1, math.ceil((a + b) / 3))","min1 = min(min1, math.ceil(b/2))"
"from math import ceil


def cal(a,b):
    if a>b:
        a,b=b,a
    if a>b//2:
        return ceil((a+b)/3)
    else:
        {{completion}}

def cal2(a,b,c):
    if a%2==1 or c%2==1:
        return a//2+c//2+1
    return a//2+b//2


n=int(input())
l=list(map(int,input().split()))
t=sorted(l)
ans=ceil(t[0]/2)+ceil(t[1]/2)
for i in range(1,n):
    ans=min(ans,cal(l[i],l[i-1]))
    if i+1<n:
        ans=min(ans,cal2(l[i-1],l[i],l[i+1]))
print(ans)

",return ceil(b/2),"ans=min(ans,ceil((l[i]+l[i+1])/2))"
"N, A = int(input()), list(map(int, input().split()))
c = 1000000
for i in range(N-2):
    prev = c
    c = min(c, max(A[i], A[i+2]))
    if A[i]%2 == A[i+2]%2 == 1: c=min(c, (A[i]//2)+(A[i+2]//2)+1)

for i in range(N-1):
    x = min(A[i], A[i+1])
    y = A[i]+A[i+1]-x

    if min(A[i], A[i+1]) <= (max(A[i], A[i+1])+1)//2: c = min(c, (max(A[i], A[i+1])+1)//2)
    else: {{completion}}

X = sorted(A)
c = min(c, ((X[0]+1)//2)+((X[1]+1)//2))

print(c)","c = min(c, (A[i]+A[i+1]+2)//3)","c = min(c, ((X[0]+1)//2)+((X[1]+1)//2))"
"import sys
sys.setrecursionlimit(10000)
 
def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))
 
def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)
 
 
def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases
 
 
 
 
 
 
 
def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if used.get(an[pa],0)<=0:
                {{completion}}
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            used[prv]=used.get(prv,0)+1
        prv=c
    return True
 
 
 
 
 
 
def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""
 
 
def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    
 
process()
",return False,"used[prv]=used.get(prv,0)+1"
"import sys
sys.setrecursionlimit(10000)
 
def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))
 
def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)
 
 
def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases
 
 
 
 
 
 
 
def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if used.get(an[pa],0)<=0:
                return False
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            {{completion}}
        prv=c
    return True
 
 
 
 
 
 
def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""
 
 
def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    
 
process()
","used[prv]=used.get(prv,0)+1",return False
"import sys
sys.setrecursionlimit(10000)

def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))

def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)


def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases







def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if used.get(an[pa],0)<=0:
                {{completion}}
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            used[prv]=used.get(prv,0)+1
        prv=c
    return True






def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""


def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    

process()",return False,"used[prv]=used.get(prv,0)+1"
"import sys
sys.setrecursionlimit(10000)

def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))

def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)


def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases







def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if used.get(an[pa],0)<=0:
                return False
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            {{completion}}
        prv=c
    return True






def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""


def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    

process()","used[prv]=used.get(prv,0)+1",return False
"import sys;input=sys.stdin.readline

I=lambda:map(int,input().split())
n, q = I()
s = input()
pre0,pre1 = [0]*n,[0]*n
for i in range(1,n):
  c1,c2=s[i-1],s[i]
  pre0[i],pre1[i] = pre0[i-1],pre1[i-1]
  if c1 == c2 == '0':pre0[i]+=1
  elif c1 == c2 == '1':{{completion}}
for _ in range(q):
  l,r=I()
  print(max(pre0[r-1]-pre0[l-1], pre1[r-1]-pre1[l-1])+1)",pre1[i]+=1,pre1[i] = pre1[i - 1]
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

n, q = I()
s = input()
ones = [0, 0]
zeroes = [0, 0]
for i in range(1, n):
	if s[i] == s[i - 1] == '0':
		zeroes.append(zeroes[-1] + 1)
	else:
		{{completion}}
	if s[i] == s[i - 1] == '1':
		ones.append(ones[-1] + 1)
	else:
		ones.append(ones[-1])
for i in range(q):
	l, r = I()
	o = ones[r] - ones[l]
	z = zeroes[r] - zeroes[l]
	print(max(o, z) + 1)",zeroes.append(zeroes[-1]),"































































































































"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

n, q = I()
s = input()
ones = [0, 0]
zeroes = [0, 0]
for i in range(1, n):
	if s[i] == s[i - 1] == '0':
		zeroes.append(zeroes[-1] + 1)
	else:
		zeroes.append(zeroes[-1])
	if s[i] == s[i - 1] == '1':
		ones.append(ones[-1] + 1)
	else:
		{{completion}}
for i in range(q):
	l, r = I()
	o = ones[r] - ones[l]
	z = zeroes[r] - zeroes[l]
	print(max(o, z) + 1)",ones.append(ones[-1]),zeroes.append(zeroes[-1])
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 998244353
r, c = I()
rows = []
for i in range(r):
	rows.append([*input()])
if r % 2 == 0 and c % 2 == 0:
	blanks = 0
	for i in range(r):
		blanks += rows[i].count('?')
	print(pow(2, blanks, M))
elif r % 2 + c % 2 == 1:
	if r % 2 == 1:
		nrows = []
		for i in range(c):
			nrows.append([rows[j][i] for j in range(r)])
		rows = nrows
	ones = 1
	zeroes = 1
	for row in rows:
		unk = 0
		xor = 0
		for char in row:
			if char == '?':
				unk += 1
			elif char == '1':
				xor = 1 - xor
		if unk == 0:
			if xor == 1:
				zeroes = 0
			else:
				ones = 0
		else:
			zeroes = zeroes * pow(2, unk - 1, M) % M
			ones = ones * pow(2, unk - 1, M ) % M
	print((ones + zeroes) % M)
else:
	RC = [0] * (r + c)
	edges = [[] for i in range(r + c)]
	for i in range(r):
		for j in range(c):
			char = rows[i][j]
			if char == '?':
				edges[i].append(j + r)
				edges[j + r].append(i)
			elif char == '1':
				RC[i] = 1 - RC[i]
				RC[r + j] = 1 - RC[r + j]
	seen = [0] * (r + c)
	zeroes = []
	ones = []
	for i in range(r + c):
		if not seen[i]:
			component = [i]
			seen[i] = 1
			j = 0
			while j < len(component):
				if len(component) == r + c:
					break
				for v in edges[component[j]]:
					if not seen[v]:
						{{completion}}
				j += 1
			n = len(component)
			m = 0
			x = 0
			for v in component:
				m += len(edges[v])
				x ^= RC[v]
			m //= 2
			if n % 2 == 0:
				if x == 0:
					y = pow(2, m - n + 1, M)
					zeroes.append(y)
					ones.append(y)
				else:
					print(0)
					exit()
			else:
				y = pow(2, m - n + 1, M)
				if x == 0:
					zeroes.append(y)
					ones.append(0)
				else:
					ones.append(y)
					zeroes.append(0)
	zs = 1
	for g in zeroes:
		zs = zs * g % M
	os = 1
	for g in ones:
		os = os * g % M
	print((zs + os) % M)","seen[v] = 1
						component.append(v)","ones.append(y)
					zeroes.append(0)"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 998244353
r, c = I()
rows = []
for i in range(r):
	rows.append([*input()])
if r % 2 == 0 and c % 2 == 0:
	blanks = 0
	for i in range(r):
		blanks += rows[i].count('?')
	print(pow(2, blanks, M))
elif r % 2 + c % 2 == 1:
	if r % 2 == 1:
		nrows = []
		for i in range(c):
			nrows.append([rows[j][i] for j in range(r)])
		rows = nrows
	ones = 1
	zeroes = 1
	for row in rows:
		unk = 0
		xor = 0
		for char in row:
			if char == '?':
				unk += 1
			elif char == '1':
				xor = 1 - xor
		if unk == 0:
			if xor == 1:
				zeroes = 0
			else:
				ones = 0
		else:
			zeroes = zeroes * pow(2, unk - 1, M) % M
			ones = ones * pow(2, unk - 1, M ) % M
	print((ones + zeroes) % M)
else:
	RC = [0] * (r + c)
	edges = [[] for i in range(r + c)]
	for i in range(r):
		for j in range(c):
			char = rows[i][j]
			if char == '?':
				edges[i].append(j + r)
				edges[j + r].append(i)
			elif char == '1':
				RC[i] = 1 - RC[i]
				RC[r + j] = 1 - RC[r + j]
	seen = [0] * (r + c)
	zeroes = []
	ones = []
	for i in range(r + c):
		if not seen[i]:
			component = [i]
			seen[i] = 1
			j = 0
			while j < len(component):
				if len(component) == r + c:
					break
				for v in edges[component[j]]:
					if not seen[v]:
						seen[v] = 1
						component.append(v)
				j += 1
			n = len(component)
			m = 0
			x = 0
			for v in component:
				m += len(edges[v])
				x ^= RC[v]
			m //= 2
			if n % 2 == 0:
				if x == 0:
					y = pow(2, m - n + 1, M)
					zeroes.append(y)
					ones.append(y)
				else:
					print(0)
					exit()
			else:
				y = pow(2, m - n + 1, M)
				if x == 0:
					zeroes.append(y)
					ones.append(0)
				else:
					{{completion}}
	zs = 1
	for g in zeroes:
		zs = zs * g % M
	os = 1
	for g in ones:
		os = os * g % M
	print((zs + os) % M)","ones.append(y)
					zeroes.append(0)","seen[v] = 1
					component.append(v)"
"for _ in range(int(input())):
    n = int(input())
    a = b = 0
    c = '-'
    for x, y in zip(*[iter(input())]*2):
        if x != y:
            a += 1
        else:
            {{completion}}
    print(a, max(1, b))","b += x != c
            c = x",b+=1
"
inp = [*open(0)]

for s in inp[2::2]:
    s = s.strip()
    res = 0
    mseg = 1
    prebit = None
    for i in range(len(s) // 2):
        if s[2*i] != s[2*i+1]:
            res += 1
        else:
            if prebit is None:
                prebit = s[2*i]
            else:
                {{completion}}

    print(res, mseg)
","mseg += 1 if s[2*i] != prebit else 0
                prebit = s[2*i]",prebit = s[2*i]
"
for _ in range(int(input().strip())):
    n = int(input().strip())
    arr = input()
    ans = 0
    t = []
    for i in range(0, len(arr), 2):
        if arr[i] != arr[i + 1]:
            ans += 1
        else:
            {{completion}}
    seg = 1
    for i in range(0, len(t) - 1):
        if t[i] != t[i + 1]:
            seg += 1
    print(ans, seg)
",t.append(arr[i]),t.append(int(arr[i]))
"import sys

input=sys.stdin.readline

for _ in range(int(input())):
    n=int(input())
    s=input()
    x,y,Lf=0,0,-1
    for i in range(0,n,2):
        if(s[i]!=s[i+1]):
            x+=1
        else:
            if(Lf!=s[i]):
                {{completion}}
            Lf=s[i]
    print(x,max(y,1))",y+=1,y+=1
"for _ in range(int(input())):
    n = int(input())
    l = [[], []]
    for x, y in zip(*[iter(input())]*2):
        {{completion}}
    print(len(l[0]), sum(map(lambda x : x[0] ^ x[1], zip(l[1], l[1][1:]))) + 1)",l[x==y].append(int(x)),"l[0].append(x)
l[1].append(y)"
"def solve(s):
	res = 0
	seg = 0
	prev = -1
	allDiff = True
	for i in range(1,len(s),2):
		if s[i] == s[i-1]:
			allDiff = False
			if prev != s[i]: {{completion}}
			prev = s[i]
		else:
			res += 1
	if allDiff: seg += 1
	print(res,seg)


if __name__ == ""__main__"":
	t = int(input())
	while t:
		n= int(input())
		s = input()
		solve(s)
		t -= 1

",seg += 1,prev = s[i]
"for _ in range(int(input())):
	{{completion}}","n,s=int(input()),input()
	print(sum([1 for i in range(1,n,2) if s[i]!=s[i-1]]))","for _ in range(int(input())):
    n=int(input())
    a=input()
    count=0
    for k in range(n//2):
        if(a[2*k]!=a[2*k+1]):
            count+=1
    print(count)"
"import re
for s in[*open(0)][2::2]:
 i=p=r=0
 for t in re.findall('0+|1+',s):
  i+=1
  if len(t)&1:
   if p:r+=i-p;p=0
   else:{{completion}}
 print(r)",p=i,p+=1
"t=int(input(""""))
for z in range(t):
    n=int(input(""""))
    a=input("""")
    s=[]
    for i in range(0,len(a)-1,2):
        {{completion}}

    b=s.count('10')
    c=s.count('01')
    print(b+c)","ab=a[i]+a[i+1]
        s.append(ab)","s.append('10')
s.append('01')"
"def func(s):
    curr=s[0]
    c=0
    count=0
    for i in s:
        if i==curr:
            c+=1
        elif c%2==0:
            {{completion}}
        else:
            curr=i
            c=2
            count+=1
    return count

for i in range(int(input())):
    n=int(input())
    print(func(input()))
","c=1
            curr=i
            continue",c=2
"def func(s):
    curr=s[0]
    c=0
    count=0
    for i in s:
        if i==curr:
            c+=1
        elif c%2==0:
            c=1
            curr=i
            continue
        else:
            {{completion}}
    return count

for i in range(int(input())):
    n=int(input())
    print(func(input()))
","curr=i
            c=2
            count+=1","c=1
            curr=i
            continue"
"for _ in range(int(input())):
	input()
	inp, count = input(), 0
	for i in range(0, len(inp), 2):
		if (inp[i] != inp[i+1]):
			{{completion}}
	print(count)",count += 1,count+=1
"t = int(input())
for _ in range(t):
    _, s = input(), input()
    res, i, c = 0, 0, 0
    while i < len(s):
        d = s[i]
        while i < len(s) and s[i] == d:
            {{completion}}
        c = c & 1
        res += 1 if c else 0
    print(res)
","c += 1
            i += 1","if(s[i]!=s[i-1]):
    c=1"
"t=int(input())
for i in range (t):
    n=int(input())
    a=input()
    count=0
    for k in range(n//2):
        if(a[2*k]!=a[2*k+1]):
            {{completion}}
    print(count)
",count+=1,count+=1
"from itertools import groupby
t = int(input())

while t:
    t-=1

    n = int(input())
    s = input()
    o = [len("""".join(g))&1 for _,g in groupby(s)]

    l = -1
    res = 0

    for i, o_ in enumerate(o):
        if o_:
            if l == -1:
                l = i
            else:
                {{completion}}
    print(res)","res += i-l
                l = -1","if l!= -1:
        res += 1
        l = -1
        for i in range(n):
            if s[i]!= s[i-1]:
                if l == -1:
                    l = i
                else:
                    res += 1
                    l = -1

    print(res)"
"n=int(input(""""))
t=0
while(t<n):
    t+=1
    length=int(input(""""))
    s=input("""")
    count=0
    for i in range(1, length, 2):
        if s[i]!=s[i-1]:
            {{completion}}
    print(count)
",count+=1,count+=1
"for t in range(int(input())):
    {{completion}}","n = int(input()); a = [*map(int,input().split())]
    print(n+(-a.count(0) or len(set(a))==n))","def solve():
    n=int(input())
    a=[*map(int,input().split())]
    return n-a.count(0)+(0 not in a and len(a)==len(set(a)))"
"for n in [*open(0)][2::2]:
    *a,=map(int,n.split());b=len(a);c=a.count(0)
    while a:
        q=a.pop()
        if a.count(q)>0:
            {{completion}}
    print(b+(a==[])*(c==0)-c)
",break,"n=int(input())
 a=[*map(int,input().split())]
 print(n-a.count(0)+(0 not in a and len(a)==len(set(a))))"
"def solve():
    {{completion}}
T=int(input())
for i in range(T):
    print(solve())","N=int(input())
    A=sorted(list(map(int,input().split())))
    return sum([i>0 for i in A])+all([i>0 for i in A])*all([A[i]<A[i+1] for i in range(N-1)])","































































































































"
"def solve():
    N=int(input())
    A=sorted(list(map(int,input().split())))
    return sum([i>0 for i in A])+all([i>0 for i in A])*all([A[i]<A[i+1] for i in range(N-1)])
T=int(input())
for i in range(T):
    {{completion}}",print(solve()),"































































































































"
"t=int(input())
for _ in range(t):
    n=int(input())
    ar=list(map(int,input().split()))
    z=[0]*110
    for x in range(n):
        z[ar[x]]+=1 
    eq=False
    for x in range(110):
        if z[x]>1:
            {{completion}}
    if z[0]>0:
        print(n-z[0])
    elif eq:
        print(n)
    else:
        print(n+1)",eq=True,"
this is the start of the ground truth
n=int(input())
    a=list(map(int,input().split()))
    z=[0]*110
    for x in range(n):
        z[a[x]]+=1
    if z[0]>0:
        print(n-z[0])
    elif z[0]==0 and z[1]==0:
        print(n+1)
    else:
        print(n+z[0])

"
"for j in range(int(input())):
	h = int(input())
	a = list(map(int,input().split()))
	if 0 in a:
		print(h - a.count(0))
	else:
		if len(set(a)) < len(a):
			print(len(a))
		else:
			{{completion}}",print(len(a)+1),print(h-a.count(0))
"for i in range(int(input())):
    n = int(input())
    s = input().split()
    if s.count(""0""):
        print(n-s.count(""0""))
    else:
        for i in s:
            if s.count(i)>1:
                {{completion}}
        else:
            print(n+1)","print(n)
                break",print(len(s)+1)
"import sys
input = sys.stdin.readline
def getInts(): return map(int, input().split())


def solve():
    input()
    a = [*getInts()]
    if 0 in a:
        print(len(a) - a.count(0))
    else:
        {{completion}}


for _ in range(int(input())):
    solve()
","s = set(a)
        print(len(a) + (len(a) == len(s)))","N=int(input())
    A=sorted(list(map(int,input().split())))
    return sum([i>0 for i in A])+all([i>0 for i in A])*all([A[i]<A[i+1] for i in range(N-1)])"
"test=int(input())
while test:
    test-=1
    n=int(input())
    arr=[int(x) for x in input().split()]
    zero=0
    s=set(arr)
    for i in arr:
        if i==0:
            {{completion}}
    if zero:
        print(n-zero)
    elif len(s)==n:
        print(n+1)
    else:
        print(n)
",zero+=1,"n=int(input())
 a=[*map(int,input().split())]
 print(n-a.count(0)+(0 not in a and len(a)==len(set(a))))"
"for _ in[0]*int(input()):
 {{completion}}","n=int(input())
 a=[*map(int,input().split())]
 print(n-a.count(0)+(0 not in a and len(a)==len(set(a))))","































































































































"
"import sys

def diff_ops(arr):
    result = True
    for i in range(1, len(arr)):
        {{completion}}
    return result

if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    len_input = len(input_arr)
    n = input_arr[0]
    test_cases = []
    pos = 1
    while pos <= len_input - 1:
        case_len = input_arr[pos]
        test_cases.append(input_arr[pos + 1: pos + 1 + case_len])
        pos += case_len + 1
    for case in test_cases:
        print(""YES"" if diff_ops(case) else ""NO"")

",result = result and arr[i] % arr[0] == 0,"for i in range(1, len(arr)):
    arr[i] -= arr[i - 1]"
"import sys

def diff_ops(arr):
    result = True
    for i in range(1, len(arr)):
        result = result and arr[i] % arr[0] == 0
    return result

if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    len_input = len(input_arr)
    n = input_arr[0]
    test_cases = []
    pos = 1
    while pos <= len_input - 1:
        {{completion}}
    for case in test_cases:
        print(""YES"" if diff_ops(case) else ""NO"")

","case_len = input_arr[pos]
        test_cases.append(input_arr[pos + 1: pos + 1 + case_len])
        pos += case_len + 1",result = result and arr[i] % arr[0] == 0
"n, k = map(int, input().split())
answer = [0] * (n + 1)
dp = [1] + [0] * n
MIN = 0
while MIN + k <= n:
    mod = [0 for _ in range(k)]
    for i in range(MIN, n + 1):
        {{completion}}
    MIN += k
    k += 1
print(*answer[1:])","dp[i], mod[i % k] = mod[i % k], dp[i] + mod[i % k]
        mod[i % k] %= 998244353
        answer[i] += dp[i]
        answer[i] %= 998244353","mod[i % k] = (mod[i % k] + dp[i]) % MOD
        answer[i] = (answer[i] + mod[i % k]) % MOD"
"import copy
n, k = list(map(int, input().split(' ')))


dp = [0]*(n+1)
for i in range(k, n+1, k):
    dp[i] = 1

# print(list(range(n+1)))
# print(dp, k)
ans = copy.copy(dp)
dp2 = [0]*(n+1)
for s in range(2,n):   # will be sqrt(n) really
    ks = k + s - 1
    first = (ks * (ks+1) // 2) - ((k-1) * k // 2)
    if first > n+1:
        {{completion}}
    for i in range(first, n+1):
        dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353
    dp = dp2
    # print(dp, ks)
    dp2 = [0]*(n+1)
    for i in range(0, n+1):
        ans[i] = (ans[i] + dp[i]) % 998244353
print(' '.join(map(str, ans[1:])))",break,dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353
"import copy
n, k = list(map(int, input().split(' ')))


dp = [0]*(n+1)
for i in range(k, n+1, k):
    dp[i] = 1

# print(list(range(n+1)))
# print(dp, k)
ans = copy.copy(dp)
dp2 = [0]*(n+1)
for s in range(2,n):   # will be sqrt(n) really
    ks = k + s - 1
    first = (ks * (ks+1) // 2) - ((k-1) * k // 2)
    if first > n+1:
        break
    for i in range(first, n+1):
        {{completion}}
    dp = dp2
    # print(dp, ks)
    dp2 = [0]*(n+1)
    for i in range(0, n+1):
        ans[i] = (ans[i] + dp[i]) % 998244353
print(' '.join(map(str, ans[1:])))",dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353,break
"import sys

inf=float('inf')
mod=998244353
#input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())

def main():

    n,k=inpnm()
    N=n+1
    f1=[0]*N
    res=[0]*N

    f1[0]=1
    i=1
    while True:
        step=k+i-1
        f2=[0]*N
        for j in range(step,N):
            {{completion}}

        for j in range(N):
            f1[j]=f2[j]

        if (k+k+i-1)*i>2*n:
            break
        i+=1
    print(*res[1:])

main()","f2[j]=(f1[j-step]+f2[j-step])%mod
            res[j]=(res[j]+f2[j])%mod",f1[j]=f2[j]
"import sys

inf=float('inf')
mod=998244353
#input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())

def main():

    n,k=inpnm()
    N=n+1
    f1=[0]*N
    res=[0]*N

    f1[0]=1
    i=1
    while True:
        step=k+i-1
        f2=[0]*N
        for j in range(step,N):
            f2[j]=(f1[j-step]+f2[j-step])%mod
            res[j]=(res[j]+f2[j])%mod

        for j in range(N):
            {{completion}}

        if (k+k+i-1)*i>2*n:
            break
        i+=1
    print(*res[1:])

main()",f1[j]=f2[j],"f2[j]=(f1[j-step]+f2[j-step])%mod
            res[j]=(res[j]+f2[j])%mod"
"t=1
mod=998244353
while t:
    t-=1
    n,k=[int(x) for x in input().split()]
    dp=[0 for x in range(n+1)]
    ans=[0 for x in range(n+1)]
    for i in range(k,n+1,k):
        dp[i]+=1
        ans[i]=dp[i]
    while True:
        k+=1
        shift=False

        for i in reversed(range(n+1)):

            if i-k>=0:
                dp[i]=dp[i-k]
                dp[i-k]=0
                if dp[i]:
                    {{completion}}
            else:
                dp[i]=0

        for i in range(n+1):
            if i+k<=n:
                dp[i+k]+=dp[i]
                dp[i+k]%=mod
        for i in range(n+1):
            ans[i]+=dp[i]
            ans[i]%=mod
        if not shift:
            break
    print(*ans[1:])


",shift=True,"this is the start of the ground truth
dp[i]=dp[i-k]
        dp[i-k]=0
        if dp[i]:
            dp[i]=dp[i-k]
            dp[i-k]=0
            if dp[i]:
                dp[i]=dp[i-k]
                dp[i-k]=0
                if dp[i]:
                    dp[i]=dp[i-k]
                    dp"
"MOD, MAXN = 998244353, 10**5 * 2
N, K = map(int, input().split())
ans, dp = [0] * (MAXN + 10), [0] * (MAXN + 10)
dp[0] = 1
s = 0
for i in range(701):
    if s > N:
        {{completion}}
    new_dp = [0] * (MAXN + 10)
    for j in range(s + i + K, N + 1):
        new_dp[j] = (new_dp[j - i - K] + dp[j - i - K]) % MOD
        ans[j] = (ans[j] + new_dp[j]) % MOD
    dp = new_dp
    s += i + K
print(*ans[1:N + 1])
",break,"dp[j] = (dp[j - i - K] + dp[j - i - K]) % MOD
        ans[j] = (ans[j] + dp[j]) % MOD"
"MOD, MAXN = 998244353, 10**5 * 2
N, K = map(int, input().split())
ans, dp = [0] * (MAXN + 10), [0] * (MAXN + 10)
dp[0] = 1
s = 0
for i in range(701):
    if s > N:
        break
    new_dp = [0] * (MAXN + 10)
    for j in range(s + i + K, N + 1):
        {{completion}}
    dp = new_dp
    s += i + K
print(*ans[1:N + 1])
","new_dp[j] = (new_dp[j - i - K] + dp[j - i - K]) % MOD
        ans[j] = (ans[j] + new_dp[j]) % MOD","j=i%k
    s[j],f[i],z[i]=(s[j]+f[i])%M,s[j],(z[i]+s[j])%M"
"n,k=map(int,input().split());M=998244353
f,z=[1]+[0]*n,[0]*(n+1);l=0
while l<=n-k:
  s=[0]*k
  for i in range(l,n+1):
    {{completion}}
  l+=k;k+=1
print(*z[1:])","j=i%k
    s[j],f[i],z[i]=(s[j]+f[i])%M,s[j],(z[i]+s[j])%M","z[i]=z[i-l]+f[i-l]
        z[i]%=M
        f[i]=z[i]"
"def readline():
    line = input()
    while not line:
        line = input()
    return line


def main():
    t = int(readline())
    for _ in range(t):
        m = int(readline())
        a = [ [], [] ]
        a[0] += list(map(int, readline().split()))
        a[1] = list(map(int, readline().split()))

        h = [ [None] * m, [None] * m ]
        h[0][m-1] = max(a[1][m-1]+1, a[0][m-1]+1+1)
        h[1][m-1] = max(a[0][m-1]+1, a[1][m-1]+1+1)
        for i in reversed(range(m-1)):
            h[0][i] = max(a[1][i]+1, h[0][i+1]+1, a[0][i]+(i!=0)+(m-i-1)*2+1)
            h[1][i] = max(a[0][i]+1, h[1][i+1]+1, a[1][i]+1+(m-i-1)*2+1)

        pos = (0,0)
        t = 0
        best_total_time = 10**10
        for i in range(2*m-1):
            if i % 2 == 0:
                total_time = max(t+(m-i//2-1)*2+1, h[pos[0]][pos[1]])
                # print(pos, t,total_time)
                best_total_time = min(best_total_time, total_time)

            if i % 4 == 0:
                # abajo
                pos = (pos[0]+1, pos[1])
            elif (i-1) % 4 == 0:
                # derecha
                {{completion}}
            elif (i-2) % 4 == 0:
                # arr
                pos = (pos[0]-1, pos[1])
            elif (i-3) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            t = max(a[pos[0]][pos[1]] + 1, t+1)

        # for line in h:
        #     print(line)
        print(best_total_time)


main()
","pos = (pos[0], pos[1]+1)","pos = (pos[0]-1, pos[1])"
"def readline():
    line = input()
    while not line:
        line = input()
    return line


def main():
    t = int(readline())
    for _ in range(t):
        m = int(readline())
        a = [ [], [] ]
        a[0] += list(map(int, readline().split()))
        a[1] = list(map(int, readline().split()))

        h = [ [None] * m, [None] * m ]
        h[0][m-1] = max(a[1][m-1]+1, a[0][m-1]+1+1)
        h[1][m-1] = max(a[0][m-1]+1, a[1][m-1]+1+1)
        for i in reversed(range(m-1)):
            h[0][i] = max(a[1][i]+1, h[0][i+1]+1, a[0][i]+(i!=0)+(m-i-1)*2+1)
            h[1][i] = max(a[0][i]+1, h[1][i+1]+1, a[1][i]+1+(m-i-1)*2+1)

        pos = (0,0)
        t = 0
        best_total_time = 10**10
        for i in range(2*m-1):
            if i % 2 == 0:
                total_time = max(t+(m-i//2-1)*2+1, h[pos[0]][pos[1]])
                # print(pos, t,total_time)
                best_total_time = min(best_total_time, total_time)

            if i % 4 == 0:
                # abajo
                pos = (pos[0]+1, pos[1])
            elif (i-1) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            elif (i-2) % 4 == 0:
                # arr
                {{completion}}
            elif (i-3) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            t = max(a[pos[0]][pos[1]] + 1, t+1)

        # for line in h:
        #     print(line)
        print(best_total_time)


main()
","pos = (pos[0]-1, pos[1])","pos = (pos[0]-1, pos[1])"
"import sys; input = sys.stdin.readline

def seg(start, end):
    if start == end:
        {{completion}}
    mid = (start + end) // 2
    l = seg(start, mid)
    r = seg(mid + 1, end)
    result = []
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    l, r = r, l
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    return result
        
n = int(input())
l = 1 << n
arr = list(map(int, input().split()))
tree = seg(0, l - 1)
i = 0
for _ in range(int(input())):
    i ^= (1 << int(input()))
    print(tree[i][0])","val = max(arr[start], 0)
        return [(val, val, val, arr[start])]","lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))"
"import sys; input = sys.stdin.readline

def seg(start, end):
    if start == end:
        val = max(arr[start], 0)
        return [(val, val, val, arr[start])]
    mid = (start + end) // 2
    l = seg(start, mid)
    r = seg(mid + 1, end)
    result = []
    for i in range((end - start + 1) // 2):
        {{completion}}
    l, r = r, l
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    return result
        
n = int(input())
l = 1 << n
arr = list(map(int, input().split()))
tree = seg(0, l - 1)
i = 0
for _ in range(int(input())):
    i ^= (1 << int(input()))
    print(tree[i][0])","lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))","val = max(arr[start], 0)
        return [(val, val, val, arr[start])]"
"import sys

input = lambda: sys.stdin.readline().rstrip()

class Node:
    def __init__(self, seg, suf, pref, sum) -> None:
        self.best = seg
        self.suf = suf
        self.pref = pref
        self.sum = sum


def merge(a, b):
    seg = max(a.best, b.best, a.suf + b.pref)
    suf = max(b.suf, b.sum + a.suf)
    pref = max(a.pref, a.sum + b.pref)
    sum = a.sum + b.sum
    return Node(seg, suf, pref, sum)

def single(a):
    v = max(a, 0)
    return Node(v, v, v, a)

def build(v, l, r):
    if l + 1 == r:
        return [single(A[l])]
    else:
        m = (l + r) // 2
        vl = build(2 * v + 1, l, m)
        vr = build(2 * v + 2, m, r)
        ans = []
        for _ in range(2):
            for i in range((r - l) // 2):
                {{completion}}
            vl, vr = vr, vl
        return ans

N = int(input())
A = list(map(int, input().split()))
Q = int(input())

M = 1 << N
tree = build(0, 0, M)
curr = 0
for _ in range(Q):
    K = int(input())
    curr ^= (1 << K)
    print(tree[curr].best)","ans.append(merge(vl[i], vr[i]))","v = max(a.best, b.best, a.suf + b.pref)
    suf = max(b.suf, b.sum + a.suf)
    pref = max(a.pref, a.sum + b.pref)
    sum = a.sum + b.sum
    return Node(v, suf, pref, sum)"
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    N = int(input())
    G = [[int(x) for x in input()] + [0] for _ in range(2)]
    
    dp = [[0] * 2  for _ in range(N + 1)]   # number of 1 cells robot will clean when it arrives at cell (j, i) from the left
    for j in range(2):
        dp[N - 1][j] = G[1 - j][N - 1]
    
    for i in range(N - 2, - 1, -1):
        for j in range(2):
            dp[i][j] = G[j][i + 1] + dp[i + 1][j]   # base case: ignore row 1 - j and proceed right
            if G[1 - j][i]:
                {{completion}}

    print(dp[0][0])
    return

solve()","dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])","dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + dp[i + 1][1 - j])"
"import sys
inf = float('inf')
mod = 998244353
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int, input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())


n=inpint()
s=[]
for i in range(2):
    s.append([i for i in list(input())]+['0','0'])
#print(arr)
f=[[-inf]*(2) for _ in range(n+2)]
f[0][0]=0
for i in range(n):
    for j in range(2):
        f[i+1][j]=max(f[i+1][j],f[i][j]+int(s[j][i+1]))
        if s[j^1][i]=='1':
            {{completion}}
print(max(f[n][0],f[n][1]))","f[min(i+2,n)][j^1]=max(f[min(i+2,n)][j^1],f[i][j]+1+int(s[j^1][i+1])+int(s[j^1][i+2]))","f[i+1][j]=max(f[i+1][j],f[i][j]+int(s[j][i+1]))"
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    N = int(input())
    G = [[int(x) for x in input()] + [0] for _ in range(2)]
    
    dp = [[0] * 2  for _ in range(N + 1)]
    for j in range(2):
        dp[N - 1][j] = G[1 - j][N - 1]
    
    for i in range(N - 2, - 1, -1):
        for j in range(2):
            dp[i][j] = G[j][i + 1] + dp[i + 1][j]   # can always ignore row 1 - j and proceed right
            if G[1 - j][i]:
                if G[j][i + 1]:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])
                else:
                    {{completion}}

    print(dp[0][0])
    return

solve()","dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + dp[i + 1][1 - j])","dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])"
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for i in range(tc):
        n, row1, row2 = input_arr[pos:pos + 3]
        row1n, row2n = [], []
        for k,j in zip(row1, row2):
            if k == ""G"":
                {{completion}}
            if j == ""G"":
                j = ""B""
            row1n.append(k)
            row2n.append(j)
        print(""YES"" if row1n == row2n else ""NO"")

        pos += 3

# '6 2 RG RB 4 GRBG GBGB 5 GGGGG BBBBB 7 BBBBBBB RRRRRRR 8 RGBRRGBR RGGRRBGR 1 G G'
","k = ""B""","k = ""B"""
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for i in range(tc):
        n, row1, row2 = input_arr[pos:pos + 3]
        row1n, row2n = [], []
        for k,j in zip(row1, row2):
            if k == ""G"":
                k = ""B""
            if j == ""G"":
                {{completion}}
            row1n.append(k)
            row2n.append(j)
        print(""YES"" if row1n == row2n else ""NO"")

        pos += 3

# '6 2 RG RB 4 GRBG GBGB 5 GGGGG BBBBB 7 BBBBBBB RRRRRRR 8 RGBRRGBR RGGRRBGR 1 G G'
","j = ""B""","j = ""B"""
"import sys


if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    n = input_arr[0]
    pos = 1
    for i in range(n):
        n, code = input_arr[pos:pos+2]
        code_str = str(code)
        result = []
        j = n-1
        while j >= 0:
            if j >= 2:
                sub = code_str[j-2:j+1]
                if sub[-1] == ""0"":
                    result.append(chr(int(sub)//10 + 96))
                    j -= 3
                else:
                    {{completion}}
            else:
                result.append(chr(int(code_str[j]) + 96))
                j -= 1
        print("""".join(result[::-1]))
        pos += 2

# sys.stdin.read()
","result.append(chr(int(code_str[j])+96))
                    j -= 1","this is the start of the ground truth
if j >= 2:
    sub = code_str[j-2:j+1]
    if sub[-1] == ""0"":
        result.append(chr(int(sub)//10 + 96))
        j -= 3
    else:
        result.append(chr(int(sub) + 96))
        j -= 2
else:
    result.append(chr(int(code_str[j]) + 96))"
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  s = str(inp1())[::-1]
  alph = ""0abcdefghijklmnopqrstuvwxyz""
  d = deque()
  i = 0
  while i < n:
    if s[i] == ""0"":
      d.appendleft(int(s[i + 1:i + 3][::-1]))
      i += 3
    else:
      {{completion}}
  ret = """"
  for i in d:
    ret += alph[i]
  print(ret)
","d.appendleft(int(s[i]))
      i += 1","d.appendleft(int(s[i + 1:i + 3][::-1]))
      i += 3
    else:
      d.appendleft(int(s[i]))
      i += 1
  ret = """"
  for i in d:
    ret += alph[i]
  print(ret)"
"import sys


def calculate(x, y1, y2):
    x = int(x)
    y1 = int(y1)
    y2 = int(y2)
    diff1 = abs(x - 1)
    diff2 = abs(y1-y2) if y2 == 1 else abs(y1-y2)+y2-1
    if diff1 < diff2:
        return 1
    elif diff2 < diff1:
        return 2
    else:
        return 3


if __name__ == ""__main__"":
    for line in sys.stdin:
        input = line.split()
        if len(input) == 3:
            {{completion}}
","print(calculate(input[0], input[1], input[2]))","print(calculate(input[0], input[1], input[2]))"
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              tt = [l[0] + r[0] + 1, r[1]]
            elif tt[0] == l[0] + r[0] + 1:
              {{completion}}
            d[j][i] = tt
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt[1] = tt[1] + r[1],"tt = [l[0] + r[0] + 1, r[1]]"
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              {{completion}}
            elif tt[0] == l[0] + r[0] + 1:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
","tt = [l[0] + r[0] + 1, r[1]]",tt[1] = tt[1] + r[1]
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              tt = [l[0] + r[0] + 1, r[1]]
            elif tt[0] == l[0] + r[0] + 1:
              {{completion}}
            d[j][i] = tt
          else:
            break
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt[1] = tt[1] + r[1],"tt = [l[0] + r[0] + 1, r[1]]"
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              {{completion}}
            elif tt[0] == l[0] + r[0] + 1:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
          else:
            break
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
","tt = [l[0] + r[0] + 1, r[1]]",tt[1] = tt[1] + r[1]
"from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List


def solve() -> None:
  a = [int(c) % 9 for c in next_token()]
  n = len(a)
  sa = list(a)
  for i in range(1, n):
    sa[i] += sa[i - 1]
  w = next_int()
  indices = defaultdict(list)
  for i in range(w, n + 1):
    vlr = ((sa[i - 1] - (sa[i - w - 1] if i - w > 0 else 0)) % 9 + 9) % 9
    indices[vlr].append(i - w + 1)
  cache = dict()
  INF = (n + 1, n)
  for _ in range(next_int()):
    l = next_int() - 1
    r = next_int() - 1
    k = next_int()
    vlr = ((sa[r] - (sa[l - 1] if l > 0 else 0)) % 9 + 9) % 9
    if (vlr, k) not in cache:
      res = INF
      for v1 in range(9):
        for v2 in range(9):
          if ((v1 * vlr + v2) % 9 + 9) % 9 == k:
            if v1 == v2:
              if len(indices[v1]) > 1:
                res = min(res, tuple(indices[v1][:2]))
            else:
              if len(indices[v1]) > 0 and len(indices[v2]) > 0:
                {{completion}}
      cache[(vlr, k)] = res if res != INF else (-1, -1)
    print(*cache[(vlr, k)])


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
","res = min(res, (indices[v1][0], indices[v2][0]))",tt[1] = tt[1] + r[1]
"from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List


def solve() -> None:
  a = [int(c) % 9 for c in next_token()]
  n = len(a)
  sa = list(a)
  for i in range(1, n):
    sa[i] += sa[i - 1]
  w = next_int()
  indices = defaultdict(list)
  for i in range(w, n + 1):
    vlr = ((sa[i - 1] - (sa[i - w - 1] if i - w > 0 else 0)) % 9 + 9) % 9
    indices[vlr].append(i - w + 1)
  cache = dict()
  INF = (n + 1, n)
  for _ in range(next_int()):
    l = next_int() - 1
    r = next_int() - 1
    k = next_int()
    vlr = ((sa[r] - (sa[l - 1] if l > 0 else 0)) % 9 + 9) % 9
    if (vlr, k) not in cache:
      res = INF
      for v1 in range(9):
        for v2 in range(9):
          if ((v1 * vlr + v2) % 9 + 9) % 9 == k:
            if v1 == v2:
              if len(indices[v1]) > 1:
                {{completion}}
            else:
              if len(indices[v1]) > 0 and len(indices[v2]) > 0:
                res = min(res, (indices[v1][0], indices[v2][0]))
      cache[(vlr, k)] = res if res != INF else (-1, -1)
    print(*cache[(vlr, k)])


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
","res = min(res, tuple(indices[v1][:2]))",tt[1] = tt[1] + r[1]
"# from collections import Counter
""""""
standing at point i, why choose to jump to a point j?

if jump:
a*(j-i) + cost(j,n)
if not jump(ie. start from i):
every unconquered kingdom require the distance j-i be conqured, totally n-j times,
-> (j-i)*b*(n-j) + cost(j,n)

compare the two equations:
when a < b*(n-j), we choose to jump to j.
""""""
row=lambda:map(int,input().split())
t=int(input())
for _ in range(t):
    n,a,b=row()
    arr=[0]+list(row())
    
    pos=res=0
    for i in range(1,n+1):
      d=arr[i]-arr[pos]
      res+=b*d
      if a<b*(n-i):
        {{completion}}
    print(res)","res+=a*d
        pos=i","res+=a*(arr[i]-arr[pos])
      else:
        res+=(arr[i]-arr[pos])*b*(n-i)
        pos=i"
"import sys
lines = list(map(str.strip, sys.stdin.readlines()))

def cum_sum(nums):
    curr = 0
    result = [0]*len(nums)
    for idx, num in enumerate(nums):
        {{completion}}
    return result

for i in range(1, len(lines), 2):
    n, a, b = map(int, lines[i].split("" ""))
    nums = [0] + list(map(int, lines[i+1].split("" "")))
    cumulative = cum_sum(nums)
    smallest = float(""inf"")
    for f in range(0, n+1):
        curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
        smallest = min(curr, smallest)
    print(smallest)
","curr += num
        result[idx] = curr","curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
smallest = min(curr, smallest)"
"import sys
lines = list(map(str.strip, sys.stdin.readlines()))

def cum_sum(nums):
    curr = 0
    result = [0]*len(nums)
    for idx, num in enumerate(nums):
        curr += num
        result[idx] = curr
    return result

for i in range(1, len(lines), 2):
    n, a, b = map(int, lines[i].split("" ""))
    nums = [0] + list(map(int, lines[i+1].split("" "")))
    cumulative = cum_sum(nums)
    smallest = float(""inf"")
    for f in range(0, n+1):
        {{completion}}
    print(smallest)
","curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
        smallest = min(curr, smallest)","curr += num
        result[idx] = curr"
"#Name:      Codeforces Round #782 (Div. 4)
#Code:      
#Rating:    00
#Date:      14/06/2022
#Author:    auros25
#Done:      


#sys.stdin.readline().strip()
#sys.stdout.write(+""\n"")

import sys
#import bisect

for lol in range(int(sys.stdin.readline().strip())):
    n, a, b = list(map(int, sys.stdin.readline().strip().split()))
    x = list(map(int, sys.stdin.readline().strip().split()))
    k = a//b + 1
    #print(k)
    if k >=n:
        sys.stdout.write(str(b*(sum(x))) +""\n"")
    else:
        {{completion}}
   
","c=a+b
##        v=c*x[n-k-1]
##        w=k*b*x[n-k-1]
##        u= sum(x[n-k:])*b
        #print(v, w, u)
        #print(v-w+u)
        sys.stdout.write( str( c*x[n-k-1] + b*(sum(x[n-k:])-x[n-k-1]*k)) +""\n"")","sys.stdout.write(str(b*(sum(x))) +""\n"")"
"for _ in range(int(input())):
	n,a,b=map(int, input().split())
	w=[int(x) for x in input().split()]
	fb=sum(w)*b
	fa=0
	ans = fb
	cap = 0
	cur = n
	for x in w:
		fb -= x * b
		cur -= 1
		if (x - cap) * a + fb - (x - cap) * cur * b < fb:
			{{completion}}
		#print(cap)
	print(ans)","ans += (x - cap) * a
			ans -= (x - cap) * cur * b
			cap = x","ans += a*(x-cap)
			cap = x"
"t = int(input())
for i in range(t):
    li = input().split()
    n = int(li[0])
    a = int(li[1])
    b = int(li[2])
    x = input().split()
    ans = 0
    now = 0
    for j in range(n):
        ans += b*(int(x[j])-now)
        if a < b*(n-j-1):
            {{completion}}
    print(ans)
","ans += a*(int(x[j])-now)
            now = int(x[j])","ans+=a*(int(x[j])-now)
            now = int(x[j])"
"def solve():
  n,a,b=map(int,input().split())
  xs=list(map(int,input().split()))
  cum=0
  ans=sum(xs)*b
  for i in range(n):
    {{completion}}
  
  print(ans)

for _ in range(int(input())):
  solve()","x=xs[-i-1]
    ans=min(ans,x*(a+b)+(cum-x*i)*b)
    cum+=x","ans+=d*a
            c=i"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
for _ in range(t):
	n, a, b = I()
	x = [0] + I()
	suffixes = [0]
	for i in range(n - 1, -1, -1):
		{{completion}}
	suffixes = suffixes[::-1]
	best = float('inf')
	for i in range(n + 1):
		best = min(best, x[i] * (b + a) + suffixes[i])
	print(best)
","move = x[i + 1] - x[i]
		tot = suffixes[-1] + len(suffixes) * move * b
		suffixes.append(tot)","best = min(best, x[i] * (b + a) + suffixes[i])"
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
for _ in range(t):
	n, a, b = I()
	x = [0] + I()
	suffixes = [0]
	for i in range(n - 1, -1, -1):
		move = x[i + 1] - x[i]
		tot = suffixes[-1] + len(suffixes) * move * b
		suffixes.append(tot)
	suffixes = suffixes[::-1]
	best = float('inf')
	for i in range(n + 1):
		{{completion}}
	print(best)
","best = min(best, x[i] * (b + a) + suffixes[i])","move = x[i + 1] - x[i]
		tot = suffixes[-1] + len(suffixes) * move * b
		suffixes.append(tot)"
"def f(ar,a,b):
    ans=0
    c=0
    n=len(ar)
    for id,i in enumerate(ar):
        d=i-c
        ans+=d*b
        if d*a<(n-id-1)*(d)*b:
            {{completion}}
    return ans

r=lambda :map(int,input().strip().split())
for _ in range(int(input())):
    n,a,b=r()
    ar=list(r())
    print(f(ar,a,b))
","ans+=d*a
            c=i","ans+=a*(i-c)
            c=i"
for s in[*open(0)][1:]:{{completion}},"n,r,b=map(int,s.split());b+=1;c=r//b*'R'+'B';print((r%b*('R'+c)+n*c)[:n])","n,r,b=map(int,s.split());b+=1;n=r//b*'R';print((r%b*(n+'RB')+(b-r%b)*(n+'B'))[:-1])"
"for _ in range(int(input())):
    {{completion}}","n,r,b=map(int,input().split())
    t=((r-1)//(b+1)+1)
    k=t*(b+1)-r
    res=('R'*t+'B')*(b+1-k)+('R'*(t-1)+'B')*k
    print(res[:-1])
    #","n,r,b=map(int,input().split());b+=1;c=r//b*'R'+'B';print((r%b*('R'+c)+n*c)[:n])"
"tc=int(input())
for _ in range(tc):
 {{completion}}","n,a,b=map(int,input().split());b+=1
 print((('R'*(a//b+1)+'B')*(a%b)+('R'*(a//b)+'B')*(b-a%b))[:-1])","































































































































"
"
def solve():
  n, r, b = list(map(int, input().split("" "")))

  d = r // (b+1)
  rem = r%(b+1)
  s = ''

  for i in range(b):
    if(rem > 0):
      {{completion}}
    s += 'R'*d + 'B'
  
  s += 'R'*d
  s+='R'*rem

  print(s)

for t in range(int(input())):
    solve()
","s += 'R'
      rem-= 1",s += 'R'*d + 'B'
for n in[*open(0)][1:]:{{completion}},"n,r,b=map(int,n.split());b+=1;n=r//b*'R';print((r%b*(n+'RB')+(b-r%b)*(n+'B'))[:-1])","n,r,b=map(int,n.split());b+=1;n=r//b*'R';print((r%b*(n+'RB')+(b-r%b)*(n+'B'))[:-1])"
"t=int(input())
for i in range(0,t):
    {{completion}}","n,r,b=map(int,input().split())
    eq=r//(b+1)
    rem=r%(b+1)
    print(rem*((eq+1)*""R""+""B"")+(b-rem)*(eq*(""R"")+""B"")+eq*""R"")","n,r,b=map(int,input().split())
    eq=r//(b+1)
    rem=r%(b+1)
    print(rem*((eq+1)*""R""+""B"")+(b-rem)*(eq*(""R"")+""B"")+eq*""R"")"
"for t in range(int(input())):
    n,r,b = map(int,input().split())
    s = []
    while r and b:
        s.append(""R"")
        s.append(""B"")
        r-=1
        b-=1
    s.append(""R"")
    r-=1
    j = 0
    while r:
        s[j]+='R'
        r-=1
        j+=2
        if j>=len(s):
            {{completion}}

    print(*s,sep="""")
        
        
    ",j=0,"this is the start of the ground truth
n,r,b=map(int,input().split())
    s=[]
    while r and b:
        s.append(""R"")
        s.append(""B"")
        r-=1
        b-=1
    s.append(""R"")
    r-=1
    j=0
    while r:
        s[j]+='R'
        r-=1
        j+=2
        if j>=len("
"for l in [*open(0)][1:]:
	{{completion}}","n,r,b=map(int,l.split())
	b+=1
	c=(r//b)*'R'+'B'
	print(((r%b)*('R'+c)+n*c)[:n])","n,r,b=map(int,l.split())
	b+=1
	c=(r//b)*'R'+'B'
	print(((r%b)*('R'+c)+n*c)[:n])"
"t = int(input())
for i in range(t):
    x = input().split()
    r = int(x[1])
    b = int(x[2])
    x = """"
    p = r%(b+1)
    q = r//(b+1)
    for i in range(p):
        {{completion}}
    for i in range(b+1-p):
        x+= ""R""*(q)+""B""
    print(x[:-1])","x += ""R""*(q+1)+""B""","x+= ""R""*(q)+""B"""
"t = int(input())
for i in range(t):
    x = input().split()
    r = int(x[1])
    b = int(x[2])
    x = """"
    p = r%(b+1)
    q = r//(b+1)
    for i in range(p):
        x += ""R""*(q+1)+""B""
    for i in range(b+1-p):
        {{completion}}
    print(x[:-1])","x+= ""R""*(q)+""B""","x+= ""R""*(q)+""B"""
"for s in[*open(0)][2::2]:
    c=[*map(int,s.split())]
    a=[1 if x else 0 for x in c]+[1]
    for i,x in enumerate(c):
        {{completion}}
    print(*a[:-1])
",a[x+i-i*a[i]]=0,a[i]=1
"
import sys


def solve():
    n = int(input())
    num = list(map(int , input().split()))
    ret = [1]*n
    for i in range(n):
        j = num[i]
        if j == 0 or ret[i] == 0:
            {{completion}}
        if j < n:
            ret[j] = 0
    print(*ret)



for _ in range(int(input())):
    solve()
",j += i,ret[j] = 0
"
import sys


def solve():
    n = int(input())
    num = list(map(int , input().split()))
    ret = [1]*n
    for i in range(n):
        j = num[i]
        if j == 0 or ret[i] == 0:
            j += i
        if j < n:
            {{completion}}
    print(*ret)



for _ in range(int(input())):
    solve()
",ret[j] = 0,j += i
"t = int(input())
for _ in range(t):
    n = int(input())
    c = list(map(int, input().split()))
    a, e, se, s = [], [0]*n, 0, sum(c)
    for i in range(n, 0, -1):
        {{completion}}
    print(*reversed(a))
        ","se -= e[i-1]
        n1 = s//i
        t = 0 if c[i-1] < i + se else 1
        a.append(t)
        s -= (n1 + (i-1)*t)
        e[i-n1-1] += 1
        se += 1",a.append(0)
"from sys import stdin,stderr
def rl():
    return [int(w) for w in stdin.readline().split()]

t, = rl()
for _ in range(t):
    n, = rl()
    c = rl()
    a = [1] * n
    for i in range(n):
        j = c[i]
        if j == 0 or  a[i] == 0:
            {{completion}}
        if j < n:
            a[j] = 0
    print(*a)
",j += i,a[j] = 0
"from sys import stdin,stderr
def rl():
    return [int(w) for w in stdin.readline().split()]

t, = rl()
for _ in range(t):
    n, = rl()
    c = rl()
    a = [1] * n
    for i in range(n):
        j = c[i]
        if j == 0 or  a[i] == 0:
            j += i
        if j < n:
            {{completion}}
    print(*a)
",a[j] = 0,a[j] = 0
"for _ in range(int(input())):
    n=int(input())
    C=list(map(int,input().split()))
    z=sum(C)//n
    d=[0]*(n+1)
    ans=[]
    for i in range(n-1,-1,-1):
        d[i]+=d[i+1]
        d[i]-=1
        d[i-z]+=1
        if z and C[i]+d[i]==i:
            ans.append(1)
            z-=1
        else:
            {{completion}}
    print(*ans[::-1])",ans.append(0),d[i-z]+=1
"import sys
input = sys.stdin.readline


T = int(input())
for t in range(T):
    N=int(input())
    C=list(map(int,input().split()))
    ans=[0]*N
    k=sum(C)//N
    i=N-1
    while i>-1 and k>0:
        if C[i]==N:
            ans[i]=1
            k-=1
        else:
            {{completion}}
        i-=1
    print(*ans)",C[i-k]+=N-i,ans[i+k-k*ans[i]]=1
"import sys
input = sys.stdin.readline

class DSU:

    def __init__(self, n):
        self.UF = list(range(n))
        self.sz = [0]*n

    def find(self, u):
        UF = self.UF

        if UF[u]!=u:
            UF[u] = self.find(UF[u])
        return UF[u]

    def union(self,u,v):
        UF = self.UF
        sz = self.sz

        pu = self.find(u)
        pv = self.find(v)

        if pu == pv:
            return False
        if sz[pu] >= sz[pv]:
            sz[pu] += 1
            UF[pv] = pu
        else:
            {{completion}}
        return True

n,m = map(int,input().split())
good = []

DSUs = [DSU(n+1) for _ in range(30)]

for _ in range(m):
    u,v,w = map(int,input().split())

    u -= 1
    v -= 1

    if w%2 == 0:
        good.append((u,v,w))

    for k in range(0, 30):
        if w & (1<<k):
            DSUs[k].union(u,v)

q = int(input())
Q = [None]*q
ans = [2]*q

for i in range(q):
    u,v = map(int,input().split())

    u -= 1
    v -= 1

    Q[i] = u,v

    for k in range(0, 30):
        if DSUs[k].find(u) == DSUs[k].find(v):
            ans[i] = 0
            break

for u,v,w in good:
    for k in range(1, 30):
        DSUs[k].union(u, n)
        DSUs[k].union(v, n)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(n):
            ans[i] = 1
            break

print(""\n"".join(str(x) for x in ans))

","sz[pv] += 1
            UF[pu] = pv","ans = 1
                    break"
"import sys
input = sys.stdin.readline

class DSU:

    def __init__(self, n):
        self.UF = list(range(n))
        self.sz = [0]*n

    def find(self, u):
        UF = self.UF

        if UF[u]!=u:
            {{completion}}
        return UF[u]

    def union(self,u,v):
        UF = self.UF
        sz = self.sz

        pu = self.find(u)
        pv = self.find(v)

        if pu == pv:
            return False
        if sz[pu] >= sz[pv]:
            sz[pu] += 1
            UF[pv] = pu
        else:
            sz[pv] += 1
            UF[pu] = pv
        return True

n,m = map(int,input().split())
good = []

DSUs = [DSU(n+1) for _ in range(30)]

for _ in range(m):
    u,v,w = map(int,input().split())

    u -= 1
    v -= 1

    if w%2 == 0:
        good.append((u,v,w))

    for k in range(0, 30):
        if w & (1<<k):
            DSUs[k].union(u,v)

q = int(input())
Q = [None]*q
ans = [2]*q

for i in range(q):
    u,v = map(int,input().split())

    u -= 1
    v -= 1

    Q[i] = u,v

    for k in range(0, 30):
        if DSUs[k].find(u) == DSUs[k].find(v):
            ans[i] = 0
            break

for u,v,w in good:
    for k in range(1, 30):
        DSUs[k].union(u, n)
        DSUs[k].union(v, n)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(n):
            ans[i] = 1
            break

print(""\n"".join(str(x) for x in ans))

",UF[u] = self.find(UF[u]),"ans = 1
                    break"
"import sys

input = sys.stdin.readline

def bit(w, b):
    if w & (1 << b):
        return 1
    return 0


class DSU:

    def __init__(self, n):
        self.n = n
        self.parent = [i for i in range(self.n)]
        self.SZ = [1 for _ in range(self.n)]

    def root(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.root(self.parent[node])
        return self.parent[node]

    def merge(self, u, v):
        u = self.root(u)
        v = self.root(v)

        if u == v:
            return

        if self.SZ[u] < self.SZ[v]:
            temp = u
            u = v
            v = temp

        self.parent[v] = u
        self.SZ[u] += self.SZ[v]


class Solver1659E:

    def __init__(self):
        self.C = 30
        self.n, self.m = list(map(int, input().split(' ')))
        self.bit_i = [DSU(self.n) for _ in range(self.C)]
        self.bit_i_0 = [DSU(self.n) for _ in range(self.C)]
        self.one_works = [[0 for _ in range(self.n)] for _ in range(self.C)]

        for i in range(self.m):
            u, v, w = list(map(int, input().split(' ')))

            u -= 1
            v -= 1

            for j in range(self.C):
                if bit(w, j):
                    {{completion}}

                if bit(w, j) and bit(w, 0):
                    self.bit_i_0[j].merge(u, v)

                if bit(w, 0) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.one_works[b][i] == 1:
                    self.one_works[b][self.bit_i_0[b].root(i)] = 1

        #print(self.one_works)

    def query(self):

        u, v = list(map(int, input().split(' ')))

        u -= 1
        v -= 1

        for b in range(self.C):
            if self.bit_i[b].root(u) == self.bit_i[b].root(v):
                return 0

        for b in range(1, self.C):
            if self.bit_i_0[b].root(u) == self.bit_i_0[b].root(v):
                #print(""i_0="",b)
                return 1

            if self.one_works[b][self.bit_i_0[b].root(u)]:
                #print(""one_works="",b,self.bit_i_0[b].root(u))
                return 1

        return 2


cur = Solver1659E()

q = int(input())

while q:

    q -= 1

    print(cur.query())
","self.bit_i[j].merge(u, v)","































































































































"
"import sys

input = sys.stdin.readline

def bit(w, b):
    if w & (1 << b):
        return 1
    return 0


class DSU:

    def __init__(self, n):
        self.n = n
        self.parent = [i for i in range(self.n)]
        self.SZ = [1 for _ in range(self.n)]

    def root(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.root(self.parent[node])
        return self.parent[node]

    def merge(self, u, v):
        u = self.root(u)
        v = self.root(v)

        if u == v:
            return

        if self.SZ[u] < self.SZ[v]:
            temp = u
            u = v
            v = temp

        self.parent[v] = u
        self.SZ[u] += self.SZ[v]


class Solver1659E:

    def __init__(self):
        self.C = 30
        self.n, self.m = list(map(int, input().split(' ')))
        self.bit_i = [DSU(self.n) for _ in range(self.C)]
        self.bit_i_0 = [DSU(self.n) for _ in range(self.C)]
        self.one_works = [[0 for _ in range(self.n)] for _ in range(self.C)]

        for i in range(self.m):
            u, v, w = list(map(int, input().split(' ')))

            u -= 1
            v -= 1

            for j in range(self.C):
                if bit(w, j):
                    self.bit_i[j].merge(u, v)

                if bit(w, j) and bit(w, 0):
                    {{completion}}

                if bit(w, 0) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.one_works[b][i] == 1:
                    self.one_works[b][self.bit_i_0[b].root(i)] = 1

        #print(self.one_works)

    def query(self):

        u, v = list(map(int, input().split(' ')))

        u -= 1
        v -= 1

        for b in range(self.C):
            if self.bit_i[b].root(u) == self.bit_i[b].root(v):
                return 0

        for b in range(1, self.C):
            if self.bit_i_0[b].root(u) == self.bit_i_0[b].root(v):
                #print(""i_0="",b)
                return 1

            if self.one_works[b][self.bit_i_0[b].root(u)]:
                #print(""one_works="",b,self.bit_i_0[b].root(u))
                return 1

        return 2


cur = Solver1659E()

q = int(input())

while q:

    q -= 1

    print(cur.query())
","self.bit_i_0[j].merge(u, v)","































































































































"
"
import sys
from sys import stdin

def uf_find(n,p):

    ufl = []

    while p[n] != n:
        ufl.append(n)
        n = p[n]

    for i in ufl:
        p[i] = n

    return n


def uf_union(a,b,p,rank,flags):

    ap = uf_find(a,p)
    bp = uf_find(b,p)

    if ap == bp:
        return True
    else:

        if rank[ap] > rank[bp]:
            p[bp] = ap
            flags[ap] = flags[ap] or flags[bp]
        elif rank[ap] < rank[bp]:
            {{completion}}
        else:
            p[bp] = ap
            flags[ap] = flags[ap] or flags[bp]
            rank[ap] += 1

        return False


n,m = map(int,stdin.readline().split())

p = [ [j for j in range(n)] for i in range(30) ]
rank = [[0]*n for i in range(30)]
flags = [[False] * n for i in range(30)]

for loop in range(m):

    u,v,w = map(int,stdin.readline().split())
    u -= 1
    v -= 1

    if w & 1 == 0:
        for bit in range(1,30):
            up = uf_find(u,p[bit])
            flags[bit][up] = True
            vp = uf_find(v,p[bit])
            flags[bit][vp] = True

    vi = 1
    for bit in range(30):
        if vi & w != 0:
            uf_union(u,v,p[bit],rank[bit],flags[bit])
        vi *= 2

ANS = []
Q = int(stdin.readline())

for loop in range(Q):

    u,v = map(int,stdin.readline().split())
    u -= 1
    v -= 1

    #zero
    zflag = False
    for bit in range(30):
        if uf_find(u,p[bit]) == uf_find(v,p[bit]):
            zflag = True
            break

    if zflag:
        ANS.append(""0"")
        continue

    #one
    oflag = False
    for bit in range(1,30):
        up = uf_find(u,p[bit])
        if flags[bit][up]:
            oflag = True
            break

    if oflag:
        ANS.append(""1"")
    else:
        ANS.append(""2"")
            

print (""\n"".join(map(str,ANS)))
","p[ap] = bp
            flags[bp] = flags[ap] or flags[bp]","p[bp] = ap
            flags[ap] = flags[ap] or flags[bp]
            rank[ap] += 1"
"
import sys
from sys import stdin

def uf_find(n,p):

    ufl = []

    while p[n] != n:
        ufl.append(n)
        n = p[n]

    for i in ufl:
        p[i] = n

    return n


def uf_union(a,b,p,rank,flags):

    ap = uf_find(a,p)
    bp = uf_find(b,p)

    if ap == bp:
        return True
    else:

        if rank[ap] > rank[bp]:
            p[bp] = ap
            flags[ap] = flags[ap] or flags[bp]
        elif rank[ap] < rank[bp]:
            p[ap] = bp
            flags[bp] = flags[ap] or flags[bp]
        else:
            {{completion}}

        return False


n,m = map(int,stdin.readline().split())

p = [ [j for j in range(n)] for i in range(30) ]
rank = [[0]*n for i in range(30)]
flags = [[False] * n for i in range(30)]

for loop in range(m):

    u,v,w = map(int,stdin.readline().split())
    u -= 1
    v -= 1

    if w & 1 == 0:
        for bit in range(1,30):
            up = uf_find(u,p[bit])
            flags[bit][up] = True
            vp = uf_find(v,p[bit])
            flags[bit][vp] = True

    vi = 1
    for bit in range(30):
        if vi & w != 0:
            uf_union(u,v,p[bit],rank[bit],flags[bit])
        vi *= 2

ANS = []
Q = int(stdin.readline())

for loop in range(Q):

    u,v = map(int,stdin.readline().split())
    u -= 1
    v -= 1

    #zero
    zflag = False
    for bit in range(30):
        if uf_find(u,p[bit]) == uf_find(v,p[bit]):
            zflag = True
            break

    if zflag:
        ANS.append(""0"")
        continue

    #one
    oflag = False
    for bit in range(1,30):
        up = uf_find(u,p[bit])
        if flags[bit][up]:
            oflag = True
            break

    if oflag:
        ANS.append(""1"")
    else:
        ANS.append(""2"")
            

print (""\n"".join(map(str,ANS)))
","p[bp] = ap
            flags[ap] = flags[ap] or flags[bp]
            rank[ap] += 1","uf_union(u,v,p[bit],rank[bit],flags[bit])"
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


class dsu:

    def __init__(self , n):

        self.p = [0]*(n + 1)
        self.rank = [0]*(n + 1)

        for i in range(1 , n + 1):
            self.p[i] = i

    def find(self , node):
        if(self.p[node] == node):return node

        self.p[node] = self.find(self.p[node])
        return self.p[node]

    def union(self , u , v):
        u , v = self.find(u) , self.find(v)

        if(self.rank[u] == self.rank[v]):
            self.p[v] = u
            self.rank[u] += 1

        elif(self.rank[u] > self.rank[v]):
            self.p[v] = u

        else:
            self.p[u] = v

def answer():

    zeronotset = [False for i in range(n + 1)]
    for i in range(m):
        u , v , w = edges[i]

        if(w & 1 == 0):
            zeronotset[u] = True
            zeronotset[v] = True

    d = [dsu(n) for i in range(30)]
    for i in range(30):

        for j in range(m):
            u , v , w = edges[j]

            if(w >> i & 1):
                d[i].union(u , v)


    zero = [dsu(n) for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):

            u , v , w = edges[j]

            if(w & 1 and w >> i & 1):
                zero[i].union(u , v)
                

    value = [[2 for i in range(n + 1)] for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):
            u , v , w = edges[j]

            if(zeronotset[u]):
                value[i][zero[i].find(u)] = 1

            if(zeronotset[v]):
                value[i][zero[i].find(v)] = 1

    for q in range(int(input())):

        u , v = inp()

        ans = 2
        for i in range(30):
            if(d[i].find(u) == d[i].find(v)):
                ans = 0
                break

        if(ans == 2):

            for i in range(1 , 30):
                 if(value[i][zero[i].find(u)] == 1):
                    {{completion}}

        print(ans)
                
            
            
for T in range(1):

    n , m = inp()

    edges = []
    for i in range(m):
        u , v , w = inp()
        edges.append([u , v , w])
    

    answer()
","ans = 1
                    break","































































































































"
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


class dsu:

    def __init__(self , n):

        self.p = [0]*(n + 1)
        self.rank = [0]*(n + 1)

        for i in range(1 , n + 1):
            self.p[i] = i

    def find(self , node):
        if(self.p[node] == node):return node

        self.p[node] = self.find(self.p[node])
        return self.p[node]

    def union(self , u , v):
        u , v = self.find(u) , self.find(v)

        if(self.rank[u] == self.rank[v]):
            self.p[v] = u
            self.rank[u] += 1

        elif(self.rank[u] > self.rank[v]):
            self.p[v] = u

        else:
            self.p[u] = v

def answer():

    zeronotset = [False for i in range(n + 1)]
    for i in range(m):
        u , v , w = edges[i]

        if(w & 1 == 0):
            zeronotset[u] = True
            zeronotset[v] = True

    d = [dsu(n) for i in range(30)]
    for i in range(30):

        for j in range(m):
            u , v , w = edges[j]

            if(w >> i & 1):
                {{completion}}


    zero = [dsu(n) for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):

            u , v , w = edges[j]

            if(w & 1 and w >> i & 1):
                zero[i].union(u , v)
                

    value = [[2 for i in range(n + 1)] for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):
            u , v , w = edges[j]

            if(zeronotset[u]):
                value[i][zero[i].find(u)] = 1

            if(zeronotset[v]):
                value[i][zero[i].find(v)] = 1

    for q in range(int(input())):

        u , v = inp()

        ans = 2
        for i in range(30):
            if(d[i].find(u) == d[i].find(v)):
                ans = 0
                break

        if(ans == 2):

            for i in range(1 , 30):
                 if(value[i][zero[i].find(u)] == 1):
                    ans = 1
                    break

        print(ans)
                
            
            
for T in range(1):

    n , m = inp()

    edges = []
    for i in range(m):
        u , v , w = inp()
        edges.append([u , v , w])
    

    answer()
","d[i].union(u , v)","































































































































"
