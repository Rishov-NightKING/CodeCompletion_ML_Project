eval_prompt,ground_truth,model_output
"n,q = map(int,input().split())
graph = [set() for _ in range(n)]
start = [0xffffffff]*n
for _ in range(q):
    i,j,x = map(int,input().split())
    i -= 1; j -= 1
    graph[i].add(j)
    graph[j].add(i)
    start[i] &= x
    start[j] &= x
for i in range(n):
    if {{completion}}
        continue
    val = start[i]
    for j in graph[i]:
        val &= start[j]
    start[i] ^= val
print(*start)",i in graph[i]:,i in graph[i]:
"n,q = map(int,input().split())
graph = [set() for _ in range(n)]
start = [0xffffffff]*n
for _ in range(q):
    i,j,x = map(int,input().split())
    i -= 1; j -= 1
    graph[i].add(j)
    graph[j].add(i)
    start[i] &= x
    start[j] &= x
for i in range(n):
    if i in graph[i]:
        continue
    val = start[i]
    for {{completion}}
        val &= start[j]
    start[i] ^= val
print(*start)",j in graph[i]:,j in graph[i]:
"import sys

n, Q = list(map(int, sys.stdin.readline().strip().split()))
m = [0] * n
M = [2 ** 30 - 1] * n
L = [[] for i in range (0, n)]
for q in range (0, Q):
    i, j, x = list(map(int, sys.stdin.readline().strip().split()))
    i -= 1
    j -= 1
    M[i] &= x
    M[j] &= x
    L[i].append((j, x))
    L[j].append((i, x))
for i in range (0, n):
    for (j, x) in L[i]:
        if {{completion}}
            m[i] |= x ^ M[j]
        else:
            m[i] = x
    M[i] = m[i]
print(*m)
",j != i:,i in L[i]:
"from sys import stdin, stdout
input, print = stdin.buffer.readline, stdout.write

n, T = [int(x) for x in input().split()]

ans = [(1<<31)-1] * n


from collections import defaultdict
R = defaultdict(list)

for _ in range(T):
    a,b, x = [int(_a) for _a in input().split()]
    a -= 1
    b -= 1
    a,b = min(a,b), max(a,b)
    ans[a] &=  x
    ans[b] &=  x
    R[a].append(b)
    R[b].append(a)



for i in range(len(ans)):
    for b in range(30,-1,-1):
        mask = 1 << b
        if mask & ans[i] == 0:
            continue
        can_remove = True
        for j in R[i]:
            if {{completion}}
                can_remove = False
                break
        if can_remove:
            ans[i] ^= mask

print("" "".join(str(x)for x in ans)+""\n"")
",i == j or mask & ans[j] == 0:,j in R[i]:
"n,q = map(int, input().split())
adj = [list() for i in range(n+1)]
val = [-1]*(n+1)
for _ in range(q):
    i,j,x=map(int, input().split())
    val[i] &= x
    val[j] &= x
    adj[i].append(j)
    adj[j].append(i)
# print(*val[1:], sep="" "")
# print(*adj, sep=""\n"")

for a in range(1, n+1):
    if val[a] == -1:
        val[a] = 0
        continue
    t = val[a]
    for b in adj[a]: 
        if {{completion}}
            t = 0
            break
        t &= val[b]
    val[a] ^= t
    # print(*val[1:], sep="" "")

print(*val[1:], sep="" "")
        


    
",b == a:,a in adj[a]:
"n, q = map(int, input().strip().split())

qs = [[] for _ in range(n)]
refers_self = [False for _ in range(n)]
for _ in range(q):
    i, j, x = map(int, input().strip().split())
    if i==j:
        refers_self[i-1] = True
    qs[i-1].append((j-1, x))
    qs[j-1].append((i-1, x))

a = []
for i in range(n):
    if qs[i]:
        ans = (2<<32) - 1
        for {{completion}}
            ans = ans & x
        a.append(ans)
    else:
        a.append(0)


for i in range(n):
    if refers_self[i]:
        continue
    ans = (2<<32) - 1
    for j, x in qs[i]:
        ans = ans & a[j]

    a[i] = a[i] - (a[i]&ans)

print(*a)
","j, x in qs[i]:",i == j:
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def update(i , t):

    global ans

    if(i + 1 < n and a[i] == a[i + 1]):
        ans += t * (i + 1)
    else:
        ans += t * (n - i) * (i + 1)

    return ans

def answer():

    global ans

    ans = 0
    for i in range(n):

        update(i , 1)


    for q in range(m):
        i , x = inp()
        i -= 1

        if{{completion}}update(i - 1 , -1)
        update(i , -1)

        a[i] = x
        if(i >= 0):update(i - 1 , 1)
        update(i , 1)

        print(ans)

        
for T in range(1):

    n , m = inp()
    a = inp()
    
    answer()
",(i >= 0):,(i >= 0):
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def update(i , t):

    global ans

    if(i + 1 < n and a[i] == a[i + 1]):
        ans += t * (i + 1)
    else:
        ans += t * (n - i) * (i + 1)

    return ans

def answer():

    global ans

    ans = 0
    for i in range(n):

        update(i , 1)


    for q in range(m):
        i , x = inp()
        i -= 1

        if(i >= 0):update(i - 1 , -1)
        update(i , -1)

        a[i] = x
        if{{completion}}update(i - 1 , 1)
        update(i , 1)

        print(ans)

        
for T in range(1):

    n , m = inp()
    a = inp()
    
    answer()
",(i >= 0):,(i >= 0):
"import sys
input = sys.stdin.readline 

n, m = map(int, input().split())
a = list(map(int, input().split()))
a.insert(0, 0)
a.append(0)
ans = 0 
for {{completion}}
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    
while(m):
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    m -= 1
","i in range(1, n + 1):",(m):
"import sys
input = sys.stdin.readline 

n, m = map(int, input().split())
a = list(map(int, input().split()))
a.insert(0, 0)
a.append(0)
ans = 0 
for i in range(1, n + 1):
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    
while{{completion}}
    i, x = map(int, input().split())
    ans -= (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans -= (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    a[i] = x 
    ans += (a[i] != a[i - 1]) * (n - i + 1) * (i - 1)
    ans += (a[i] != a[i + 1]) * (n - (i + 1) + 1) * i 
    print(ans + n * (n + 1) // 2)
    m -= 1
",(m):,"i in range(1, n + 1):"
"import time, sys

n, m = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]
t1 = time.time()
w = [(i+1)*(n-i-1) for i in range(n-1)]
c = sum([w[i] if a[i+1] != a[i] else 0 for i in range(n-1)])
for _ in range(m):
    ix, x = [int(i) for i in sys.stdin.readline().split()]
    ix -= 1
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += w[ix-1]
        elif {{completion}}
            c -= w[ix-1]
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif a[ix] != a[ix+1] == x:
            c -= w[ix]
    a[ix] = x

    sys.stdout.write(str(c+(n*(n+1))//2) + '\n')",a[ix] != a[ix-1] == x:,a[ix]!= a[ix+1] == x:
"import time, sys

n, m = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]
t1 = time.time()
w = [(i+1)*(n-i-1) for i in range(n-1)]
c = sum([w[i] if a[i+1] != a[i] else 0 for i in range(n-1)])
for _ in range(m):
    ix, x = [int(i) for i in sys.stdin.readline().split()]
    ix -= 1
    if ix != 0:
        if a[ix] == a[ix-1] != x:
            c += w[ix-1]
        elif a[ix] != a[ix-1] == x:
            c -= w[ix-1]
    if ix != n-1:
        if a[ix] == a[ix+1] != x:
            c += w[ix]
        elif {{completion}}
            c -= w[ix]
    a[ix] = x

    sys.stdout.write(str(c+(n*(n+1))//2) + '\n')",a[ix] != a[ix+1] == x:,a[ix]!= a[ix+1] == x:
"import sys
import collections
inf=float('inf')
mod=10**5+7
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())
# for case in range(inpint()):
n,m=inpnm()
arr=inparr()
res=[1]
cnt=0
se=1
t=1
for i in range(1,n):
    if arr[i]==arr[i-1]:
        cnt+=1
        res.append(res[-1]+1)
    else:
 
        se+=1
        t=res[-1]
        res.append(res[-1]+se+cnt)
 
ans=sum(res)
for q in range(m):
 
    i,x=inpnm()
    i-=1
    if {{completion}}
        ans-=i*(n-i)
    if i!=n-1 and arr[i+1]!=arr[i]:
        ans-=(i+1)*(n-i-1)
 
    arr[i]=x
 
    if i!=0 and arr[i-1]!=x:
        ans+=i*(n-i)
 
    if i!=n-1 and arr[i+1]!=x:
        ans+=(i+1)*(n-i-1)
    print(ans)",i!=0 and arr[i-1]!=arr[i]:,i!=n-1 and arr[i+1]!=arr[i]:
"import sys
import collections
inf=float('inf')
mod=10**5+7
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())
# for case in range(inpint()):
n,m=inpnm()
arr=inparr()
res=[1]
cnt=0
se=1
t=1
for i in range(1,n):
    if arr[i]==arr[i-1]:
        cnt+=1
        res.append(res[-1]+1)
    else:
 
        se+=1
        t=res[-1]
        res.append(res[-1]+se+cnt)
 
ans=sum(res)
for q in range(m):
 
    i,x=inpnm()
    i-=1
    if i!=0 and arr[i-1]!=arr[i]:
        ans-=i*(n-i)
    if {{completion}}
        ans-=(i+1)*(n-i-1)
 
    arr[i]=x
 
    if i!=0 and arr[i-1]!=x:
        ans+=i*(n-i)
 
    if i!=n-1 and arr[i+1]!=x:
        ans+=(i+1)*(n-i-1)
    print(ans)",i!=n-1 and arr[i+1]!=arr[i]:,i!=n-1 and arr[i+1]!=arr[i]:
"def update_awesomeness(arr, i, x, curr_aws):
    left_edit = (x != arr[i - 1]) - (arr[i] != arr[i - 1]) if i != 0 else 0
    right_edit = (x != arr[i + 1]) - (arr[i] != arr[i + 1]) if i != n - 1 else 0
    arr[i] = x
    return curr_aws + left_edit * i * (n - i) + right_edit * (i + 1) * (n - i - 1)


INPUT = [*open(0)]

n, m = map(int, INPUT[0].split())
arr = list(map(int, INPUT[1].split()))
tar = [0] * n
aws = (n * (n + 1)) // 2

for {{completion}}
    aws = update_awesomeness(tar, i, x, aws)

for line in INPUT[2:]:
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i - 1, x, aws)
    print(aws)","i, x in enumerate(arr):",(m):
"def update_awesomeness(arr, i, x, curr_aws):
    left_edit = (x != arr[i - 1]) - (arr[i] != arr[i - 1]) if i != 0 else 0
    right_edit = (x != arr[i + 1]) - (arr[i] != arr[i + 1]) if i != n - 1 else 0
    arr[i] = x
    return curr_aws + left_edit * i * (n - i) + right_edit * (i + 1) * (n - i - 1)


INPUT = [*open(0)]

n, m = map(int, INPUT[0].split())
arr = list(map(int, INPUT[1].split()))
tar = [0] * n
aws = (n * (n + 1)) // 2

for i, x in enumerate(arr):
    aws = update_awesomeness(tar, i, x, aws)

for {{completion}}
    i, x = map(int, line.split())
    aws = update_awesomeness(tar, i - 1, x, aws)
    print(aws)",line in INPUT[2:]:,"i, x in enumerate(arr):"
"""""""
author: Manoj
inp_start
5 5
1 2 3 4 5
3 2
4 2
3 1
2 1
2 2

inp_end
""""""
n, m = list(map(int, input().split()))
li = list(map(int, input().split()))
ans = int((n*(n+1))/2)

for i in range(1, n):
	if li[i]!=li[i-1]:
		ans += i*(n-i) 

al = []
for tc in range(m):
	i, x = list(map(int, input().split()))
	i -= 1
	if i>0:
		if {{completion}}
			ans-=i*(n-i)
		if x!=li[i-1]:
			ans+=i*(n-i)
	if i+1<n:
		if li[i]!=li[i+1]:
			ans-=(i+1)*(n-i-1)
		if x!=li[i+1]:
			ans+=(i+1)*(n-i-1)
			
	li[i]=x
	al.append(ans)
	
print(*al)
	
	",li[i]!=li[i-1]:,x!=li[i-1]:
"""""""
author: Manoj
inp_start
5 5
1 2 3 4 5
3 2
4 2
3 1
2 1
2 2

inp_end
""""""
n, m = list(map(int, input().split()))
li = list(map(int, input().split()))
ans = int((n*(n+1))/2)

for i in range(1, n):
	if li[i]!=li[i-1]:
		ans += i*(n-i) 

al = []
for tc in range(m):
	i, x = list(map(int, input().split()))
	i -= 1
	if i>0:
		if li[i]!=li[i-1]:
			ans-=i*(n-i)
		if {{completion}}
			ans+=i*(n-i)
	if i+1<n:
		if li[i]!=li[i+1]:
			ans-=(i+1)*(n-i-1)
		if x!=li[i+1]:
			ans+=(i+1)*(n-i-1)
			
	li[i]=x
	al.append(ans)
	
print(*al)
	
	",x!=li[i-1]:,li[i]!=li[i-1]:
"import sys
input=lambda:sys.stdin.readline().rstrip()
n,q=map(int,input().split())
arr=[0]+[*map(int,input().split())]+[0]
awe=0
awr=[0]*(n+1)
for i in range(1,n+1):
    if {{completion}}
        awr[i]+=awr[i-1]+(i-1)
    else:
        awr[i]+=awr[i-1]
    awr[i]+=1
awe=sum(awr)
for _ in range(q):
    i,x=map(int,input().split())
    lprev=arr[i]!=arr[i-1]
    rprev=arr[i]!=arr[i+1]
    arr[i]=x
    laftr=arr[i]!=arr[i-1]
    raftr=arr[i]!=arr[i+1]
    dl=laftr-lprev
    dr=raftr-rprev
    awe+=dl*(i-1)*(n-i+1)
    awe+=dr*(i)*(n-i)
    print(awe)",arr[i]!=arr[i-1]:,"i in range(1, n + 1):"
"



import sys
input=sys.stdin.readline #文字列入力はするな！！



########################################
from heapq import heappush, heappop
B=10**5+10
def dijkstra( G, dist, INF=10**11):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    G[v] = [(nod, cost)]:
        頂点vから遷移可能な頂点(nod)とそのコスト(cost)
    s: 始点の頂点""""""

    N=len(dist)
    hp=[]
    for i in range(N):
        heappush(hp,dist[i]*B+i)
    while hp:
        cv=heappop(hp)
        c, v = cv//B,cv%B
        if dist[v] < c:
            continue
        for u, cost in G[v]:
            if {{completion}}
                dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)
    return dist
##################################################




#########################################
from collections import deque
class Convex_Hull_Trick():

    #https://tjkendev.github.io/procon-library/python/convex_hull_trick/deque.html
    #追加する傾きが単調かつqueryのxが単調
    #単調性なしが良いならこちらへ(queryのxは先読み) https://judge.yosupo.jp/submission/30579

    def __init__(self):
        self.deq=deque()
    def check(self,f1, f2, f3):
        return (f2[0] - f1[0]) * (f3[1] - f2[1]) >= (f2[1] - f1[1]) * (f3[0] - f2[0])
    def f(self,f1, x):
        return f1[0] * x + f1[1]

    # add f_i(x) = a*x + b
    def add_line(self,a, b):
        f1 = (a, b)
        while len(self.deq) >= 2 and self.check(self.deq[-2], self.deq[-1], f1):
            self.deq.pop()
        self.deq.append(f1)

    # min f_i(x)
    def query(self,x):
        while len(self.deq) >= 2 and self.f(self.deq[0], x) >= self.f(self.deq[1], x):
            self.deq.popleft()
        return self.f(self.deq[0], x)

##################################


n,m,k=map(int,input().split())
root=[[] for i in range(n+2)]
for i in range(m):
    a,b,c=map(int,input().split())
    root[a].append((b,c))
    root[b].append((a,c))
dp=[10**11]*(n+1)
dp[1]=0
dp=dijkstra(root,dp)
for iii in range(k):
    newdp=[10**11]*(n+1)
    cht=Convex_Hull_Trick()
    for i in range(1,n+1):
        cht.add_line(-2*i,dp[i]+i**2)
    for i in range(1,n+1):
        newdp[i]=cht.query(i)+i**2


    dp=newdp[:]
    dp=dijkstra(root,dp)
print(*dp[1:])




",dist[v] + cost < dist[u]:,"u, cost in G[v]:"
"



import sys
input=sys.stdin.readline #文字列入力はするな！！



########################################
from heapq import heappush, heappop
B=10**5+10
def dijkstra( G, dist, INF=10**11):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    G[v] = [(nod, cost)]:
        頂点vから遷移可能な頂点(nod)とそのコスト(cost)
    s: 始点の頂点""""""

    N=len(dist)
    hp=[]
    for i in range(N):
        heappush(hp,dist[i]*B+i)
    while hp:
        cv=heappop(hp)
        c, v = cv//B,cv%B
        if dist[v] < c:
            continue
        for {{completion}}
            if dist[v] + cost < dist[u]:
                dist[u] = dist[v] + cost
                heappush(hp, dist[u]*B+u)
    return dist
##################################################




#########################################
from collections import deque
class Convex_Hull_Trick():

    #https://tjkendev.github.io/procon-library/python/convex_hull_trick/deque.html
    #追加する傾きが単調かつqueryのxが単調
    #単調性なしが良いならこちらへ(queryのxは先読み) https://judge.yosupo.jp/submission/30579

    def __init__(self):
        self.deq=deque()
    def check(self,f1, f2, f3):
        return (f2[0] - f1[0]) * (f3[1] - f2[1]) >= (f2[1] - f1[1]) * (f3[0] - f2[0])
    def f(self,f1, x):
        return f1[0] * x + f1[1]

    # add f_i(x) = a*x + b
    def add_line(self,a, b):
        f1 = (a, b)
        while len(self.deq) >= 2 and self.check(self.deq[-2], self.deq[-1], f1):
            self.deq.pop()
        self.deq.append(f1)

    # min f_i(x)
    def query(self,x):
        while len(self.deq) >= 2 and self.f(self.deq[0], x) >= self.f(self.deq[1], x):
            self.deq.popleft()
        return self.f(self.deq[0], x)

##################################


n,m,k=map(int,input().split())
root=[[] for i in range(n+2)]
for i in range(m):
    a,b,c=map(int,input().split())
    root[a].append((b,c))
    root[b].append((a,c))
dp=[10**11]*(n+1)
dp[1]=0
dp=dijkstra(root,dp)
for iii in range(k):
    newdp=[10**11]*(n+1)
    cht=Convex_Hull_Trick()
    for i in range(1,n+1):
        cht.add_line(-2*i,dp[i]+i**2)
    for i in range(1,n+1):
        newdp[i]=cht.query(i)+i**2


    dp=newdp[:]
    dp=dijkstra(root,dp)
print(*dp[1:])




","u, cost in G[v]:",dp[v] + cost < dp[u]:
"n,k=map(int,input().split())
l=list(map(int,input().split()))

ans=-2
b=l.count(0)

for y in range(n):
	a=l[y:]+l[:y]
	ind=[]
	s=0
	
	for i in range(n):
		if {{completion}}
			ind+=[i]
			a[i]=k
		s+=a[i]
	
	while s>0 and len(ind)>0:
		a[ind[-1]]=max(k-s,-k)
		s+=(-k+a[ind[-1]])
		ind=ind[:-1]
	
	s=0
	f=0
	for i in range(n):
		s+=a[i]
		f=max(f,s)
	
	if sum(a)==0:
		ans=max(ans,f)
	

print(ans+1)
",a[i]==0:,s>0 and len(ind)>0:
"R=lambda:map(int,input().split())
n,k=R();n+=1
a=[0]+[*R()]

p0,p=[0]*n,[0]*n
for i in range(1,n):
  p0[i]=p0[i-1]+int(a[i]==0)
  p[i]=p[i-1]+a[i]
s=p[-1]

if p0[-1]*k<abs(s):
  res=-1
else:
  res=0
  for i in range(n):
    for {{completion}}
      l0=p0[j]-p0[i];r0=p0[-1]-l0
      l,r=max(-l0*k, -s-r0*k),min(l0*k, -s+r0*k)
      v=p[j]-p[i]
      res=max(res, 1+abs(v+l), 1+abs(v+r))
print(res)","j in range(i+1,n):",p0[j]-p0[i]<0:
"import sys
input = sys.stdin.readline

def ProGamerMove():
	n, k = map(int, input().split())
	a = list(map(int, input().split()))
	zeros = a.count(0)
	sm = sum(a)
	s1, s2 = 0, 0
	c1, c2 = 0, 0
	res = -2
	def intersect(m1, b1, m2, b2):
		l1, r1 = m1 - b1 * k, m1 + b1 * k
		l2, r2 = m2 - b2 * k, m2 + b2 * k
		return not (r1 < l2 or r2 < l1)
	for l in range(0, n + 1):
		s2, c2 = 0, 0
		for r in range(0, n + 1):
			if l <= r:
				b1, b2, b3 = c1, c2 - c1, zeros - c2
				m1, m2, m3 = s1, s2 - s1, sm - s2
				# b1 + b3 == -b2
				# min b1, b3
				if {{completion}} continue
				r1 = max(m1 + m3 - (b1 + b3) * k, -m2 - b2 * k)
				r2 = min(m1 + m3 + (b1 + b3) * k, -m2 + b2 * k)
				res = max(res, abs(r1), abs(r2))
			if r < n:
				s2 += a[r]
				c2 += a[r] == 0
		if l < n:
			s1 += a[l]
			c1 += a[l] == 0
	print(res + 1)

n = 1
#n = int(input())
for _ in range(0, n): ProGamerMove()
","not intersect(m1 + m3, b1 + b3, -m2, b2):",b1 + b3 == -b2
"n, k = map(int, input().split())
A = list(map(int, input().split()))

ans = 0
for i in range(n):
    C = [0]*n
    for j in range(n-1, -1, -1):
        if A[j] == 0:
            C[j] = 1
        if j+1 < n:
            C[j] += C[j+1]
    B = A.copy()
    s = sum(B)
    flag = True
    for j in range(n):
        if B[j] == 0:
            if {{completion}}
                x = C[j+1]
            else:
                x = 0
            B[j] = min(k, x*k-s)
            if B[j] < -k:
                flag = False
            s += B[j]
    if flag:
        pos = 0
        mn = 0
        mx = 0
        for j in range(n):
            pos += B[j]
            mn = min(mn, pos)
            mx = max(mx, pos)
        if pos == 0:
            ans = max(ans, mx-mn+1)
    A = A[1:]+A[0:1]

if ans != 0:
    print(ans)
else:
    print(-1)
",j+1 < n:,B[j] < -k:
"n, k = map(int, input().split())
A = list(map(int, input().split()))

ans = 0
for i in range(n):
    C = [0]*n
    for j in range(n-1, -1, -1):
        if A[j] == 0:
            C[j] = 1
        if j+1 < n:
            C[j] += C[j+1]
    B = A.copy()
    s = sum(B)
    flag = True
    for j in range(n):
        if B[j] == 0:
            if j+1 < n:
                x = C[j+1]
            else:
                x = 0
            B[j] = min(k, x*k-s)
            if {{completion}}
                flag = False
            s += B[j]
    if flag:
        pos = 0
        mn = 0
        mx = 0
        for j in range(n):
            pos += B[j]
            mn = min(mn, pos)
            mx = max(mx, pos)
        if pos == 0:
            ans = max(ans, mx-mn+1)
    A = A[1:]+A[0:1]

if ans != 0:
    print(ans)
else:
    print(-1)
",B[j] < -k:,B[j] < -k:
"MOD = 998244353
TRANS = [6, 3, 7, 4, 1, 0]
 
s = input().strip()
dp = [0] * 7 + [1]
for c in map(int, s):
    dp1 = [0] * 8
    for i in range(8):
        for k in TRANS:
            if c:
                dp1[k & i] += dp[i]
            elif {{completion}}
                dp1[i] += dp[i]
    dp = [x % MOD for x in dp1]
n = int(s, base=2) + 1
print((n**3 + 3 * n**2 - n - 3 * sum(dp)) % MOD)",(k & i) == 0:,(k&i)==0:
"MOD=998244353
TRANS=[6,3,7,4,1,0]
s=input().strip()
dp=[0]*7+[1]
for c in map(int,s):
    dp1=[0]*8
    for i in range(8):
        for k in TRANS:
            if c:
                dp1[k&i]+=dp[i]
            elif{{completion}}
                dp1[i]+=dp[i]
    dp=[x%MOD for x in dp1]
n=int(s,base=2)+1
print((n**3+3*n**2-n-3*sum(dp))%MOD)",(k&i)==0:,(k&i)==0:
"I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if {{completion}}z=0;break
    if p==0:zero=True
    if p<0:z=0;break
  print(['NO','YES'][zero and z])",zero and p>0:,p==0:
"I=input
for _ in [0]*int(I()):
  I();p,z,zero=0,1,0
  for v in I().split():
    p+=int(v)
    if zero and p>0:z=0;break
    if {{completion}}zero=True
    if p<0:z=0;break
  print(['NO','YES'][zero and z])",p==0:,zero and p>0:
"import sys
input = lambda : sys.stdin.readline().rstrip()

dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]


def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    if sum(arr)!=0:
        return 0

    psum = 0
    f = 0
    
    for i in range(len(arr)):
        psum += arr[i]
        if psum < 0:
            return 0
        if psum==0:
            f = 1
        elif {{completion}}
            return 0
        
    return 1


for __ in range(int(input())):
    print('Yes' if solve() else 'No')",f:,psum==0:
"for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    tot = a[0]

    for i in range(1, n):
        if tot < 0:
            break
        elif tot == 0:
            if {{completion}}
                break
        else:
            tot += a[i]
    else:
        if tot == 0:
            print(""Yes"")
            continue

    print(""No"")
",a[i] != 0:,tot<0:
"from sys import stdin

t = int(stdin.readline())
for h in range(t):
    n = int(stdin.readline())
    a = list(map(int,stdin.readline().split(' ')))
    b = 0
    v = True
    for i in range(n):
        b += a[i]
        if b<0:
            v = False
            break
        elif b==0:
            for j in range(i+1,n):
                if {{completion}}
                    v = False
                    break
            break
    if v and sum(a) == 0:
        print('YES')
    else:
        print('NO')",a[j] != 0:,b==0:
"for _ in [0]*int(input()):
    input()
    n = list(map(int,input().split()))
    s,f,m = 0,0,0
    for i in n:
        s+=i
        if {{completion}}m = 1;break
        if s==0:f=1
        if f and s>0:m=1;break
    print(""YNEOS""[(m or not f)::2])",s<0:,s==0:
"for _ in [0]*int(input()):
    input()
    n = list(map(int,input().split()))
    s,f,m = 0,0,0
    for i in n:
        s+=i
        if s<0:m = 1;break
        if {{completion}}f=1
        if f and s>0:m=1;break
    print(""YNEOS""[(m or not f)::2])",s==0:,s<0:
"if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        n = int(input())
        a = [int(i) for i in input().split()]

        x = a[0]

        ok = True
        for v in a[1:]:
            if {{completion}}
                ok = False
                break
            if x == 0 and v != 0:
                ok = False
                break
            x += v

        print(""yes"" if ok and x == 0 else ""no"")
",x < 0:,x == 0 and v!= 0:
"if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        n = int(input())
        a = [int(i) for i in input().split()]

        x = a[0]

        ok = True
        for v in a[1:]:
            if x < 0:
                ok = False
                break
            if {{completion}}
                ok = False
                break
            x += v

        print(""yes"" if ok and x == 0 else ""no"")
",x == 0 and v != 0:,x < 0:
"input = __import__('sys').stdin.readline


def solve():
    n = int(input())
    allzeros = False
    total = 0
    for x in map(int, input().split()):
        total += x
        if {{completion}}
            print('No')
            return
        allzeros = allzeros or total == 0

    print('YES' if total == 0 else 'NO')


for _ in range(int(input())):
    solve()",total < 0 or total != 0 and allzeros:,total==0:
"import sys
input=sys.stdin.readline
I = lambda : list(map(int,input().split()))

t,=I()
for _ in range(t):
	n, = I()
	l = I()
	pos = 0
	if sum(l)!=0 or l[-1]>0:
		pos=1
	else:
		pref = l[0]
		seen = 0
		if pref<0:
			pos=1
		if pref==0:
			seen = 1
		for i in range(1,n):
			pref+=l[i]
			if pref<0:
				pos=1
				break
			elif pref==0:
				seen = 1
			else:
				if {{completion}}
					pos=1
					break
	print(""YNeos""[pos::2])",seen:,pref<0:
"for t in range(int(input())):
    
    n=int(input())
    a=list(map(int,input().split()))
    i=n-1
    while(a[i]==0 and i!=0):
        i-=1 
    while(i>0):
        if a[i]>=0:
            print(""NO"")
            break
        a[i-1]+=a[i]
        i-=1
    else:
        if {{completion}}
            print(""YES"")
        else:
            print(""NO"")
",a[i]==0:,a[i]>=0:
"for i in range(int(input())):
    n=int(input())
    c=[int(j) for j in input().split()]
    k=1
    if [0]*n==c:
        print('Yes')
    else:
        g=0
        while c[-1]==0:
            c.pop()
        while len(c)-1:
            if {{completion}}
                k=0
                break
            g=g-c.pop()
        print(['No','Yes'][g==c[0] and k])",g<=c[-1]:,k==0:
"import heapq as hq
INF = 1001001001
N, M = map(int, input().split())
G = [[] for _ in range(N)]
d = [0] * N
for _ in range(M):
    U, V = map(int, input().split())
    G[V - 1].append(U - 1)
    d[U - 1] += 1

dists = [INF] * N
dists[N - 1] = 0
queue = [(0, N - 1)]
while queue:
    dist, V = hq.heappop(queue)
    if dists[V] < dist: continue
    for v in G[V]:
        if {{completion}}
            dists[v] = dist + d[v]
            hq.heappush(queue, (dist + d[v], v))
        d[v] -= 1
print(dists[0])",dist + d[v] < dists[v]:,dists[v]<dist+d[v]:
"from heapq import*;I=input;R=lambda:map(int,I().split())
n,m=R();g,q,vis=[[] for _ in range(n)],[(0,n-1)],[0]*n
d,out=[m+1]*n,[0]*n;d[-1]=0
for _ in range(m):u,v=R();u,v=u-1,v-1;g[v].append(u);out[u]+=1
while q:
  _,u=heappop(q)
  if vis[u]:continue
  vis[u]=1
  for v in g[u]:
    if {{completion}}d[v]=d[u]+out[v];heappush(q,(d[v],v))
    out[v]-=1
print(d[0])",d[u]+out[v]<d[v]:,d[v]>d[u]+out[v]:
"


import sys
input=sys.stdin.readline #文字列入力はするな！！
from heapq import *

n,m=map(int,input().split())
root=[[] for i in range(n+2)]
rootinv=[[] for i in range(n+2)]
no=[0]*(n+2)
for i in range(m):
    u,v=map(int,input().split())
    root[u].append(v)
    rootinv[v].append(u)
    no[u]+=1
dp=[10**18]*(n+3)
dp[n]=0
hp=[(0,n)]
while hp:
    c,x=heappop(hp)
    if dp[x]<c:continue
    for y in rootinv[x]:
        no[y]-=1
        cost=no[y]+1
        if {{completion}}
            dp[y]=dp[x]+cost
            heappush(hp,(dp[y],y))
print(dp[1])



",dp[y]>dp[x]+cost:,dp[y]<c:
"import sys, heapq
input=sys.stdin.readline

n,m=map(int,input().split())
iadj=[{} for _ in range(n)]  # inverted road
nadj=[0]*n
dist=[n+1]*n
cost=[float(""inf"")]*n
visit=[0]*n

for _ in range(m):
    v,u=map(int,input().split())
    v-=1
    u-=1
    pi=iadj[u].setdefault(v,0)
    iadj[u][v]=1+pi  # road from v->u
    nadj[v]+=1

q = [(0,n-1)]
cost[n-1]=0
while q:
    d,v=heapq.heappop(q)
    if visit[v]:
        continue
    visit[v]=1
    for u in iadj[v]:
        nadj[u]-=iadj[v][u]
        if {{completion}}
            cost[u]=cost[v]+nadj[u] + 1
            heapq.heappush(q, (cost[u], u))

print(cost[0])",cost[v] + nadj[u] + 1 < cost[u]:,cost[u]<cost[v]:
"input = __import__('sys').stdin.readline


n = int(input())
a = list(map(int, input().split())) + [n+1]


ans = 0
cache = {}
for i in range(n):
    u = 0
    d = n+1
    
    keys = []
    j = i
    while j+1 <= n:
        key = (j, u, d)
        v = cache.get(key, -1)
        if v != -1:
            j = v
            break
        
        keys.append(key)
        # greedy
        if u < a[j] < d: # if can insert to both
            if a[j] < a[j+1]:
                u = max(u, a[j])
            elif {{completion}}
                d = min(d, a[j])
        elif u < a[j]: # if only can insert to increasing subsequence
            u = a[j]
        elif d > a[j]: # if only can insert to decreasing subsequence
            d = a[j]
        else:
            break

        j += 1
    
    for key in keys:
        cache[key] = j

    ans += j - i
    # print(f'at {i} max {j} ans {ans}', u, d)

# print(f'count={len(cache)}')
print(ans)
",a[j] > a[j+1]:,a[j] > a[j+1]:
"input = __import__('sys').stdin.readline


n = int(input())
a = list(map(int, input().split())) + [n+1]

cache = {}
def check(i, u, d):
    keys = []
    j = i
    while j+1 <= n:
        key = (j, u, d)
        v = cache.get(key, -1)
        if v != -1:
            j = v
            break
        
        keys.append(key)
        if u < a[j] < d: # if can insert to both
            if a[j] < a[j+1]:
                u = max(u, a[j])
            elif {{completion}}
                d = min(d, a[j])
        elif u < a[j]: # if only can insert to increasing subsequence
            u = a[j]
        elif d > a[j]: # if only can insert to decreasing subsequence
            d = a[j]
        else:
            break

        j += 1
    
    for key in keys:
        cache[key] = j
    
    return j

ans = 0
for i in range(n):
    u = 0
    d = n+1
    j = check(i, u, d)
    ans += j - i
    # print(f'at {i} max {j} ans {ans}', u, d)

# print(f'count={count}')
print(ans)
",a[j] > a[j+1]:,a[j] > a[j+1]:
"#from niumeng

from itertools import accumulate
I=input;R=lambda:map(int,I().split())
n,q=R();a=sorted(R())[::-1];p=[0]+list(accumulate(a))
for {{completion}}
  x,y=R();print(p[x]-p[x-y])
",_ in range(q):,
"n, q = [int(x) for x in input().split()]
prices = [int(price) for price in input().split("" "")]
prices.sort(reverse=True)
for {{completion}}
    prices[i] += prices[i-1]
 
while q:
    # 5 5 3 2 1
    # 5 10 13 15 16
    x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1","i in range(1, len(prices)):",i<n-1:
"n, q = [int(x) for x in input().split()]
prices = [int(price) for price in input().split("" "")]
prices.sort(reverse=True)
for i in range(1, len(prices)):
    prices[i] += prices[i-1]
 
while {{completion}}
    # 5 5 3 2 1
    # 5 10 13 15 16
    x, y = [int(x) for x in input().split()]
    l = 0 if x == y else prices[x - y - 1]
    print(prices[x-1] - l)
    q -= 1",q:,"i in range(1, len(prices)):"
"n,q=map(int,input().split())
a=[0]
for {{completion}}a+=a[-1]+x,
for _ in[0]*q:x,y=map(int,input().split());print(a[x]-a[x-y])
","x in sorted(map(int,input().split()))[::-1]:",_ in[0]*q:
"n,q=map(int,input().split())
a=[0]
for x in sorted(map(int,input().split()))[::-1]:a+=a[-1]+x,
for {{completion}}x,y=map(int,input().split());print(a[x]-a[x-y])
",_ in[0]*q:,"x in sorted(map(int,input().split()))[::-1]:"
"f=open(0)
R=lambda:map(int,next(f).split())
n,q=R();p=[0]
for {{completion}} p+=p[-1]+w,
for _ in "" ""*q: x, y=R();print(p[n-x+y]-p[n-x])
",w in sorted(R()):,"x in "" ""*q:"
"f=open(0)
R=lambda:map(int,next(f).split())
n,q=R();p=[0]
for w in sorted(R()): p+=p[-1]+w,
for {{completion}} x, y=R();print(p[n-x+y]-p[n-x])
","_ in "" ""*q:",w in sorted(R()):
"from sys import stdin
# t = int(stdin.readline().rstrip())
# while t>0:
    
#     t-=1
n,q = map(int,stdin.readline().split())
l = list(map(int,stdin.readline().split()))
l.sort()
for i in range(1,n):
    l[i] += l[i-1]
# print(l)
for i in range(q):
    x,y = map(int,stdin.readline().split())
    actual = n-x+y-1
    val = l[actual]
    if {{completion}}
        val -= l[n-x-1]
    print(val)
    ",n-x > 0:,"x in sorted(map(int,input().split()))[::-1]:"
"Y=lambda:map(int,input().split())
O=[];n,q=Y();p=sorted(Y())[::-1];s=[0]
for {{completion}}s+=[s[-1]+i]
for _ in[0]*q:x,y=Y();O+=[str(s[x]-s[x-y])]
print('\n'.join(O))",i in p:,_ in[0]*q:
"Y=lambda:map(int,input().split())
O=[];n,q=Y();p=sorted(Y())[::-1];s=[0]
for i in p:s+=[s[-1]+i]
for {{completion}}x,y=Y();O+=[str(s[x]-s[x-y])]
print('\n'.join(O))",_ in[0]*q:,_ in[0]*q:
"arr=[int(i) for i in input().split()]
ans=[]
prices=[int(i) for i in input().split()]
prices.sort(reverse=True)
for i in range(1,arr[0]):
    prices[i]=prices[i]+prices[i-1]
    
for i in range(arr[1]):
    xy=[int(i) for i in input().split()]
    if{{completion}}
        ans.append(prices[xy[0]-1])
    else:
        ans.append(prices[xy[0]-1]-prices[xy[0]-xy[1]-1])
for ele in ans:
    print(ele)",(xy[0]==xy[1]):,"i in range(1, len(prices)):"
"import sys

n, p = map(int, sys.stdin.readline().split())
l = map(int, sys.stdin.readline().split())
l = sorted(l, reverse=True)

for i in range(n-1, 0, -1):
    l[i-1] += l[i]

for _ in range(p):
    xi, yi = map(int, sys.stdin.readline().split())
    a = n-xi
    b = a+yi

    if {{completion}}
        print(l[-b])
    else:
        print(l[-b]-l[-a])
",a == 0:,_ in[0]*p:
"## cf does not have numpy so with lists
r=open(0)
g=lambda:map(int,next(r).split())
n,q=g()
a=[0]
for {{completion}}a+=a[-1]+x,
for b in[0]*q:x,y=g();print(a[x]-a[x-y])


",x in sorted(g())[::-1]:,b in[0]*q:
"## cf does not have numpy so with lists
r=open(0)
g=lambda:map(int,next(r).split())
n,q=g()
a=[0]
for x in sorted(g())[::-1]:a+=a[-1]+x,
for {{completion}}x,y=g();print(a[x]-a[x-y])


",b in[0]*q:,x in sorted(g())[::-1]:
"(n, q) = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort(reverse=True)
for i in range (1,n):
   arr[i] = arr[i] + arr[i-1]
for trial in range(q):
    (x, y) = map(int, input().split())
    if {{completion}}
        print (arr[x-1])
    else:
        print (arr[x-1] - arr[x-y-1])",(x==y):,_ in[0]*q:
"from collections import deque

def solve():
    n = int(input())
    MOD = 998244353
    arr = [list(map(int, input().split())) for i in range(n)]
    dis = [[10**9]*n for i in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                dis[i][j] = abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1])
    g = [[] for i in range(n)]
    adj = [[0]*n for i in range(n)]
    for i in range(n):
        m = min(dis[i])
        for j in range(n):
            if dis[i][j] == m:
                g[i].append(j)
                adj[i][j] = 1

    gr = []
    for i in range(n):
        cur = []
        queue = deque()
        queue.append(i)
        v = [0] * n
        v[i] = 1
        while queue:
            x = queue.popleft()
            cur.append(x)
            for y in g[x]:
                if {{completion}}
                    v[y] = 1
                    queue.append(y)
        ok = 1
        for x in cur:
            for y in cur:
                if x != y and adj[x][y] == 0:
                    ok = 0
                    break
        if ok:
            if min(cur) == i:
                gr.append(len(cur))
        else:
            gr.append(1)
    dp = [0]*(n+1)
    dp[0] = 1
    for a in gr:
        dp1 = [0]*(n+1)
        for i in range(n):
            dp1[i+1] = (dp1[i+1]+dp[i])%MOD
            if a > 1 and i+a <= n:
                dp1[i+a] = (dp1[i+a]+dp[i])%MOD
        dp = dp1
    ans = 0
    k = n
    for i in range(1, n+1):
        ans = (ans+dp[i]*k)%MOD
        k = k*(n-i)%MOD
    return ans


import sys
input = lambda: sys.stdin.readline().rstrip()
print(solve())
",v[y] == 0:,adj[x][y]==0
"from collections import deque

def solve():
    n = int(input())
    MOD = 998244353
    arr = [list(map(int, input().split())) for i in range(n)]
    dis = [[10**9]*n for i in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                dis[i][j] = abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1])
    g = [[] for i in range(n)]
    adj = [[0]*n for i in range(n)]
    for i in range(n):
        m = min(dis[i])
        for j in range(n):
            if dis[i][j] == m:
                g[i].append(j)
                adj[i][j] = 1

    gr = []
    for i in range(n):
        cur = []
        queue = deque()
        queue.append(i)
        v = [0] * n
        v[i] = 1
        while queue:
            x = queue.popleft()
            cur.append(x)
            for y in g[x]:
                if v[y] == 0:
                    v[y] = 1
                    queue.append(y)
        ok = 1
        for x in cur:
            for y in cur:
                if {{completion}}
                    ok = 0
                    break
        if ok:
            if min(cur) == i:
                gr.append(len(cur))
        else:
            gr.append(1)
    dp = [0]*(n+1)
    dp[0] = 1
    for a in gr:
        dp1 = [0]*(n+1)
        for i in range(n):
            dp1[i+1] = (dp1[i+1]+dp[i])%MOD
            if a > 1 and i+a <= n:
                dp1[i+a] = (dp1[i+a]+dp[i])%MOD
        dp = dp1
    ans = 0
    k = n
    for i in range(1, n+1):
        ans = (ans+dp[i]*k)%MOD
        k = k*(n-i)%MOD
    return ans


import sys
input = lambda: sys.stdin.readline().rstrip()
print(solve())
",x != y and adj[x][y] == 0:,v[y] == 0:
"from math import perm, comb
import sys
input = sys.stdin.readline
 
M = 998244353
 
n = int(input())
x, y = [0]*n, [0]*n
for i in range(n):
    x[i], y[i] = map(int, input().split())
# print(x, y)
 
dist = [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        dist[i].append(abs(x[i] - x[j]) + abs(y[i] - y[j]))
# print(dist)
 
mindist, nbr = [M] * n, [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        if i == j:
            continue
        if dist[i][j] < mindist[i]:
            mindist[i] = dist[i][j]
            nbr[i] = [j]
        elif {{completion}}
            nbr[i].append(j)
# print(mindist, nbr)
 
grp = [0] * n
for i in range(n):
    if grp[i] > 0:
        continue
    if len(nbr[i]) > 3:
        grp[i] = 1
        continue
 
    checknbr = [False] * n
    checknbr[i] = True
    for j in nbr[i]:
        checknbr[j] = True
 
    check = False
    for j in nbr[i]:
        if len(nbr[j]) != len(nbr[i]):
            check = True
            break
        for c in nbr[j]:
            if not checknbr[c]:
                check = True
                break
    if check:
        grp[i] = 1
    else:
        grp[i] = len(nbr[i]) + 1
        for j in nbr[i]:
            grp[j] = grp[i]
# print(grp)
 
cnt = [0] * 5
for i in grp:
    cnt[i] += 1
cnt[2] //= 2
cnt[3] //= 3
cnt[4] //= 4
# print(cnt)
 
ans = 0
for i in range(cnt[2] + 1):
    for j in range(cnt[3] + 1):
        for k in range(cnt[4] + 1):
            z = (comb(cnt[2], i) * comb(cnt[3], j) * comb(cnt[4], k)) % M
            z *= perm(n, n - i - 2*j - 3*k)
            z %= M
            ans = (ans + z) % M
print(ans)",dist[i][j] == mindist[i]:,mindist[i] == dist[i][j] and checknbr[j]:
"input = __import__('sys').stdin.readline


MOD = 998244353

fact = [1]
invfact = [1]

for i in range(1, 101):
    fact.append(fact[-1] * i % MOD)
    invfact.append(pow(fact[-1], MOD-2, MOD))


def C(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD


def P(n, k):
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[n-k] % MOD


n = int(input())
coords = []
for _ in range(n):
    x, y = map(int, input().split())
    coords.append((x, y))

min_dist = [10**9] * n
dist = [[-1] * n for _ in range(n)]
for u in range(n):
    for v in range(n):
        dist[u][v] = abs(coords[u][0] - coords[v][0]) + abs(coords[u][1] - coords[v][1])
        if u != v:
            min_dist[u] = min(min_dist[u], dist[u][v])

cnt = [0, 0, 0, 0, 0]
vis = [False]*n
for u in sorted(range(n), key=lambda x: min_dist[x]):
    if vis[u]:
        continue

    vis[u] = True
    seen = [False]*n
    seen[u] = True    
    ptr = 0
    found = [u]
    while ptr < len(found):
        v = found[ptr]
        ptr += 1
        for w in range(n):
            if {{completion}}
                seen[w] = True
                found.append(w)
    
    ok = all(dist[found[i]][found[j]] == min_dist[u] for i in range(len(found)) for j in range(i+1, len(found)))
    if len(found) == 1 or not ok:
        cnt[1] += 1
    else:
        # print('found', found, ok)
        cnt[len(found)] += 1
        for u in found:
            vis[u] = True


# print('cnt', cnt[1:])

ans = 0
for two in range(cnt[2] + 1):
    for three in range(cnt[3] + 1):
        for four in range(cnt[4] + 1):
            ans += P(n, n - two - 2*three - 3*four) * C(cnt[2], two) % MOD \
                * C(cnt[3], three) % MOD \
                * C(cnt[4], four) % MOD
            if ans >= MOD:
                ans -= MOD
            # print(f'add P({n},{n - two - 2*three - 3*four})*C({cnt[2]},{two})*C({cnt[3]},{three})*C({cnt[4]},{four}) {ans}')
print(ans)",not seen[w] and dist[v][w] == min_dist[v]:,seen[w] = True
"



#############################
#############
cnb_max=10**5
mod=998244353
#############

kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod

rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod

def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod


def inv(n):
    return kai[n-1]*rkai[n]%mod

##################################



n=int(input())
x=[]
y=[]
for i in range(n):
    a,b=map(int,input().split())
    x.append(a)
    y.append(b)
ok=[[0]*n for i in range(n)]
tto=[0]*n
def dist(i,j):
    return abs(x[i]-x[j])+abs(y[i]-y[j])
for i in range(n):
    mi=10**18
    for j in range(n):
        if i==j:continue
        mi=min(mi,dist(i,j))
    for j in range(n):
        if i==j:continue
        if mi==dist(i,j):
            ok[i][j]=1
            tto[i]+=1

s=[]
for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
            for d in range(c+1,n):
                nod=[a,b,c,d]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=3:flag=0
                if flag:s.append(4)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if {{completion}}continue
                        flag&=ok[i][j]
                    if tto[i]!=2:flag=0
                if flag:s.append(3)

for a in range(n):
    for b in range(a+1,n):
                nod=[a,b]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=1:flag=0
                if flag:s.append(2)

dp=[0]*(n+1)
dp[n-sum(s)]=1
for cnt in s:
    newdp=[0]*(n+1)
    for i in range(n+1):
        dp[i]%=mod
        if i+cnt<=n:newdp[i+cnt]+=dp[i]
        if i+1<=n:newdp[i+1]+=dp[i]
    dp=newdp[:]
ans=0
for k in range(n+1):
    ans+=dp[k]*cnb(n,k)*kai[k]
    ans%=mod
print(ans)



",i==j:,i in nod:
"



#############################
#############
cnb_max=10**5
mod=998244353
#############

kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod

rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod

def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod


def inv(n):
    return kai[n-1]*rkai[n]%mod

##################################



n=int(input())
x=[]
y=[]
for i in range(n):
    a,b=map(int,input().split())
    x.append(a)
    y.append(b)
ok=[[0]*n for i in range(n)]
tto=[0]*n
def dist(i,j):
    return abs(x[i]-x[j])+abs(y[i]-y[j])
for i in range(n):
    mi=10**18
    for j in range(n):
        if i==j:continue
        mi=min(mi,dist(i,j))
    for j in range(n):
        if i==j:continue
        if mi==dist(i,j):
            ok[i][j]=1
            tto[i]+=1

s=[]
for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
            for d in range(c+1,n):
                nod=[a,b,c,d]
                flag=1
                for {{completion}}
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=3:flag=0
                if flag:s.append(4)

for a in range(n):
    for b in range(a+1,n):
        for c in range(b+1,n):
                nod=[a,b,c]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=2:flag=0
                if flag:s.append(3)

for a in range(n):
    for b in range(a+1,n):
                nod=[a,b]
                flag=1
                for i in nod:
                    for j in nod:
                        if i==j:continue
                        flag&=ok[i][j]
                    if tto[i]!=1:flag=0
                if flag:s.append(2)

dp=[0]*(n+1)
dp[n-sum(s)]=1
for cnt in s:
    newdp=[0]*(n+1)
    for i in range(n+1):
        dp[i]%=mod
        if i+cnt<=n:newdp[i+cnt]+=dp[i]
        if i+1<=n:newdp[i+1]+=dp[i]
    dp=newdp[:]
ans=0
for k in range(n+1):
    ans+=dp[k]*cnb(n,k)*kai[k]
    ans%=mod
print(ans)



",i in nod:,(i==j) or (j==k) or (i==k):
"for {{completion}}
    r = int(input())
    print('Division', 4 - sum(r >= p for p in (1400, 1600, 1900)))
",_ in range(int(input())):,r >= 1900:
"for {{completion}}r=int(n)/100;print('Division',1+(r<19)+(r<16)+(r<14))",n in[*open(0)][1:]:,1600 <= b <= 1899:
"from bisect import bisect
b = [-5001, 1400, 1600, 1900]
for {{completion}} print(f'Division {-bisect(b, int(input()))+5}')",i in range(int(input())):,"bisect(b, int(input()))"
"n=int(input())
while n:
    num=int(input())
    if num>=1900:print(""Division 1"")
    elif {{completion}}print(""Division 2"")
    elif num>=1400:print(""Division 3"")
    else:print(""Division 4"")
    n-=1",num>=1600:,num>=1600:
"n=int(input())
while n:
    num=int(input())
    if num>=1900:print(""Division 1"")
    elif num>=1600:print(""Division 2"")
    elif {{completion}}print(""Division 3"")
    else:print(""Division 4"")
    n-=1",num>=1400:,num>=1400:
"def div(n):
    return 1 if n >= 1900 else 2 if n >= 1600 else 3 if n >= 1400 else 4

for {{completion}}
    print(f'Division {div(int(input()))}')
",_ in range(int(input())):,n >= 1600 and n <1900:
"x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif {{completion}}
        print('Division 2')
    elif int(z) >= 1400:
        print('Division 3')
    else:
        print('Division 4')
",int(z) >= 1600:,int(z) >= 1600:
"x = input()
for i in range(int(x)):
    z = input()
    if int(z) >= 1900:
        print('Division 1')
    elif int(z) >= 1600:
        print('Division 2')
    elif {{completion}}
        print('Division 3')
    else:
        print('Division 4')
",int(z) >= 1400:,int(z) >= 1400 and int(z) < 1600:
"k = 0
a = int(input())
for x in range(1, a+1):
    b = int(input())
    if 1900<= b:
        d = 1
    elif {{completion}}
        d = 2
    elif 1400 <= b <= 1599:
        d = 3
    elif b <= 1399:
        d = 4
    print('Division', d)",1600 <= b <= 1899:,"































































































































"
"k = 0
a = int(input())
for x in range(1, a+1):
    b = int(input())
    if 1900<= b:
        d = 1
    elif 1600 <= b <= 1899:
        d = 2
    elif {{completion}}
        d = 3
    elif b <= 1399:
        d = 4
    print('Division', d)",1400 <= b <= 1599:,1400 <= b <= 1599:
"t = int(input())
while t > 0:
	n = int(input())
	if n >= 1900:
		print(""Division"",1)
	elif {{completion}}
		print(""Division"", 2)
	elif n >= 1400 and n < 1600:
		print(""Division"", 3)
	else:
		print(""Division"",4)
	t -= 1
",n >= 1600 and n <1900:,int(z) >= 1400 and int(z) < 1600:
"t = int(input())
while t > 0:
	n = int(input())
	if n >= 1900:
		print(""Division"",1)
	elif n >= 1600 and n <1900:
		print(""Division"", 2)
	elif {{completion}}
		print(""Division"", 3)
	else:
		print(""Division"",4)
	t -= 1
",n >= 1400 and n < 1600:,n >= 1400 and n <1600:
"x=int(input(""""))
for i in range (x):
    c=int(input(""""))
    if c<=1399:
        print("" Division 4"")
    elif {{completion}}
        print("" Division 3"")
    elif 1600<=c<=1899:
       print("" Division 2"") 
    else :
       print("" Division 1"")",1400<=c<=1599:,1400<=c<=1599:
"x=int(input(""""))
for i in range (x):
    c=int(input(""""))
    if c<=1399:
        print("" Division 4"")
    elif 1400<=c<=1599:
        print("" Division 3"")
    elif {{completion}}
       print("" Division 2"") 
    else :
       print("" Division 1"")",1600<=c<=1899:,1600<=c<=1899:
"'''
How pros write B)
'''

for {{completion}}
    x = int(input())
    print(""Division 4"" if x < 1400 else ""Division 3"" if x < 1600 else ""Division 2"" if x < 1900 else ""Division 1"")",i in range(int(input())):,"
'''
How I write B)
'''

for i in range(int(input())):
    x = int(input())
    if x < 1400:
        print(""Division 4"")
    elif x < 1600:
        print(""Division 3"")
    elif x < 1900:
        print(""Division 2"")
    else:
        print(""Division 1"")

'''
How I write A)
"
"from collections import deque
for _ in range(int(input())):
    n = int(input())
    l = deque(map(int, input().split()))
    a, b = 0, 0
    ans = 0
    cur = 0
    while l:
        cur+=1
        if {{completion}}
            b += l.pop()
        else:
            a += l.popleft()
        if a==b:
            ans = cur
    print(ans)
",a>=b:,a>b:
"from collections import deque
for _ in range(int(input())):
    n = int(input())
    l = deque(map(int, input().split()))
    a, b = 0, 0
    ans = 0
    cur = 0
    while l:
        cur+=1
        if a>=b:
            b += l.pop()
        else:
            a += l.popleft()
        if {{completion}}
            ans = cur
    print(ans)
",a==b:,a>b:
"for n in[*open(0)][2::2]:
    n=[*map(int,n.split())]
    a,b,l,f=[0]*4;r=len(n)-1
    while l<=r:
        if a<=b:
            a+=n[l]
            l+=1
        elif {{completion}}
            b+=n[r]
            r-=1
        if a==b:
            f=len(n)-r+l-1
    print(f)",b<a:,a<=b:
"from bisect import *
from itertools import *

t = int(input())
for _ in range(t):
	n = int(input())
	w = list(map(int, input().split()))
	aw = list(accumulate(w))
	bw = list(accumulate(w[::-1]))
	mx = 0
	for i, a in enumerate(aw):
		c = bisect_left(bw, a, hi=len(bw)-i-2)
		if {{completion}}
			mx = max(mx, (i+1)+(c+1))
	print(mx)
",a==bw[c] and i<(len(bw)-c-1):,c<i:
"def solve():
 n=int(input())
 a=[*map(int,input().split())]
 b=a[:]
 for i in range(n-1):a[i+1]+=a[i]
 for i in range(n-1,0,-1):b[i-1]+=b[i]
 l,r=0,n-1
 sol=0
 while r-l>=1:
  if {{completion}}sol=l+n-r+1;l+=1
  if a[l]<b[r]:l+=1
  else:r-=1
 return sol
for _ in [0]*int(input()):print(solve())",a[l]==b[r]:,a[l]<b[r]:
"def solve():
 n=int(input())
 a=[*map(int,input().split())]
 b=a[:]
 for i in range(n-1):a[i+1]+=a[i]
 for i in range(n-1,0,-1):b[i-1]+=b[i]
 l,r=0,n-1
 sol=0
 while r-l>=1:
  if a[l]==b[r]:sol=l+n-r+1;l+=1
  if {{completion}}l+=1
  else:r-=1
 return sol
for _ in [0]*int(input()):print(solve())",a[l]<b[r]:,a[l]<b[r]:
"I=lambda:[int(i) for i in input().split()]
for _ in range(I()[0]):
    n=I()[0]
    l=I()
    l2=[]
    s1,s2=0,0
    p1,p2=0,n-1
    while (p1-1<=p2):
        if {{completion}} l2.append(p1 + n-1-p2); s1+=l[p1]; p1+=1
        if s1 < s2: s1+=l[p1]; p1+=1
        if s2 < s1: s2+=l[p2]; p2-=1
    print(l2[-1])

    ",s1 == s2:,s1<s2:
"I=lambda:[int(i) for i in input().split()]
for _ in range(I()[0]):
    n=I()[0]
    l=I()
    l2=[]
    s1,s2=0,0
    p1,p2=0,n-1
    while (p1-1<=p2):
        if s1 == s2: l2.append(p1 + n-1-p2); s1+=l[p1]; p1+=1
        if {{completion}} s1+=l[p1]; p1+=1
        if s2 < s1: s2+=l[p2]; p2-=1
    print(l2[-1])

    ",s1 < s2:,s1 < s2:
"import math as m

i = input()
inp = []
for a in range(0,int(i)):
    inp += [[input(), input()]]

def maxx(arr):
    if arr == []:
        return 0
    else:
        return max(arr)

for s in inp:
    n = int(s[0])
    arr = [int(x) for x in s[1].split()]
    
    i = 0
    j = n-1
    lsum = arr[i]
    rsum = arr[j]

    best = 0
    while i < j:
        if lsum < rsum:
            i += 1
            lsum += arr[i]
        elif {{completion}}
            j -= 1
            rsum += arr[j]
        else:
            best = i + (n-1-j) + 2
            i += 1
            lsum += arr[i]
    print(best)
    
    
",rsum < lsum:,lsum==rsum:
"for t in range(int(input())):
    n=int(input())
    l1=list(map(int,input().split()))
    l=0
    h=n-1
    ans=0
    a=0
    b=0
    while(l<=h):
        if{{completion}}
            b=b+l1[h]
            h=h-1
        else:
            a=a+l1[l]
            l=l+1
        if(a==b):
            ans=l+n-h-1
    print(ans)",(a>b):,a>b:
"for t in range(int(input())):
    n=int(input())
    l1=list(map(int,input().split()))
    l=0
    h=n-1
    ans=0
    a=0
    b=0
    while(l<=h):
        if(a>b):
            b=b+l1[h]
            h=h-1
        else:
            a=a+l1[l]
            l=l+1
        if{{completion}}
            ans=l+n-h-1
    print(ans)",(a==b):,(a==b):
"for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    x = sum(a) // 2
    s, d = 0, {}
    for idx, i in enumerate(a):
        s += i
        if {{completion}} break
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if s in d: r = idx + 1 + d[s]
    print(r)",s > x:,s in d:
"for _ in range(int(input())):
    n = int(input())
    a = [*map(int, input().split())]
    x = sum(a) // 2
    s, d = 0, {}
    for idx, i in enumerate(a):
        s += i
        if s > x: break
        d[s] = idx + 1
    s, r = 0, 0
    for idx, i in enumerate(a[::-1]):
        s += i
        if {{completion}} r = idx + 1 + d[s]
    print(r)",s in d:,s < x:
"n = int(input())
for i in range(n):
    h = 1
    g = 1
    counter = 0
    m = int(input())
    lst = list(map(int, input().split()))
    index =0
    e= 0
    r =m-1
    highest = lst[m-1]
    lowest = lst[0]
    while h+g <= m:
        if lowest<highest:
            lowest+=lst[e+1]
            e+=1
            g +=1
        elif {{completion}}
            highest+=lst[r-1]
            r-=1
            h+=1
        elif highest == lowest:
            lowest+=lst[e+1]
            e+=1
            g+=1
            index = e + (m - r)
    print(index)
",highest<lowest:,highest == lowest:
"n = int(input())
for i in range(n):
    h = 1
    g = 1
    counter = 0
    m = int(input())
    lst = list(map(int, input().split()))
    index =0
    e= 0
    r =m-1
    highest = lst[m-1]
    lowest = lst[0]
    while h+g <= m:
        if lowest<highest:
            lowest+=lst[e+1]
            e+=1
            g +=1
        elif highest<lowest:
            highest+=lst[r-1]
            r-=1
            h+=1
        elif {{completion}}
            lowest+=lst[e+1]
            e+=1
            g+=1
            index = e + (m - r)
    print(index)
",highest == lowest:,highest == lowest:
"def read():
    return int(input())

def readline():
    return list(map(int,input().split()))

def solve():
    n=read()
    arr=readline()
    ans,cur=0,0
    a,suma=-1,0
    b,sumb=n,0
    while True:
        if a>=b: break
        elif {{completion}}
            b-=1
            sumb+=arr[b]
            cur+=1
        elif suma<sumb:
            a+=1
            suma+=arr[a]
            cur+=1
        else :
            ans=cur
            a+=1
            b-=1
            suma+=arr[a]
            sumb+=arr[b]
            cur+=2
    print(ans)


if __name__ == ""__main__"":
    T=read()
    for i in range(T):
        solve()",suma>sumb:,suma>sumb:
"def read():
    return int(input())

def readline():
    return list(map(int,input().split()))

def solve():
    n=read()
    arr=readline()
    ans,cur=0,0
    a,suma=-1,0
    b,sumb=n,0
    while True:
        if a>=b: break
        elif suma>sumb:
            b-=1
            sumb+=arr[b]
            cur+=1
        elif {{completion}}
            a+=1
            suma+=arr[a]
            cur+=1
        else :
            ans=cur
            a+=1
            b-=1
            suma+=arr[a]
            sumb+=arr[b]
            cur+=2
    print(ans)


if __name__ == ""__main__"":
    T=read()
    for i in range(T):
        solve()",suma<sumb:,suma<sumb:
"for _ in range(int(input())):
    n, _ = map(int, input().split())
    a = map("""".join, zip(*(input() for _ in range(n))))
    a = (""o"".join("""".join(sorted(y, reverse=True)) for y in x.split(""o"")) for x in a)
    for {{completion}}
        print("""".join(x))
 			  	 	    				   	  	 	    	",x in zip(*a):,"a = (""o"".join("""".join(sorted(y, reverse=True)) for y in x.split(""o"")) for x in a)"
"# Write your code here :-)
# Fall Down
def solution():
    n, m = [int(i) for i in input().split()]
    grid = [list(input()) for _ in range(n)]
    for i in range(m):
        for j in range(n - 1, -1, -1):
            if grid[j][i] == ""*"":
                grid[j][i] = "".""
                pos = j
                while {{completion}}
                    pos += 1
                grid[pos][i] = ""*""
    for row in grid:
        print(*row, sep="""")


t = int(input())
for _ in range(t):
    solution()
","pos < n - 1 and grid[pos + 1][i] == ""."":",j in range(n):
"def res(s):
 a=s.split('o');t=''
 for i in a:t+=i.count('*')*'*'+i.count('.')*'.'+'o'
 return t[:-1]

for _ in[0]*int(input()):
 n,m=map(int,input().split())
 a=[[*input()] for x in[0]*n]
 b=[]
 for i in range(m):b+=res(''.join([a[~j][i] for j in range(n)])),
 for i in range(n):
  for {{completion}}print(b[j][~i],end='')
  print()
 print()",j in range(m):,i in range(n):
"c=input()
for _ in range(int(c)):
    b=input().split()
    a=[]
    for i in range(int(b[0])):
        a.append(list(input()))
    for i in range(int(b[1])):
        count=0
        row=int(b[0])-1
        for j in range(int(b[0])):
            if a[row][i]=='.':
                count+=1
            elif {{completion}}
                count=0
            else:
                a[row][i],a[row+count][i]='.',a[row][i]
            row-=1
    for i in range(int(b[0])):
        print("""".join(a[i]))


",a[row][i]=='o':,a[row][i]=='*':
"import sys
input = sys.stdin.readline
for _ in [0]*int(input()):
    n,m=map(int,input().split())
    s=['']*m
    for _ in [0]*n:
        s=[s[i]+j for i,j in zip(range(m),input())]
    col=['']*n
    k=0
    for i in s:
        bl=0
        x=''
        for j in i[::-1]:
            if j=='o':
                x=j+'.'*bl+x
                bl=0
            elif {{completion}}
                x=j+x
            else:
                bl=bl+1
        x='.'*bl+x
        col=[col[ind]+val for val,ind in zip(x,range(n))]
        k=k+1
    for j in col:
        print(j)",j=='*':,j=='o' or j=='*':
"for i in range(int(input())):
    n,m=map(int,input().split())
    s=[list(input()) for j in range(n)]
    for _ in range(n):
        for a in reversed(range(n-1)):
            for b in range(m):
                if s[a][b]=='*':
                    if {{completion}}
                        continue
                    else:
                        s[a][b]='.'
                        s[a+1][b]='*'
    for a in range(n):
        print(*s[a],sep='')",s[a+1][b]=='o' or s[a+1][b]=='*':,s[a][b]=='*'and s[a+1][b]=='.'
"I=lambda:map(int,input().split())
for _ in range(int(input())):
    n,m=I()
    a=[input() for _ in range(n)]
    
    at=[''.join(col).split('o') for col in zip(*a)]
    f=lambda s:''.join(sorted(s,reverse=True))
    at=['o'.join(map(f, col)) for col in at]
    
    for {{completion}}
      print(''.join(row))",row in zip(*at):,
"I = input
for _ in range(int(I())):
    n,m = map(int,I().split())
    grid = [I().strip() for __ in range(n)]
    res = []
    for col in range(m):
        newcol = ''
        for {{completion}}
            newcol += '.'*seg.count('.')+'*'*seg.count('*')+'o'
        res.append(newcol[0:-1])
    for row in range(n):
        print(''.join(res[col][row] for col in range(m)))",seg in (''.join(grid[row][col] for row in range(n))).split('o'):,col in range(m):
"for ii in range(int(input())):
	n,m = map(int, input().split())
	mat=[]
	r=[0]*m
	for jj in range(n):
		a=list(input())
		for kk in range(m):
			if a[kk]==""*"":
				r[kk]+=1
				a[kk]="".""
			elif a[kk]==""o"":
				while {{completion}}
					mat[jj-r[kk]][kk]=""*""
					r[kk]-=1
		mat.append(a)
	for jj in range(m):
		while r[jj]:
			mat[n-r[jj]][jj]=""*""
			r[jj]-=1
	for jj in range(n):
		print("""".join(mat[jj]))",r[kk]:,jj in range(m):
"t = int(input())

for i in range (t):
    n, m = map(int,input().split())
    arr = [[0]*m]*n
    for j in range(n):
        arr[j] = list(input())
        # for h in range(m):
            # print(arr[j][h])
    for k in range(m):
        for l in range(n-1, -1, -1):
           if arr[l][k]=='.':
            #    print(""yes"")
               for f in range(l-1,-1,-1):
                   if arr[f][k]=='o':
                       break
                   elif {{completion}}
                    #    print(""yes"")
                       arr[f][k]='.'
                       arr[l][k]='*'
                       break
    for g in range(n):
        for h in range(m-1):
            print(arr[g][h],end="""")
        print(arr[g][m-1],end=""\n"")
                
                
            
            
        

",arr[f][k]=='*':,arr[l][k]=='*':
"from collections import Counter
for _ in range(int(input())):
    n = int(input())
    num = Counter(input() for x in [1]*n)
    cnt = 0
    for x in num:
        for y in num:
            if {{completion}}
                cnt+=num[x]*num[y]
    print(cnt//2)",x!=y and (x[0] == y[0] or x[1] == y[1]):,i!= j and (i[0] == j[0] or i[1] == j[1]):
"from collections import Counter
from itertools import islice
from sys import stdin

LETTERS = 'abcdefghijk'

data = (line.strip() for line in stdin.readlines()[1:])

res = []
for line in data:
    n = int(line)
    s = 0
    ctr = Counter()
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if {{completion}}
                s += ctr[f'{l}{b}']
            if l != b:
                s += ctr[f'{a}{l}']
    res.append(s)

print('\n'.join(str(x) for x in res))
",l != a:,(x!=y and (x[1]==y[1] or x[0]==y[0])):
"from collections import Counter
from itertools import islice
from sys import stdin

LETTERS = 'abcdefghijk'

data = (line.strip() for line in stdin.readlines()[1:])

res = []
for line in data:
    n = int(line)
    s = 0
    ctr = Counter()
    for ab in islice(data, n):
        a, b = ab
        ctr[ab] += 1
        for l in LETTERS:
            if l != a:
                s += ctr[f'{l}{b}']
            if {{completion}}
                s += ctr[f'{a}{l}']
    res.append(s)

print('\n'.join(str(x) for x in res))
",l != b:,(x!=y and (x[1]==y[1] or x[0]==y[0])):
"for i in range(int(input())):
    data = [[0 for l in range(11)] for k in range(11)]

    for j in range(int(input())):
        first, second = input()
        data[ord(first)-ord('a')][ord(second)-ord('a')] += 1

    answer = 0
    for j in range(11):
        for k in range(11):
            for l in range(11):
                if {{completion}}
                    answer += data[j][k]*data[l][k]

                if k != l:
                    answer += data[j][k]*data[j][l]

    print(answer//2)",j != l:,i!= j and (i[0] == j[0] or i[1] == j[1]):
"for i in range(int(input())):
    data = [[0 for l in range(11)] for k in range(11)]

    for j in range(int(input())):
        first, second = input()
        data[ord(first)-ord('a')][ord(second)-ord('a')] += 1

    answer = 0
    for j in range(11):
        for k in range(11):
            for l in range(11):
                if j != l:
                    answer += data[j][k]*data[l][k]

                if {{completion}}
                    answer += data[j][k]*data[j][l]

    print(answer//2)",k != l:,k!= l:
"from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if c != s[0]:
                if {{completion}}
                    count += d[c + s[1]]
            if c != s[1]:
                if d[s[0] + c] > 0:
                    count += d[s[0] + c]
        d[s] += 1
    print(count)",d[c + s[1]] > 0:,d[s[0] + c] > 0:
"from collections import defaultdict
ak = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k""]

t = int(input())
for _ in range(t):
    count = 0
    d = defaultdict(int)
    n = int(input())
    for i in range(n):
        s = input()
        for c in ak:
            if c != s[0]:
                if d[c + s[1]] > 0:
                    count += d[c + s[1]]
            if c != s[1]:
                if {{completion}}
                    count += d[s[0] + c]
        d[s] += 1
    print(count)",d[s[0] + c] > 0:,i!= j and (i[0] == j[0] or i[1] == j[1]):
"for ii in range(int(input())):
	n=int(input())
	a=[]
	co=0
	x=set()
	for jj in range(n):
		a.append(input())
	for jj in range(n):
		mul=1
		if jj not in x:
			for kk in range(jj+1,n):
				if a[jj][0]!=a[kk][0] and a[jj][1]==a[kk][1]:
					co+=mul
				elif {{completion}}
					co+=mul
				elif a[jj][0]==a[kk][0] and a[jj][1]==a[kk][1]:
					mul+=1
					x.add(kk)
	print(co)",a[jj][0]==a[kk][0] and a[jj][1]!=a[kk][1]:,(jj!=kk and (a[jj][1]==a[kk][1] or a[jj][0]==a[kk][0])):
"t=int(input())
for i in range(t):
  n=int(input())
  result=0
  dic1={}
  dic2={}
  dic3={}
  for i in range(n):
    S=input()
    if {{completion}}
      result+=dic1[S[0]]
      dic1[S[0]]+=1
    else:
      dic1[S[0]]=1
    if S[1] in dic2:
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      dic2[S[1]]=1
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)",S[0] in dic1:,S[0] in dic1 and S[1] in dic2:
"t=int(input())
for i in range(t):
  n=int(input())
  result=0
  dic1={}
  dic2={}
  dic3={}
  for i in range(n):
    S=input()
    if S[0] in dic1:
      result+=dic1[S[0]]
      dic1[S[0]]+=1
    else:
      dic1[S[0]]=1
    if {{completion}}
      result+=dic2[S[1]]
      dic2[S[1]]+=1
    else:
      dic2[S[1]]=1
    if S in dic3:
      result-=dic3[S]*2
      dic3[S]+=1
    else:
      dic3[S]=1
  print(result)",S[1] in dic2:,S[1] in dic2:
"for i in range(int(input())):
    n= int(input())
    a = dict()
    b = dict()
    c = dict()
    ans = 0
    for j in range(n):
        d,e = str(input())
        try:
            ans += a[d]
            a[d] += 1
        except KeyError:
            a[d] = 1
        try:
            ans += b[e]
            b[e] += 1
        except KeyError:
            b[e] = 1
        if {{completion}}
            c[d+e] = 0
        else:
            ans -= c[d+e]
        c[d+e] += 2
    print(ans)",d+e not in c:,(x!=y and (x[1]==y[1] or x[0]==y[0])):
"from collections import Counter

t=int(input())
while(t!=0):
    n=int(input())
    s = Counter(input() for x in [1]*n)
    cnt = 0
    for x in s:
        for y in s:
            if{{completion}} cnt += s[x]*s[y]
    print(cnt//2)
   
    t-=1
",(x!=y and (x[1]==y[1] or x[0]==y[0])):,x!=y and (x[0] == y[0] or x[1] == y[1]):
"t = int(input())
for x in range(t):
    n = int(input())
    d1 = {}
    for i in range(97,109):
        for j in range(97,109):
            d1[chr(i)+chr(j)] = 0
    ans1 = 0
    for y in range(n):
        s = input()
        for l in range(2):
            for m in range(97,109):
                a = list(s)
                a[l] = chr(m)
                a = ''.join(a)
                if {{completion}}
                    continue
                ans1+=d1[a]
        d1[s]+=1
    print(ans1)",a == s:,d1[s]>1:
"for n in range(int(input())):
    a = {}
    for j in range(int(input())):
        c = input()
        if c not in a:
            a[c] = 1
        elif c in a:
            a[c] += 1
    count = 0
    for i in a.keys():
        for j in a.keys():
            if {{completion}}
                count += a[i] * a[j]
    print(count // 2)
",i != j and (i[0] == j[0] or i[1] == j[1]):,a[i] * a[j]
"for {{completion}}print('YNEOS'[1in map(len,map(set,s[:-1].split('W')))::2])",s in[*open(0)][2::2]:,s in[*open(0)][2::2]:
"for {{completion}}
	l = int(input())
	print(""NO"" if any (len(set(x)) == 1 for x in input().split('W') ) else ""YES"")",_ in range(int(input())) :,"































































































































"
"def solve():
    n = int(input())
    s = input().split('W')
    for i in s:
        bs = 'B' in i
        rs = 'R' in i
        if {{completion}}
            print('NO')
            return

    print('YES')

for t in range(int(input())):
    solve()
",bs ^ rs:,"i in s[:-1].split(""W""):"
for {{completion}}print('YNEOS'[1in[len({*x})for x in s[:-1].split('W')]::2]),s in[*open(0)][2::2]:,s in[*open(0)][2::2]:
"g = input()
for i in range(int(g)):
    input()
    numb = input().split('W')
    ans = 'yes'
    for z in numb:
        if z == '':
            pass
        else:
            if {{completion}}
                pass
            else:
                ans = 'no'
    print(ans)
",('R' in z) and ('B' in z):,z.count('')
"for s in[*open(0)][2::2]:
    b=0
    for {{completion}}b|=len({*i})%2
    print('YNEOS'[b::2])",i in s[:-1].split('W'):,"i in s[:-1].split(""W""):"
"t=int(input())

for i in range(t):
    n=int(input())
    s=input()
    s=s.strip(""W"")
    temp=list(s.split('W'))

    for i in temp:
        if i:
            if {{completion}}
                print(""NO"")
                break
    else:
        print(""YES"")
        ",'B' not in i or 'R' not in i:,bs ^ rs:
"for {{completion}}
    num = int(input())
    line = [elem for elem in input().split(""W"") if elem != """"]
    print(""YES"" if all([""B"" in elem and ""R"" in elem for elem in line]) else ""NO"")",i in range(int(input())):,i in line:
"for s in[*open(0)][2::2]:
    b = 0
    for {{completion}}
        b|=(len(set(i))==1)
    print('YNEOS '[b::2])","i in s[:-1].split(""W""):",i in s[:-1].split('W'):
"t = int(input())
Ans = [-1]*t
for z in range(t):
    n = int(input())
    l = input().split('W')
    bad = False
    for s in l:
        b1 = 'R' in s
        b2 = 'B' in s
        if {{completion}}
        	bad = True
    print(""NO"" if bad else ""YES"")
    

",(b1 ^ b2):,bs ^ rs:
"n=int(input())
l=[int(i) for i in input().split()]

def f(l):
    cur = 0
    n = 0
    for {{completion}}
        n += cur // i + 1
        cur = i * (cur // i + 1)
    return n

print(min(f(l[i+1:])+f(l[:i][::-1]) for i in range(n)))",i in l:,i in range(n):
"n = int(input().strip())
a = list(map(int, input().strip().split()))
ans = None

for i in range(n):
    acc, p = 0, 0
    for {{completion}}
        x = (p - 1) // a[j]
        acc += -x
        p = x * a[j]
    p = 0
    for j in range(i+1, n):
        x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]
    ans = min(ans, acc) if ans is not None else acc

print(ans)
","j in range(i-1, -1, -1):","j in range(i-1, -1, -1):"
"n = int(input().strip())
a = list(map(int, input().strip().split()))
ans = None

for i in range(n):
    acc, p = 0, 0
    for j in range(i-1, -1, -1):
        x = (p - 1) // a[j]
        acc += -x
        p = x * a[j]
    p = 0
    for {{completion}}
        x = (p + a[j]) // a[j]
        acc += x
        p = x * a[j]
    ans = min(ans, acc) if ans is not None else acc

print(ans)
","j in range(i+1, n):","j in range(i+1, len(b)):"
"from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float(""inf"")
for i in range(len(a)):
    t=[0]*n
    temp=0
    j=i-1
    prev =0
    while {{completion}}
        x=(ceil((prev+1)/a[j]))
        temp+=x
        prev=(a[j]*x)
        j-=1
    
    k=i+1
    prev=0
    while k<len(a):
        x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1
    ans=min(ans,temp)
print(int(ans))",j>=0:,j>=0:
"from math import ceil
n=int(input())
a=list(map(int,input().split()))
ans=float(""inf"")
for i in range(len(a)):
    t=[0]*n
    temp=0
    j=i-1
    prev =0
    while j>=0:
        x=(ceil((prev+1)/a[j]))
        temp+=x
        prev=(a[j]*x)
        j-=1
    
    k=i+1
    prev=0
    while {{completion}}
        x=(ceil((prev+1)/a[k]))
        temp+=x
        prev=(a[k]*x)
        k+=1
    ans=min(ans,temp)
print(int(ans))",k<len(a):,k>=i:
"
for _ in range(1):
    n = int(input())
    a = list(map(int, input().split()))
    Min = 1e18
    for l in range(n):
        m = a[l]
        answer = 1
        for i in range(l-1, -1, -1):
            answer += (m + a[i]) // a[i]
            m = a[i] * ((m + a[i]) // a[i])
        if l + 1 < n:
            m = 0
            for {{completion}}
                answer += (m + a[i]) // a[i]
                m = a[i] * ((m + a[i]) // a[i])
        Min = min(answer, Min)
    print(Min)","i in range(l + 2, n):","i in range(l+1, n):"
"m=int(input())
a=[int(i)for i in input().split()]
t1,min=0,10**20
while(t1<m):
    t2=t1
    k,t=0,0
    while{{completion}}
        t+=(k//a[t2+1]+1)
        k=a[t2+1]*(k//a[t2+1]+1)
        t2+=1
    t2=t1
    k=0
    while(t2>0):
        t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1
    if(min>t):
        min=t
    t1+=1
print(min)
",(t2<m-1):,t2>0:
"m=int(input())
a=[int(i)for i in input().split()]
t1,min=0,10**20
while(t1<m):
    t2=t1
    k,t=0,0
    while(t2<m-1):
        t+=(k//a[t2+1]+1)
        k=a[t2+1]*(k//a[t2+1]+1)
        t2+=1
    t2=t1
    k=0
    while{{completion}}
        t+=(k//a[t2-1]+1)
        k=a[t2-1]*(k//a[t2-1]+1)
        t2-=1
    if(min>t):
        min=t
    t1+=1
print(min)
",(t2>0):,(t2>0):
"import math
n = int(input())
a = list(map(int, input().split(' '))) # numbers w/ ws

c = None
d = 0
for i in range(len(a)):
	p = 0
	t = 0
	for {{completion}}
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	t = 0
	for k in reversed(a[:i]):
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	if c == None or p < c:
		c = p

print(c)",k in a[i+1:]:,k in a[:i]:
"import math
n = int(input())
a = list(map(int, input().split(' '))) # numbers w/ ws

c = None
d = 0
for i in range(len(a)):
	p = 0
	t = 0
	for k in a[i+1:]:
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	t = 0
	for {{completion}}
		d = math.ceil((t+1)/k)
		t = k*d
		p += d
	if c == None or p < c:
		c = p

print(c)",k in reversed(a[:i]):,k in a[i+1:]:
"def f(b, i):
    return e(b[::-1], i)

def e(b, i):
    if b == []:
        return 0
    count = 0
    ggg = [0] * len(b)
    for {{completion}}
        ggg[i] = (b[i - 1] * ggg[i - 1]) // b[i] + 1
        count += ggg[i]
    return count

def c(b, i):
    return e(b[i + 1:], 0) + f(b[:i], 0)

a = int(input())
b = input().split()
for i in range(a):
    b[i] = int(b[i])
d = c(b, 1)
for i in range(2, a - 1):
    d = min(d, c(b, i))
print(d)
",i in range(len(b)):,i in range(a-1):
"

n=int(input())


a=list(map(int,input().split()))
b=[int(0) for _ in range(n)]
m=1e18
for i in range(n):
    c=0
    p=0
    for {{completion}}
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for j in range(i-1,-1,-1):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    m=min(m,c)

print(m)


","j in range(i+1,len(b)):","j in range(i-1,-1,-1):"
"

n=int(input())


a=list(map(int,input().split()))
b=[int(0) for _ in range(n)]
m=1e18
for i in range(n):
    c=0
    p=0
    for j in range(i+1,len(b)):
        p+=a[j]-p%a[j]
        c+=p//a[j]
    p=0
    for {{completion}}
        p+=a[j]-p%a[j]
        c+=p//a[j]
    m=min(m,c)

print(m)


","j in range(i-1,-1,-1):","j in range(i+1,len(b)):"
"t=lambda:map(int,input().split())
for {{completion}}n,m=t();a=[*t()];print(""YNEOS""[sum(a)+max(a)-min(a)+n>m::2])",_ in range(int(input())):,t:
"for _t in range(int(input())):
	n,m = map(int, input().split(' ')) # numbers w/ ws
	a = sorted(map(int, input().split(' ')))

	tot = 0
	dis = 0
	p_i = a[-1]
	for i in a:
		tot += 2*i+1
		if {{completion}}
			dis += p_i
		else:
			dis += i
		p_i = i

	if tot-dis <= m:
		print(""YES"")
	else:
		print(""NO"")",p_i < i:,_t+1:
"
import sys


def solve():
    n, m = map(int, input().split())
    num = list(map(int , input().split())) 
    num.sort()
    s = sum(num[1:]) + num[-1] + n
    print(""YES"" if s <= m else ""NO"")


for {{completion}}
    solve()
",_ in range(int(input())):,_ in [1]*t:
"import sys
for t in range(int(sys.stdin.readline())):
    n,m = map(int, sys.stdin.readline().strip().split())
    a = list(map(int, sys.stdin.readline().strip().split()))
    if {{completion}}print('yes')
    else:print('no')",sum(a)-min(a)+max(a) + n <= m:,n+sum(a)+max(a)-min(a)>m:
"x = lambda: map(int,input().split())
t,= x()
for {{completion}}
    p,n = x()
    a = [*x()]
    s = sum(a) + (p-1) - min(a)
    print(""YNEOS""[n-1-s<max(a)::2])",_ in [1]*t:,t:
"def Dist():
    num_nm = input().split()
    m = int(num_nm[1])
    n = int(num_nm[0])
    
    a = input().split()
    a = list(map(int, a))
    
    wish = n + sum(a) - min(a) + max(a) 
    print(""NO"" if wish >m else ""YES"")


num_iter = int(input())
for {{completion}}
    Dist()
    
    ",_ in range(num_iter):,_ in [1]*num_iter:
"for T in range (int(input())) :
    n,m = map(int, input().strip().split())
    a = sorted(list(map(int,input().strip().split())),reverse=True)
    m -= 2*a[0] + 1
    cont = 0
    for i in range(1,n) :
        if {{completion}} break
        m -= a[i] + 1
        cont +=1

    if cont == n-1 : print('YES')
    else : print ('NO')
",m <= 0 :,m-2*a[0]-1
"I=lambda:[*map(int,input().split())]
t,=I()
while {{completion}}t-=1;n,m=I();a=sorted(I());print('YNEOS'[sum(max(a[i-1],a[i])for i in range(n))+n>m::2])",t:,_ in range(int(input())):
"for i in range(int(input())):
	n,m=map(int,input().split())
	a=list(map(int,input().split()))
	if {{completion}}
		print(""no"")
	else:
		print(""yes"")",n+sum(a)+max(a)-min(a)>m:,_ in range(int(input())):
"from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


MOD = 998244353
input = stdin.readline
finp = [int(x) for x in stdin.buffer.read().split()]

def inp(force_list=False):
    re = list(map(int, input().split()))
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def qmod(a, b, mod=MOD):
    res = 1
    while b:
        if b&1:
            res = (res*a)%mod
        b >>= 1
        a = (a*a)%mod
    return res

def inv(a):
    return qmod(a, MOD-2)

INF = 1<<30

class Seg(object):
    def __init__(self, n):
        self._da = [-INF] * (n * 5)
        self._op = [-INF] * (n * 5)

    def update(self, p):
        self._op[p] = max(self._op[p*2], self._op[p*2+1])

    def modify(self, pos, x, p, l, r):
        if l==r-1:
            self._da[p] = self._op[p] = x
            return
        mid = (l+r)//2
        if pos < mid:
            self.modify(pos, x, p*2, l, mid)
        else:
            self.modify(pos, x, p*2 + 1, mid, r)
        self.update(p)

    def query(self, x, y, p, l, r):
        if x <= l and r <= y:
            return self._op[p]
        if x >= r or y<=l:
            return -INF
        mid = (l+r)//2
        return max(self.query(x, y, p*2, l, mid), self.query(x, y, p*2+1, mid, r))


class Fenwick(object):
    def __init__(self, n):
        self._da = [-INF] * (n+2)
        self._mx = n+2

    def max(self, x):
        res = -INF
        while {{completion}}
            res = max(res, self._da[x])
            x = (x&(x+1))-1
        return res

    def modify(self, p, x):
        while p < self._mx:
            self._da[p] = max(self._da[p], x)
            p |= p+1

def my_main():
    # print(500000)
    # for i in range(500000):
    #     print(1)
    #     print(-1000000000)
    ii = 0 
    kase = finp[ii];ii+=1
    pans = []
    for skase in range(kase):
        # print(""Case #%d: "" % (skase+1), end='')
        n = finp[ii];ii+=1
        da = finp[ii:ii+n];ii+=n
        pref = [0]
        for i in da:
            pref.append(pref[-1] + i)
        spos, sneg = sorted([(pref[i], -i) for i, v in enumerate(pref)]), sorted([(pref[i], i) for i, v in enumerate(pref)])
        ordpos, ordneg = [0] * (n+1), [0] * (n+1)
        pfen, nfen = Fenwick(n), Fenwick(n)
        dmx = {}
        for i in range(n+1):
            ordpos[-spos[i][-1]] = i
            ordneg[sneg[i][-1]] = i
        dp = [0] * (n+1)
        dmx[0] = 0
        pfen.modify(ordpos[0], 0)
        nfen.modify(n+1-ordneg[0], 0)
        for i in range(1, n+1):
            dp[i] = max(i+pfen.max(ordpos[i]), nfen.max(n+1-ordneg[i])-i, dmx.get(pref[i], -INF))
            pfen.modify(ordpos[i], dp[i]-i)
            nfen.modify(n+1-ordneg[i], dp[i]+i)
            if dp[i] > dmx.get(pref[i], -INF):
                dmx[pref[i]] = dp[i]
        pans.append(str(dp[n]))
    print('\n'.join(pans))


my_main()


",x>0:,(p&1)==0:
"from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


MOD = 998244353
input = stdin.readline
finp = [int(x) for x in stdin.buffer.read().split()]

def inp(force_list=False):
    re = list(map(int, input().split()))
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def qmod(a, b, mod=MOD):
    res = 1
    while b:
        if b&1:
            res = (res*a)%mod
        b >>= 1
        a = (a*a)%mod
    return res

def inv(a):
    return qmod(a, MOD-2)

INF = 1<<30

class Seg(object):
    def __init__(self, n):
        self._da = [-INF] * (n * 5)
        self._op = [-INF] * (n * 5)

    def update(self, p):
        self._op[p] = max(self._op[p*2], self._op[p*2+1])

    def modify(self, pos, x, p, l, r):
        if l==r-1:
            self._da[p] = self._op[p] = x
            return
        mid = (l+r)//2
        if pos < mid:
            self.modify(pos, x, p*2, l, mid)
        else:
            self.modify(pos, x, p*2 + 1, mid, r)
        self.update(p)

    def query(self, x, y, p, l, r):
        if x <= l and r <= y:
            return self._op[p]
        if x >= r or y<=l:
            return -INF
        mid = (l+r)//2
        return max(self.query(x, y, p*2, l, mid), self.query(x, y, p*2+1, mid, r))


class Fenwick(object):
    def __init__(self, n):
        self._da = [-INF] * (n+2)
        self._mx = n+2

    def max(self, x):
        res = -INF
        while x>0:
            res = max(res, self._da[x])
            x = (x&(x+1))-1
        return res

    def modify(self, p, x):
        while {{completion}}
            self._da[p] = max(self._da[p], x)
            p |= p+1

def my_main():
    # print(500000)
    # for i in range(500000):
    #     print(1)
    #     print(-1000000000)
    ii = 0 
    kase = finp[ii];ii+=1
    pans = []
    for skase in range(kase):
        # print(""Case #%d: "" % (skase+1), end='')
        n = finp[ii];ii+=1
        da = finp[ii:ii+n];ii+=n
        pref = [0]
        for i in da:
            pref.append(pref[-1] + i)
        spos, sneg = sorted([(pref[i], -i) for i, v in enumerate(pref)]), sorted([(pref[i], i) for i, v in enumerate(pref)])
        ordpos, ordneg = [0] * (n+1), [0] * (n+1)
        pfen, nfen = Fenwick(n), Fenwick(n)
        dmx = {}
        for i in range(n+1):
            ordpos[-spos[i][-1]] = i
            ordneg[sneg[i][-1]] = i
        dp = [0] * (n+1)
        dmx[0] = 0
        pfen.modify(ordpos[0], 0)
        nfen.modify(n+1-ordneg[0], 0)
        for i in range(1, n+1):
            dp[i] = max(i+pfen.max(ordpos[i]), nfen.max(n+1-ordneg[i])-i, dmx.get(pref[i], -INF))
            pfen.modify(ordpos[i], dp[i]-i)
            nfen.modify(n+1-ordneg[i], dp[i]+i)
            if dp[i] > dmx.get(pref[i], -INF):
                dmx[pref[i]] = dp[i]
        pans.append(str(dp[n]))
    print('\n'.join(pans))


my_main()


",p < self._mx:,(p & (p+1))-1
"import sys
input = sys.stdin.readline

n = int(input())

o1 = [0] * (n * n)
o2 = [0] * (n * n)
for i in range(n):
    curr = (list(map(int, input().split())))

    for {{completion}}
        o1[curr[j] - 1] = i
        o2[curr[j] - 1] = j
        

row_count = [0] * n
col_count = [0] * n

ct = 0

for u in range(n * n):
    i = o1[u]
    j = o2[u]

    ct += row_count[i] * col_count[j]

    row_count[i] += 1
    col_count[j] += 1


n2 = (n * n - n)//2

ct -= n2 * n2

print(n2 * n2 - ct)
",j in range(n):,j in range(n):
"import sys
import random

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N = int(input())
As = [list(map(int, input().split())) for _ in range(N)]

# N = 1500
# As = list(range(1, N ** 2 + 1))
# random.shuffle(As)
# As = [As[i * N:(i + 1) * N] for i in range(N)]

ijs = [0] * (N ** 2)
for i in range(N):
    for {{completion}}
        ijs[As[i][j] - 1] = (i, j)

answer = 0
row_sum = [0] * N
col_sum = [0] * N
for i, j in ijs:
    l_row = row_sum[i]
    g_row = N - 1 - row_sum[i]
    l_col = col_sum[j]
    g_col = N - 1 - col_sum[j]
    answer += l_col * g_row + g_col * l_row
    row_sum[i] += 1
    col_sum[j] += 1

assert answer % 2 == 0
print(answer // 2)
",j in range(N):,l_row == g_row and l_col == g_col:
"import sys
import bisect

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N, V = map(int, input().split())
Ts = list(map(int, input().split()))
As = list(map(int, input().split()))

points = []
for T, A in zip(Ts, As):
    B = T * V
    x = B - A
    y = B + A
    if {{completion}}
        continue
    points.append((x, y))

points.sort()
# print(points)

lis = []
for _, w in points:
    index = bisect.bisect_right(lis, w)
    if index < len(lis):
        lis[index] = w
    else:
        lis.append(w)

print(len(lis))

",x < 0 or y < 0:,index < len(lis):
"import sys
import bisect

input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

N, V = map(int, input().split())
Ts = list(map(int, input().split()))
As = list(map(int, input().split()))

points = []
for T, A in zip(Ts, As):
    B = T * V
    x = B - A
    y = B + A
    if x < 0 or y < 0:
        continue
    points.append((x, y))

points.sort()
# print(points)

lis = []
for _, w in points:
    index = bisect.bisect_right(lis, w)
    if {{completion}}
        lis[index] = w
    else:
        lis.append(w)

print(len(lis))

",index < len(lis):,x < 0 or y < 0:
"from bisect import bisect_right,bisect_left
n,v = map(int,input().split())
t = [*map(int,input().split())]
a = [*map(int,input().split())]
res = []
for i in range(n):
    xi,yi = t[i]*v+a[i],t[i]*v-a[i]
    if{{completion}}
        res.append((xi,yi))
res.sort()
dp = [float(""inf"")]*(n+3)
dp[0] = 0
dp[n+2] = 0
for i in range(len(res)):
    pos = bisect_right(dp,res[i][1],0,n+2)
    dp[pos] = res[i][1]
for i in range(n,-1,-1):
    if(dp[i]!=float(""inf"")):
        print(i)
        break",(xi>=0 and yi>=0):,"(dp[i]!=float(""inf"")):"
"from bisect import bisect_right,bisect_left
n,v = map(int,input().split())
t = [*map(int,input().split())]
a = [*map(int,input().split())]
res = []
for i in range(n):
    xi,yi = t[i]*v+a[i],t[i]*v-a[i]
    if(xi>=0 and yi>=0):
        res.append((xi,yi))
res.sort()
dp = [float(""inf"")]*(n+3)
dp[0] = 0
dp[n+2] = 0
for i in range(len(res)):
    pos = bisect_right(dp,res[i][1],0,n+2)
    dp[pos] = res[i][1]
for i in range(n,-1,-1):
    if{{completion}}
        print(i)
        break","(dp[i]!=float(""inf"")):",pos < n:
"t = int(input())
for _ in range(t):

    field = [[0 for _ in range(2*360)] for _ in range(42)]
    vis = [[False for _ in range(2*360)] for _ in range(42)]
    
    n = int(input())
    for _ in range(n):

        line = input().split()
        a, b, c = map(int, line[1:])

        if line[0] == ""C"":
            y = 2*a

            x = 2*b
            while x != 2*c:
                field[y][x] = -1
                x = (x + 1) % 720

            field[y][x] = -1
        else:
            x = 2*c

            for y in range(2*a, 2*b+1):
                field[y][x] = -1


    # for row in field: print(*row)

    def check():
        st = [(0, 0)]

        while st:
            y, x = st.pop(-1)

            x = (x + 720) % 720
            if y < 0 or y >= 42 or field[y][x] < 0: continue

            if vis[y][x]: continue
            vis[y][x] = True

            if y > 40: return True

            for ny in range(y-1, y+1+1):
                for {{completion}}
                    st.append((ny, nx))

        return False

    print(""YES"" if check() else ""NO"")
","nx in range(x-1, x+1+1):","y in range(2*a, 2*b+1):"
"t = int(input())
for _ in range(t):

    field = [[0 for _ in range(2*360)] for _ in range(42)]
    vis = [[False for _ in range(2*360)] for _ in range(42)]
    
    n = int(input())
    for _ in range(n):

        line = input().split()
        a, b, c = map(int, line[1:])

        if line[0] == ""C"":
            y = 2*a

            x = 2*b
            while x != 2*c:
                field[y][x] = -1
                x = (x + 1) % 720

            field[y][x] = -1
        else:
            x = 2*c

            for {{completion}}
                field[y][x] = -1


    # for row in field: print(*row)

    def check():
        st = [(0, 0)]

        while st:
            y, x = st.pop(-1)

            x = (x + 720) % 720
            if y < 0 or y >= 42 or field[y][x] < 0: continue

            if vis[y][x]: continue
            vis[y][x] = True

            if y > 40: return True

            for ny in range(y-1, y+1+1):
                for nx in range(x-1, x+1+1):
                    st.append((ny, nx))

        return False

    print(""YES"" if check() else ""NO"")
","y in range(2*a, 2*b+1):","nx in range(x-1, x+1+1):"
"from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited

for tc in range(int(input())):
    graph = {}
    for r in range(0, 22):
        for angle in range(0, 360):
            graph[(r,angle)] = set([
                (r, (angle+1)%360),
                (r, (angle-1)%360)])
            if r < 21:
                graph[(r,angle)].add((r+1, angle))
            if r > 0:
                graph[(r,angle)].add((r-1, angle))
    nwalls = int(input())
    for wallid in range(nwalls):
        typ, a, b, c = input().split()
        if typ == 'C':
            rad, t1, t2 = map(int, (a,b,c))
            th = t1
            while th != t2:
                graph[(rad, th)].remove((rad-1, th))
                graph[(rad-1, th)].remove((rad, th))
                th = (th + 1) % 360
                #print(th)
                #print((rad, th%360), (rad-1, th%360))
        else:
            r1, r2, th = map(int, (a,b,c))
            for {{completion}}
                graph[(rad, th)].remove((rad, (th-1)%360))
                graph[(rad, (th-1)%360)].remove((rad, th))
        
    if (0,0) in bfs(graph, (21, 0)):
        print('YES')
    else:
        print('NO')
","rad in range(r1, r2):","nx in range(x-1, x+1+1):"
"from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited

for tc in range(int(input())):
    graph = {}
    for r in range(0, 22):
        for angle in range(0, 360):
            graph[(r,angle)] = set([
                (r, (angle+1)%360),
                (r, (angle-1)%360)])
            if {{completion}}
                graph[(r,angle)].add((r+1, angle))
            if r > 0:
                graph[(r,angle)].add((r-1, angle))
    nwalls = int(input())
    for wallid in range(nwalls):
        typ, a, b, c = input().split()
        if typ == 'C':
            rad, t1, t2 = map(int, (a,b,c))
            th = t1
            while th != t2:
                graph[(rad, th)].remove((rad-1, th))
                graph[(rad-1, th)].remove((rad, th))
                th = (th + 1) % 360
                #print(th)
                #print((rad, th%360), (rad-1, th%360))
        else:
            r1, r2, th = map(int, (a,b,c))
            for rad in range(r1, r2):
                graph[(rad, th)].remove((rad, (th-1)%360))
                graph[(rad, (th-1)%360)].remove((rad, th))
        
    if (0,0) in bfs(graph, (21, 0)):
        print('YES')
    else:
        print('NO')
",r < 21:,"rad in range(r1, r2):"
"from itertools import islice, chain
from sys import stdin

MAX_RADIUS = 20

lines = iter(stdin.readlines()[1:])

for line in lines:
    n = int(line)
    circular_wall, straight_wall = ([[False] * 360 for _ in range(MAX_RADIUS)] for _ in range(2))
    for shape, *params in map(str.split, islice(lines, n)):
        params = map(int, params)
        if shape == 'C':
            r, theta_1, theta_2 = params
            r -= 1
            theta_range = range(theta_1, theta_2) if theta_1 <= theta_2 \
                else chain(range(theta_1, 360), range(0, theta_2))
            for theta in theta_range:
                circular_wall[r][theta] = True
        else:
            assert shape == 'S'
            r1, r2, theta = params
            r1 -= 1
            r2 -= 1
            for {{completion}}
                straight_wall[r][theta] = True

    queue = [(0, i) for i, inner_wall in enumerate(circular_wall[0]) if not inner_wall]
    seen = set(queue)
    while queue:
        row, col = queue.pop()
        # print(row, col)
        neighbors = []
        if row >= 1 and not circular_wall[row][col]:
            neighbors.append((row - 1, col))
        right_col = (col + 1) % 360
        if not straight_wall[row][right_col]:
            neighbors.append((row, right_col))
        if not straight_wall[row][col]:
            neighbors.append((row, (col - 1) % 360))
        next_row = row + 1
        if not circular_wall[next_row][col]:
            if next_row == MAX_RADIUS - 1:
                print('YES')
                break
            neighbors.append((next_row, col))

        for neighbor in neighbors:
            if neighbor in seen:
                continue
            queue.append(neighbor)
            seen.add(neighbor)
    else:  # no break
        print('NO')
","r in range(r1, r2):",theta in theta_range:
"from itertools import islice, chain
from sys import stdin

MAX_RADIUS = 20

lines = iter(stdin.readlines()[1:])

for line in lines:
    n = int(line)
    circular_wall, straight_wall = ([[False] * 360 for _ in range(MAX_RADIUS)] for _ in range(2))
    for shape, *params in map(str.split, islice(lines, n)):
        params = map(int, params)
        if shape == 'C':
            r, theta_1, theta_2 = params
            r -= 1
            theta_range = range(theta_1, theta_2) if theta_1 <= theta_2 \
                else chain(range(theta_1, 360), range(0, theta_2))
            for {{completion}}
                circular_wall[r][theta] = True
        else:
            assert shape == 'S'
            r1, r2, theta = params
            r1 -= 1
            r2 -= 1
            for r in range(r1, r2):
                straight_wall[r][theta] = True

    queue = [(0, i) for i, inner_wall in enumerate(circular_wall[0]) if not inner_wall]
    seen = set(queue)
    while queue:
        row, col = queue.pop()
        # print(row, col)
        neighbors = []
        if row >= 1 and not circular_wall[row][col]:
            neighbors.append((row - 1, col))
        right_col = (col + 1) % 360
        if not straight_wall[row][right_col]:
            neighbors.append((row, right_col))
        if not straight_wall[row][col]:
            neighbors.append((row, (col - 1) % 360))
        next_row = row + 1
        if not circular_wall[next_row][col]:
            if next_row == MAX_RADIUS - 1:
                print('YES')
                break
            neighbors.append((next_row, col))

        for neighbor in neighbors:
            if neighbor in seen:
                continue
            queue.append(neighbor)
            seen.add(neighbor)
    else:  # no break
        print('NO')
",theta in theta_range:,"r in range(r1, r2):"
"from itertools import chain
from sys import stdin

(n, m), population, shops = [[int(x) for x in line.split()] for line in stdin.readlines()]
shops.sort()
shops = chain([float('-inf')], (v / 100 for v in shops), [float('inf')])

shop_left, shop_right = next(shops), next(shops)
hut_left_idx = max_score = score = 0
for hut_right_idx, hut_right_score in enumerate(population):
    score += hut_right_score
    # print(f'{score=}')
    while {{completion}}
        shop_left, shop_right = shop_right, next(shops)
    # print(f'{hut_right_idx=} {shop_left=} {shop_right=}')
    shop_delta = shop_right - shop_left
    while shop_left >= hut_left_idx or 2 * (hut_right_idx - hut_left_idx) >= shop_delta:
        score -= population[hut_left_idx]
        hut_left_idx += 1
    # print(f'{score=} {hut_left_idx=} {hut_right_idx=} {shop_delta=}')
    if score > max_score:
        max_score = score
print(max_score)
",shop_right <= hut_right_idx:,shop_left >= hut_left_idx or 2 * (hut_right_idx - hut_left_idx) >= shop_delta:
"from itertools import chain
from sys import stdin

(n, m), population, shops = [[int(x) for x in line.split()] for line in stdin.readlines()]
shops.sort()
shops = chain([float('-inf')], (v / 100 for v in shops), [float('inf')])

shop_left, shop_right = next(shops), next(shops)
hut_left_idx = max_score = score = 0
for hut_right_idx, hut_right_score in enumerate(population):
    score += hut_right_score
    # print(f'{score=}')
    while shop_right <= hut_right_idx:
        shop_left, shop_right = shop_right, next(shops)
    # print(f'{hut_right_idx=} {shop_left=} {shop_right=}')
    shop_delta = shop_right - shop_left
    while {{completion}}
        score -= population[hut_left_idx]
        hut_left_idx += 1
    # print(f'{score=} {hut_left_idx=} {hut_right_idx=} {shop_delta=}')
    if score > max_score:
        max_score = score
print(max_score)
",shop_left >= hut_left_idx or 2 * (hut_right_idx - hut_left_idx) >= shop_delta:,shop_right <= hut_right_idx:
"n,m=map(int,input().split())
p=list(map(int,input().split()))
x=sorted(list(map(int,input().split())))
s=sum(p[:-(-(x[0])//100)])
for i in range(len(x)-1):
    if x[i]//100+1>=n:
       break
    num=int(((x[i+1]-x[i])/2)//(100)+1)
    l=x[i]//100+1
    r=-(-(x[i+1])//100)
    r=min(r,n)
    prefs=0
    if {{completion}}
        prefs=sum(p[l:l+num])
        s=max(s,prefs)
    while l+num<r:
        prefs-=p[l]
        prefs+=p[l+num] if l+num<n else 0
        s=max(s,prefs)
        l+=1
s=max(s,sum(p[x[-1]//100+1:]))
print(s)",l+num<=r:,x[i+1]//100+1>=n:
"N, M = [int(x) for x in input().split()]
hut = [int(x) for x in input().split()]
shop = [int(x) for x in input().split()]
shop = sorted([-1e9] + shop + [1e9])
events = []
j = 0
for i in range(N):
  while {{completion}}
    j += 1
  if shop[j] != 100 * i:
    d = min(100*i - shop[j-1], shop[j] - 100*i)
    events.append((100*i-d, hut[i]))
    events.append((100*i+d, -hut[i]))
events.sort()
cont = 0
max = 0
for a in events:
    cont += a[1]
    if cont > max:
        max = cont
print(max)
",shop[j] < 100*i:,shop[j]!= 100 * i:
"N, M = [int(x) for x in input().split()]
hut = [int(x) for x in input().split()]
shop = [int(x) for x in input().split()]
shop = sorted([-1e9] + shop + [1e9])
events = []
j = 0
for i in range(N):
  while shop[j] < 100*i:
    j += 1
  if {{completion}}
    d = min(100*i - shop[j-1], shop[j] - 100*i)
    events.append((100*i-d, hut[i]))
    events.append((100*i+d, -hut[i]))
events.sort()
cont = 0
max = 0
for a in events:
    cont += a[1]
    if cont > max:
        max = cont
print(max)
",shop[j] != 100 * i:,shop[j]!= 100 * i:
"from math import sqrt, floor
from sys import stdin

data = [int(x) for x in stdin.read().split()[1:]]
res = []
for w, l in zip(data[::2], data[1::2]):
    half_perimeter = w + l - 2
    solutions = {1, 2}
    for i in range(2, floor(sqrt(half_perimeter)) + 1):
        div, mod_i = divmod(half_perimeter, i)
        if mod_i != 0:
            continue
        for a in [i, div]:
            mod_a = w % a
            if {{completion}}
                assert (l - 2 + mod_a) % a == 0
                solutions.add(a)
    res.append(f""{len(solutions)} {' '.join(map(str, sorted(solutions)))}"")
print('\n'.join(res))
",mod_a <= 2:,l - 2 + mod_a == 0:
"t = int(input())
for _ in range(t):
    a, b, c, d = [int(i) for i in input().split()]
    s = input()
    if s.count('A') != a+c+d:
        print(""NO"")
        continue
    ult = 'X'
    k = 0
    z = []
    for x in s:
        if x == ult:
            z.append((k, ult))
            k = 1
        else:
            ult = x
            k += 1
    z.append((k, ult))
    r = 0
    z.sort()
    for k,v in z:
        if k % 2 == 0:
            if v == 'A' and d >= k//2:
                d -= k//2
            elif {{completion}}
                c -= k//2
            else:
                r += k//2 - 1
        else:
            r += k//2
    print(""YES"" if r >= c+d else ""NO"")",v == 'B' and c >= k//2:,v == 'A' and d >= k//2:
"def canmake(s,a,b,c,d):
    anum = s.count('A')
    bnum = s.count('B')

    cnum = s.count('AB')
    dnum = s.count('BA')

    if cnum < c or dnum < d or anum != a + c + d or bnum != b + c + d:
        return False

    n=len(s)

    ans=0

    abls=[]
    bals=[]
    l=0
    while l<n:
        while l<n-1 and  s[l]==s[l+1]:
            l+=1

        r=l
        while {{completion}}
            r+=1

        if s[l]== s[r]=='B':
            ans+=(r-l+1)//2
        if s[l]==s[r]=='A':
            ans+=(r-l+1)//2

        if s[l]=='A' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='B' and s[r]=='A':
            bals.append((r-l+1)//2)


        l=r+1
    abls.sort()
    bals.sort()

    for i in abls:
        if i<=c:
            c-=i
        else:

            d-=i-c-1
            c = 0

    for i in bals:
        if i<=d:
            d-=i
        else:

            c-=i-d-1
            d = 0



    return (c+d)<=ans


t=int(input())

for _ in range(t):
    a,b,c,d=[int(x) for x  in input().split()]
    s=input()
    res=canmake(s,a,b,c,d)
    if res:
        print('YES')
    else:
        print('NO')",r<n-1 and s[r]!=s[r+1]:,s[l]== s[r]=='B':
"def canmake(s,a,b,c,d):
    anum = s.count('A')
    bnum = s.count('B')

    cnum = s.count('AB')
    dnum = s.count('BA')

    if cnum < c or dnum < d or anum != a + c + d or bnum != b + c + d:
        return False

    n=len(s)

    ans=0

    abls=[]
    bals=[]
    l=0
    while l<n:
        while l<n-1 and  s[l]==s[l+1]:
            l+=1

        r=l
        while r<n-1 and s[r]!=s[r+1]:
            r+=1

        if {{completion}}
            ans+=(r-l+1)//2
        if s[l]==s[r]=='A':
            ans+=(r-l+1)//2

        if s[l]=='A' and s[r]=='B':
            abls.append((r-l+1)//2)

        if s[l]=='B' and s[r]=='A':
            bals.append((r-l+1)//2)


        l=r+1
    abls.sort()
    bals.sort()

    for i in abls:
        if i<=c:
            c-=i
        else:

            d-=i-c-1
            c = 0

    for i in bals:
        if i<=d:
            d-=i
        else:

            c-=i-d-1
            d = 0



    return (c+d)<=ans


t=int(input())

for _ in range(t):
    a,b,c,d=[int(x) for x  in input().split()]
    s=input()
    res=canmake(s,a,b,c,d)
    if res:
        print('YES')
    else:
        print('NO')",s[l]== s[r]=='B':,r<n-1 and s[r]!=s[r+1]:
"for _ in range(int(input())):
    a,b,ab,ba=map(int,input().split());s=input()
    if s.count('A')!=a+ab+ba:print('NO');continue
    stack=[[1,s[0]]]
    for i in range(1,len(s)):
        if stack[-1][1]!=s[i]:
            x=stack.pop()
            stack.append([x[0]+1,s[i]])
        else: stack.append([1,s[i]])
    stack.sort();trash=0
    for val,ele in stack:
        if not val%2:
            if ele=='A' and ba>=val//2:ba-=(val//2)
            elif {{completion}}ab-=(val//2)
            else:trash+=(val//2-1)
        else:
            trash+=(val//2)
    print('YES' if trash>=ab+ba else 'NO')",ele=='B' and ab>=val//2:,ab-=(val//2)
"import sys,os,io
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
input = sys.stdin.readline

for _ in range (int(input())):
    c = [int(i) for i in input().split()]
    s = list(input().strip())
    if s.count('A') != c[0] + c[2] + c[3] or s.count('B') != c[1] + c[2] + c[3]:
        print(""NO"")
        continue
    n = len(s)
    a = [[s[0]]]
    for i in range (1,n):
        if s[i]==s[i-1]:
            a.append([s[i]])
        else:
            a[-1].append(s[i])
    extra = 0
    for i in a:
        if len(i)%2:
            c[ord(i[0]) - ord('A')] -= 1
            extra += len(i)//2
    
    a.sort(key = lambda x: len(x))
    
    for i in a:
        if len(i)%2==0:
            cnt = len(i)//2
            if {{completion}}
                c[2 + ord(i[0]) - ord('A')]-=cnt
            else:
                extra += cnt - 1              
    if min(c)<0 or extra < c[2]+c[3]:
        print(""NO"")
    else:
        print(""YES"")",cnt <= c[2 + ord(i[0])-ord('A')]:,extra < c[2]+c[3]:
"import sys
import math

def do_test():

    a,b,ab,ba = map(int, input().split())
    S = input().strip()
    n = len(S)
    
    ac = 0
    for i in S:
        if i == 'A':
            ac += 1

    if (ac != a + ab + ba):
        return ""NO""

    

    a_parts = []
    b_parts = []
    ab_total = 0

    l = 0
    f = -1
    p = S[0]
    S = S + S[n-1]
    
    for i in S:
        
        if i == p:
            
            if l > 1:
                if l % 2 == 1:
                    ab_total += l // 2
                elif {{completion}}
                    a_parts.append(l // 2)
                else:
                    b_parts.append(l // 2)
                
            l = 1
            f = i
        else:
            l += 1

        p = i

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = i
        if ba >= k:
            ba -= k
        else:
            k -= ba
            ba = 0
            if ab > 0:
                ab -= k-1

    if ab + ba > ab_total:
        return ""NO""

    return ""YES""               
                

    
    

input = sys.stdin.readline
t = int(input())
for _test_ in range(t):
    print(do_test())

    
    
        
    
    
    
    
    
        
    

    
",f == 'A':,l % 2 == 0:
"import sys
import math

def do_test():

    a,b,ab,ba = map(int, input().split())
    S = input().strip()
    n = len(S)
    
    ac = 0
    for i in S:
        if i == 'A':
            ac += 1

    if (ac != a + ab + ba):
        return ""NO""

    

    a_parts = []
    b_parts = []
    ab_total = 0

    l = 0
    f = -1
    p = S[0]
    S = S + S[n-1]
    
    for i in S:
        
        if i == p:
            
            if l > 1:
                if {{completion}}
                    ab_total += l // 2
                elif f == 'A':
                    a_parts.append(l // 2)
                else:
                    b_parts.append(l // 2)
                
            l = 1
            f = i
        else:
            l += 1

        p = i

    a_parts.sort()
    b_parts.sort()
    
    for i in a_parts:
        k = i
        if ab >= k:
            ab -= k
        else:
            k -= ab
            ab = 0
            if ba > 0:
                ba -= k-1

    for i in b_parts:
        k = i
        if ba >= k:
            ba -= k
        else:
            k -= ba
            ba = 0
            if ab > 0:
                ab -= k-1

    if ab + ba > ab_total:
        return ""NO""

    return ""YES""               
                

    
    

input = sys.stdin.readline
t = int(input())
for _test_ in range(t):
    print(do_test())

    
    
        
    
    
    
    
    
        
    

    
",l % 2 == 1:,l % 2 == 1:
"def solve():
    cnt_a, cnt_b, cnt_ab, cnt_ba = map(int, input().strip().split())
    # print(cntA, cntB, cntAB, cntBA)
    s = input()
    if s.count('A') != cnt_a + cnt_ba + cnt_ab:
        print(""NO"")
        return

    stk = [[1, s[0]]]
    for i in range(1, len(s)):
        if i == 0:
            continue
        c = s[i]
        if c != stk[-1][1]:
            x = stk.pop()
            stk.append([x[0] + 1, c])
        else:
            stk.append([1, c])
    stk.sort()
    rest = 0
    for cnt, last in stk:
        # print(cnt, last)
        if not cnt % 2:
            if last == 'A' and cnt_ba >= (cnt >> 1):
                cnt_ba -= cnt >> 1
            elif {{completion}}
                cnt_ab -= cnt >> 1
            else:
                rest += (cnt >> 1) - 1
        else:
            rest += cnt >> 1
    # print(rest, cnt_ab, cnt_ba)
    if rest >= cnt_ab + cnt_ba:
        print(""YES"")
    else:
        print(""NO"")


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        solve()
",last == 'B' and cnt_ab >= (cnt >> 1):,cnt <= cnt_ba:
"def solve():
    cnt_a, cnt_b, cnt_ab, cnt_ba = map(int, input().strip().split())
    # print(cntA, cntB, cntAB, cntBA)
    s = input()
    if s.count('A') != cnt_a + cnt_ba + cnt_ab:
        print(""NO"")
        return

    stk = [[1, s[0]]]
    for i in range(1, len(s)):
        if i == 0:
            continue
        c = s[i]
        if c != stk[-1][1]:
            x = stk.pop()
            stk.append([x[0] + 1, c])
        else:
            stk.append([1, c])
    stk.sort()
    rest = 0
    for cnt, last in stk:
        # print(cnt, last)
        if not cnt % 2:
            if {{completion}}
                cnt_ba -= cnt >> 1
            elif last == 'B' and cnt_ab >= (cnt >> 1):
                cnt_ab -= cnt >> 1
            else:
                rest += (cnt >> 1) - 1
        else:
            rest += cnt >> 1
    # print(rest, cnt_ab, cnt_ba)
    if rest >= cnt_ab + cnt_ba:
        print(""YES"")
    else:
        print(""NO"")


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        solve()
",last == 'A' and cnt_ba >= (cnt >> 1):,cnt <= c[2 + ord(i[0])-ord('A')]:
"import fileinput

lines = []

for line in fileinput.input():
    line_f = [int(x) for x in line.split()]
    if len(line_f) > 0:
        lines.append(line_f)
    # print ffs



for i in range(1, len(lines), 2):
    n = lines[i][0]
    a = lines[i+1]

    b = 123 + 23
    c=  b + 1


    sm = 0
    for elem in a:
        sm += elem

    found = False
    for elem in a:
        lhs = elem
        rhs = ((sm - elem) / (n-1))
        if {{completion}}
            found = True
            break
    if found:
        print(""YES"")
    else:
        print(""NO"")
",lhs == rhs:,lhs == rhs:
"import fileinput

lines = []

for line in fileinput.input():
    line_f = [int(x) for x in line.split()]
    if len(line_f) > 0:
        lines.append(line_f)
    # print ffs



for i in range(1, len(lines), 2):
    n = lines[i][0]
    a = lines[i+1]

    numoddseg = 0
    prev = -1
    i = 0
    while i < n:
        if {{completion}}
            numoddseg += 1
            prev = -1
        else:
            prev = a[i]
        i += 1

    print(numoddseg)
    ",a[i] < prev:,a[i]!=prev:
"from sys import stdin, stderr

data = [int(x) for x in stdin.read().split()[1:]]

ns, ms = data[::2], data[1::2]

output = []
for n, m in zip(ns, ms):
    # n = 2 ** a * 5 ** b * c
    a = b = 0
    c = n
    while c % 2 == 0:
        a += 1
        c //= 2
    while c % 5 == 0:
        b += 1
        c //= 5
    t = 1  # our result should be a multiple of t
    if a > b:
        while a > b and 5 * t <= m:
            t *= 5
            b += 1
    elif b > a:
        while {{completion}}
            t *= 2
            a += 1
    while 10 * t <= m:
        t *= 10
    #print(n, m, t, file=stderr)
    output.append(n * (m - (m % t)))

print('\n'.join(str(x) for x in output))
",b > a and 2 * t <= m:,
"t=int(input())
while(t):
    i=0
    s=input()
    if(len(s)==1):
        print(""NO"")
        t=t-1
        continue
    while(i<len(s)):
        if(i==0):
            if(s[0:2]==""ab"" or s[0:2]==""ba""):
                print(""NO"")
                t=t-1
                break
        if(i>0 and i<len(s)-1):
            if(s[i-1:i+2]==""bab"" or s[i-1:i+2]==""aba""):
                print(""NO"")
                t=t-1
                break
        if(i==len(s)-1):
            if{{completion}}
                print(""NO"")
                t=t-1
                break
            else:
                print(""YES"")
                t=t-1
                break
        i+=1
                ","(s[i-1:]==""ba"" or s[i-1:]==""ab""):","s[i-1:i+2] == ""bab"" or s[i-1:i+2] == ""aba"":"
"n = int(input())
s = input()

c = 1


def dfs(i):
    if {{completion}}
        return s[i]
    global c
    l = dfs(2*i + 1)
    r = dfs(2*i + 2)
    if l != r:
        c *= 2
    if l > r:
        l, r = r, l
    return s[i] + l + r


dfs(0)
print(c % 998244353)
",i >= 2**(n-1)-1:,l!= r:
"n = int(input())
s = input()

c = 1


def dfs(i):
    if i >= 2**(n-1)-1:
        return s[i]
    global c
    l = dfs(2*i + 1)
    r = dfs(2*i + 2)
    if {{completion}}
        c *= 2
    if l > r:
        l, r = r, l
    return s[i] + l + r


dfs(0)
print(c % 998244353)
",l != r:,l!= r:
"mod=998244353
cnt=0
n=int(input())
s=input()

import random
q=random.randint(10**9,2*10**9)
p=random.randint(10**9,2*10**9)
r=10**9+7

a=[-1]
for i in s:
  if {{completion}}
    a.append(p)
  else:
    a.append(q)

for i in range(2**(n-1)-1,0,-1):
  if a[2*i]!=a[2*i+1]:
    cnt+=1
  a[i]=a[i]^(2*a[2*i]+2*a[2*i+1])
  a[i]%=r
  

print(pow(2,cnt,mod))",i=='A':,a[2*i]!=a[2*i+1]:
"mod=998244353
cnt=0
n=int(input())
s=input()

import random
q=random.randint(10**9,2*10**9)
p=random.randint(10**9,2*10**9)
r=10**9+7

a=[-1]
for i in s:
  if i=='A':
    a.append(p)
  else:
    a.append(q)

for i in range(2**(n-1)-1,0,-1):
  if {{completion}}
    cnt+=1
  a[i]=a[i]^(2*a[2*i]+2*a[2*i+1])
  a[i]%=r
  

print(pow(2,cnt,mod))",a[2*i]!=a[2*i+1]:,a[2*i]!=a[2*i+1]:
"MOD = 998244353
 
n, s = int(input()), input()
 
 
def calc(u: int) -> tuple:
    if {{completion}}
        return (0, 0)
    t1, t2 = calc(u * 2), calc(u * 2 + 1)
    return (t1[0] + t2[0] + (t1[1] != t2[1]),
            hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))
 
 
print(pow(2, calc(1)[0], MOD))
",u >= (1 << n):,t1[1]!= t2[1]:
"def dfs(tree,i,h):
    if {{completion}}
        return [tree[i],1]
    ls,li=dfs(tree,i*2+1,h)
    rs,ri=dfs(tree,i*2+2,h)
    res=li*ri
    if ls!=rs:
        res*=2
    if ls>rs:
        return [tree[i]+rs+ls,res]
    else:
        return [tree[i]+ls+rs,res]


h=int(input())
tree=input()
print(dfs(tree,0,h)[1]%998244353 )
",i>=2**(h-1)-1:,i >= 2**(n-1)-1:
"def dfs(tree,i,h):
    if i>=2**(h-1)-1:
        return [tree[i],1]
    ls,li=dfs(tree,i*2+1,h)
    rs,ri=dfs(tree,i*2+2,h)
    res=li*ri
    if {{completion}}
        res*=2
    if ls>rs:
        return [tree[i]+rs+ls,res]
    else:
        return [tree[i]+ls+rs,res]


h=int(input())
tree=input()
print(dfs(tree,0,h)[1]%998244353 )
",ls!=rs:,i>=2**(h-1)-1:
"import sys

N = int(sys.stdin.readline().strip())
s = sys.stdin.readline().strip()

# print(N, s)
m = 1 << N
mod = 998244353


def dfs(i):
    if i >= m: return (1, '')
    ln, ls = dfs(i * 2)
    rn, rs = dfs(i * 2 + 1)
    ln = ln % mod
    rn = rn % mod
    if ls < rs:
        return ln * rn * 2, ls + s[i - 1] + rs
    elif {{completion}}
        return ln * rn * 2, rs + s[i - 1] + ls
    else:
        return ln * rn, ls + s[i - 1] + rs


n, _ = dfs(1)
print(n % mod)
",ls > rs:,ln<rn:
"# trans rights
N = int(input())
N = 2 ** N
S = input()
U = [0] * N
cnt = 0
for i in range(N - 2, -1, -1):
    a = 2 * i + 1
    b = 2 * i + 2
    if {{completion}}
        U[i] = ord(S[i])
        continue
    if U[a] != U[b]:
        cnt += 1
    U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
    U[i] %= 2 ** 104

print(pow(2, cnt, 998244353))
",b >= N:,U[a]!= U[b]:
"# trans rights
N = int(input())
N = 2 ** N
S = input()
U = [0] * N
cnt = 0
for i in range(N - 2, -1, -1):
    a = 2 * i + 1
    b = 2 * i + 2
    if b >= N:
        U[i] = ord(S[i])
        continue
    if {{completion}}
        cnt += 1
    U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2
    U[i] %= 2 ** 104

print(pow(2, cnt, 998244353))
",U[a] != U[b]:,U[a]!= U[b]:
"import sys;I=sys.stdin.readline;R,P,G=lambda:map(int,I().split()),print,range
n,q=R();n+=1;a=[0]+[*R()];p,s,last,oe=[0]*n,[0]*n,[0]*n,[{},{}]
for i in G(1,n):
  p[i]=a[i]^p[i-1]
  if a[i]==0:s[i]=s[i-1]+1
  d=oe[i&1]
  if p[i] in d:last[i]=d[p[i]]
  oe[i&1][p[i-1]]=i
for _ in G(q):
  l,r=R()
  if s[r]>=r-l+1:P(0)
  elif p[l-1]^p[r] or r-l<2:P(-1)
  elif {{completion}}P(1)
  elif last[r]>l:P(2)
  else:P(-1)",(r-l)&1==0 or a[l]==0 or a[r]==0:,last[r]>l:
"import sys;I=sys.stdin.readline;R,P,G=lambda:map(int,I().split()),print,range
n,q=R();n+=1;a=[0]+[*R()];p,s,last,oe=[0]*n,[0]*n,[0]*n,[{},{}]
for i in G(1,n):
  p[i]=a[i]^p[i-1]
  if a[i]==0:s[i]=s[i-1]+1
  d=oe[i&1]
  if p[i] in d:last[i]=d[p[i]]
  oe[i&1][p[i-1]]=i
for _ in G(q):
  l,r=R()
  if s[r]>=r-l+1:P(0)
  elif p[l-1]^p[r] or r-l<2:P(-1)
  elif (r-l)&1==0 or a[l]==0 or a[r]==0:P(1)
  elif {{completion}}P(2)
  else:P(-1)",last[r]>l:,(r-l)&1==0 or a[l]==0 or a[r]==0:
"import sys

n, q = [int(i) for i in sys.stdin.readline().split()]
a = [int(i) for i in sys.stdin.readline().split()]

cur = 0
odd = {}
even = {}
last = [-1]*(n+1)
pxor = [0]*(n+1)
psum = [0]*(n+1)

for i, num in enumerate(a):
    pxor[i+1] = pxor[i] ^ num
    psum[i+1] = psum[i] + num
    cur = pxor[i+1]
    if i&1 == 0:
        if cur in odd:
            last[i+1] = odd[cur]
        even[cur] = i + 1
    else:
        if cur in even:
            last[i+1] = even[cur]
        odd[cur] = i + 1

for _ in range(q):
    l, r = [int(i) for i in sys.stdin.readline().split()]
    if pxor[l-1] != pxor[r]:
        print(""-1"")
    elif psum[l-1] == psum[r]:
        print(""0"")
    else:
        if (r-l)%2==0:
            print(""1"")
        elif a[l-1]==0 or a[r-1]==0:
            print(""1"")
        elif {{completion}}
            print(""2"")
        else:
            print(""-1"")

",last[r] >= l:,(r-l)&1==0 or a[l-1]==0 or a[r-1]==0:
"import sys
input = sys.stdin.readline
n,q = map(int,input().split())
a = [0] + list(map(int,input().split()))
cml = a[::1]
for i in range(1, n+1):
  a[i] ^= a[i-1]
  cml[i] += cml[i-1]
qs = [list(map(int,input().split())) for i in range(q)]

from collections import defaultdict
d = defaultdict(list)
dd = defaultdict(list)
cnt = defaultdict(int)
ord = [0]*(n+1)
for i in range(n+1):
  dd[a[i]].append(i % 2)
  cnt[a[i]] += 1
  ord[i] = cnt[a[i]]
for k,v in dd.items():
  dd[k] = [0] + v
  for i in range(len(v)+1):
    if i == 0: continue
    else:
      dd[k][i] += dd[k][i-1]
for l,r in qs:
  if a[r] != a[l-1]: 
    print(-1)
  else:
    if cml[r] - cml[l-1] == 0:
      print(0)
    elif (r-l) % 2 == 0 or a[l] == a[l-1] or a[r] == a[r-1]:
      print(1)
    else:
      ll = ord[l-1]-1
      rr = ord[r]
      tot = dd[a[r]][rr] - dd[a[r]][ll]
      if {{completion}}
        print(-1)
      else:
        print(2)
",tot == rr-ll or tot == 0:,(r-l) % 2 == 0 or a[l] == a[l-1] or a[r] == a[r-1]:
"import sys
 
def input():
    return sys.stdin.readline().strip()
    
n, q = map(int, input().split())
a = list(map(int, input().split()))
b, s = [0], [0]
nx = [n+5] * (n + 1)
d = {0: [0]}
for i, e in enumerate(a):
    bx = b[-1]^e
    sx = s[-1] + e
    b.append(bx)
    s.append(sx)
    if bx in d.keys():
        if (i + 1 - d[bx][-1]) % 2 == 0:
            d[bx].append(i + 1)
        else:
            for x in d[bx]:
                nx[x] = i + 1
            d[bx] = [i + 1]
    else:
        d[bx] = [i + 1]
        
# print(nx)
for i in range(q):
    l, r = map(int, input().split())
    if b[r] != b[l-1]:
        sys.stdout.write(""-1\n"")
    else:
        if s[r] - s[l-1] == 0:
            sys.stdout.write(""0\n"")
        elif (r - l + 1) % 2:
            sys.stdout.write(""1\n"")
        else:
            if a[l - 1]*a[r - 1] == 0:
                sys.stdout.write(""1\n"")
            elif {{completion}}
                sys.stdout.write(""2\n"")
            else:
                sys.stdout.write(""-1\n"")
",nx[l-1] <= r:,(r - l + 1) % 2:
"import collections
import sys
input = sys.stdin.readline
def sol(arr, n, m, q):
    xor = [0]
    curr = 0
    for i in arr:
        curr ^= i
        xor.append(curr)
    pre = [0]
    curr = 0
    for i in arr:
        curr += i
        pre.append(curr)
    qd = collections.defaultdict(list)
    for i in range(m):
        qd[q[i][1]].append((q[i][0], i))
    
    
    res = [-1] * m
    last = [collections.defaultdict(int), collections.defaultdict(int)]
    for r in range(1, n + 1):
        last[r & 1][xor[r]] = r
        for l, i in qd[r]:
            if xor[r] ^ xor[l - 1] != 0: 
                res[i] = (-1)
            elif pre[r] == pre[l - 1]: 
                res[i] = (0)
            elif (r - l) & 1 and arr[l - 1] and arr[r - 1]:
                if {{completion}}
                    res[i] = (2)
                else:
                    res[i] = (-1)
            else: 
                res[i] = (1)
    
    for i in res:
        print(i)


n, m = list(map(int,input().split()))
arr = list(map(int,input().split()))
q = []
for i in range(m):
    q.append(list(map(int,input().split())))
(sol(arr, n, m, q))
",last[(r & 1) ^ 1][xor[r]] >= l:,pre[r] == pre[l - 1]:
"import collections
import sys
input = sys.stdin.readline
def sol(arr, n, m, q):
    xor = [0]
    curr = 0
    for i in arr:
        curr ^= i
        xor.append(curr)
    pre = [0]
    curr = 0
    for i in arr:
        curr += i
        pre.append(curr)
    qd = collections.defaultdict(list)
    for i in range(m):
        qd[q[i][1]].append((q[i][0], i))
    
    
    res = [-1] * m
    last = [collections.defaultdict(int), collections.defaultdict(int)]
    for r in range(1, n + 1):
        last[r & 1][xor[r]] = r
        for l, i in qd[r]:
            if xor[r] ^ xor[l - 1] != 0: 
                res[i] = (-1)
            elif {{completion}} 
                res[i] = (0)
            elif (r - l) & 1 and arr[l - 1] and arr[r - 1]:
                if last[(r & 1) ^ 1][xor[r]] >= l:
                    res[i] = (2)
                else:
                    res[i] = (-1)
            else: 
                res[i] = (1)
    
    for i in res:
        print(i)


n, m = list(map(int,input().split()))
arr = list(map(int,input().split()))
q = []
for i in range(m):
    q.append(list(map(int,input().split())))
(sol(arr, n, m, q))
",pre[r] == pre[l - 1]:,(r-l)&1==0 or a[l]==0 or a[r]==0:
"for t in range(int(input())):
    n = int(input())
    if {{completion}}
        print(""1\n1 2"")
        continue
    i = 2
    j = 3*n
    ans = []
    while i<j:
        ans.append((i,j))
        i += 3
        j -= 3
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

",n == 1:,i<j:
"for t in range(int(input())):
    n = int(input())
    if n == 1:
        print(""1\n1 2"")
        continue
    i = 2
    j = 3*n
    ans = []
    while {{completion}}
        ans.append((i,j))
        i += 3
        j -= 3
    print(len(ans))
    for i in ans:
        print(i[0],i[1])

",i<j:,i<j:
"t = int(input())
for i in range(t):
    n = int(input())
    if n == 1:
    	print(1)
    	print(1,2)
    elif n%2 :
        print(int((n+1)/2))
        for e in range(2, int((3 * n + 1)/2) + 1, 3):
            print(e,e + int((3*n)/2))
    else :
        print(int(n/2))
        for {{completion}}
            print(e,e + int(3*n/2) + 1)","e in range(2, int((3 * n + 1)/2) + 1, 3):","
Complete the code in python to solve this programming problem:

Description: You are given an integer $$$n$$$.Let's define $$$s(n)$$$ as the string ""BAN"" concatenated $$$n$$$ times. For example, $$$s(1)$$$ = ""BAN"", $$$s(3)$$$ = ""BANBANBAN"". Note that the length of the string $$$s(n)$$$ is equal to $$$3n$$$.Consider $$$s(n)$$$. You can perform the following operation on $$$s(n"
"from sys import stdin
t = int(stdin.readline().strip())
for i in range(t):
    n = int(stdin.readline().strip())
    b = list('ban'*n)
    if n==1:
        print(1)
        print(1, 2)
    else:
        z = n*3-1
        print(n//2+n%2)
        for i3 in range(n//2+n%2):
            for i2 in range(n*3):
                if {{completion}}
                    c = b[z]
                    b[z] = 'a'
                    b[i2] = c
                    print(min(i2+1, z+1), max(i2+1, z+1))
                    z-=3
                    break",b[i2]=='a':,i2+1 < z+1 and b[i2]!= 'a':
"# get testcase input
t = int(input())
result = """"

while t:
    t -= 1
    n = int(input())
    aux = int(n/2 if n%2==0 else n/2+1)

    if {{completion}}
        result += ""1\n1 2\n""
        continue
    
    result += str(aux) + ""\n""
    for i in range(aux):
        result += str(2+3*i) + ' ' + str(3+3*(n-i-1)) + ""\n""
print(result[:-1])",n == 1:,"































































































































"
"# get testcase input
t = int(input())
result = """"

while t:
    t -= 1
    n = int(input())
    aux = int(n/2 if n%2==0 else n/2+1)

    if n == 1:
        result += ""1\n1 2\n""
        continue
    
    result += str(aux) + ""\n""
    for {{completion}}
        result += str(2+3*i) + ' ' + str(3+3*(n-i-1)) + ""\n""
print(result[:-1])",i in range(aux):,"e in range(2, int((3 * n + 1)/2) + 1, 3):"
"def ban(n):
	if {{completion}}
		return [1, [[1, 2]]]

	x = 0
	lt = []
	i = 2
	j = 3 * n
	while i < j:
		lt.append([i, j])
		x += 1
		i += 3
		j -= 3

	return [x, lt]

OUTPUT = []
for _ in range(int(input())):
	N = int(input())
	OUTPUT.append(ban(N))

for _ in OUTPUT:
	print(_[0])
	for i in _[1]:
		print(*i)
",n == 1:,i < j:
"def ban(n):
	if n == 1:
		return [1, [[1, 2]]]

	x = 0
	lt = []
	i = 2
	j = 3 * n
	while {{completion}}
		lt.append([i, j])
		x += 1
		i += 3
		j -= 3

	return [x, lt]

OUTPUT = []
for _ in range(int(input())):
	N = int(input())
	OUTPUT.append(ban(N))

for _ in OUTPUT:
	print(_[0])
	for i in _[1]:
		print(*i)
",i < j:,i < j:
"n = int(input())
for i in range(n):
    k = int(input())

    if k == 1:
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
    else:
        t = []
        p = [0, 1, 2] * k
        x, y = 0, len(p) - 1
        while x < y:
            while {{completion}} x += 1
            while x < y and p[y] != 2: y -= 1
            if x >= y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
",x < y and p[x] != 1:,x < y and p[x]!= 1:
"n = int(input())
for i in range(n):
    k = int(input())

    if k == 1:
        ans = max(1, k - 1)
        print(ans)
        print(1, 2)
    else:
        t = []
        p = [0, 1, 2] * k
        x, y = 0, len(p) - 1
        while x < y:
            while x < y and p[x] != 1: x += 1
            while {{completion}} y -= 1
            if x >= y:
                break
            t.append([x + 1, y + 1])
            p[x], p[y] = p[y], p[x]
        print(len(t))
        for x, y, in t:
            print(x, y)
",x < y and p[y] != 2:,x < y and p[y]!= 2:
"input = __import__('sys').stdin.readline


n = int(input())

adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v, x = map(lambda x: int(x)-1, input().split())
    adj[u].append((v, x))
    adj[v].append((u, x))


TRAVERSE = 0
UPDATE_DP = 1

prev_node_stack = [[0] for _ in range(n)]
prev_node = [0]*n
sz = [1]*n
dp_root = [0]*n
dp_remove = [0]*n

stack = [(TRAVERSE, (0, -1, 0))]
while len(stack) > 0:
    state, param = stack.pop()
    if state == TRAVERSE:
        u, par, i = param
        if {{completion}}
            i += 1
        if i < len(adj[u]):
            v, x = adj[u][i]
            stack.append((TRAVERSE, (u, par, i+1)))
            stack.append((UPDATE_DP, (v, u, x)))
            stack.append((TRAVERSE, (v, u, 0)))
            prev_node_stack[x].append(v)

    if state == UPDATE_DP:
        v, u, x = param
        prev_node_stack[x].pop()
        sz[u] += sz[v]
        prev_node[v] = prev_node_stack[x][-1]
        if prev_node[v] == 0:
            dp_root[x] += sz[v]
        else:
            dp_remove[prev_node[v]] += sz[v]


# print('prev_node', prev_node)
# print('dp_root', dp_root)
# print('dp_remove', dp_remove)

ans = sum((sz[v] - dp_remove[v]) * (sz[prev_node[v]] - (dp_root[x] if prev_node[v] == 0 else dp_remove[prev_node[v]]))
    for u in range(n) for v, x in adj[u] if sz[u] > sz[v])
print(ans)
",i < len(adj[u]) and adj[u][i][0] == par:,i < len(adj[u]):
"input = __import__('sys').stdin.readline


n = int(input())

adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v, x = map(lambda x: int(x)-1, input().split())
    adj[u].append((v, x))
    adj[v].append((u, x))


TRAVERSE = 0
UPDATE_DP = 1

prev_node_stack = [[0] for _ in range(n)]
prev_node = [0]*n
sz = [1]*n
dp_root = [0]*n
dp_remove = [0]*n

stack = [(TRAVERSE, (0, -1, 0))]
while len(stack) > 0:
    state, param = stack.pop()
    if state == TRAVERSE:
        u, par, i = param
        if i < len(adj[u]) and adj[u][i][0] == par:
            i += 1
        if {{completion}}
            v, x = adj[u][i]
            stack.append((TRAVERSE, (u, par, i+1)))
            stack.append((UPDATE_DP, (v, u, x)))
            stack.append((TRAVERSE, (v, u, 0)))
            prev_node_stack[x].append(v)

    if state == UPDATE_DP:
        v, u, x = param
        prev_node_stack[x].pop()
        sz[u] += sz[v]
        prev_node[v] = prev_node_stack[x][-1]
        if prev_node[v] == 0:
            dp_root[x] += sz[v]
        else:
            dp_remove[prev_node[v]] += sz[v]


# print('prev_node', prev_node)
# print('dp_root', dp_root)
# print('dp_remove', dp_remove)

ans = sum((sz[v] - dp_remove[v]) * (sz[prev_node[v]] - (dp_root[x] if prev_node[v] == 0 else dp_remove[prev_node[v]]))
    for u in range(n) for v, x in adj[u] if sz[u] > sz[v])
print(ans)
",i < len(adj[u]):,i < len(adj[u]) and adj[u][i][0] == par:
"



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))


p=[0]*(n+2)
num=[0]*(n+3)

omomi=defaultdict(int)


nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            p[next]=now
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            x=now
            num[x]=1
            for y in root[x]:
                if y==p[x]:continue
                num[x]+=num[y]
            if x>1:
                c=col[x,p[x]]
                omomi[x,c]+=num[x]
                omomi[nextp[x],c]-=num[x]
            else:
                for {{completion}}
                    omomi[x,c]+=num[x]
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)

ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)









","c in range(1,n+1):",
"




##########################



def tree_search(n,G,s,func1,func2,func3):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        if seen[now]==0 and func1!=0:func1(now)
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            if func2!=0:func2(now,next)
            search.append(next)
        else:
            if {{completion}}func3(now)
            search.pop()

#############################



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))

def cnb(n):
    return n*(n-1)//2

p=[0]*(n+2)
num=[0]*(n+3)
dp=[defaultdict(int) for i in range(n+3)]
omomi=defaultdict(int)

def f2(x,y):
    p[y]=x

def f3(x):
    num[x]=1
    for y in root[x]:
        if y==p[x]:continue
        num[x]+=num[y]

    for y in root[x]:
        if y==p[x]:continue
        if len(dp[x])<len(dp[y]):
            res=dp[y]
            for ke in dp[x]:res[ke]+=dp[x][ke]
        else:
            res = dp[x]
            for ke in dp[y]: res[ke] += dp[y][ke]
        dp[x] = res
    if x>1:
        c=col[x,p[x]]
        omomi[x,c]=num[x]-dp[x][c]
        dp[x][c]=num[x]
    else:
        for c in range(1,n+1):
            omomi[1,c]=num[1]-dp[1][c]

tree_search(n,root,1,0,f2,f3)
nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)


ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)






",func3!=0:,ke in dp[y]:
"




##########################



def tree_search(n,G,s,func1,func2,func3):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        if seen[now]==0 and func1!=0:func1(now)
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            if func2!=0:func2(now,next)
            search.append(next)
        else:
            if func3!=0:func3(now)
            search.pop()

#############################



import sys
input=sys.stdin.readline #文字列入力はするな！！
n=int(input())
root=[[] for i in range(n+3)]
col=dict()
e=[]
from _collections import defaultdict
for i in range(n-1):
    a,b,x=map(int,input().split())
    root[a].append(b)
    root[b].append(a)
    col[a,b]=x
    col[b,a]=x
    e.append((a,b,x))

def cnb(n):
    return n*(n-1)//2

p=[0]*(n+2)
num=[0]*(n+3)
dp=[defaultdict(int) for i in range(n+3)]
omomi=defaultdict(int)

def f2(x,y):
    p[y]=x

def f3(x):
    num[x]=1
    for y in root[x]:
        if y==p[x]:continue
        num[x]+=num[y]

    for y in root[x]:
        if y==p[x]:continue
        if len(dp[x])<len(dp[y]):
            res=dp[y]
            for ke in dp[x]:res[ke]+=dp[x][ke]
        else:
            res = dp[x]
            for {{completion}} res[ke] += dp[y][ke]
        dp[x] = res
    if x>1:
        c=col[x,p[x]]
        omomi[x,c]=num[x]-dp[x][c]
        dp[x][c]=num[x]
    else:
        for c in range(1,n+1):
            omomi[1,c]=num[1]-dp[1][c]

tree_search(n,root,1,0,f2,f3)
nextp=[10**10]*(n+2)
nextc=[1]*(n+1)

ch=[]
def dfs(n,G,s):
    seen = [0] * (n + 1) # 場合によっては外に出す
    ind = [0] * (n + 1) ##
    search=[s]
    while search:
        now=search[-1]
        seen[now]=1
        if len(G[now])>ind[now]:
            next=G[now][ind[now]]
            ind[now]+=1
            if seen[next]>0:continue
            c=col[now,next]
            nextp[next]=nextc[c]
            tmp = nextc[c]
            nextc[c]=next
            ch.append((c,tmp))
            search.append(next)
        else:
            if ch:
                c,tmp=ch.pop()
                nextc[c]=tmp
            search.pop()

#############################



dfs(n,root,1)


ans=0
for a,b,c in e:
    if num[a]>num[b]:
        a,b=b,a
    ans+=omomi[a,c]*omomi[nextp[a],c]
print(ans)






",ke in dp[y]:,func3!=0:
"import sys
input = sys.stdin.readline
N = int(input())
logN = (N - 2).bit_length()

door = []
for _ in range(N - 1):
    _, a, b, _ = map(int, input().split())
    door.append([a - 1, b - 1])

# door = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(N - 1)]

dist = [[[-1] * 4 for _ in range(logN)] for _ in range(N - 2)]

'''
0: 0->0
1: 0->1
2: 1->0
3: 1->1
'''

for i in range(N - 2):
    d1 = abs(i - door[i][1]) + abs(door[i][0] - i)
    dist[i][0][0] = abs(door[i][0] - door[i + 1][0]) + 1
    dist[i][0][3] = abs(door[i][1] - door[i + 1][1]) + 1
    dist[i][0][1] = min(
        abs(i + 1 - door[i + 1][1]) + abs(door[i][0] - (i + 1)) + 1,
        d1 + dist[i][0][3]
    )
    dist[i][0][2] = min(
        abs(door[i][1] - (i + 1)) + abs(i + 1 - door[i + 1][0]) + 1,
        d1 + dist[i][0][0]
    )

for j in range(1, logN):
    k = 1 << (j - 1)
    for i in range(N - 1 - (1 << j)):
        for fr in range(2):
            for to in range(2):
                dist[i][j][fr << 1 | to] = min(
                    dist[i][j - 1][fr << 1] + dist[i + k][j - 1][to],
                    dist[i][j - 1][fr << 1 | 1] + dist[i + k][j - 1][2 | to]
                )

Q = int(input())
for _ in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x) - 1, input().split())
    l1 = max(h1, w1)
    l2 = max(h2, w2)
    if l1 == l2:
        print(abs(h1 - h2) + abs(w1 - w2))
        continue
    if l1 > l2:
        l1, l2 = l2, l1
        h1, w1, h2, w2 = h2, w2, h1, w1
    now = l1
    l = l2 - l1 - 1
    d0 = abs(h1 - now) + abs(w1 - door[now][0])
    d1 = abs(h1 - door[now][1]) + abs(w1 - now)
    for i in range(logN - 1, -1, -1):
        if {{completion}}
            d0, d1 = min(d0 + dist[now][i][0], d1 + dist[now][i][2]), min(d0 + dist[now][i][1], d1 + dist[now][i][3])
            now += 1 << i
    print(min(d0 + abs(now + 1 - h2) + abs(door[now][0] - w2), d1 + abs(door[now][1] - h2) + abs(now + 1 - w2)) + 1)",l >> i & 1:,dist is None:
"input = __import__('sys').stdin.readline


def manhattan(A, B, dA=None, dB=None):
    if dA is not None:
        A = list(A)
        A[0] += dA[0]
        A[1] += dA[1]
    if dB is not None:
        B = list(B)
        B[0] += dB[0]
        B[1] += dB[1]
    return abs(A[0] - B[0]) + abs(A[1] - B[1])


n = int(input())
a = []
for _ in range(n-1):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    a.append((
        (x1, y1),
        (x2, y2),
    ))
a.append((
    (a[-1][0][0] + 1, a[-1][0][1]),
    (a[-1][1][0], a[-1][1][1] + 1),
))

jump = [
    [
        (
            min(manhattan(a[i][0], a[i+1][0], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][0], dA=(0, 1))) + 1,
            min(manhattan(a[i][0], a[i+1][1], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][1], dA=(0, 1))) + 1,
            min(manhattan(a[i][1], a[i+1][0], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][0], dA=(1, 0))) + 1,
            min(manhattan(a[i][1], a[i+1][1], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][1], dA=(1, 0))) + 1,
        ) for i in range(n-1)
    ]
]


def merge(A, B):
    return (
        min(A[0] + B[0], A[1] + B[2]),
        min(A[0] + B[1], A[1] + B[3]),
        min(A[2] + B[0], A[3] + B[2]),
        min(A[2] + B[1], A[3] + B[3]),
    )

# print(jump[0])
for j in range(20):
    jump.append([
        merge(jump[j][i], jump[j][i + (1 << j)]) for i in range(len(jump[j]) - (1 << j))
    ])
    # print(jump[-1])


for _ in range(int(input())):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    m1, m2 = max(x1, y1), max(x2, y2)
    if m1 > m2:
        m1, m2 = m2, m1
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    
    if m1 == m2:
        print(manhattan((x1, y1), (x2, y2)))
        continue
    
    s = m1
    sz = m2 - m1 - 1
    dist = None
    for i in range(20):
        if (sz >> i) & 1 == 1:
            if {{completion}}
                dist = jump[i][s]
            else:
                dist = merge(dist, jump[i][s])
            s += (1 << i)
    
    if m1 + 1 == m2:
        dist = (0, manhattan(a[m1][0], a[m1][1]), manhattan(a[m1][1], a[m1][0]), 0)
    # print('dist', dist, a[m1], a[m2-1])
    # print('>', manhattan((x1, y1), a[m1][0]), dist[0], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][0]), dist[1], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[2], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[3], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print([
    #     manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    # ])
    print(min(
        manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    ))",dist is None:,"































































































































"
"input = __import__('sys').stdin.readline


def manhattan(A, B, dA=None, dB=None):
    if dA is not None:
        A = list(A)
        A[0] += dA[0]
        A[1] += dA[1]
    if dB is not None:
        B = list(B)
        B[0] += dB[0]
        B[1] += dB[1]
    return abs(A[0] - B[0]) + abs(A[1] - B[1])


n = int(input())
a = []
for _ in range(n-1):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    a.append((
        (x1, y1),
        (x2, y2),
    ))
a.append((
    (a[-1][0][0] + 1, a[-1][0][1]),
    (a[-1][1][0], a[-1][1][1] + 1),
))

jump = [
    [
        (
            min(manhattan(a[i][0], a[i+1][0], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][0], dA=(0, 1))) + 1,
            min(manhattan(a[i][0], a[i+1][1], dA=(1, 0)), manhattan(a[i][0], a[i][1]) + manhattan(a[i][1], a[i+1][1], dA=(0, 1))) + 1,
            min(manhattan(a[i][1], a[i+1][0], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][0], dA=(1, 0))) + 1,
            min(manhattan(a[i][1], a[i+1][1], dA=(0, 1)), manhattan(a[i][1], a[i][0]) + manhattan(a[i][0], a[i+1][1], dA=(1, 0))) + 1,
        ) for i in range(n-1)
    ]
]


def merge(A, B):
    return (
        min(A[0] + B[0], A[1] + B[2]),
        min(A[0] + B[1], A[1] + B[3]),
        min(A[2] + B[0], A[3] + B[2]),
        min(A[2] + B[1], A[3] + B[3]),
    )

# print(jump[0])
for j in range(20):
    jump.append([
        merge(jump[j][i], jump[j][i + (1 << j)]) for i in range(len(jump[j]) - (1 << j))
    ])
    # print(jump[-1])


for _ in range(int(input())):
    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())
    m1, m2 = max(x1, y1), max(x2, y2)
    if m1 > m2:
        m1, m2 = m2, m1
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    
    if m1 == m2:
        print(manhattan((x1, y1), (x2, y2)))
        continue
    
    s = m1
    sz = m2 - m1 - 1
    dist = None
    for i in range(20):
        if {{completion}}
            if dist is None:
                dist = jump[i][s]
            else:
                dist = merge(dist, jump[i][s])
            s += (1 << i)
    
    if m1 + 1 == m2:
        dist = (0, manhattan(a[m1][0], a[m1][1]), manhattan(a[m1][1], a[m1][0]), 0)
    # print('dist', dist, a[m1], a[m2-1])
    # print('>', manhattan((x1, y1), a[m1][0]), dist[0], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][0]), dist[1], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[2], manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)))
    # print('>', manhattan((x1, y1), a[m1][1]), dist[3], manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)))
    # print([
    #     manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
    #     manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    # ])
    print(min(
        manhattan((x1, y1), a[m1][0]) + dist[0] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][0]) + dist[1] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[2] + manhattan(a[m2-1][0], (x2, y2), dA=(1, 0)) + 1,
        manhattan((x1, y1), a[m1][1]) + dist[3] + manhattan(a[m2-1][1], (x2, y2), dA=(0, 1)) + 1,
    ))",(sz >> i) & 1 == 1:,"































































































































"
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


def isMountain(ar):
    prefixInc = [False] * len(ar)
    prefixInc[0] = 1
    for i in range(1, len(ar)):
        prefixInc[i] = prefixInc[i - 1] and ar[i - 1] <= ar[i]

    suffixInc = [0] * len(ar)
    suffixInc[-1] = 1
    for i in range(len(ar) - 2, -1, -1):
        suffixInc[i] = suffixInc[i + 1] and ar[i] >= ar[i + 1]

    ans = prefixInc[-1] or suffixInc[0]
    for i in range(len(ar)):
        ans = ans or (prefixInc[i] and suffixInc[i])
    return ans

testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)
    print(""yes"" if isMountain(A) else ""no"")


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for {{completion}}
        solve(tc + 1)
    assert not tokens",tc in range(testcaseCount):,tc + 1
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    P = [getIntArray(2) for i in range(N)] + [[0, 0]]
    minX = abs(min(p[0] for p in P))
    maxX = abs(max(p[0] for p in P))
    minY = abs(min(p[1] for p in P))
    maxY = abs(max(p[1] for p in P))
    print(minX + minY + maxX + maxY << 1)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for {{completion}}
        solve(tc + 1)
    assert not tokens",tc in range(testcaseCount):,i == 0 and j == 0:
"a=[*map(int,[*open(0)][1].split())]
for k in 0,1:
	for i in range(19):
		z=1<<i
		for j in range(len(a)):
			if {{completion}}a[j-k*z]^=a[j+k*z-z]
print(*reversed(a))
",j&z:,a[j-k*z]^=a[j+k*z-z]
"a=[*map(int,[*open(0)][1].split())]
n=len(a)
for k in 0,1:
    for i in range(19):
        for j in range(n):
            l=j^1<<i
            if {{completion}}
                a[j]^=a[l]
print(*reversed(a))
",k^(l<j)and l<n:,j&z:
"input()
n = int(input(), 2)
m = n
for {{completion}}
    n = max(n, m | m >> i)
print(bin(n)[2:])",i in range(30):,"i in range(1,64):"
"n = int(input())
s=input()
b=int(s,2)
a=b;
mx=a|b
for i in range(0,7):
  a=a>>1
  m=a|b
  if {{completion}}
    mx=m
st=format(mx ,""b"")
print(st)",m>mx:,"i in range(1,10):"
"n = input()
s = int(input(),2)

res = 0
for {{completion}}
    res = max(res,(s | (s >> i)))
ans = bin(res)[2:]
print(ans)",i in range(100):,i in range(30):
"input()
n=int(input(),2)
ans=0
for {{completion}}
    ans=max(ans,n|(n>>i))
print(bin(ans)[2:])

","i in range(1,64):",i in range(30):
"n = input()
s = int(input(), base=2)
t = s
for {{completion}}
    t = max(t, s | s >> i)
print(""{0:b}"".format(t))","i in range(1,10):",i in range(30):
"n = int(input())
s = input().strip()

s1 = int('0b'+s,2)
res = s1

for {{completion}}
    res = max(s1 | (s1 >> i), res)

print(bin(res)[2:])","i in range(1,8):",i in range(100):
"def random(st):
	n = 8
	st = int(st, 2)
	MAX = st
	for {{completion}}
		MAX = max((st >> t) | st, MAX)

	return bin(MAX)[2:]


N = input()
b = input()
print(random(b))
",t in range(n):,"for i in range(1, 8):
  if MAX & (1 << i):
    MAX |= MAX >> i"
"# وده اقل حاجه ببايثون
input()
n=int(input(),2)
m=n
for {{completion}}m=max(m,n|n>>i)
print(""{0:b}"".format(m))","i in range(1,100):",i in range(30):
"n = int(input())
a = int(input(), 2)
temp = a
mx = a|temp
for i in range(7):
    temp = temp >> 1
    m = a|temp
    if {{completion}}
        mx = m

print(bin(mx).replace('0b', ''))
",mx < m:,i in range(30):
"import sys
import heapq
from collections import Counter
# sys.setrecursionlimit(10000)


def input_general():
    return sys.stdin.readline().rstrip('\r\n')


def input_num():
    return int(sys.stdin.readline().rstrip(""\r\n""))


def input_multi(x=int):
    return map(x, sys.stdin.readline().rstrip(""\r\n"").split())


def input_list(x=int):
    return list(input_multi(x))


def main():
    def mod_pow(p, a, e):
        base = a
        answer = 1

        while e:
            if {{completion}}
                answer = (answer * base) % p

            base = (base * base) % p
            e >>= 1
        return answer

    n = input_num()
    hp = []
    pos = [[] for _ in range(300001)]
    for i in range(n):
        l, r = input_multi()
        pos[l].append((i, r + 1))

    P = 998244353
    two_inv = (P + 1) // 2

    loc = [-1] * 300001
    for i in range(300001):
        for (idx, r) in pos[i]:
            heapq.heappush(hp, (-idx, r))

        while hp and hp[0][1] <= i:
            heapq.heappop(hp)

        if hp:
            loc[i] = -hp[0][0]

    ctr = Counter(loc)
    max_loc = max(ctr.keys())

    curr = mod_pow(P, 2, n - 1)

    answer = (curr * (ctr[0] + ctr[1])) % P
    for i in range(2, max_loc + 1):
        curr = (curr * two_inv * 3) % P
        answer = (answer + curr * ctr[i]) % P

    print(answer)


if __name__ == ""__main__"":
    # cases = input_num()
    #
    # for _ in range(cases):
    main()
",e & 1:,ctr[i]
"import sys
input=sys.stdin.readline
from collections import defaultdict
from heapq import heappop,heappush

def solve():
    N=int(input())
    p=998244353

    # 2와 3의 거듭제곱 저장
    two=[1]
    for _ in range(N):
        two.append((two[-1]*2)%p)
    three=[1]
    for _ in range(N):
        three.append((three[-1]*3)%p)

    # 각 원소별로 마지막 출현 인덱스 저장
    def lazy(n,cur,start,end,left,right):
        if end<left or right<start:
            return
        elif left<=start and end<=right:
            st[cur]=n
        else:
            lazy(n,2*cur,start,(start+end)//2,left,right)
            lazy(n,2*cur+1,(start+end)//2+1,end,left,right)
    def update(cur,start,end):
        if start==end:
            last[start]=st[cur]
            return
        if 2*cur<1200000:
            if {{completion}}
                st[2*cur]=st[cur]
            update(2*cur,start,(start+end)//2)
        if 2*cur+1<1200000:
            if st[2*cur+1]<st[cur]:
                st[2*cur+1]=st[cur]
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input().split())
        lazy(n,1,0,300000,a,b)
    update(1,0,300000)

    # last값을 기준으로 마지막 연산
    ans=0
    A=defaultdict(int)
    for l in last:
        if l!=0:
            A[l]+=1
    for l in A:
        ans=(ans+A[l]*(three[l-1]*two[N-l]))%p
    print(ans)
solve()",st[2*cur]<st[cur]:,st[2*cur+1]<st[cur]:
"import sys
input=sys.stdin.readline
from collections import defaultdict
from heapq import heappop,heappush

def solve():
    N=int(input())
    p=998244353

    # 2와 3의 거듭제곱 저장
    two=[1]
    for _ in range(N):
        two.append((two[-1]*2)%p)
    three=[1]
    for _ in range(N):
        three.append((three[-1]*3)%p)

    # 각 원소별로 마지막 출현 인덱스 저장
    def lazy(n,cur,start,end,left,right):
        if end<left or right<start:
            return
        elif left<=start and end<=right:
            st[cur]=n
        else:
            lazy(n,2*cur,start,(start+end)//2,left,right)
            lazy(n,2*cur+1,(start+end)//2+1,end,left,right)
    def update(cur,start,end):
        if start==end:
            last[start]=st[cur]
            return
        if 2*cur<1200000:
            if st[2*cur]<st[cur]:
                st[2*cur]=st[cur]
            update(2*cur,start,(start+end)//2)
        if 2*cur+1<1200000:
            if {{completion}}
                st[2*cur+1]=st[cur]
            update(2*cur+1,(start+end)//2+1,end)
    st=[0]*1200000
    last=[0]*300001
    a,b=map(int,input().split())
    lazy(1,1,0,300000,a,b)
    for n in range(1,N):
        a,b=map(int,input().split())
        lazy(n,1,0,300000,a,b)
    update(1,0,300000)

    # last값을 기준으로 마지막 연산
    ans=0
    A=defaultdict(int)
    for l in last:
        if l!=0:
            A[l]+=1
    for l in A:
        ans=(ans+A[l]*(three[l-1]*two[N-l]))%p
    print(ans)
solve()",st[2*cur+1]<st[cur]:,st[2*cur+1]<st[cur]:
"from collections import deque;I=input;R=lambda:map(int,I().split())
def f(x,pre):
  global flg;dp=[0]*(n+1)
  q=deque([(x,pre)]);R=[]
  while q:
    u,p=q.popleft()
    R.append((u))
    for v in g[u]:
      if {{completion}}q.append((v,u))
  for u in R[::-1]:
    path=0;dp[u]+=1 if u in s else 0
    for v in g[u]:
      path+=(1 if dp[v] else 0);dp[u]+=dp[v]
    flg=flg and (path<=1 or path==2 and k==dp[u])
  return dp[x]

n=int(I());g=[[] for _ in range(n+1)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)
for _ in [0]*int(I()):
  k=int(I());flg=1;s=set(R());f(1,0)
  print(['NO','YES'][flg])",v!=p:,dp[u]+=1 if u in s else 0
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
from collections import deque
n=I();adj=[[] for i in range(n)]
for i in range(n-1):
    p,q=M()
    adj[p-1].append(q-1)
    adj[q-1].append(p-1)
p=[-1]*n;d=[0]*n
q=deque([0]);v=[0]*n
while q:
    r=q.popleft()
    v[r]=1
    for j in adj[r]:
        if {{completion}}
            q.append(j);d[j]=d[r]+1;p[j]=r
q=I()
for i in range(q):
    k=I()
    a=L();y=a[:]
    f=0;z=[]
    j=0;m=0;s=set()
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s1=set();x=0
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s and p[j]!=-1:
        s1.add(j);j=p[j]
    for t in range(len(z)-1,-1,-1):
        if z[t]==j:x=1
        if x==1:s1.add(z[t])
    for i in y:
        if i-1 not in s1:f=1;break
    print(""NO"" if f else ""YES"")",v[j]==0:,p[j]!=-1:
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
from collections import deque
n=I();adj=[[] for i in range(n)]
for i in range(n-1):
    p,q=M()
    adj[p-1].append(q-1)
    adj[q-1].append(p-1)
p=[-1]*n;d=[0]*n
q=deque([0]);v=[0]*n
while q:
    r=q.popleft()
    v[r]=1
    for j in adj[r]:
        if v[j]==0:
            q.append(j);d[j]=d[r]+1;p[j]=r
q=I()
for i in range(q):
    k=I()
    a=L();y=a[:]
    f=0;z=[]
    j=0;m=0;s=set()
    for i in a:
        if {{completion}}m=d[i-1];j=i-1
    while j not in s:
        s.add(j);z.append(j);j=p[j]
        if j==-1:break
    b=[]
    for i in a:
        if i-1 not in s:b.append(i)
    a=b[:]
    if len(a)==0:print(""YES"");continue
    j=0;m=0;s1=set();x=0
    for i in a:
        if d[i-1]>m:m=d[i-1];j=i-1
    while j not in s and p[j]!=-1:
        s1.add(j);j=p[j]
    for t in range(len(z)-1,-1,-1):
        if z[t]==j:x=1
        if x==1:s1.add(z[t])
    for i in y:
        if i-1 not in s1:f=1;break
    print(""NO"" if f else ""YES"")",d[i-1]>m:,v[j]==0:
"def solve():
    n = int(input())
    g = [[] for _ in range(n)]

    for _ in range(n-1):
        u, v = [int(t) for t in input().split()]
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)

    q = int(input())
    for _ in range(q):
        input()
        S = [int(t)-1 for t in input().split()]

        in_S = [0] * n
        for v in S:
            in_S[v] = 1

        v = S[0]
        w = farthest(g, v, in_S)
        y = farthest(g, w, in_S)
        P = set(path(g, w, y))
        ans = ""YES"" if P.issuperset(S) else ""NO""

        print(ans)


def farthest(g, v, in_S):
    queue = [v]
    depth = [-1] * len(g)
    depth[v] = 0
    res = (0, v)
    for v in queue:
        if in_S[v]:
            res = max(res, (depth[v], v))
        for nei in g[v]:
            if {{completion}}
                queue.append(nei)
                depth[nei] = depth[v] + 1
    return res[1]

def path(g, st, en):
    queue = [st]
    prev = [-1] * len(g)
    prev[st] = st
    for v in queue:
        for nei in g[v]:
            if prev[nei] == -1:
                queue.append(nei)
                prev[nei] = v

    res = [en]
    while prev[res[-1]] != res[-1]:
        res.append(prev[res[-1]])

    return res[::-1]


import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

solve()

os.write(1, stdout.getvalue())",depth[nei] == -1:,prev[nei] == -1:
"def solve():
    n = int(input())
    g = [[] for _ in range(n)]

    for _ in range(n-1):
        u, v = [int(t) for t in input().split()]
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)

    q = int(input())
    for _ in range(q):
        input()
        S = [int(t)-1 for t in input().split()]

        in_S = [0] * n
        for v in S:
            in_S[v] = 1

        v = S[0]
        w = farthest(g, v, in_S)
        y = farthest(g, w, in_S)
        P = set(path(g, w, y))
        ans = ""YES"" if P.issuperset(S) else ""NO""

        print(ans)


def farthest(g, v, in_S):
    queue = [v]
    depth = [-1] * len(g)
    depth[v] = 0
    res = (0, v)
    for v in queue:
        if in_S[v]:
            res = max(res, (depth[v], v))
        for nei in g[v]:
            if depth[nei] == -1:
                queue.append(nei)
                depth[nei] = depth[v] + 1
    return res[1]

def path(g, st, en):
    queue = [st]
    prev = [-1] * len(g)
    prev[st] = st
    for v in queue:
        for nei in g[v]:
            if {{completion}}
                queue.append(nei)
                prev[nei] = v

    res = [en]
    while prev[res[-1]] != res[-1]:
        res.append(prev[res[-1]])

    return res[::-1]


import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

solve()

os.write(1, stdout.getvalue())",prev[nei] == -1:,depth[nei] == -1:
"import sys
from array import array


class graph:
    def __init__(self, n):
        self.n, self.gdict = n, [array('i') for _ in range(n + 1)]

    def add_edge(self, node1, node2):
        self.gdict[node1].append(node2)
        self.gdict[node2].append(node1)

    def dfs(self, root):
        stk, ret = array('i', [root]), 0

        while stk:
            node = stk.pop()
            for ch in self.gdict[node]:
                if not vis[ch]:
                    vis[ch] = True

                    while {{completion}}
                        vis[stk.pop()] = 0

                    ret |= mem[ch]
                    stk.append(ch)
        return ret


input = lambda: sys.stdin.buffer.readline().decode().strip()
n = int(input())
g = graph(n)

for _ in range(n - 1):
    u, v = map(int, input().split())
    g.add_edge(u, v)

for i in range(int(input())):
    k, a = int(input()), array('i', [int(x) for x in input().split()])
    vis = array('b', [False] * (n + 1))
    mem = array('b', [0] * (n + 1))
    vis[a[0]], paths = 1, 0

    for j in a:
        mem[j] = 1

    for j in g.gdict[a[0]]:
        vis[j] = 1
        paths += g.dfs(j) | mem[j]

    for j in a:
        if not vis[j]:
            paths = 3
            break

    print('yes' if paths < 3 else 'no')
",mem[ch] and stk:,j in a:
"from collections import deque
import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
    
    # build a tree with BFS
    par = [-1] * n
    depth = [0] * n
    q = deque([0])
    while q:
        u = q.popleft()
        for v in G[u]:
            if {{completion}}
                par[v] = u
                depth[v] = depth[u] + 1
                q.append(v)

    # Path to LCA
    def build_path(u, v):
        path = []
        if depth[u] < depth[v]:
            u, v = v, u
        while depth[u] > depth[v]:
            path.append(u)
            u = par[u]
        while u != v:
            path.append(u)
            path.append(v)
            u, v = par[u], par[v]
        path.append(u)
        return path


    res = []
    q = int(input())
    for _ in range(q):
        k = int(input())
        P = [int(x) - 1 for x in input().split()]
        
        if k == 1:
            res.append(""YES"")
            continue
        
        P.sort(key=lambda u: depth[u])
        u = P.pop()
        v = P.pop()        
        path = build_path(u, v)
        
        while P and u == path[0] and v == path[-1]:
            u = v
            v = P.pop()
            path = build_path(u, v)

        ans = ""YES""
        for u in P:
            if u not in path:
                ans = ""NO""
                break
        res.append(ans)

    return res

res = solve()
print(""\n"".join(res))",v != par[u]:,u not in path:
"from collections import deque
import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n = int(input())
    G = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = [int(x) - 1 for x in input().split()]
        G[u].append(v)
        G[v].append(u)
    
    # build a tree with BFS
    par = [-1] * n
    depth = [0] * n
    q = deque([0])
    while q:
        u = q.popleft()
        for v in G[u]:
            if v != par[u]:
                par[v] = u
                depth[v] = depth[u] + 1
                q.append(v)

    # Path to LCA
    def build_path(u, v):
        path = []
        if depth[u] < depth[v]:
            u, v = v, u
        while depth[u] > depth[v]:
            path.append(u)
            u = par[u]
        while u != v:
            path.append(u)
            path.append(v)
            u, v = par[u], par[v]
        path.append(u)
        return path


    res = []
    q = int(input())
    for _ in range(q):
        k = int(input())
        P = [int(x) - 1 for x in input().split()]
        
        if k == 1:
            res.append(""YES"")
            continue
        
        P.sort(key=lambda u: depth[u])
        u = P.pop()
        v = P.pop()        
        path = build_path(u, v)
        
        while P and u == path[0] and v == path[-1]:
            u = v
            v = P.pop()
            path = build_path(u, v)

        ans = ""YES""
        for u in P:
            if {{completion}}
                ans = ""NO""
                break
        res.append(ans)

    return res

res = solve()
print(""\n"".join(res))",u not in path:,v[j]==0:
"input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1


n = int(input())
adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v = map(mapnode, input().split())
    adj[u].append(v)
    adj[v].append(u)

# dfs
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)]
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if {{completion}}
            depth[v] = depth[u] + 1
            stack.append((v, u))

for _ in range(19):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])

# print('depth', depth)
# print('jump', jump)

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    step = depth[u] - depth[v]
    for i in range(19):
        if (step >> i) & 1 == 1:
            u = jump[i][u]

    if u == v:
        return u
    
    # move up together
    for i in range(18, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# answer queries
for _ in range(int(input())):
    nk = int(input())
    
    nodes = list(sorted(map(mapnode, input().split()), key=lambda u: -depth[u]))
    mindepth = min(depth[u] for u in nodes)

    # check from lowest depth
    tocheck = [nodes[i] for i in range(1, nk) if nodes[i] != lca(nodes[0], nodes[i])]
    
    # print(subroot+1, [x+1 for x in tocheck], [x+1 for x in nodes])
    ok = len(tocheck) == 0 or all(lca(tocheck[0], u) == u for u in tocheck) and depth[lca(tocheck[0], nodes[0])] <= mindepth
    print('YES' if ok else 'NO')
",v != par:,(step >> i) & 1 == 1:
"input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1


n = int(input())
adj = [[] for _ in range(n)]
for _ in range(n-1):
    u, v = map(mapnode, input().split())
    adj[u].append(v)
    adj[v].append(u)

# dfs
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)]
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for _ in range(19):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])

# print('depth', depth)
# print('jump', jump)

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    step = depth[u] - depth[v]
    for i in range(19):
        if {{completion}}
            u = jump[i][u]

    if u == v:
        return u
    
    # move up together
    for i in range(18, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# answer queries
for _ in range(int(input())):
    nk = int(input())
    
    nodes = list(sorted(map(mapnode, input().split()), key=lambda u: -depth[u]))
    mindepth = min(depth[u] for u in nodes)

    # check from lowest depth
    tocheck = [nodes[i] for i in range(1, nk) if nodes[i] != lca(nodes[0], nodes[i])]
    
    # print(subroot+1, [x+1 for x in tocheck], [x+1 for x in nodes])
    ok = len(tocheck) == 0 or all(lca(tocheck[0], u) == u for u in tocheck) and depth[lca(tocheck[0], nodes[0])] <= mindepth
    print('YES' if ok else 'NO')
",(step >> i) & 1 == 1:,u not in path:
"from collections import defaultdict, deque, Counter
import sys
from decimal import *
from heapq import heapify, heappop, heappush
import math
import random
import string
from copy import deepcopy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce, lru_cache
from bisect import bisect_left, bisect_right

def input():
    return sys.stdin.readline().rstrip()
def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getListGraph():
    return list(map(lambda x:int(x) - 1, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]

mod = 10 ** 9 + 7
MOD = 998244353

# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')
inf = float('inf')
eps = 10 ** (-12)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

#############
# Main Code #
#############

# lca
class Doubling():
    def __init__(self, n, edges, root):
        self.n = n
        self.logn = n.bit_length()
        self.doubling = [[-1] * self.n for _ in range(self.logn)]
        self.depth = [-1] * N
        self.depth[root] = 0
        # bfs
        par = [-1] * N
        pos = deque([root])
        while len(pos) > 0:
            u = pos.popleft()
            for v in edges[u]:
                if {{completion}}
                    self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)
        # doubling
        for i in range(self.n):
            self.doubling[0][i] = par[i]
        for i in range(1, self.logn):
            for j in range(self.n):
                if self.doubling[i - 1][j] == -1:
                    self.doubling[i][j] = -1
                else:
                    self.doubling[i][j] = self.doubling[i - 1][self.doubling[i - 1][j]]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):
            if (dv - du) >> i & 1:
                v = self.doubling[i][v]
        if u == v: return u

        for i in range(self.logn - 1, -1, -1):
            pu, pv = self.doubling[i][u], self.doubling[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.doubling[0][u]

    def upstream(self, s, t):
        if t == 0:
            return s
        now = s
        for k in range(self.logn):
            if t & (1 << k):
                now = self.doubling[k][now]
        return now

N = getN()
E = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = getNM()
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

D = Doubling(N, E, 0)
Q = getN()
for _ in range(Q):
    q_n = getN()
    V = sorted([[D.depth[p], p] for p in getListGraph()])
    p1 = V.pop()[1]
    flag = True
    while V:
        p2 = V.pop()[1]
        lca_p = D.lca(p1, p2)
        if lca_p != p2:
            while V:
                opt_p = V.pop()[1]
                # print(D.lca(p1, opt_p), (D.lca(p2, opt_p)))
                if not (opt_p == lca_p or ((D.lca(p1, opt_p) == opt_p) ^ (D.lca(p2, opt_p) == opt_p))):
                    flag = False

    print(""YES"" if flag else ""NO"")",self.depth[v] == -1:,"not (opt_p == lca_p or ((D.lca(p1, opt_p) == opt_p) ^ (D.lca(p2, opt_p) == opt_p))):"
"from collections import defaultdict, deque, Counter
import sys
from decimal import *
from heapq import heapify, heappop, heappush
import math
import random
import string
from copy import deepcopy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce, lru_cache
from bisect import bisect_left, bisect_right

def input():
    return sys.stdin.readline().rstrip()
def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getListGraph():
    return list(map(lambda x:int(x) - 1, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]

mod = 10 ** 9 + 7
MOD = 998244353

# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')
inf = float('inf')
eps = 10 ** (-12)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

#############
# Main Code #
#############

# lca
class Doubling():
    def __init__(self, n, edges, root):
        self.n = n
        self.logn = n.bit_length()
        self.doubling = [[-1] * self.n for _ in range(self.logn)]
        self.depth = [-1] * N
        self.depth[root] = 0
        # bfs
        par = [-1] * N
        pos = deque([root])
        while len(pos) > 0:
            u = pos.popleft()
            for v in edges[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    par[v] = u
                    pos.append(v)
        # doubling
        for i in range(self.n):
            self.doubling[0][i] = par[i]
        for i in range(1, self.logn):
            for j in range(self.n):
                if self.doubling[i - 1][j] == -1:
                    self.doubling[i][j] = -1
                else:
                    self.doubling[i][j] = self.doubling[i - 1][self.doubling[i - 1][j]]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):
            if (dv - du) >> i & 1:
                v = self.doubling[i][v]
        if u == v: return u

        for i in range(self.logn - 1, -1, -1):
            pu, pv = self.doubling[i][u], self.doubling[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.doubling[0][u]

    def upstream(self, s, t):
        if t == 0:
            return s
        now = s
        for k in range(self.logn):
            if t & (1 << k):
                now = self.doubling[k][now]
        return now

N = getN()
E = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = getNM()
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

D = Doubling(N, E, 0)
Q = getN()
for _ in range(Q):
    q_n = getN()
    V = sorted([[D.depth[p], p] for p in getListGraph()])
    p1 = V.pop()[1]
    flag = True
    while V:
        p2 = V.pop()[1]
        lca_p = D.lca(p1, p2)
        if lca_p != p2:
            while V:
                opt_p = V.pop()[1]
                # print(D.lca(p1, opt_p), (D.lca(p2, opt_p)))
                if {{completion}}
                    flag = False

    print(""YES"" if flag else ""NO"")","not (opt_p == lca_p or ((D.lca(p1, opt_p) == opt_p) ^ (D.lca(p2, opt_p) == opt_p))):",self.depth[v] == -1:
"from collections import deque;import math
import sys;I=sys.stdin.readline;R=lambda:map(lambda x:int(x)-1,input().split())
n=int(I());g=[[] for _ in range(n)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)

h=math.ceil(math.log2(n))
fa=[[-1]*(h+1) for _ in range(n)];dep=[0]*n
q=deque([0])
while q:
  u=q.popleft()
  for v in g[u]:
      if {{completion}}fa[v][0]=u;dep[v]=dep[u]+1;q.append(v)
for i in range(1,h+1):
  for u in range(n):
    fa[u][i]=fa[fa[u][i-1]][i-1]
def lca(u,v):
  if dep[u]<dep[v]:u,v=v,u
  for i in range(h,-1,-1):
    if dep[v]+(1<<i)<=dep[u]:u=fa[u][i]
  if u==v:return u
  for i in range(h,-1,-1):
    if fa[u][i]!=fa[v][i]:u=fa[u][i];v=fa[v][i]
  return fa[u][0]

for _ in [0]*int(I()):
  k=int(I());p=[*R()];z='YES'
  if k<=2:print(z);continue
  p.sort(key=lambda u:dep[u])
  u=p.pop();v=p.pop();f=lca(u,v)
  while p and f==v:u=v;v=p.pop();f=lca(u,v)
  for x in p:
    if dep[x]<=dep[f] and x!=f or lca(u,x)!=x and lca(v,x)!=x:
      z='NO';break
  print(z)",v!=fa[u][0]:,dep[v]+(1<<i)<=dep[u]:
"from collections import deque;import math
import sys;I=sys.stdin.readline;R=lambda:map(lambda x:int(x)-1,input().split())
n=int(I());g=[[] for _ in range(n)]
for _ in [0]*(n-1):
  u,v=R();g[u].append(v);g[v].append(u)

h=math.ceil(math.log2(n))
fa=[[-1]*(h+1) for _ in range(n)];dep=[0]*n
q=deque([0])
while q:
  u=q.popleft()
  for v in g[u]:
      if v!=fa[u][0]:fa[v][0]=u;dep[v]=dep[u]+1;q.append(v)
for i in range(1,h+1):
  for u in range(n):
    fa[u][i]=fa[fa[u][i-1]][i-1]
def lca(u,v):
  if dep[u]<dep[v]:u,v=v,u
  for i in range(h,-1,-1):
    if {{completion}}u=fa[u][i]
  if u==v:return u
  for i in range(h,-1,-1):
    if fa[u][i]!=fa[v][i]:u=fa[u][i];v=fa[v][i]
  return fa[u][0]

for _ in [0]*int(I()):
  k=int(I());p=[*R()];z='YES'
  if k<=2:print(z);continue
  p.sort(key=lambda u:dep[u])
  u=p.pop();v=p.pop();f=lca(u,v)
  while p and f==v:u=v;v=p.pop();f=lca(u,v)
  for x in p:
    if dep[x]<=dep[f] and x!=f or lca(u,x)!=x and lca(v,x)!=x:
      z='NO';break
  print(z)",dep[v]+(1<<i)<=dep[u]:,u=fa[u][i]
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def dfs(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl = s.pop()

        level[p] = lvl
        parent[p][0] = prev
        for i in child[p]:
            if(i == prev):continue

            s.append([i , p , lvl + 1])

def lca(u,v):

    if(level[u] > level[v]):u,v=v,u

    dist=level[v] - level[u]
    for i in range(20,-1,-1):
        if(dist >> i & 1):
            v=parent[v][i]

    if(u==v):return u
    for i in range(20,-1,-1):
        if(parent[u][i] != parent[v][i]):
            u=parent[u][i]
            v=parent[v][i]

    return parent[u][0]

for T in range(1):

    n = int(input())
    child = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u , v = inp()
        child[u].append(v)
        child[v].append(u)


    level = [0 for i in range(n + 1)]
    parent=[[-1 for i in range(21)] for j in range(n + 1)]
    dfs(1 , -1 , 1)

    for j in range(1 , 21):
        for i in range(1 , n + 1):
            if(parent[i][j - 1] == -1):continue
            
            parent[i][j] = parent[parent[i][j - 1]][j - 1]


    for q in range(int(input())):

        x = int(input())
        a = inp()

        maxval = 0
        for i in range(x):
            if(maxval < level[a[i]]):
                maxval = level[a[i]]
                left = a[i]


        maxval = 0
        for i in range(x):
            if(lca(a[i] , left) != a[i]):

                if{{completion}}
                    maxval = level[a[i]]
                    right = a[i]

        if(maxval == 0):
            print('YES')
            continue


        ok = True
        Lca = lca(left , right)
        for i in range(x):
            if(a[i] == Lca):continue
            
            if(lca(Lca , a[i]) == a[i]):
                ok = False
                break

            if(lca(a[i] , left) != a[i] and lca(a[i] , right) != a[i]):
                ok = False
                break

        if(ok):print('YES')
        else:print('NO')

            
            
",(maxval < level[a[i]]):,v[j]==0:
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def dfs(p , prev , lvl):

    s = [[p , prev , lvl]]

    while(len(s)):

        p , prev , lvl = s.pop()

        level[p] = lvl
        parent[p][0] = prev
        for i in child[p]:
            if{{completion}}continue

            s.append([i , p , lvl + 1])

def lca(u,v):

    if(level[u] > level[v]):u,v=v,u

    dist=level[v] - level[u]
    for i in range(20,-1,-1):
        if(dist >> i & 1):
            v=parent[v][i]

    if(u==v):return u
    for i in range(20,-1,-1):
        if(parent[u][i] != parent[v][i]):
            u=parent[u][i]
            v=parent[v][i]

    return parent[u][0]

for T in range(1):

    n = int(input())
    child = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u , v = inp()
        child[u].append(v)
        child[v].append(u)


    level = [0 for i in range(n + 1)]
    parent=[[-1 for i in range(21)] for j in range(n + 1)]
    dfs(1 , -1 , 1)

    for j in range(1 , 21):
        for i in range(1 , n + 1):
            if(parent[i][j - 1] == -1):continue
            
            parent[i][j] = parent[parent[i][j - 1]][j - 1]


    for q in range(int(input())):

        x = int(input())
        a = inp()

        maxval = 0
        for i in range(x):
            if(maxval < level[a[i]]):
                maxval = level[a[i]]
                left = a[i]


        maxval = 0
        for i in range(x):
            if(lca(a[i] , left) != a[i]):

                if(maxval < level[a[i]]):
                    maxval = level[a[i]]
                    right = a[i]

        if(maxval == 0):
            print('YES')
            continue


        ok = True
        Lca = lca(left , right)
        for i in range(x):
            if(a[i] == Lca):continue
            
            if(lca(Lca , a[i]) == a[i]):
                ok = False
                break

            if(lca(a[i] , left) != a[i] and lca(a[i] , right) != a[i]):
                ok = False
                break

        if(ok):print('YES')
        else:print('NO')

            
            
",(i == prev):,(maxval < level[a[i]]):
"import sys


class LCA:
    def __init__(self, g, root=0):
        self.g = g
        self.root = root
        n = len(g)
        self.logn = (n - 1).bit_length()
        self.depth = [None] * n
        self.parent = [[None] * self.logn for _ in range(n)]
        self._dfs()
        self._doubling()

    def _dfs(self):
        self.depth[self.root] = 0
        stack = [self.root]
        while stack:
            u = stack.pop()
            for v in self.g[u]:
                if {{completion}}
                    self.depth[v] = self.depth[u] + 1
                    self.parent[v][0] = u
                    stack.append(v)

    def _doubling(self):
        for i in range(self.logn - 1):
            for p in self.parent:
                if p[i] is not None:
                    p[i + 1] = self.parent[p[i]][i]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        d = self.depth[v] - self.depth[u]
        for i in range(d.bit_length()):
            if d >> i & 1:
                v = self.parent[v][i]
        if u == v:
            return u
        for i in reversed(range(self.logn)):
            if (pu := self.parent[u][i]) != (pv := self.parent[v][i]):
                u, v = pu, pv
        return self.parent[u][i]


def query(lca):
    k = int(sys.stdin.readline())
    p = sorted(
        (int(x) - 1 for x in sys.stdin.readline().split()),
        key=lca.depth.__getitem__,
        reverse=True,
    )
    branch = []
    top = p[0]
    for x in p[1:]:
        if lca.lca(top, x) == x:
            top = x
        else:
            branch.append(x)
    if not branch:
        return True
    if lca.lca(branch[0], p[0]) != lca.lca(branch[0], top):
        return False
    for i in range(1, len(branch)):
        if lca.lca(branch[i - 1], branch[i]) != branch[i]:
            return False
    return True


n = int(input())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = (int(x) - 1 for x in sys.stdin.readline().split())
    g[u].append(v)
    g[v].append(u)
lca = LCA(g)
for _ in range(int(input())):
    print(""YES"" if query(lca) else ""NO"")
",self.depth[v] is None:,p[i] is not None:
"import sys


class LCA:
    def __init__(self, g, root=0):
        self.g = g
        self.root = root
        n = len(g)
        self.logn = (n - 1).bit_length()
        self.depth = [None] * n
        self.parent = [[None] * self.logn for _ in range(n)]
        self._dfs()
        self._doubling()

    def _dfs(self):
        self.depth[self.root] = 0
        stack = [self.root]
        while stack:
            u = stack.pop()
            for v in self.g[u]:
                if self.depth[v] is None:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[v][0] = u
                    stack.append(v)

    def _doubling(self):
        for i in range(self.logn - 1):
            for p in self.parent:
                if {{completion}}
                    p[i + 1] = self.parent[p[i]][i]

    def lca(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        d = self.depth[v] - self.depth[u]
        for i in range(d.bit_length()):
            if d >> i & 1:
                v = self.parent[v][i]
        if u == v:
            return u
        for i in reversed(range(self.logn)):
            if (pu := self.parent[u][i]) != (pv := self.parent[v][i]):
                u, v = pu, pv
        return self.parent[u][i]


def query(lca):
    k = int(sys.stdin.readline())
    p = sorted(
        (int(x) - 1 for x in sys.stdin.readline().split()),
        key=lca.depth.__getitem__,
        reverse=True,
    )
    branch = []
    top = p[0]
    for x in p[1:]:
        if lca.lca(top, x) == x:
            top = x
        else:
            branch.append(x)
    if not branch:
        return True
    if lca.lca(branch[0], p[0]) != lca.lca(branch[0], top):
        return False
    for i in range(1, len(branch)):
        if lca.lca(branch[i - 1], branch[i]) != branch[i]:
            return False
    return True


n = int(input())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = (int(x) - 1 for x in sys.stdin.readline().split())
    g[u].append(v)
    g[v].append(u)
lca = LCA(g)
for _ in range(int(input())):
    print(""YES"" if query(lca) else ""NO"")
",p[i] is not None:,self.depth[v] is None:
"from collections import Counter
for _ in range(int(input())):
    n=int(input());
    l=list(map(int, input().split()));c = Counter(l);
    if {{completion}}
        print(-1); continue
    print(*[i if i!=0 and l[i]==l[i-1] else i+c[l[i]] for i in range(n)])",any(x == 1 for x in c.values()):,c[l[i]]>1:
"import collections
import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())
    data = dict(collections.Counter(map(int, input().split())))

    if min(list(data.values())) > 1:
        last = 1
        for i in data.keys():
            print(last + data[i] - 1, end=' ')
            for {{completion}}
                print(j, end=' ')
            last = last + data[i]
        print()
    else:
        print(-1)
","j in range(last, last + data[i] - 1):","this is the start of the ground truth
for i in range(1, n):
    if data[i] > 1:
        print(-1)
        break
    else:
        for j in range(i + 1, n + 1):
            if j not in data:
                print(-1)
                break
            elif data[j] > 1:
                print(-1)
                break
        else:
            for j in range(1, n + 1):
                if"
"for t in range(int(input())):
    n=int(input())
    x=list(map(int,input().split()))
    g={}
    if n==1:
        print(-1)
    else:


        for i in range(n-1):
            if not((x[i]==x[i+1] or x[i]==x[i-1]) and ( x[-1]==x[-2])):
                print(-1)
                break
            g[x[i]]=[]


        else:
            for i in range(n):
                g[x[i]].append(i+1)
            for i,j in g.items():
                for {{completion}}
                    print(j[q-1],end=' ')
            print()
            
        
        ",q in range(len(j)):,i==0 or i==n-1:
"t = int(input())
for i in range(t):
    n = int(input())
    s = [int(x) for x in input().split(' ')]
    s.append('A')
    f = 0
    p = s[0]
    c = 0
    for x in range(n+1):
        if s[x] == p:
            s[x] = str(x)
            c+=1
        else:
            if {{completion}}
                s = -1
                break
            else:
                s[f] = str(x)
                f = x
                p = s[x]
                c = 1
    if s != -1:
        s.pop()
        print(' '.join(s))
    else:
        print(s)
",c == 1:,c == 1:
"import sys
input=sys.stdin.readline
for _ in range(int(input())):
    n=int(input())
    x=tuple(map(int,input().split()))
    if n==1:
        print(-1)
        continue
    ans=[-1]*n
    extra=[]
    visited=[False]*n
    for i in range(n-1,-1,-1):
        if i!=0 and x[i]==x[i-1]:
            ans[i]=i
            visited[i-1]=True
            if not visited[i]:
                extra.append(i+1)
        else:
            if {{completion}}
                ans[i]=extra.pop()
            else:
                print(-1)
                break
    else:
        print(*ans)
",extra:,i==0 or x[i]!=x[i-1]:
"from sys import stdin
input = stdin.readline

I = lambda : list(map(int, input().split()))

def solve(N,A):
    dic = {}
    
    for i in range(N):
        if {{completion}}
            dic[A[i]] = []
        dic[A[i]].append(i)

    ans = [0]*N
    for k in dic.keys():
        l = dic[k]
        if len(l) == 1:
            return [-1]
        for i in range(len(l)):
            ans[l[i]] = l[(i-1)%len(l)] + 1
    return ans
    
T = int(input())

for _ in range(T):
    N = int(input())
    A = I()
    print(*solve(N,A))",A[i] not in dic:,len(l) == 1:
"from sys import stdin
input = stdin.readline

I = lambda : list(map(int, input().split()))

def solve(N,A):
    dic = {}
    
    for i in range(N):
        if A[i] not in dic:
            dic[A[i]] = []
        dic[A[i]].append(i)

    ans = [0]*N
    for k in dic.keys():
        l = dic[k]
        if {{completion}}
            return [-1]
        for i in range(len(l)):
            ans[l[i]] = l[(i-1)%len(l)] + 1
    return ans
    
T = int(input())

for _ in range(T):
    N = int(input())
    A = I()
    print(*solve(N,A))",len(l) == 1:,len(l)==1:
"for _ in range(int(input())):
    n = int(input())
    arr = list(map(int,input().split()))
    freq = {}
    for i in arr:
        if(i in freq): freq[i] += 1
        else: freq[i] = 1
    for i in freq:
        if(freq[i] == 1): #not in pairs
            print(-1);break
    else:
        ans2 = []
        for i in freq:
            res = []
            res.append(freq[i]+len(ans2))
            for {{completion}}
                res.append(j+len(ans2))
            ans2.extend(res)
        print(*ans2)","j in range(1,freq[i]):",j == i:
"from bisect import bisect_left

cases = int(input())
for run in range(cases):
    n = int(input())
    shoes = input().split()
    for x in range(len(shoes)):
        shoes[x] = int(shoes[x])
    
    perm = []
    i = 0

    while i < len(shoes) and perm != [-1]:
        p = bisect_left(shoes,shoes[i]+1)-1
        if {{completion}}
            perm = [-1]
        else:
            perm.append(p+1)
            perm += list(range(i+1,p+1))
            i = p+1
            
    print("" "".join([str(int) for int in perm]))
                
                
            
",p == i:,p == len(shoes)-1:
"import sys
sys.setrecursionlimit(300000)

import faulthandler
faulthandler.enable()

n, k = map(int, input().split())
MOD = 10**9 + 7

fact = [1 for i in range(n+1)]
for i in range(2, n+1):
	fact[i] = i*fact[i-1] % MOD

inv_fact = [1 for i in range(n+1)]
inv_fact[-1] = pow(fact[-1], MOD-2, MOD)
for i in range(1, n):
	inv_fact[n-i] = (n-i+1)*inv_fact[n-i+1] % MOD

def comb(a, b):
	if a < b:
		return 0
	return fact[a]*inv_fact[b]*inv_fact[a-b] % MOD

edges = [[] for i in range(n)]
for _ in range(n-1):
	x, y = map(lambda a: int(a)-1, input().split())
	edges[x].append(y)
	edges[y].append(x)

ends = [[] for i in range(n)]

visited = [0 for i in range(n)]
totals = [1 for i in range(n)]
dfs_stack = [0]

while len(dfs_stack) > 0:
	node = dfs_stack[-1]

	if visited[node] == 1:
		visited[node] = 2

		for next_node in edges[node]:
			if visited[next_node] == 2:
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])

		ends[node].append(n-totals[node])
		dfs_stack.pop()
	else:
		visited[node] = 1

		for next_node in edges[node]:
			if {{completion}}
				dfs_stack.append(next_node)

z = n*n * comb(n, k) % MOD
node_v = [0 for i in range(n)]

for i in range(n):
	node_v[i] = sum(comb(e, k) for e in ends[i]) % MOD

	for e in ends[i]:
		z = (z - e*e * (comb(n-e, k) + comb(e, k) - node_v[i])) % MOD

print(z)",visited[next_node] == 0:,visited[next_node] == 2:
"import sys
sys.setrecursionlimit(300000)

import faulthandler
faulthandler.enable()

n, k = map(int, input().split())
MOD = 10**9 + 7

fact = [1 for i in range(n+1)]
for i in range(2, n+1):
	fact[i] = i*fact[i-1] % MOD

inv_fact = [1 for i in range(n+1)]
inv_fact[-1] = pow(fact[-1], MOD-2, MOD)
for i in range(1, n):
	inv_fact[n-i] = (n-i+1)*inv_fact[n-i+1] % MOD

def comb(a, b):
	if a < b:
		return 0
	return fact[a]*inv_fact[b]*inv_fact[a-b] % MOD

edges = [[] for i in range(n)]
for _ in range(n-1):
	x, y = map(lambda a: int(a)-1, input().split())
	edges[x].append(y)
	edges[y].append(x)

ends = [[] for i in range(n)]

visited = [0 for i in range(n)]
totals = [1 for i in range(n)]
dfs_stack = [0]

while len(dfs_stack) > 0:
	node = dfs_stack[-1]

	if visited[node] == 1:
		visited[node] = 2

		for next_node in edges[node]:
			if {{completion}}
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])

		ends[node].append(n-totals[node])
		dfs_stack.pop()
	else:
		visited[node] = 1

		for next_node in edges[node]:
			if visited[next_node] == 0:
				dfs_stack.append(next_node)

z = n*n * comb(n, k) % MOD
node_v = [0 for i in range(n)]

for i in range(n):
	node_v[i] = sum(comb(e, k) for e in ends[i]) % MOD

	for e in ends[i]:
		z = (z - e*e * (comb(n-e, k) + comb(e, k) - node_v[i])) % MOD

print(z)",visited[next_node] == 2:,visited[next_node] == 2:
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 10 ** 9 + 7

n, k = I()

binomk = [0] * k
binomk.append(1)
for i in range(k + 1, n + 1):
	binomk.append(binomk[-1] * i * pow(i - k, M - 2, M) % M)
neighbors = [[] for i in range(n)]
for i in range(n - 1):
	a, b = I()
	a -= 1
	b -= 1
	neighbors[a].append(b)
	neighbors[b].append(a)
parents = [None] + [-1] * (n - 1)
children = [[] for i in range(n)]
layer = [0]
while layer:
	newlayer = []
	for guy in layer:
		for boi in neighbors[guy]:
			if {{completion}}
				children[guy].append(boi)
				parents[boi] = guy
				newlayer.append(boi)
	layer = newlayer
size = [0] * n
q = []
for i in range(n):
	if len(children[i]) == 0:
		q.append(i)
qind = 0
left = [len(children[i]) for i in range(n)]
while qind < len(q):
	v = q[qind]
	tot = 1
	for guy in children[v]:
		tot += size[guy]
	size[v] = tot
	if parents[v] is None:
		break
	left[parents[v]] -= 1
	if left[parents[v]] == 0:
		q.append(parents[v])
	qind += 1

answer = 0
for i in range(n):
	things = []
	for guy in children[i]:
		things.append(size[guy])
	if i != 0:
		things.append(n - 1 - sum(things))
	bins = [binomk[i] for i in things]
	ss = sum(bins) % M
	for guy in things:
		answer = (answer + (n - guy) * guy * binomk[n - guy]) % M
		answer = (answer - (n - guy) * guy * (ss - binomk[guy])) % M
	answer = (answer + n * binomk[n]) % M
	answer = (answer - ss * n) % M
print(answer)
",boi != parents[guy]:,boi in neighbors[guy]:
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 10 ** 9 + 7

n, k = I()

binomk = [0] * k
binomk.append(1)
for i in range(k + 1, n + 1):
	binomk.append(binomk[-1] * i * pow(i - k, M - 2, M) % M)
neighbors = [[] for i in range(n)]
for i in range(n - 1):
	a, b = I()
	a -= 1
	b -= 1
	neighbors[a].append(b)
	neighbors[b].append(a)
parents = [None] + [-1] * (n - 1)
children = [[] for i in range(n)]
layer = [0]
while layer:
	newlayer = []
	for guy in layer:
		for {{completion}}
			if boi != parents[guy]:
				children[guy].append(boi)
				parents[boi] = guy
				newlayer.append(boi)
	layer = newlayer
size = [0] * n
q = []
for i in range(n):
	if len(children[i]) == 0:
		q.append(i)
qind = 0
left = [len(children[i]) for i in range(n)]
while qind < len(q):
	v = q[qind]
	tot = 1
	for guy in children[v]:
		tot += size[guy]
	size[v] = tot
	if parents[v] is None:
		break
	left[parents[v]] -= 1
	if left[parents[v]] == 0:
		q.append(parents[v])
	qind += 1

answer = 0
for i in range(n):
	things = []
	for guy in children[i]:
		things.append(size[guy])
	if i != 0:
		things.append(n - 1 - sum(things))
	bins = [binomk[i] for i in things]
	ss = sum(bins) % M
	for guy in things:
		answer = (answer + (n - guy) * guy * binomk[n - guy]) % M
		answer = (answer - (n - guy) * guy * (ss - binomk[guy])) % M
	answer = (answer + n * binomk[n]) % M
	answer = (answer - ss * n) % M
print(answer)
",boi in neighbors[guy]:,boi!= parents[guy]:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    if N % 2 == 0:
        a1 = [A[i] for i in range(0, N, 2)]
        a2 = [A[i] for i in range(1, N, 2)]

        i1, i2 = a1.index(min(a1)), a2.index(min(a2))
        m1 = min(a1) * len(a1) + i1
        m2 = min(a2) * len(a2) + i2

        print(""Mike"" if m1 > m2 else ""Joe"")
    else:
        print(""Mike"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for {{completion}}
        solve(tc + 1)
    assert not tokens",tc in range(testcaseCount):,i == 0:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if {{completion}} continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i == 0 and j == 0:,i == 0 and j == 0:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if {{completion}} B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i:,i:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for _ in range(N)]

    if N < M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if {{completion}} continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i == 0 and j == 0:,i == 0 and j == 0:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for _ in range(N)]

    if N < M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if {{completion}} B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i:,i == 0 and j == 0:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    if N > M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if {{completion}} continue
            if i: B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i == 0 and j == 0:,i == 0 and j == 0:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    if N > M:
        A = [list(i) for i in zip(*A)]
        N, M = M, N

    def get(sum):
        return sum + N + M

    B = [[0] * M for i in range(N)]
    B[0][0] |= 1 << get(A[0][0])

    for i in range(N):
        for j in range(M):
            if i == 0 and j == 0: continue
            if {{completion}} B[i][j] |= B[i - 1][j]
            if j: B[i][j] |= B[i][j - 1]
            if A[i][j] > 0: B[i][j] <<= 1
            else: B[i][j] >>= 1
        if i: B[i - 1] = None

    print(""YES"" if B[-1][-1] & (1 << get(0)) else ""NO"")

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i:,i == 0 and j == 0:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, M = nextInt(), nextInt()
    A = [getIntArray(M) for i in range(N)]

    X = Y = 0
    for i in range(N):
        for j in range(M):
            if {{completion}}
                X, Y = i, j

    height = max(N - X, X + 1)
    width = max(M - Y, Y + 1)
    print(height * width)

    pass


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",A[i][j] > A[X][Y]:,i == 0 and j == 0:
"import sys


def _input_iter():
    for line in sys.stdin:
        for part in line.strip().split(' '):
            stripped = part.strip()
            if {{completion}}
                yield stripped


def read_int():
    return int(next(stream))


def read_str():
    return next(stream)


def get_ans(a, b):
    if len(a) < len(b):
        return False
    if len(a) == len(b):
        return a == b

    if len(b) == 1:
        return b in a

    if a[-len(b) + 1:] != b[1:]:
        return False

    return b[0] in a[:len(a) - len(b) + 1]


def run():
    read_int(), read_int()
    a, b = read_str(), read_str()
    print('YES' if get_ans(a, b) else 'NO')


stream = _input_iter()


def main():
    t = read_int()
    for _ in range(t):
        run()


if __name__ == '__main__':
    main()
",stripped:,a[-len(b) + 1:]!= b[1:]:
"R=lambda:map(int,input().split());G=range;t,=R()
for {{completion}}
  n,m=R();s=[sum(i*v for i,v in enumerate(R()))for _ in G(n)]
  mx=max(s);print(s.index(mx)+1,mx-min(s))",_ in G(t):,"mx, mn = max(s), min(s)"
"for _ in range(int(input())):
	n, m = map(int, input().split())

	vals = []
	for _ in range(n):
		count = 0
		for {{completion}}
			count += a*b
		vals.append(count)


	c = vals.index(max(vals))
	print(c + 1, vals[c] - vals[c-1])","a, b in enumerate(map(int, input().split())):",a>b:
"case=int(input())
for i in range(case):
  n,m = (int(v) for v in input().split())
  tmp=0
  for j in range(n):
    list1 = [int(v) for v in input().split()]
    value = 0
    for k in range(m):
      value += list1[k]*(k+1)
    if j==0:
      tmp = value
    else:
      if value > tmp:
        print(str(j+1)+"" ""+str(value-tmp))
      elif {{completion}}
        print(""1 ""+str(tmp-value))
        tmp = value
      else:
        pass",value < tmp:,"if tmp > value:
  print(""1 ""+str(tmp-value))
elif tmp < value:
  print(str(j+1)+"" ""+str(value-tmp))
else:
  pass"
"input = __import__('sys').stdin.readline


def solve():
    n, m = map(int, input().split())

    mx = (0, -1)
    mn = (10**18, -1)
    for i in range(n):
        current, total = 0, 0
        for {{completion}}
            current += x
            total += current
        
        mx = max(mx, (total, i))
        mn = min(mn, (total, i))
    
    print(mn[1]+1, mx[0] - mn[0])


for _ in range(int(input())):
    solve()","x in map(int, input().split()):",a>b[mm]:
"import sys 
input= sys.stdin.readline

rn=lambda: [*map(int,input().split())]

for _ in range(*rn()):
    n,m=rn()
    b=[]
    mm=0
    for i in range(0,n):
        a=sum([*map(lambda x,y:int(x)*y,input().split(),range(1,m+1))])
        b.append(a)
        if {{completion}}
            mm=i
    print(mm+1,b[mm]-b[mm-1])",a>b[mm]:,b[mm]-b[mm-1]
"for t in range(int(input())):
    N, M = map(int, input().split())
    minV = int(1e20)
    maxV = -1
    ret = 0
    for index in range(N):
        mlist = list(map(int, input().split()))
        cur = sum([index*val for index, val in enumerate(mlist)])
        
        minV = min(minV, cur)
        if {{completion}}
            ret = index+1
        maxV = max(maxV, cur)
    print(f""{ret} {maxV-minV}"")",maxV < cur:,if index == ret:
"import sys
input = sys.stdin.readline
s = input().strip()
l = len(s)
d, p = [], [0]
d.append([1 if s[0] == chr(x+97)  else 0 for x in range(26)])
for idx, i in enumerate(s):
    if {{completion}} continue
    x = ord(i) - 97
    d.append(d[p[idx-1]][:])
    d[idx][x] = idx+1
    p.append(d[p[idx-1]][x])
for i in range(10): p.append(0); d.append([])
for i in range(int(input())):
    for idx, t in enumerate(input().strip()):
        x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]
    print(*p[l:l+idx+1])",idx == 0:,"idx, t in enumerate(input().strip()):"
"import sys
input = sys.stdin.readline
s = input().strip()
l = len(s)
d, p = [], [0]
d.append([1 if s[0] == chr(x+97)  else 0 for x in range(26)])
for idx, i in enumerate(s):
    if idx == 0: continue
    x = ord(i) - 97
    d.append(d[p[idx-1]][:])
    d[idx][x] = idx+1
    p.append(d[p[idx-1]][x])
for i in range(10): p.append(0); d.append([])
for i in range(int(input())):
    for {{completion}}
        x, pos = ord(t) - 97, idx+l
        d[pos] = d[p[pos-1]][:]
        d[pos][x] = pos+1
        p[pos] = d[p[pos-1]][x]
    print(*p[l:l+idx+1])","idx, t in enumerate(input().strip()):",idx == 0:
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif {{completion}}
            print(2)
        elif l == 2:
            print(1)
        elif l == 1:
            print(0)
        pos += 2
",l == 3:,l == 2:
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        a1, a2 = input_arr[pos:pos + 2]
        char = []
        for i in a1:
            char.append(i)
        for j in a2:
            char.append(j)
        l = len(set(char))
        if l == 4:
            print(3)
        elif l == 3:
            print(2)
        elif {{completion}}
            print(1)
        elif l == 1:
            print(0)
        pos += 2
",l == 2:,l == 2:
"import sys

from itertools import permutations, combinations

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

    
def solve(n, a, b):
    ps = [((list(range(n))), (list(range(n))))]
    res = (1<<30) - 1

    for k in range(30, -1, -1):
        next_ps = []
        for (pa, pb) in ps:

            a0, a1, b0, b1 = [], [], [], []
            for pai in pa:
                if {{completion}} a0.append(pai) 
                else: a1.append(pai)
            for pbi in pb:
                if b[pbi] & (1<<k) == 0: b0.append(pbi) 
                else: b1.append(pbi)

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))

        ps = next_ps if int(res & (1<<k)) != 0 else ps       

    return res
    #return rec(a, b, max_order-1)


for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    print(solve(n, a, b))
",a[pai] & (1<<k) == 0:,a[pai] & (1<<k) == 0:
"import sys

from itertools import permutations, combinations

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

    
def solve(n, a, b):
    ps = [((list(range(n))), (list(range(n))))]
    res = (1<<30) - 1

    for k in range(30, -1, -1):
        next_ps = []
        for (pa, pb) in ps:

            a0, a1, b0, b1 = [], [], [], []
            for pai in pa:
                if a[pai] & (1<<k) == 0: a0.append(pai) 
                else: a1.append(pai)
            for pbi in pb:
                if {{completion}} b0.append(pbi) 
                else: b1.append(pbi)

            if len(a0) == len(b1):   
                res = res & (res | (1 << k))               
                if len(a0) > 0 and len(b1) > 0: next_ps.append((a0, b1))
                if len(a1) > 0 and len(b0) > 0: next_ps.append((a1, b0))
            else:
                res = res & ~(1 << k)
                next_ps.append((pa, pb))

        ps = next_ps if int(res & (1<<k)) != 0 else ps       

    return res
    #return rec(a, b, max_order-1)


for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    print(solve(n, a, b))
",b[pbi] & (1<<k) == 0:,a[pai] & (1<<k) == 0:
"import sys
from math import ceil

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def at_least(L, x):
    for i in range(len(L)):
        if L[i] >= x:
            return i
    return len(L)-1

def at_most(L, x):
    for i in range(len(L)-1, -1, -1):
        if L[i] <= x:
            return i
    return 0

def solve(n, a, b):
    dmin, dmax = [-1]*n, [-1]*n
    imin, imax = 0, n-1
    for i in range(n):
        
        while b[imin] < a[i]:
            imin += 1

        dmin[i] = b[imin] - a[i]
        dmax[n-1-i] = b[imax] - a[n-1-i]
        
        if i < n-1:
            if {{completion}}
                imax = n-i-2

    return dmin, dmax

for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    dmin, dmax = solve(n, a, b)
    print(*dmin)
    print(*dmax)",b[n-i-2] < a[n-i-1]:,b[imin] < a[i]:
"import sys
from math import ceil

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def at_least(L, x):
    for i in range(len(L)):
        if L[i] >= x:
            return i
    return len(L)-1

def at_most(L, x):
    for i in range(len(L)-1, -1, -1):
        if L[i] <= x:
            return i
    return 0

def solve(n, a, b):
    dmin, dmax = [-1]*n, [-1]*n
    imin, imax = 0, n-1
    for i in range(n):
        
        while {{completion}}
            imin += 1

        dmin[i] = b[imin] - a[i]
        dmax[n-1-i] = b[imax] - a[n-1-i]
        
        if i < n-1:
            if b[n-i-2] < a[n-i-1]:
                imax = n-i-2

    return dmin, dmax

for i in range(1, len(ls)-1, 3):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    b = [int(x) for x in ls[i+2].split(' ')]
    dmin, dmax = solve(n, a, b)
    print(*dmin)
    print(*dmax)",b[imin] < a[i]:,b[n-i-2] < a[n-i-1]:
"import sys

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if {{completion}}
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def ins(u, mn, mx):
    return u[0] >= mn[0] and u[1] >= mn[1] and u[0] <= mx[0] and u[1] <= mx[1]

def clmp(x, n):
    if x < 0: return 0
    if x >= n: return n-1
    return x

def clp(u, n, m):
    return (clmp(u[0], n), clmp(u[1], m)) 

def d(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def solve(n, m, sx, sy, d):
    if d ==0: return n+m-2
    smin = clp((sx-d, sy-d), n, m)
    smax = clp((sx+d, sy+d), n, m)
    if abs(smax[0]-smin[0]) >= n-1 or abs(smax[1]-smin[1]) >= m-1: return -1
    if ins((0, 0), smin, smax) or ins((n-1, m-1), smin, smax) : return -1
    return n+m-2

for l in ls[1:]:
    n, m, sx, sy, d = [int(x) for x in l.split(' ')]
    print(solve(n, m, sx-1, sy-1, d))",len(lst) > 0:,r & 1:
"_,(*a,),*r=(map(int,s.split())for s in open(0))
b=[[0],[0]]
for x in b:
 for {{completion}}x+=x[-1]+max(0,u-v),
 max=min
for s,t in r:l=b[s>t];print(l[t]-l[s])","u,v in zip([0]+a,a):","u,v in zip([0]+a,a):"
"n,m=map(int,input().split())
c=[int(i) for i in input().split()]
f=[0]*n
g=[0]*n
for i in range(1,n):
	f[i]=f[i-1]+max(0,c[i-1]-c[i])
	g[-i-1]=g[-i]+max(0,c[-i]-c[-i-1])
for i in range(m):
	x,y=map(int,input().split())
	if {{completion}}
		print(f[y-1]-f[x-1])
	else:
		print(g[y-1]-g[x-1])",x<y:,x<y:
"R=lambda:map(int,input().split())
n,m=R()
*a,=R()
b=[[0],[0]]
f=max
for x in b:
 for {{completion}}x+=x[-1]+f(0,u-v),
 f=min
for _ in[0]*m:s,t=R();l=b[s>t];print(l[t]-l[s])","u,v in zip([0]+a,a):","u,v in zip([0]+a,a):"
"n,m=map(int,input().split())
world=['x']+list(map(int,input().split()))
L1=[0]
L2=[0]
for i in range(1,n):
    L1.append(L1[i-1]+max(world[i]-world[i+1],0))
    L2.append(L2[i-1]+max(world[i+1]-world[i],0))
for i in range(m):
    s,t=map(int,input().split())
    if {{completion}}
        print(L1[t-1]-L1[s-1])
    else:
        print(L2[s-1]-L2[t-1])",s<t:,"i in range(1,n):"
"n,m=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
ltr,rtl=[0],[0]
for i in range(1,n):
    ltr.append(max(0,a[i-1]-a[i])+ltr[-1])
    rtl.append(max(0,a[i]-a[i-1])+rtl[-1])
for i in range(m):
    s,t=[int(x) for x in input().split()]
    if {{completion}}
        print(ltr[t-1]-ltr[s-1])
    else:
        print(rtl[s-1]-rtl[t-1])
        ",s<=t:,"i in range(1,n):"
"(n,m),(*a,),*r=(map(int,s.split())for s in open(0))
b=[[0],[0]]
for x in b:
 for {{completion}}x+=x[-1]+max(0,u-v),
 max=min
for s,t in r:l=b[s>t];print(l[t]-l[s])","u,v in zip([0]+a,a):","u,v in zip([0]+a,a):"
"n, m = map(int, input().split())
a = list(map(int, input().split()))
inc = [0]
dec = [0]
for i in range(n-1):
    inc.append(inc[i] + max(0, a[i]-a[i+1]))
    dec.append(dec[i] + max(0, a[i+1] - a[i]))
    
for i in range(m):
    x, y = map(int, input().split())
    #print(x, y)
    #ans = 0
    if {{completion}}
        ans = inc[y-1] - inc[x-1]
    else:
        ans = dec[x-1] - dec[y-1]
    print(ans)
",x < y:,i in range(n-1):
"R=lambda:map(int,input().split())
n,m=R()
*a,=R()
b=[[0],[0]]
for x in b:
 for {{completion}}x+=x[-1]+max(0,u-v),
 a=a[::-1]
b[1]=[0]+b[1][::-1]
for _ in[0]*m:s,t=R();l=b[s>t];print(abs(l[s]-l[t]))","u,v in zip([0]+a,a):","u,v in zip([0]+a,a):"
"n, m = map(int, input().split());a = list(map(int, input().split()));l = [0] + [max(0, a[i] - a[i + 1]) for i in range(n - 1)];r = [0] + [max(0, a[i] - a[i - 1]) for i in range(1, n)]
for {{completion}} l[i + 1] += l[i];r[i + 1] += r[i]
for _ in range(m): s, t = map(int, input().split());print(l[t - 1] - l[s - 1]) if(s < t) else print(r[s - 1] - r[t - 1])",i in range(n - 1):,"l[i + 1] += l[i];r[i + 1] += r[i]
for _ in range(m):"
"n, m = map(int, input().split());a = list(map(int, input().split()));l = [0] + [max(0, a[i] - a[i + 1]) for i in range(n - 1)];r = [0] + [max(0, a[i] - a[i - 1]) for i in range(1, n)]
for i in range(n - 1): l[i + 1] += l[i];r[i + 1] += r[i]
for {{completion}} s, t = map(int, input().split());print(l[t - 1] - l[s - 1]) if(s < t) else print(r[s - 1] - r[t - 1])",_ in range(m):,_ in range(m):
"n,m=(map(int,input().split()))
l=list(map(int,input().split()))

f=[0]*n
b=[0]*n
d=0
for j in range(1,n):
    d=d+max(0,l[j-1]-l[j])
    f[j]=d
l=l[::-1]
d=0
for k in range(1,n):
    d=d+max(0,l[k-1]-l[k])
    b[k]=d
b=b[::-1]
for i in range(m):
    s,t=(map(int,input().split()))
    if {{completion}}
        print(f[t-1]-f[s-1])
    else:
        print(b[t-1]-b[s-1])",s<t:,"i in range(1,n):"
"import sys, collections, math, itertools
input = lambda: sys.stdin.readline().strip()
ints = lambda: list(map(int, input().split()))
Int = lambda: int(input())
n, m = ints()
a = ints()
s = int(m ** .5 + 1)
maxs = [max(a[i:i + s]) for i in range(0, m, s)]
for i in range(Int()):
    ys, xs, yf, xf, k = ints()
    yes = (xs - xf) % k == 0 and (ys - yf) % k == 0
    if {{completion}}
        print('no')
        continue
    mi, ma = min(xs, xf), max(xs, xf)
    high = max([0] + a[mi:min(ma, (mi // s + 1) * s)] + a[max(mi, ma // s * s):ma])
    for j in range(min(xs, xf) // s + 1, max(xs, xf) // s):
        high = max(high, maxs[j])
    if high < ys:
        print('yes')
        continue
    print('yes' if ((high - ys) // k + 1) * k + ys <= n else 'no')",not yes:,(high-ys)//k+1
"import math
import sys
input = sys.stdin.buffer.readline

y, x_ = input().split()
block = [int(x) for x in input().split()]
 
list2 = [[0] *20 for i in range( len(block))]
for a in range(len(block)):
    list2[a][0] = block[a]
    
z, x = 0, 1
while (1 << x) <= len(block):
    z = 0
    while (z + (1 << x) - 1) < len(block):
        list2[z][x] = (max(list2[z][x - 1], list2[z + (1 << (x - 1))][x - 1]))
        z += 1
    x += 1
    
 
for i in range(int(input())):
    s = [int(x) for x in input().split()]
    if abs(s[0] - s[2]) % s[-1] != 0 or abs(s[1] - s[3]) % s[-1] != 0:
        print(""NO"")
    else:
        smaller = min(s[1], s[3])
        bigger = max(s[1], s[3])
        k = 0
        while {{completion}}
            k += 1
        highest = max(list2[smaller - 1][k], list2[bigger - (1 << k)][k])
        if highest < s[-1] * ((int(y) - s[0]) // s[-1]) + s[0]:
            print(""YES"")
        else:
            print(""NO"")",(1 << (k + 1)) <= bigger - smaller + 1:,"































































































































"
"import math
import sys
input = sys.stdin.buffer.readline

y, x_ = input().split()
block = [int(x) for x in input().split()]
 
list2 = [[0] *20 for i in range( len(block))]
for a in range(len(block)):
    list2[a][0] = block[a]
    
z, x = 0, 1
while (1 << x) <= len(block):
    z = 0
    while (z + (1 << x) - 1) < len(block):
        list2[z][x] = (max(list2[z][x - 1], list2[z + (1 << (x - 1))][x - 1]))
        z += 1
    x += 1
    
 
for i in range(int(input())):
    s = [int(x) for x in input().split()]
    if abs(s[0] - s[2]) % s[-1] != 0 or abs(s[1] - s[3]) % s[-1] != 0:
        print(""NO"")
    else:
        smaller = min(s[1], s[3])
        bigger = max(s[1], s[3])
        k = 0
        while (1 << (k + 1)) <= bigger - smaller + 1:
            k += 1
        highest = max(list2[smaller - 1][k], list2[bigger - (1 << k)][k])
        if {{completion}}
            print(""YES"")
        else:
            print(""NO"")",highest < s[-1] * ((int(y) - s[0]) // s[-1]) + s[0]:,(1 << (k + 1)) <= bigger - smaller + 1:
"from sys import stdin, stdout
from math import floor, ceil, log
input, print = stdin.readline, stdout.write

def main():
  n, m = map(int, input().split())
  arr = [0] + [int(x) for x in input().split()]
  st = construct(arr, m)
  for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if {{completion}}
      print(""NO\n"")
      continue
    if (x1 <= arr[y1] or x2 <= arr[y2]):
      print(""NO\n"")
      continue
    max_x = ((n-x1)//k)*k + x1 
    if (max_x <= getMax(st, m, min(y1, y2), max(y1, y2))):
      print(""NO\n"")
      continue
    print(""YES\n"")

def construct(arr, n):
  x = ceil(log(n, 2))
  max_size = 2 * pow(2, x) - 1 
  st = [0]*max_size
  construct2(arr, 0, n-1, st, 0)
  return st
  
def construct2(arr, ss, se, st, si):
  if (ss == se):
    st[si] = arr[ss]
    return arr[ss]
  mid = getMid(ss, se)
  st[si] = max(construct2(arr, ss, mid, st, si * 2 + 1), construct2(arr, mid + 1, se, st, si * 2 + 2))
  return st[si]

def getMid(s, e):
  return s + (e - s) // 2

def getMax(st, n, l, r):
  return MaxUtil(st, 0, n - 1, l, r, 0)

def MaxUtil(st, ss, se, l, r, node):
  if (l <= ss and r >= se):
    return st[node]
  if (se < l or ss > r):
    return -1
  mid = getMid(ss, se)
  return max(MaxUtil(st, ss, mid, l, r, 2 * node + 1), MaxUtil(st, mid + 1, se, l, r, 2 * node + 2))
  
main()",((y2 - y1) % k != 0 or (x2 - x1) % k != 0):,"(max_x <= getMax(st, m, min(y1, y2), max(y1, y2))):"
"from sys import stdin, stdout
from math import floor, ceil, log
input, print = stdin.readline, stdout.write

def main():
  n, m = map(int, input().split())
  arr = [0] + [int(x) for x in input().split()]
  st = construct(arr, m)
  for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if ((y2 - y1) % k != 0 or (x2 - x1) % k != 0):
      print(""NO\n"")
      continue
    if (x1 <= arr[y1] or x2 <= arr[y2]):
      print(""NO\n"")
      continue
    max_x = ((n-x1)//k)*k + x1 
    if {{completion}}
      print(""NO\n"")
      continue
    print(""YES\n"")

def construct(arr, n):
  x = ceil(log(n, 2))
  max_size = 2 * pow(2, x) - 1 
  st = [0]*max_size
  construct2(arr, 0, n-1, st, 0)
  return st
  
def construct2(arr, ss, se, st, si):
  if (ss == se):
    st[si] = arr[ss]
    return arr[ss]
  mid = getMid(ss, se)
  st[si] = max(construct2(arr, ss, mid, st, si * 2 + 1), construct2(arr, mid + 1, se, st, si * 2 + 2))
  return st[si]

def getMid(s, e):
  return s + (e - s) // 2

def getMax(st, n, l, r):
  return MaxUtil(st, 0, n - 1, l, r, 0)

def MaxUtil(st, ss, se, l, r, node):
  if (l <= ss and r >= se):
    return st[node]
  if (se < l or ss > r):
    return -1
  mid = getMid(ss, se)
  return max(MaxUtil(st, ss, mid, l, r, 2 * node + 1), MaxUtil(st, mid + 1, se, l, r, 2 * node + 2))
  
main()","(max_x <= getMax(st, m, min(y1, y2), max(y1, y2))):",(x1 - x2) % k!= 0 or (y1 - y2) % k!= 0:
"import sys
from array import array

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
debug = lambda *x: print(*x, file=sys.stderr)
out = []


class sparse_table:
    def __init__(self, n, a, default=0, func=max):
        self.n, self.lg = n, 20
        self.func = func
        self.table = [array('i', [default] * n) for _ in range(self.lg)]
        self.table[0] = a
        self.preprocess()

    def preprocess(self):
        for j in range(1, self.lg):
            i = 0
            while {{completion}}
                ix = i + (1 << (j - 1))
                self.table[j][i] = self.func(self.table[j - 1][i], self.table[j - 1][ix])
                i += 1

    def quary(self, l, r):
        '''[l,r]'''
        l1 = (r - l + 1).bit_length() - 1
        r1 = r - (1 << l1) + 1
        return self.func(self.table[l1][l], self.table[l1][r1])


n, m = inp(int)
a = array('i', inp(int))
mem = sparse_table(m, a)

for _ in range(int(input())):
    xs, ys, xf, yf, k = inp(int)
    div, mod = divmod(n - xs, k)
    xma = n - mod
    qur = mem.quary(min(ys, yf) - 1, max(ys, yf) - 1)

    if qur >= xma or abs(xma - xf) % k or abs(ys - yf) % k:
        out.append('no')
    else:
        out.append('yes')

print('\n'.join(out))
",i + (1 << j) - 1 < self.n:,(r&1):
"from sys import setrecursionlimit, stdin
readline = stdin.readline

# def I(): return int(readline())
# def ST(): return readline()[:-1]
# def LI(): return list(map(int, readline().split()))

def solve():
    N, m = map(int, readline().split())
    A = [0] + list(map(int, readline().split()))
    n = len(A)
    num = 1 << (n - 1).bit_length()
    tree = [0] * 2 * num
    for i in range(n):
        tree[num + i] = A[i] 
    for i in range(num - 1, 0, -1):
        tree[i] = max(tree[2 * i], tree[2 * i + 1])

    def query(l, r):
        ret = 0
        l += num
        r += num
        while l < r:
            if {{completion}}
                ret = max(ret, tree[l])
                l += 1
            if r & 1:
                ret = max(ret, tree[r - 1])
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, gy + 1) < top: print(""YES"")
        else: print(""NO"")

solve()",l & 1:,(1 << (k + 1)) <= bigger - smaller + 1:
"from sys import setrecursionlimit, stdin
readline = stdin.readline

# def I(): return int(readline())
# def ST(): return readline()[:-1]
# def LI(): return list(map(int, readline().split()))

def solve():
    N, m = map(int, readline().split())
    A = [0] + list(map(int, readline().split()))
    n = len(A)
    num = 1 << (n - 1).bit_length()
    tree = [0] * 2 * num
    for i in range(n):
        tree[num + i] = A[i] 
    for i in range(num - 1, 0, -1):
        tree[i] = max(tree[2 * i], tree[2 * i + 1])

    def query(l, r):
        ret = 0
        l += num
        r += num
        while l < r:
            if l & 1:
                ret = max(ret, tree[l])
                l += 1
            if {{completion}}
                ret = max(ret, tree[r - 1])
            l >>= 1
            r >>= 1
        return ret

    for _ in range(int(input())):
        sx, sy, gx, gy, k = map(int, readline().split())
        dx = abs(sx - gx)
        dy = abs(sy - gy)
        if dx % k or dy % k:
            print(""NO"")
            continue
        top = sx + k * ((N - sx) // k)
        if sy > gy: sy, gy = gy, sy
        if query(sy, gy + 1) < top: print(""YES"")
        else: print(""NO"")

solve()",r & 1:,(1 << (k + 1)) <= bigger - smaller + 1:
"input = __import__('sys').stdin.readline


log2s = [0, 0]
for i in range(2, 200005):
    log2s.append(log2s[i // 2] + 1)


n, m = map(int, input().split())
sparse = [[0] + list(map(int, input().split()))]
for j in range(20):
    sparse.append([max(sparse[j][min(i + (1 << j), m)], sparse[j][i]) for i in range(m+1)])

def getmax(L, R):
    j = log2s[R - L + 1]
    return max(sparse[j][R - (1 << j) + 1], sparse[j][L])

for _ in range(int(input())):
    x1, y1, x2, y2, k = map(int, input().split())
    if {{completion}}
        print('NO')
        continue
    
    # i * k + x1 <= n
    i = (n - x1) // k
    h = i * k + x1
    while h > n:
        h -= k
    print('YES' if getmax(min(y1, y2), max(y1, y2)) < h else 'NO')
",(x1 - x2) % k != 0 or (y1 - y2) % k != 0:,"getmax(min(y1, y2), max(y1, y2)) < h:"
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

n,m=M();a=L();q=I()

t=[0]*(2*m)
# a is the array of initial values
def build(t,n,a):
    for i in range(n):t[i+n]=a[i]
    for i in range(n-1,0,-1):t[i]=max(t[i<<1],t[(i<<1)|1])

# change value at position p to v
def modify(t,n,p,v):
    p+=n
    t[p]=v
    while p>1:
        t[p>>1]=max(t[p],t[p^1])
        p>>=1

# find the combined value of range [l,r)
def query(t,n,l,r):
    resl=resr=0
    l+=n;r+=n
    while l<r:
        if {{completion}}resl=max(resl,t[l]);l+=1
        if (r&1):r-=1;resr=max(t[r],resr)
        l>>=1;r>>=1
    return max(resl,resr)

build(t,m,a)

for i in range(q):
    xs,ys,xf,yf,k=M()
    if abs(xs-xf)%k or abs(ys-yf)%k:print(""NO"");continue
    p=query(t,m,min(ys,yf)-1,max(ys,yf))
    z=min(xs,xf)+((n-min(xs,xf))//k)*k
    if z<=p:print(""NO"")
    else:print(""YES"")",(l&1):,(r&1):
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

n,m=M();a=L();q=I()

t=[0]*(2*m)
# a is the array of initial values
def build(t,n,a):
    for i in range(n):t[i+n]=a[i]
    for i in range(n-1,0,-1):t[i]=max(t[i<<1],t[(i<<1)|1])

# change value at position p to v
def modify(t,n,p,v):
    p+=n
    t[p]=v
    while p>1:
        t[p>>1]=max(t[p],t[p^1])
        p>>=1

# find the combined value of range [l,r)
def query(t,n,l,r):
    resl=resr=0
    l+=n;r+=n
    while l<r:
        if (l&1):resl=max(resl,t[l]);l+=1
        if {{completion}}r-=1;resr=max(t[r],resr)
        l>>=1;r>>=1
    return max(resl,resr)

build(t,m,a)

for i in range(q):
    xs,ys,xf,yf,k=M()
    if abs(xs-xf)%k or abs(ys-yf)%k:print(""NO"");continue
    p=query(t,m,min(ys,yf)-1,max(ys,yf))
    z=min(xs,xf)+((n-min(xs,xf))//k)*k
    if z<=p:print(""NO"")
    else:print(""YES"")",(r&1):,(l&1):
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            self.s.add(el)

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])


        #print('merging', i, j, list(D[i]), list(D[j]))
        if any(x in D[i] for x in D[j]):
            r += 1
            D[i].s.clear()
            break
        else:
            for {{completion}}
                D[i].add(x ^ A[i])

        #assert 0 not in D[i]

    #print(i, A[i], adj[i], list(D[i]))

print(r)
",x in D[j]:,x in D[j]:
"import sys 
from types import GeneratorType
from collections import defaultdict

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if {{completion}}
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

input = lambda: sys.stdin.readline().rstrip()

def solve():

    N = int(input())
    A = [int(x) for x in input().split()]

    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = [int(x) - 1 for x in input().split()]
        G[x].append(y)
        G[y].append(x)
    
    
    B = [0] * N
    vals = defaultdict(set)
    res = [0]

    @bootstrap
    def fill_dfs(v, p):
        B[v] = A[v]
        if p != -1:
            B[v] ^= B[p]
        for u in G[v]:
            if u != p:
                yield fill_dfs(u, v)
        yield
                
    
    @bootstrap
    def calc_dfs(v, p):
        zero = False
        vals[v].add(B[v])
        for u in G[v]:
            if u != p:
                yield calc_dfs(u, v)
                if len(vals[v]) < len(vals[u]):
                    vals[v], vals[u] = vals[u], vals[v]
                for x in vals[u]:
                    zero |= (x ^ A[v]) in vals[v]
                for x in vals[u]:
                    vals[v].add(x)
                vals[u].clear()
        if zero:
            res[0] += 1
            vals[v].clear()
        yield

    fill_dfs(0, -1)
    calc_dfs(0, -1)

    return res[0]

print(solve())",not stack:,type(to) is GeneratorType:
"import sys 
from types import GeneratorType
from collections import defaultdict

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if {{completion}}
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

input = lambda: sys.stdin.readline().rstrip()

def solve():

    N = int(input())
    A = [int(x) for x in input().split()]

    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = [int(x) - 1 for x in input().split()]
        G[x].append(y)
        G[y].append(x)
    
    
    B = [0] * N
    vals = defaultdict(set)
    res = [0]

    @bootstrap
    def fill_dfs(v, p):
        B[v] = A[v]
        if p != -1:
            B[v] ^= B[p]
        for u in G[v]:
            if u != p:
                yield fill_dfs(u, v)
        yield
                
    
    @bootstrap
    def calc_dfs(v, p):
        zero = False
        vals[v].add(B[v])
        for u in G[v]:
            if u != p:
                yield calc_dfs(u, v)
                if len(vals[v]) < len(vals[u]):
                    vals[v], vals[u] = vals[u], vals[v]
                for x in vals[u]:
                    zero |= (x ^ A[v]) in vals[v]
                for x in vals[u]:
                    vals[v].add(x)
                vals[u].clear()
        if zero:
            res[0] += 1
            vals[v].clear()
        yield

    fill_dfs(0, -1)
    calc_dfs(0, -1)

    return res[0]

print(solve())",type(to) is GeneratorType:,not stack:
"import sys

input = sys.stdin.buffer.readline

N = int(input())
A = list(map(int, input().split()))
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda s: int(s) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)


O = [0]
for i in O:
    for j in adj[i]:
        adj[j].remove(i)
        O.append(j)


class XORSet:
    def __init__(self, el=None):
        self.s = set()
        self.xor = 0
        if el is not None:
            self.s.add(el)

    def add(self, el: int):
        self.s.add(el ^ self.xor)

    def update(self, xor: int):
        self.xor ^= xor

    def __len__(self) -> int:
        return len(self.s)

    def __iter__(self):
        return (x ^ self.xor for x in self.s)

    def __contains__(self, el: int) -> bool:
        return (el ^ self.xor) in self.s

r = 0
D = [XORSet(a) for a in A]
for i in reversed(O):
    for j in adj[i]:
        if len(D[j]) > len(D[i]):
            D[i], D[j] = D[j], D[i]
            D[i].update(A[i])
            D[j].update(A[i])

        l = list(D[j])
        for x in l:
            if x in D[i]:
                r += 1
                D[i].s.clear()
                break
        else:
            for {{completion}}
                D[i].add(x ^ A[i])

            continue

        break

    #print(i, A[i], adj[i], list(D[i]))

print(r)
",x in l:,x in D[j]:
"import collections

def caminho(parent, sala):
  resp = []
  while sala is not None:
    resp.append(sala)
    sala = parent[sala]
  return list(reversed(resp))

def solve(grafo, total, inicio):
  if len(grafo[inicio]) < 2:
    return
  globalParent = collections.defaultdict(lambda: None)
  for sala1 in grafo[inicio]:
    currentParent = collections.defaultdict(lambda: None)
    currentParent[sala1] = inicio
    
    fila = collections.deque()
    fila.append(sala1)

    while len(fila) > 0:
      y = fila.popleft()
      for x in grafo[y]:
        if {{completion}}
          currentParent[x] = y
          fila.append(x)

    for x in currentParent:
      if x in globalParent:
        #Deu bom
        return (caminho(globalParent, x), caminho(currentParent, x))
        
    for x,y in currentParent.items():
      globalParent[x] = y
      
    

n, m, s = map(int, input().split())
g = collections.defaultdict(list)
for i in range(m):
  x,y = map(int, input().split())
  g[x].append(y)

paths = solve(g,n,s)

if paths is None:
  print(""Impossible"")
else:
  print(""Possible"")
  for i in paths:
    print(len(i))
    print("" "".join(map(str,i)))",x != inicio and currentParent[x] is None:,x in grafo[y]:
"import collections

def caminho(parent, sala):
  resp = []
  while sala is not None:
    resp.append(sala)
    sala = parent[sala]
  return list(reversed(resp))

def solve(grafo, total, inicio):
  if len(grafo[inicio]) < 2:
    return
  globalParent = collections.defaultdict(lambda: None)
  for sala1 in grafo[inicio]:
    currentParent = collections.defaultdict(lambda: None)
    currentParent[sala1] = inicio
    
    fila = collections.deque()
    fila.append(sala1)

    while len(fila) > 0:
      y = fila.popleft()
      for {{completion}}
        if x != inicio and currentParent[x] is None:
          currentParent[x] = y
          fila.append(x)

    for x in currentParent:
      if x in globalParent:
        #Deu bom
        return (caminho(globalParent, x), caminho(currentParent, x))
        
    for x,y in currentParent.items():
      globalParent[x] = y
      
    

n, m, s = map(int, input().split())
g = collections.defaultdict(list)
for i in range(m):
  x,y = map(int, input().split())
  g[x].append(y)

paths = solve(g,n,s)

if paths is None:
  print(""Impossible"")
else:
  print(""Possible"")
  for i in paths:
    print(len(i))
    print("" "".join(map(str,i)))",x in grafo[y]:,x!= inicio and currentParent[x] is None:
"n, m, s = [int(x) for x in input().split()]
labyrinth = {x: set() for x in range(1, n+1)}
for _ in range(m):
    pt1, pt2 = [int(x) for x in input().split()]
    labyrinth[pt1].add(pt2)
d_father = {}
for pt in labyrinth[s]:
    d_father[pt] = s
if len(d_father) < 2: print('Impossible')
else:
    for pt in labyrinth[s]:
        visited = {pt, s}
        to_visit = {pt}
        while to_visit:
            new_visit = set()
            for origin in to_visit:
                for new_pt in labyrinth[origin]:
                    if new_pt not in visited:
                        if new_pt in d_father:
                            path1 = [new_pt]
                            path2 = [new_pt, origin]
                            while {{completion}}
                                path1.append(d_father[path1[-1]])
                            while path2[-1] in d_father:
                                path2.append(d_father[path2[-1]])
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue
                break
            else:
                to_visit = new_visit
                continue
            break
        else: continue
        break
    else: print('Impossible')",path1[-1] in d_father:,path2[-1] in d_father:
"n, m, s = [int(x) for x in input().split()]
labyrinth = {x: set() for x in range(1, n+1)}
for _ in range(m):
    pt1, pt2 = [int(x) for x in input().split()]
    labyrinth[pt1].add(pt2)
d_father = {}
for pt in labyrinth[s]:
    d_father[pt] = s
if len(d_father) < 2: print('Impossible')
else:
    for pt in labyrinth[s]:
        visited = {pt, s}
        to_visit = {pt}
        while to_visit:
            new_visit = set()
            for origin in to_visit:
                for new_pt in labyrinth[origin]:
                    if new_pt not in visited:
                        if new_pt in d_father:
                            path1 = [new_pt]
                            path2 = [new_pt, origin]
                            while path1[-1] in d_father:
                                path1.append(d_father[path1[-1]])
                            while {{completion}}
                                path2.append(d_father[path2[-1]])
                            path1.reverse()
                            path2.reverse()
                            print('Possible')
                            print(len(path1))
                            print(' '.join(str(x) for x in path1))
                            print(len(path2))
                            print(' '.join(str(x) for x in path2))
                            break
                        else:
                            d_father[new_pt] = origin
                            new_visit.add(new_pt)
                            visited.add(new_pt)
                else: continue
                break
            else:
                to_visit = new_visit
                continue
            break
        else: continue
        break
    else: print('Impossible')",path2[-1] in d_father:,path1[-1] in d_father:
"import re
import sys
exit=sys.exit
from bisect import *
from collections import *
ddict=defaultdict
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
rb=lambda:list(map(int,rl()))
rfs=lambda:rln().split()
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rl=lambda:rln().rstrip('\n')
rln=sys.stdin.readline
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'
########################################################################

n,m,s=ris()
adj=[[] for _ in range(n+1)]
for _ in range(m):
  u,v=ris()
  adj[u].append(v)

vis=[{} for _ in range(n+1)]
for i in adj[s]:
  stk=[i]
  vis[s][i]=0
  vis[i][i]=s
  while stk:
    u=stk.pop()
    if 1<len(vis[u]):
      print('Possible')
      for j in vis[u]:
        x,path=u,[]
        while {{completion}}
          path.append(x)
          x=vis[x][j]
        print(len(path))
        print(*reversed(path))
      exit()
    for v in adj[u]:
      if i in vis[v] or v==s:
        continue
      stk.append(v)
      vis[v][i]=u
  
print('Impossible')
",j in vis[x]:,len(vis[u])==1:
"def DFS(start):
    nodes=set()
    stack=[start]
    while stack:
        parent=stack.pop()
        if(not visited[parent]):
            nodes.add(parent)
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                else:
                    if {{completion}}
                        return child
        else:
            if parent not in nodes and parent != s:
                return parent
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path=[]
    while node!=-1:
        path.append(node)
        node=parent_list[node]
    path.reverse()
    return path
n,m,s=map(int,input().split())
s-=1
graph=[[] for _ in range(n)]
for _ in range(m):
    a,b=map(int,input().split())
    a-=1
    b-=1
    graph[a].append(b)
visited=[False]*n
visited[s]=True
for child in graph[s]:
    end=DFS(child)
    if end!=-1:
        visited = [False] * n
        parent_list=[-1]*n
        visited[s]=True
        ans=[]
        for child in graph[s]:
            if DFS_get_path(child):
                ans.append([s]+get_path(end))
            if len(ans)==2:
                break
        print(""Possible"")
        for i in ans:
            print(len(i))
            print(*[j+1 for j in i])
        break
else:
    print(""Impossible"")

# 3 3 1
# 1 2
# 2 1
# 1 3",child not in nodes and child!=s:,(not visited[child]):
"def DFS(start):
    nodes=set()
    stack=[start]
    while stack:
        parent=stack.pop()
        if(not visited[parent]):
            nodes.add(parent)
            visited[parent]=True
            for child in graph[parent]:
                if {{completion}}
                    stack.append(child)
                else:
                    if child not in nodes and child!=s:
                        return child
        else:
            if parent not in nodes and parent != s:
                return parent
    return -1
def DFS_get_path(start):
    stack=[start]
    parent_list[start]=-1
    while stack:
        parent=stack.pop()
        if parent==end:
            visited[end]=False
            return True
        if(not visited[parent]):
            visited[parent]=True
            for child in graph[parent]:
                if (not visited[child]):
                    stack.append(child)
                    parent_list[child]=parent
    return False
def get_path(node):
    path=[]
    while node!=-1:
        path.append(node)
        node=parent_list[node]
    path.reverse()
    return path
n,m,s=map(int,input().split())
s-=1
graph=[[] for _ in range(n)]
for _ in range(m):
    a,b=map(int,input().split())
    a-=1
    b-=1
    graph[a].append(b)
visited=[False]*n
visited[s]=True
for child in graph[s]:
    end=DFS(child)
    if end!=-1:
        visited = [False] * n
        parent_list=[-1]*n
        visited[s]=True
        ans=[]
        for child in graph[s]:
            if DFS_get_path(child):
                ans.append([s]+get_path(end))
            if len(ans)==2:
                break
        print(""Possible"")
        for i in ans:
            print(len(i))
            print(*[j+1 for j in i])
        break
else:
    print(""Impossible"")

# 3 3 1
# 1 2
# 2 1
# 1 3",(not visited[child]):,child not in nodes and child!=s:
"l=[[*map(int,input().split())] for i in range(3)]
l=sorted(l,key=lambda x:x[1])
ans=[]
ans.append([l[0][0],l[0][1],l[0][0],l[1][1]])
l[0]=[l[0][0],l[1][1]]
if (l[1][0]<l[0][0] and l[2][0]>l[0][0]) or (l[1][0]>l[0][0] and l[2][0]<l[0][0]):
    ans.append([*l[0],l[1][0],l[0][1]])
    ans.append([*l[0],l[2][0],l[0][1]])
    ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])
else:
    if {{completion}}leng=max(l[1][0],l[2][0])
    else:leng=min(l[1][0],l[2][0])
    ans.append([*l[0],leng,l[0][1]])
    ans.append([l[2][0],l[0][1],l[2][0],l[2][1]])
print(len(ans))
for i in ans:
    print(*i)
","max(l[1][0],l[2][0])>l[0][0]:",l[1][0]<l[0][0] and l[2][0]>l[0][0]:
"'''
题意：将n个人安排到二叉树中，每两人之间通过最短路径d[i,j]通信，消息数量c[i,j]通过矩阵给出，
要求构造的二叉树满足：任意节点u的左子树中节点序号<u、右子树…>，且所有的节点对之间的c[i,j]*d[i,j]的总和最小。

区间dp，对于f[l,r]，枚举根节点k，得到最大值时记住区间[l,r]的根节点k，
最后先序遍历为每个节点指定根节点。
'''
R,G=lambda:map(int,input().split()),range;n,=R();Fa=[0]*n;N=n+1
A=lambda:[[0]*N for _ in G(N)];S,Rt,f=A(),A(),A()
for i in G(n):
  r=[*R()]
  for j in G(n):S[i+1][j+1]=r[j]+S[i][j+1]+S[i+1][j]-S[i][j]
rec=lambda i,x:S[x][x]-S[x][i]-S[i][x]+S[i][i]
for c in G(1,N):
  for l in G(N-c):
    r=l+c;f[l][l+c]=float('inf')
    for k in G(l,r):
      C=f[l][k]+S[k][n]-S[l][n]-rec(l,k)+f[k+1][r]+S[r][n]-S[k+1][n]-rec(k+1,r)
      if {{completion}}f[l][r]=C;Rt[l][r]=k
def F(l,r,fa):
  if l==r:return
  mid=Rt[l][r];Fa[mid]=fa+1;F(l,mid,mid);F(mid+1,r,mid)
F(0,n,-1);print(*Fa)",C<f[l][r]:,f[l][r]<f[i][r]:
"n = int(input().strip())

S = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    for j, c in enumerate(map(int, input().strip().split())):
        S[i][j] = c

for i in range(n):
    for j in range(n):
        if i > 0 and j > 0:
            S[i][j] += S[i][j-1] + S[i-1][j] - S[i-1][j-1]
        elif i > 0:
            S[i][j] += S[i-1][j]
        elif {{completion}}
            S[i][j] += S[i][j-1]


def acc(i1, i2, j1, j2):
    if i1 >= i2 or j1 >= j2:
        return 0
    a = S[i2-1][j2-1]
    b = S[i2-1][j1-1] if j1 > 0 else 0
    c = S[i1-1][j2-1] if i1 > 0 else 0
    d = S[i1-1][j1-1] if i1 > 0 and j1 > 0 else 0
    return a - b - c + d

M = [[-1 for i in range(n)] for j in range(n)]
P = [[-1 for i in range(n)] for j in range(n)]
def solve(b, e):
    if e - b == 1:
        M[b][e-1] = 0
        return 0
    if e - b == 0:
        return 0
    if M[b][e-1] != -1:
        return M[b][e-1]
    M[b][e-1] = 1e18
    for i in range(b, e):
        s = solve(b, i) + solve(i+1, e)
        s += acc(0, b, b, i) + acc(b, i, i, n) + acc(0, i+1, i+1, e) + acc(i+1, e, e, n)
        if s < M[b][e-1]:
            M[b][e-1] = s
            P[b][e-1] = i
    return M[b][e-1]
solve(0, n)
sol = ["""" for _ in range(n)]
def label(b, e, p):
    if e - b == 1:
        sol[b] = str(p)
        return
    elif e - b == 0:
        return
    i = P[b][e-1]
    sol[i] = str(p)
    label(b, i, i+1)
    label(i+1, e, i+1)
label(0, n, 0)
print("" "".join(sol))
",j > 0:,temp<M[b][e-1]:
"n=int(input())
c=[]
for _ in range(n):
    c.append(tuple(map(int,input().split())))
prefix_sum=[[0]*(n+1) for _ in range(n+1)]
for i in range(1,n+1):
    temp=0
    for j in range(1,n+1):
        temp+=c[i-1][j-1]
        prefix_sum[i][j]+=prefix_sum[i-1][j]+temp
def get_rectangel_sum(x1,y1,x2,y2):
    return prefix_sum[x2+1][y2+1]-prefix_sum[x1][y2+1]-prefix_sum[x2+1][y1]+prefix_sum[x1][y1]
def cost(x,y):
    if x>y:
        return 0
    a=get_rectangel_sum(x,0,y,x-1) if x!=0 else 0
    b=get_rectangel_sum(x,y+1,y,n-1) if y!=n-1 else 0
    return a+b
dp=[[float(""INF"")]*n for _ in range(n)]
best_root_for_range=[[-1]*n for _ in range(n)]
for i in range(n):
    dp[i][i]=0
    best_root_for_range[i][i]=i
def get_dp_cost(x,y):
    return dp[x][y] if x<=y else 0
for length in range(1,n):
    # actual length is length+1
    for i in range(n-length):
        j=i+length
        for root in range(i,j+1):
            temp=cost(i,root-1)+cost(root+1,j)+get_dp_cost(i,root-1)+get_dp_cost(root+1,j)
            if {{completion}}
                dp[i][j]=temp
                best_root_for_range[i][j]=root
ans=[-1]*n
def assign_ans(ansecstor,x,y):
    if x>y:
        return
    root=best_root_for_range[x][y]
    ans[root]=ansecstor
    assign_ans(root,x,root-1)
    assign_ans(root,root+1,y)
assign_ans(-1,0,n-1)
print(*[i+1 for i in ans])

# 3
# 0 1 2
# 1 0 3
# 2 3 0

# 4
# 0 1 2 3
# 1 0 5 7
# 2 5 0 4
# 3 7 4 0

# 6
# 0 100 20 37 14 73
# 100 0 17 13 20 2
# 20 17 0 1093 900 1
# 37 13 1093 0 2 4
# 14 20 900 2 0 1
# 73 2 1 4 1 0",temp<dp[i][j]:,j > 0:
"n,s=open(0)
for {{completion}}print(min(-int(x)%2**i-i+15for i in range(16)))",x in s.split():,"x in map(int,s.split()):"
"n = int(input())
mod = 1 << 15
for x in map(int, input().split()):
    res = 16
    for a in range(15):
        for b in range(15):
            if {{completion}}
                res = min(res, a + b)
    print(res)
",(x + a) * (1 << b) % mod == 0:,"x in map(int,s.split()):"
"n, s = open(0)
for {{completion}}
    print(min(15-i+-x % 2**i for i in range(16)))
","x in map(int, s.split()):","x in map(int, s.split()):"
"n,s=open(0)
for {{completion}}print(min(-x%2**i-i+15for i in range(16)))","x in map(int,s.split()):",x in s.split():
"n,s=open(0)
for {{completion}}print(min(15-i+-x%2**i for i in range(16)))","x in map(int,s.split()):","x in map(int,s.split()):"
"n,s=open(0)
for {{completion}}print(min(-int(x)%2**i-i+15for i in range(16)))",x in s.split():,x in s.split():
"for test in range(int(input())):
    n = int(input())
    h = [int(i) for i in input().split()]
    res = 2 << 69

    for req in range(max(h), max(h)+3):
        hm = req
        d = 0
        c = 0
        for {{completion}}
            d += req-i
            c += (req-i) & 1
        res = min(res, max((d//3)*2+d % 3, c*2-1))

    print(res)
",i in h:,"req in range(max(h), max(h)+3):
    hm = req
    d = 0
    c = 0
    for i in h:
        d += req-i
        c += (req-i) & 1
    res = min(res, max((d//3)*2+d % 3, c*2-1))"
"from bisect import bisect

t = int(input().strip())

def solve(o, t):
    if {{completion}}
        d = (t - o) // 3 + ((t - o) % 3 == 2)
        o, t = o + 2 * d, t - d
    return (o + (t > o)) * 2 - (o > t)


out = []
for _ in range(t):
    n = int(input().strip())
    h = list(map(int, input().strip().split()))
    mx = max(h)
    o, t, e = 0, 0, 0
    for x in h:
        e += (mx - x + 1) % 2
        o += (mx - x) % 2
        t += (mx - x) // 2
    out.append(str(min(solve(o, t), solve(e, t + o))))


print(""\n"".join(out))
",t - o > 1:,x in h:
"from bisect import bisect

t = int(input().strip())

def solve(o, t):
    if t - o > 1:
        d = (t - o) // 3 + ((t - o) % 3 == 2)
        o, t = o + 2 * d, t - d
    return (o + (t > o)) * 2 - (o > t)


out = []
for _ in range(t):
    n = int(input().strip())
    h = list(map(int, input().strip().split()))
    mx = max(h)
    o, t, e = 0, 0, 0
    for {{completion}}
        e += (mx - x + 1) % 2
        o += (mx - x) % 2
        t += (mx - x) // 2
    out.append(str(min(solve(o, t), solve(e, t + o))))


print(""\n"".join(out))
",x in h:,j in range(n):
"def solve(target,r):
 k=len(r)
 ones=twos=0
 for {{completion}}
  ones+=(target-r[i])%2
  twos+=(target-r[i])//2
 if ones>twos:return 2*ones-1
 return (ones+twos*2)//3*2+(ones+twos*2)%3
for _ in [0]*int(input()):
 input();r=[*map(int,input().split())]
 print(min(solve(max(r),r),solve(max(r)+1,r)))",i in range(k):,i in r:
"for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().strip().split()))
    l.sort()
    a=l.count(l[-1])
    odd,even=0,0
    for i in l:
        if {{completion}}
            even+=1
        else:
            odd+=1
    su=sum(l[:n-a])
    needed=l[-1]*(n-a)-su
    if l[-1]%2==0:
        p1,p2=odd,even
    else:
        p1,p2=even,odd
    ans=max(2*(needed//3)+needed%3,2*p1-1)
    needed+=n
    ans2=max(2*(needed//3)+needed%3,2*p2-1)
    print(min(ans,ans2))",i%2==0:,l[-1]%2==0
"def solve(m,a):
    ev=od=0
    for {{completion}}
        ev += (m-i)//2; od += (m-i)%2
    if(od>=ev):
        return od*2-(od!=ev)
    ev = (ev-od)*2
    return od*2 + ev//3*2 + ev%3

I = lambda: map(int,input().split())
t,=I()
for _ in [1]*t:
    n, = I()
    b = [*I()]
    mx = max(b)
    print(min(solve(mx,b),solve(mx+1,b)))",i in a:,mx-i>0:
"# by the authority of GOD     author: Kritarth Sharma #
import sys
from collections import defaultdict,deque,Counter
from bisect import bisect_left
import math
input=sys.stdin.readline
def inp():
    l=list(map(int,input().split()))
    return l

for _ in range(int(input())):
        n,=inp()
        l=inp()
        m=max(l)
        a=float('inf')
        for i in range(m,m+2):
            x=0
            y=0
            for {{completion}}
                x+=(i-l[j])//2
                y+=(i-l[j])%2
            a=min(a,max( 2*y -1, ((2*x+y)//3)*2 +((2*x+y)%3) ))
        print(a)",j in range(n):,"i in range(m,m+2):"
"inp = lambda : list(map(int,input().split()))
for _ in range(int(input())):
    n = int(input())
    t = inp()
    c = 0
    m = max(t)
    def mm(m):
        n1 = n2 = 0
        tot =0
        for {{completion}}
            n1+= (m-i)%2
            n2+= (m-i)//2
        return (n1*2-1) if n2<n1 else ((n2*2+n1)//3*2+(n2*2+n1)%3)    

    print(min(mm(m),mm(m+1)))",i in t:,i in t:
"for ii in range(int(input())):
	n=int(input())
	a = list(map(int, input().split()))
	m=max(a)
	ans=float(""inf"")
	for jj in range(m,m+4):
		x,y=0,0
		for {{completion}}
			x+=(jj-kk)%2
			y+=(jj-kk)//2
		ans=min(max(((x+y*2)//3*2)+(x+y*2)%3,x*2-1),ans)
	print(ans)",kk in a:,jj-kk>1:
"n,k = map(int, input().split())
bb = list(map(int, input().split()))
ans = 0
sofar = 0
sumprog = 0
timeq = []
for ib,b in enumerate(bb[::-1]):
    kk = min(k, n-ib)
    time = (max(0,b-sofar)+kk-1)//kk
    ans += time
    timeq.append(time)
    sumprog += time
    if {{completion}}
        sumprog -= timeq[ib-k]
    sofar += kk*time
    sofar -= sumprog
    # print(time, sofar, timeq, sumprog)
print(ans)
",ib >= k:,time > 0:
"I = lambda: [int(x) for x in input().split()]
n, k = I()
B, d = I() + [0]*k, [0] * (n + k)

s = total = 0
for i in range(n-1, -1, -1):
    B[i] -= total
    if {{completion}}
        dd = min(k, i + 1)
        d[i] = (B[i] + dd - 1)//dd
    s += d[i] - d[i + k]
    total += d[i] * dd - s
    
print(sum(d))",B[i] > 0:,i+k<n:
"#!/usr/bin/env PyPy3

from collections import Counter, defaultdict, deque
import itertools
import re
import math
from functools import reduce
import operator
import bisect
import heapq
import functools
mod=10**9+7

import sys
input=sys.stdin.readline
n,k=map(int,input().split())
b=list(map(int,input().split()))
ans = 0
dec = 0
cnt = [0] * n
tmp = 0
for i in range(k-1,n)[::-1]:
    tmp -= cnt[i]
    dec -= tmp
    #print(tmp,dec)
    if b[i] > dec:
        #print(b[i]-dec)
        x = -(-(b[i]-dec) // k)
        ans += x
        if {{completion}}
            cnt[i-k-1] = x
        dec += x * k
        tmp += x
    #print(ans)
    #tmp -= cnt[i]
#print(cnt)
ma = 0
for i in range(k-1)[::-1]:
    tmp -= cnt[i]
    dec -= tmp
    ma = max(ma,-(-(b[i]-dec) // (i+1)))

print(ans+ma)",i - k - 1 >= 0:,b[i]-dec>0:
"n, k = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]

dd = [0]*(len(a)+5)

add = 0
diff = 0
moves = 0
for key, i in reversed([*enumerate(a)]):
    add += diff
    i += add
    diff += dd[-1]
    dd.pop()
    if {{completion}}
        K = min(k, key+1)
        dd[-K] -= (i+K-1)//K
        diff += (i+K-1)//K
        moves += (i+K-1)//K
        add -= K*((i+K-1)//K)
print(moves)
",i > 0:,i+K-1>=K*(i+K-1)//K:
"""""""
take element as ""the tail"" will use more less operations,

use variables s,cnt and closed,
to avoid the inner iteration(update neighbor k elements every time),
complexity is O(n).
""""""
row=lambda:map(int,input().split())
n,k=row()
a=list(row())
closed=[0]*n
s=cnt=res=0
for i in range(n-1,-1,-1):
    # print(i,a[i],'s,cnt:',s,cnt,'closed:',closed)
    s-=cnt
    cnt-=closed[i]
    a[i]-=s
    if {{completion}}
        continue
    th=min(i+1,k)
    need=(a[i]+th-1)//th#equals ceil()
    s+=need*th
    cnt+=need
    res+=need
    if i>=th:
        closed[i-th]+=need
print(res)",a[i]<=0:,i>=th:
"""""""
take element as ""the tail"" will use more less operations,

use variables s,cnt and closed,
to avoid the inner iteration(update neighbor k elements every time),
complexity is O(n).
""""""
row=lambda:map(int,input().split())
n,k=row()
a=list(row())
closed=[0]*n
s=cnt=res=0
for i in range(n-1,-1,-1):
    # print(i,a[i],'s,cnt:',s,cnt,'closed:',closed)
    s-=cnt
    cnt-=closed[i]
    a[i]-=s
    if a[i]<=0:
        continue
    th=min(i+1,k)
    need=(a[i]+th-1)//th#equals ceil()
    s+=need*th
    cnt+=need
    res+=need
    if {{completion}}
        closed[i-th]+=need
print(res)",i>=th:,a[i]<=0:
"import math     
n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))
ans = res = tot = minus = 0
pre = []
prefix = []
for i in range(n)[::-1]:
    if {{completion}}
        minus += k * pre[-1] - prefix[-1]
    nums[i] -= minus
    cur = max(0, math.ceil(nums[i] / k))
    ans += (cur if i >= k else 0)
    pre.append(cur if i >= k else 0)
    tot += (cur if i >= k else 0)
    if len(pre) > k:
        tot -= pre[- k - 1]
    prefix.append(tot)
for i in range(k):
    res = max(res, math.ceil(nums[i] / (i + 1)))
print(ans + res)  ",i < n - 1:,len(pre) > k:
"import math     
n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))
ans = res = tot = minus = 0
pre = []
prefix = []
for i in range(n)[::-1]:
    if i < n - 1:
        minus += k * pre[-1] - prefix[-1]
    nums[i] -= minus
    cur = max(0, math.ceil(nums[i] / k))
    ans += (cur if i >= k else 0)
    pre.append(cur if i >= k else 0)
    tot += (cur if i >= k else 0)
    if {{completion}}
        tot -= pre[- k - 1]
    prefix.append(tot)
for i in range(k):
    res = max(res, math.ceil(nums[i] / (i + 1)))
print(ans + res)  ",len(pre) > k:,i < n - 1:
"I=lambda:[*map(int,input().split())]
def F(g,i):s=g//i;b=g%i;return b*(s+1)**2+(i-b)*s**2
def f(g,c):
	if c>g**2//2:return 0,g**2
	s=0;b=g
	while b-s>1:
		m=(b+s)//2
		if {{completion}}s=m
		else:b=m
	return s,F(g,b)
n,=I()
a=[0]+I()
m,=I()
G=[a[i+1]-a[i]for i in range(n)]
s=2
b=1<<59
while b-s>1:
	C=0;M=(b+s)//2
	for g in G:a,c=f(g,M);C+=c
	if C>m:b=M
	else:s=M
A=C=0
for g in G:a,c=f(g,b);A+=a;C+=c
print(A+max(0,(C-m-1)//s+1))","F(g,m)-F(g,m+1)>=c:",a - b >= c:
"from collections import Counter
n, a, m = int(input()), [*map(int, input().split())], int(input())
def energy(l, t):
    x,y = divmod(l, t+1)
    return x*x*(t+1-y)+(x+1)*(x+1)*y
def getdiff(l, diff):
    lo, hi = 0, l
    while lo < hi:
        mid = lo + hi >> 1
        if {{completion}} hi = mid
        else: lo = mid + 1
    return lo, energy(l, lo)
def getsum(d, c=0): a1,a2 = zip(*[getdiff(i, d) for i,_ in a]); return (0 if c else sum(a1[i]*x for i, (_, x) in enumerate(a)), sum(a2[i]*x for i, (_, x) in enumerate(a)))
a = [0] + a
a = Counter([a[i+1]-a[i] for i in range(n)]).items()
lo, hi = 1, m
while lo < hi:
    mid = lo + hi >> 1
    if getsum(mid, 1)[1] > m: hi = mid
    else: lo = mid + 1
lo-=1
a1, a2 = getsum(lo)
print(a1-(m-a2)//lo if lo else a1)","energy(l, mid) - energy(l, mid+1) < diff:",mid < m:
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

def ff(gap, ints): 
	sml = gap // ints
	bigcount = gap % ints
	return bigcount * (sml + 1) ** 2 + (ints - bigcount) * sml ** 2

def f(gap, c):
	if c > gap ** 2 // 2:
		return 0, gap ** 2
	sml = 0
	big = gap
	while big - sml > 1:
		mid = (big + sml) // 2
		a = ff(gap, mid)
		b = ff(gap, mid + 1)
		if {{completion}}
			sml = mid
		else:
			big = mid
	return sml, ff(gap, big)

n, = I()
a = I()
m, = I()
gaps = [a[0]]
for i in range(n - 1):
	gaps.append(a[i + 1] - a[i])

sml = 2
big = 1 << 59 + 2
while big - sml > 1:
	cost = 0
	mid = (big + sml) // 2
	for g in gaps:
		a, c = f(g, mid)
		cost += c
	if cost > m:
		big = mid
	else:
		sml = mid
abig = 0
cbig = 0
for g in gaps:
	a, c = f(g, big)
	abig += a
	cbig += c

print(abig + max(0, (cbig - m - 1) // sml + 1))",a - b >= c:,"ff(gap, mid) - ff(gap, mid+1) < diff:"
"from functools import cache
from math import inf
from itertools import accumulate

def solve(A, m):
    n = len(A)
    A.reverse()

    @cache
    def dp(i, val, balance):
        if abs(balance) > m:
            return inf
        if {{completion}}
            return inf
        if i == n:
            return 0 if balance == 0 else inf

        curr = A[i] + balance
        take = abs(curr - val) + dp(i + 1, val, curr - val)
        skip = dp(i, val + 1, balance)
        return min(take, skip)

    return dp(0, 0, 0)


n, m = map(int, input().split())
A = list(map(int, input().split()))
print(solve(A, m))
",(n - i) * val > m:,i == n:
"from functools import cache
from math import inf
from itertools import accumulate

def solve(A, m):
    n = len(A)
    A.reverse()

    @cache
    def dp(i, val, balance):
        if abs(balance) > m:
            return inf
        if (n - i) * val > m:
            return inf
        if {{completion}}
            return 0 if balance == 0 else inf

        curr = A[i] + balance
        take = abs(curr - val) + dp(i + 1, val, curr - val)
        skip = dp(i, val + 1, balance)
        return min(take, skip)

    return dp(0, 0, 0)


n, m = map(int, input().split())
A = list(map(int, input().split()))
print(solve(A, m))
",i == n:,(n - i) * val > m:
"from itertools import accumulate
I=lambda:map(int,input().split())
n,m=I()
a,inf=[*I()],float('inf')
pre=[0]+[*accumulate(a)]

dp=[[inf]*(m+1) for _ in range(m+1)]
dp[m][0]=0
for i in range(n):
  cur=[[inf]*(m+1) for _ in range(m+1)]
  for lst in reversed(range(m+1)):
    for sums in range(m+1):
      if {{completion}}
        dp[lst][sums]=min(dp[lst][sums],dp[lst+1][sums])
      if sums+lst<=m:
        cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))
  dp,cur=cur,dp
print(min(dp[lst][m] for lst in range(m+1)))",lst<m:,sums+lst<=m:
"from itertools import accumulate
I=lambda:map(int,input().split())
n,m=I()
a,inf=[*I()],float('inf')
pre=[0]+[*accumulate(a)]

dp=[[inf]*(m+1) for _ in range(m+1)]
dp[m][0]=0
for i in range(n):
  cur=[[inf]*(m+1) for _ in range(m+1)]
  for lst in reversed(range(m+1)):
    for sums in range(m+1):
      if lst<m:
        dp[lst][sums]=min(dp[lst][sums],dp[lst+1][sums])
      if {{completion}}
        cur[lst][sums+lst]=min(cur[lst][sums+lst], dp[lst][sums]+abs(pre[i+1]-(sums+lst)))
  dp,cur=cur,dp
print(min(dp[lst][m] for lst in range(m+1)))",sums+lst<=m:,lst<m:
"n,m=map(int,input().split())
a=list(map(int,input().split()))[::-1]

id=[]
for i in range(n):
  for _ in range(a[i]):
    id.append(i)

inf=10**5
dp=[[inf]*(m+1) for i in range(m+1)]
dp[0][0]=0
for i in range(n):
  cost=[]
  for j in id:
    cost.append(abs(i-j))
  cum=[0]
  tmp=0
  for j in cost:
    tmp+=j
    cum.append(tmp)
  
  dp_new=[[inf]*(m+1) for i in range(m+1)]
  for j in range(m+1):
    mx=(m-j)//(n-i)
    for k in range(mx+1):
      if dp[j][k]==inf:continue
      #print(i,j,k,mx)
      for {{completion}}
        #print(l)
        c=cum[l+j]-cum[j]
        dp_new[j+l][l]=min(dp_new[j+l][l],dp[j][k]+c)
  dp=dp_new
print(min(dp[-1]))","l in range(k,mx+1):",dp[j][k]==inf:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, K = map(int, getIntArray(2))
    A = getIntArray(N)

    s = [set() for i in range(3005)]
    for i in range(N):
        for k in range(1, K + 1):
            s[A[i] // k].add(i)

    ans = 999999999999999999999999999999999999999999999999999999999999999999999
    r = 0
    freq = {}
    for l in range(len(s)):
        while len(freq) < N and r < len(s):
            for v in s[r]:
                if {{completion}} freq[v] = 0
                freq[v] += 1
            r += 1
        if len(freq) < N: break
        ans = min(ans, r - l - 1)
        for v in s[l]:
            if freq[v] == 1: del freq[v]
            else: freq[v] -= 1
    print(ans)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",v not in freq:,v in s[r]:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N, K = map(int, getIntArray(2))
    A = getIntArray(N)

    s = [set() for i in range(3005)]
    for i in range(N):
        for k in range(1, K + 1):
            s[A[i] // k].add(i)

    ans = 999999999999999999999999999999999999999999999999999999999999999999999
    r = 0
    freq = {}
    for l in range(len(s)):
        while len(freq) < N and r < len(s):
            for {{completion}}
                if v not in freq: freq[v] = 0
                freq[v] += 1
            r += 1
        if len(freq) < N: break
        ans = min(ans, r - l - 1)
        for v in s[l]:
            if freq[v] == 1: del freq[v]
            else: freq[v] -= 1
    print(ans)


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",v in s[r]:,v not in freq:
"import sys
tokens = ''.join(sys.stdin.readlines()).split()[::-1]

def next(): return tokens.pop()
def nextInt(): return int(next())
def nextFloat(): return float(next())
def getIntArray(n): return [nextInt() for _ in range(n)]
def getFloatArray(n): return [nextFloat() for _ in range(n)]
def getStringArray(n): return [next() for _ in range(n)]


testcase = True
def solve(testcase = 1):
    N = nextInt()
    A = getIntArray(N)

    map = {}
    for i in range(N):
        if A[i] not in map: map[A[i]] = []
        map[A[i]].append(i)

    for color in range(1, N + 1):
        if color not in map:
            print(0, end=' ')
            continue
        ar = map[color]
        oddCount = evenCount = 0
        for i in ar:
            if {{completion}}
                evenCount = max(evenCount, oddCount + 1)
            else:
                oddCount = max(oddCount, evenCount + 1)
        print(max(oddCount, evenCount), end=' ')
    print()


if testcase is None:
    testcaseCount = 1
    while tokens:
        solve(testcaseCount)
        testcaseCount += 1
else:
    testcaseCount = nextInt() if testcase else 1
    for tc in range(testcaseCount):
        solve(tc + 1)
    assert not tokens",i % 2 == 0:,"(color in range(1, N + 1)):"
"n, d = map(int, input().split())
p = sorted(map(int, input().split()), reverse=True)
ans = 0
for num in p:
    if {{completion}}
        n -= d // num + 1
        ans += 1
    else:
        break
print(ans)
",n >= d // num + 1:,num == p[0]:
"def solve():
    n, d = [int(i) for i in input().split(' ')]
    power = [int(i) for i in input().split(' ')]
    
    power.sort()

    used = 0
    w = 0
    for i in range(len(power)-1, -1, -1):
        min_players = -(d // -power[i])
        p = power[i] * min_players
        if(p > d):
            used += min_players
        elif{{completion}}
            used += min_players + 1

        if(used > n):
            break

        w += 1

    print(w)

solve()",(p == d):,used > n:
"import math
enemy_power=int(input().split()[1])
team=[int(i) for i in input().split()]
team.sort()
days=0
while len(team)>0:
    num=enemy_power//team[-1]+1
    if {{completion}}
        break;
    else:
        del team[-1]
        del team[0:num-1]
        days+=1
print(days)",len(team)<num:,len(team)==0:
"import sys,math
n,team=map(int,sys.stdin.readline().split())
arr=sorted(map(int,sys.stdin.readline().split()),reverse=True)
# print(arr)
all=n+1
count=0
for i in range(n):
    sub=int(math.floor(team/arr[i])+1)
    all-=sub
    if {{completion}}
        count+=1
    else:break
print(count)",all>0:,all-=sub
"def solve():
    n,d=map(int,input().split())
    a=sorted([*map(int,input().split())])[::-1]
    i,j,r=0,len(a),0
    while i<j:
        x=a[i]
        while x<=d:
            j-=1
            if {{completion}}
                x+=a[i]
            else:
                return r
        else:
            r+=1
            i+=1
    return r
print(solve())
",i<j:,x <= d:
"from sys import stdin,stdout
def ans():
    n,d=map(int,stdin.readline().strip().split())
    p=list(map(int,stdin.readline().strip().split()))
    temp=int(n)
    ans=0
    for x in sorted(p,reverse=True):
        if {{completion}}
            temp-=((d//x)+1)
            ans+=1
    print(ans)     
    
if __name__=='__main__':
    ans()
",temp>=((d//x)+1):,temp >= 0:
"d = int(input().split("" "")[1])
p = sorted(map(int, input().split("" "")))
c = 0
l = 0
r = len(p) - 1

s = p[r]

while r > l:
    while {{completion}}
        s += p[r]
        l += 1
    if l > r:
        break
    r -= 1
    s = p[r]
    c += 1

if p[0] > d:
    c += 1

print(c)
",s <= d:,l > r:
"import sys
input=sys.stdin.readline

from heapq import heappush,heappop,heapify 
from collections import defaultdict
 
def main():
	n,m=map(int,input().split())
	gf=defaultdict(list)
	gb=defaultdict(list)
	for _ in range(m):
		u,v,w=map(int,input().split())
		gf[u].append((v,w))
		gb[v].append((u,w))
	dis=[float('inf')]*(n+1)
	dis[1]=0
	h=[]
	heapify(h)
	heappush(h,(0,1))
	while h:
		cd,cn=heappop(h)
		if dis[cn]==cd:
			for nn,nw in gf[cn]:
				if {{completion}}
					dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	res=[float('inf')]*(n+1)
	res[1]=0
	h=[]
	for i in range(1,n+1):
		if dis[i]!=float('inf'):
			res[i]=dis[i]
			h.append((dis[i],i))
	heapify(h)
	while h:
		cd,cn=heappop(h)
		if res[cn]==cd:
			for nn,nw in gb[cn]:
				if cd+nw<res[nn]:
					res[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	for i in range(1,len(res)):
		if res[i]==float('inf'):res[i]=-1
	print(*res[2:])

main()",cd+nw<dis[nn]:,cd+nw<res[nn]:
"import sys
input=sys.stdin.readline

from heapq import heappush,heappop,heapify 
from collections import defaultdict
 
def main():
	n,m=map(int,input().split())
	gf=defaultdict(list)
	gb=defaultdict(list)
	for _ in range(m):
		u,v,w=map(int,input().split())
		gf[u].append((v,w))
		gb[v].append((u,w))
	dis=[float('inf')]*(n+1)
	dis[1]=0
	h=[]
	heapify(h)
	heappush(h,(0,1))
	while h:
		cd,cn=heappop(h)
		if dis[cn]==cd:
			for nn,nw in gf[cn]:
				if cd+nw<dis[nn]:
					dis[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	res=[float('inf')]*(n+1)
	res[1]=0
	h=[]
	for i in range(1,n+1):
		if dis[i]!=float('inf'):
			res[i]=dis[i]
			h.append((dis[i],i))
	heapify(h)
	while h:
		cd,cn=heappop(h)
		if res[cn]==cd:
			for nn,nw in gb[cn]:
				if {{completion}}
					res[nn]=cd+nw
					heappush(h,(nw+cd,nn))
	for i in range(1,len(res)):
		if res[i]==float('inf'):res[i]=-1
	print(*res[2:])

main()",cd+nw<res[nn]:,cd+nw<dis[nn]:
"def ev(x):
    k = 0
    while x%2 == 0:
        x//=2
        k+=1
    return x+k
p,q = [int(i) for i in input().split()]
t,s,sum = 1,1,0
while True:
    ss = s + (t+1)//2
    if ss > p:
        m = (p-s+1)
        sum += m*t
        break
    sum += t*((t+1)//2)
    s = ss
    t += 1
mx = t-2*m+1
print(sum)
mul,ded,turn = 0,0,0
t -= 0 if mx==turn else 1
for i in range(q):
    x = int(input())
    if x == 1:
        print(1)
        continue
    while True:
        if {{completion}}
            print(ev(x-ded)+mul)
            break
        ded += (t+1)//2
        turn+=1
        mul += 1
        t -= 0 if mx==turn else 1",x-ded <= t:,ded + (t+1)//2 <= p:
"def ev(x):
    k = 0
    while x%2 == 0:
        x//=2
        k+=1
    return x+k
p,q = [int(i) for i in input().split()]
t = 1
s = 1
sum = 0
while True:
    ss = s + (t+1)//2
    if ss > p:
        m = (p-s+1)
        sum += m*t
        break
    sum += t*((t+1)//2)
    s = ss
    t += 1
mx = t-2*m+1
print(sum)
tt = t
mul = 0
ded = 0
turn = 0
tt -= 0 if mx==turn else 1
for i in range(q):
    x = int(input())
    if x == 1:
        print(1)
        continue
    while True:
        #print(""A:"",turn,tt,x-ded)
        if {{completion}}
            print(ev(x-ded)+mul)
            break
        #print(""WUT"")
        if tt < 0:
            print(ev(x-ded)+mul)
            break
        ded += (tt+1)//2
        turn+=1
        mul += 1
        tt -= 0 if mx==turn else 1",x-ded <= tt:,x-ded <= t:
"import sys

#sys.stdin = open(""C:\\Users\\asawe\\Documents\\input.txt"",""r"")

mx = 3 * (10 ** 5) + 10
mod = 998244353

fact = [1]
inv_fact = [1]


def modpow(a, b, m):
    res = 1
    x = a
    y = b

    while (y > 0):
        if {{completion}}
            res = (res * x) % m
        y = y >> 1
        x = ((x % m) * (x % m)) % m

    return (res % m + m) % m

def inverse(a, m):
    u,v = 0,1
    while a != 0:
        t = m // a
        m -= t * a
        a, m = m, a
        u -= t * v
        u, v = v, u
    return u

for i in range(1, mx):
    fact.append((fact[-1] * i) % mod)
    inv_fact.append(inverse(fact[-1], mod)%mod)

def P(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[n - k]) % mod

def C(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[k] * inv_fact[n - k]) % mod

n,m = map(int,sys.stdin.readline().split())
a = list(map(int,sys.stdin.readline().split()))
s = sum(a)

psum = [0] * n
for i in range(n-1):
    psum[i] = psum[i-1] + a[i]
di = {}
for i in psum:
    di[i] = 0
count = 0
for i in psum:
    if i + s/2 in di:
        count+=1
v = n - 2 * count
ans = 0
for i in range(count+1):
    ans = (ans + C(count,i) * P(m,count-i) * modpow(m-count+i,v,mod) * modpow(P(m-count+i,2),i,mod)) % mod
print(ans)
",(y & 1):,n%2:
"import sys

#sys.stdin = open(""C:\\Users\\asawe\\Documents\\input.txt"",""r"")

mx = 3 * (10 ** 5) + 10
mod = 998244353

fact = [1]
inv_fact = [1]


def modpow(a, b, m):
    res = 1
    x = a
    y = b

    while {{completion}}
        if (y & 1):
            res = (res * x) % m
        y = y >> 1
        x = ((x % m) * (x % m)) % m

    return (res % m + m) % m

def inverse(a, m):
    u,v = 0,1
    while a != 0:
        t = m // a
        m -= t * a
        a, m = m, a
        u -= t * v
        u, v = v, u
    return u

for i in range(1, mx):
    fact.append((fact[-1] * i) % mod)
    inv_fact.append(inverse(fact[-1], mod)%mod)

def P(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[n - k]) % mod

def C(n, k):
    if k < 0 or k > n:
        return 0
    return (fact[n] * inv_fact[k] * inv_fact[n - k]) % mod

n,m = map(int,sys.stdin.readline().split())
a = list(map(int,sys.stdin.readline().split()))
s = sum(a)

psum = [0] * n
for i in range(n-1):
    psum[i] = psum[i-1] + a[i]
di = {}
for i in psum:
    di[i] = 0
count = 0
for i in psum:
    if i + s/2 in di:
        count+=1
v = n - 2 * count
ans = 0
for i in range(count+1):
    ans = (ans + C(count,i) * P(m,count-i) * modpow(m-count+i,v,mod) * modpow(P(m-count+i,2),i,mod)) % mod
print(ans)
",(y > 0):,n%2:
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if {{completion}}
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      anss+=ans
print(anss%pmod)",n%2:,n%2:
"from math import comb
def bpow(a,n,p):
    res = 1
    while n:
        if {{completion}}
            res = (res*a)%p
            n-=1
        else:
            a = (a*a)%p
            n//=2
    return res
N = 3 * 10**5 + 5
 
factorialNumInverse = [None] * (N + 1)
 
naturalNumInverse = [None] * (N + 1)
 
fact = [None] * (N + 1)
 
def InverseofNumber(p):
    naturalNumInverse[0] = naturalNumInverse[1] = 1
    for i in range(2, N + 1, 1):
        naturalNumInverse[i] = (naturalNumInverse[p % i] *
                                   (p - int(p / i)) % p)
 
def InverseofFactorial(p):
    factorialNumInverse[0] = factorialNumInverse[1] = 1
 
    
    for i in range(2, N + 1, 1):
        factorialNumInverse[i] = (naturalNumInverse[i] *
                                  factorialNumInverse[i - 1]) % p
 
 
def factorial(p):
    fact[0] = 1
 
    
    for i in range(1, N + 1):
        fact[i] = (fact[i - 1] * i) % p
 
def Binomial(N, R, p):
     
    
    ans = ((fact[N] * factorialNumInverse[R])% p *
                      factorialNumInverse[N - R])% p
    return ans
pmod = 998244353
InverseofNumber(pmod)
InverseofFactorial(pmod)
factorial(pmod)
n,pp = map(int,input().split())
l = list(map(int,input().split()))
pref,a = 0,[]
for i in l:
    pref+=i
    a.append(pref)
qq = pref
qq = qq/2
q = 1
k = 0
po = 0
p = 0
while(q<n):
      if(a[q]-a[po]>qq):
        po+=1
      elif(a[q]-a[po]<qq):
        q+=1
      else:
          k+=1
          po+=1
          q+=1
p=pp
anss = 0
for i in range(k+1):
      ans=1
      ans*=Binomial(k,k-i,pmod)
      ans%=pmod
      #print(f'ans after step 1 is {ans}')
      ans*=bpow(((p-(k-i))*(p-(k-i)-1)),i,pmod)
      ans%=pmod
      #print(f'ans after step 2 is {ans}')
      ans*=fact[p]*factorialNumInverse[p-k+i]
      ans%=pmod
      #print(f'ans after step 3 is {ans}')
      ans*=bpow(p-k+i,(n-k*2),pmod)
      ans%=pmod
      anss+=ans
print(anss%pmod)",n%2:,n%2:
"def solve(a, b):
    inf = 2 * 10 ** 6
    d, n = inf, len(b)

    for i in range(n):
        if {{completion}}
            d = min(d, a[i] - b[i])

    # b[i] > a[i]
    if d < 0:
        print(""NO"")
        return
    # All elements of b are 0s
    if d == inf:
        print(""YES"")
        return

    for i in range(n):
        if a[i] - b[i] > d:
            print(""NO"")
            return
        if b[i] > 0 and a[i] - b[i] < d:
            print(""NO"")
            return
    # all a[i] - b[i] == d
    print(""YES"")

def main():
    from sys import stdin
    from itertools import islice

    tkns = map(int, stdin.read().split())
    t = next(tkns)

    for T in range(t):
        n = next(tkns)
        a, b = list(islice(tkns, n)), list(islice(tkns, n))

        solve(a, b)

main()
",b[i] > 0:,a[i] - b[i] > d:
"def solve(a, b):
    inf = 2 * 10 ** 6
    d, n = inf, len(b)

    for i in range(n):
        if b[i] > 0:
            d = min(d, a[i] - b[i])

    # b[i] > a[i]
    if d < 0:
        print(""NO"")
        return
    # All elements of b are 0s
    if d == inf:
        print(""YES"")
        return

    for i in range(n):
        if {{completion}}
            print(""NO"")
            return
        if b[i] > 0 and a[i] - b[i] < d:
            print(""NO"")
            return
    # all a[i] - b[i] == d
    print(""YES"")

def main():
    from sys import stdin
    from itertools import islice

    tkns = map(int, stdin.read().split())
    t = next(tkns)

    for T in range(t):
        n = next(tkns)
        a, b = list(islice(tkns, n)), list(islice(tkns, n))

        solve(a, b)

main()
",a[i] - b[i] > d:,a[i] - b[i] > d:
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  a = list(map(int, inp(n)))
  s = list(inp1())
  d = {}
  ok = True
  for i in range(n):
    if a[i] not in d:
      d[a[i]] = s[i]
    elif {{completion}}
      ok = not ok
      break
  print(""YES"" if ok else ""NO"")

",d[a[i]] != s[i]:,s[i]!= d[a[i]]:
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  c = inp1()
  s = inp1()
  ret = 0
  l = []
  last = ''
  for i in range(n):
    cur = s[i]
    if cur == last:
      continue
    if cur == c:
      last = cur
      l.append((c, i))
    elif {{completion}}
      last = cur
      l.append(('g', i))
  first_g = -1
  for i in range(len(l)):
    if l[i][0] == 'g' and first_g != -1:
      continue
    elif l[i][0] == 'g' and first_g == -1:
      first_g = l[i][1]
    elif i == len(l) - 1:
      ret = max(ret, n - l[i][1] + first_g)
    else:
      ret = max(ret, l[i + 1][1] - l[i][1])
  print(ret)
",cur == 'g':,l[i][0] == 'g' and first_g == -1:
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  n = int(inp1())
  c = inp1()
  s = inp1()
  ret = 0
  l = []
  last = ''
  for i in range(n):
    cur = s[i]
    if cur == last:
      continue
    if cur == c:
      last = cur
      l.append((c, i))
    elif cur == 'g':
      last = cur
      l.append(('g', i))
  first_g = -1
  for i in range(len(l)):
    if l[i][0] == 'g' and first_g != -1:
      continue
    elif {{completion}}
      first_g = l[i][1]
    elif i == len(l) - 1:
      ret = max(ret, n - l[i][1] + first_g)
    else:
      ret = max(ret, l[i + 1][1] - l[i][1])
  print(ret)
",l[i][0] == 'g' and first_g == -1:,l[i][0] == 'g' and first_g!= -1:
"from itertools import islice
from sys import stdin

data = iter([int(x) for x in stdin.read().split()[1:]])

res = []
while True:
    try:
        n = next(data)
    except StopIteration:
        break
    q = next(data)
    counts = [0, 0]
    sums = [0, 0]
    for v in islice(data, n):
        counts[v % 2] += 1
        sums[v % 2] += v
    for _ in range(q):
        mod = next(data)
        x = next(data)
        to_add = counts[mod] * x
        if {{completion}}
            counts[1 - mod] += counts[mod]
            sums[1 - mod] += sums[mod] + to_add
            counts[mod] = sums[mod] = 0
        else:
            sums[mod] += to_add
        res.append(sum(sums))

print('\n'.join(str(x) for x in res))",x % 2:,mod == 0:
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  q = inp1()
  a = inp(n)
  tx = [inp(2) for _ in range(q)]
  odd = 0
  even = 0
  for i in a:
    if i % 2 == 0:
      even +=1
    else:
      odd +=1
  ret = sum(a)
  for i in tx:
    if i[0] == 0:
      ret += even * i[1]
      if i[1] % 2 != 0:
        odd = n
        even = 0
    else:
      ret += odd * i[1]
      if {{completion}}
        even = n
        odd = 0
    print(ret)
",i[1] % 2 != 0:,odd == 0:
"for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    prefix = suffix = 0
    for i in range(n - 1):
        if {{completion}}
            prefix += d
        else:
            suffix -= d
    print(abs(a[0] - prefix) + prefix + suffix)
",(d := a[i] - a[i + 1]) > 0:,x < y:
"for line in [*open(0)][2::2]:
  tot = 0
  list = line.split(' ')
  list2 = [0] + list
  minv = int(list[0])
  for val in range(len(list)-1):
    diff = int(list2[val+1]) - int(list[val+1])
    if {{completion}}
      tot += diff
      minv -= diff
  print(tot-minv+abs(minv)+int(list[len(list)-1]))",(diff >= 0):,x < y:
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();d=[a[0]]
    for i in range(1,n):d.append(a[i]-a[i-1])
    for i in range(1,n):
        if {{completion}}d[0]+=d[i]
    print(sum(abs(i) for i in d))",d[i]<=0:,x<0:
"for _ in range(int(input())):
    input()
    a = [int(x) for x in input().split()]
    prefix_value = a[0]
    suffix_value = 0
    steps = 0
    for x, y in zip(a, a[1:]):
        if x > y:
            steps += x - y
            prefix_value = y - suffix_value
        elif {{completion}}
            steps += y - x
            suffix_value += y - x
    print(steps + abs(prefix_value))
",y > x:,x<0:
"from sys import stdin
a = int(stdin.readline())

for t in range(0,a):
    b = int(stdin.readline())
    c = stdin.readline().split()
    count = 0
    current = int(c[0])
    for u in range(0,b-1):
        if int(c[u+1])>int(c[u]):
            count+=(int(c[u+1])-int(c[u]))

        elif {{completion}}
            count+=(int(c[u]) - int(c[u+1]))
            current = current - (int(c[u]) - int(c[u+1]))
        


    print(abs(current)+count)",int(c[u+1]) < int(c[u]):,x<0:
"t = int(input())
 
for _ in range(t):
	n = int(input())
	A = list(map(int,input().split()))
	res,r = 0,0
	for i in range(n-1):
		x = A[i+1]-A[i]
		if {{completion}}  
			r+=x
		res+=abs(x)
	res+=abs(r-A[n-1])
	print(res) ",x>0:,r-A[n-1]<=0:
"def solve():
    n = int(input())
    a = [int(i) for i in input().split()]
    dl, dr = 0, 0
    for i in range(1, n):
        if {{completion}}
            dr += (a[i]-dr)-(a[0]-dl)
        else:
            dl += (a[0]-dl)-(a[i]-dr)
    return dl+dr+abs(a[0]-dl)

for _ in range(int(input())):
    print(solve())",a[i]-dr >= a[0]-dl:,x>0:
"v = int(input())

while v > 0:
    n = int(input())
    arr = input().split()
    ori = int(arr[0])
    temp = 0
    ans = 0
    x = 1
    while x < n:
        nex = int(arr[x])
        ans += abs(nex - ori)
        if {{completion}}
            temp += abs(nex - ori)
        ori = nex
        x += 1
    ans += abs(int(arr[0]) - temp)
    print(ans)
    v -= 1",nex - ori < 0:,x < y:
"import sys

T = int(sys.stdin.readline())
for t in range(T):
    n = int(sys.stdin.readline())
    a = [int(x) for x in sys.stdin.readline().strip().split(' ')]
    l, r = 0, 0
    for i in range(len(a) - 1):
        x, y = a[i], a[i+1]
        if x > y:
            l += x - y
        elif {{completion}}
            r += y - x
    print(abs(a[-1]-r)+l+r)

# 4
# 3
# -2 -2 -2
# 3
# 10 4 7
# 4
# 4 -4 4 -4
# 5
# 1 -2 3 -4 5
",x < y:,a[i]>a[i+1]:
"
# 1 0 0 1 0 0
# 0 1 0 0 0 1
# 1 1 1 2 2 2
# 0 1 1 1 1 2
# swap two same number is useless
# each time we swap i and i+1, only prefix of i is changed, either increased by 1 or decreased by 1

# same argument as of inversion, each time inversion can only increased by 1 or decreased by 1
# so in one step we can always move a prefix closer to the expected by 1
# Let s = sum(diff(prefix[a] - prefix[a'])) , we can always achive this in minimum time

# prefix + (0, 1) | (1,0)
# we would like to make every prefix of a is same as a' (with a' is fixed)

# when we swap pair (0,1) in two row, say we are at column j, then the prefix of one row decreased by 1 and the other is increased by 1 form the column j

# 1 1 1 0 0 0
# 0 0 0 1 1 1
# i

# Now let's construct array diff of two row
# Reprahsed of the problem
# In one step, we can either
# 1. increase / decrease any diff by 1
# 2. at a certain column, increase diff of either by 1 and decrease the other by 1  till the last column

# Analysis
# Go from the start since we have increamnt suffix operation
# If both element is same sign ,then add their abs since suffix operation not reduce their diff but also increase the total number of operatons, if on suffix operatons help the rest move closer to the target then we can just apply from the i+1 position to get the same result and take 1 less move
# If there are of different sign
# k = min(abs(row1[i]]), abs(row2[i])) normaly we would take k to make one ddiff move to zeros, but now with suffix opertions, we also move the other closer to 0 by k, so we are have free k more free operations, if this suffix make the rest worst then just apply k reverse suffix operation on i+1 to cancel the efffect so this algorithm always move to a better answer

n = int(input())

a, b, x, y = [list(map(int, input().split())) for _ in range(4)]
s0 = s1 = ans = 0
for m, n, p, q in zip(a, b, x, y):
    s0 += m
    s0 -= p
    s1 += n
    s1 -= q
    while s0 > 0 and s1 < 0:
        ans += 1
        s0 -= 1
        s1 += 1
    while {{completion}}
        ans += 1
        s0 += 1
        s1 -= 1
    ans += abs(s0) + abs(s1)
print(-1 if s1 or s0 else ans)  # finally but prefix must be 0
",s0 < 0 and s1 > 0:,s0 > 0 and s1 < 0:
"n=int(input())
s=input()[::2],input()[::2]
t=input()[::2],input()[::2]

d=[0,0]
total=0
for y in range(n):
    for x in 0,1:
        d[x]+=(s[x][y]==""1"")-(t[x][y]==""1"")
    if d[0]>0 and d[1]<0:
        total+=1
        d[0]-=1
        d[1]+=1
    elif {{completion}}
        total+=1
        d[0]+=1
        d[1]-=1
    total+=abs(d[0])+abs(d[1])
print(total if d==[0,0] else -1)",d[0]<0 and d[1]>0:,d[0] < 0 and d[1] > 0:
"def solve():
    # Size of the matrices.
    n = int(input())
    # Data matrix (the first two rows correspond to the original matrix
    # and the last two to the target matrix).
    matrix = []

    # Read the input data.
    for _ in range(4):
        matrix.append([int(data) for data in input().split()])

    top = 0  # Difference between the prefixes of the first rows of the matrices.
    bottom = 0  # Difference between the prefixes of the second rows of the matrices.
    total = 0  # Total cost of the operations.

    for i in range(n):
        top += (matrix[0][i] - matrix[2][i])  # Update the first prefix.
        bottom += (matrix[1][i] - matrix[3][i])  # Update the second prefix.

        # If the prefix differences have different signs, swap the exceeding one
        # in the positive row to the negative, spending an operation on it.
        if bottom < 0 and 0 < top:
            top -= 1
            bottom += 1
            total += 1
        elif {{completion}}
            top += 1
            bottom -= 1
            total += 1

        # Update the total cost with the cost of fixing this prefix, since the last fix.
        total += abs(top) + abs(bottom)

    # The condition top + bottom == 0 is equivalent to top == 0 && bottom == 0, because top and
    # bottom always have the same sign or at least one is zero.
    # Therefore, if top + bottom != 0, then top != 0 or bottom != 0.
    # This mean the matrices have different amount of one, so the problem is unsolvable.
    if top + bottom != 0:
        return -1

    # Otherwise, the problem has a solution, and it's the total calculated cost.
    return total


print(solve())
",top < 0 and 0 < bottom:,top < 0 and bottom > 0:
"import math

lines = [*open(0)]
sizes = lines[1].split(' ')

tot, running = 0, 0
minval = 0

for lock in sizes:
    tot += int(lock)
    running += 1
    minval = max(minval, tot/running)

for mintime in lines[3:]:
  if {{completion}}
    print(""-1"")
  else:
    print(math.ceil(tot/int(mintime)))",(int(mintime) < minval):,"this is the start of the ground truth
lines = [*open(0)]
sizes = lines[1].split(' ')

tot, running = 0, 0
minval = 0

for lock in sizes:
    tot += int(lock)
    running += 1
    minval = max(minval, tot/running)

for mintime in lines[3:]:
  if mintime < minval:
    print(""-1"")
  else:
    print("
"I=input;n=int(I());p=m=0
for {{completion}}
  p+=int(v);m=max(m,(p+i)//(i+1))
for _ in [0]*int(I()):
  t=int(I());print([-1,(p+t-1)//t][t>=m])","i,v in enumerate(I().split()):","































































































































"
"I=input;n=int(I());p=m=0
for i,v in enumerate(I().split()):
  p+=int(v);m=max(m,(p+i)//(i+1))
for {{completion}}
  t=int(I());print([-1,(p+t-1)//t][t>=m])",_ in [0]*int(I()):,"































































































































"
"import math as ma

r = range
R = lambda: int(input())
num_of_locks = R()
vols_arr = list(map(int, input().split("" "")))
sum_of_vols = 0
avg_vols = []
for _ in r(len(vols_arr)): sum_of_vols += vols_arr[_]; avg_vols += ma.ceil(sum_of_vols/(_ + 1)),
max_avg_vols = max(avg_vols)
for _ in r(R()):
    liters = R(); answer = ma.ceil(sum_of_vols/liters)
    if {{completion}}
        answer = -1
    print(answer)",max_avg_vols > liters:,_ in [0]*int(I()):
"n = int(input())
a = list(map(int, input().split()))
maxi = tot = 0
for i, j in enumerate(a, 1):
    tot += j
    maxi = max(maxi, (tot+i-1) // i)

q = int(input())
for _ in range(q):
    k = int(input())
    if {{completion}}
        print(-1)
    else:
        # open x pipe
        # time = ceil(sum / x) => x increased => time decrease
        # => sum <= x * time -> x >= sum / time -> x = ceil(sum / time) (looking for x min)
        print((tot + k - 1) // k)
",k < maxi:,_ in [0]*int(I()):
"from sys import stdin, stderr


def debug(*args, **kwargs):
    print(*args, file=stderr, **kwargs)


_, volumes, _, *queries = stdin.readlines()
volumes = map(int, volumes.split())
queries = map(int, queries)

s = t_min = 0
for i, v in enumerate(volumes, 1):
    s += v
    div, mod = divmod(s, i)
    t_min = max(t_min, div + (mod != 0))

res = []
for q in map(int, queries):
    if {{completion}}
        ans = -1
    else:
        div, mod = divmod(s, q)
        ans = div + (mod != 0)
    res.append(ans)

print('\n'.join(str(x) for x in res))
",q < t_min:,"i,v in enumerate(I().split()):"
"import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for {{completion}}
    m=max((v[i]-1)//(i+1)+1,m)
for _ in range(int(input())):
    t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)
",i in range(n):,"i,v in enumerate(I().split()):"
"import itertools
m=0
n = int(input())
v = list(itertools.accumulate(map(int, input().split())))

for i in range(n):
    m=max((v[i]-1)//(i+1)+1,m)
for {{completion}}
    t = int(input())
    print((v[-1] - 1) // t + 1 if t >= m else -1)
",_ in range(int(input())):,i in range(n):
"number = int(input())
V = [int(i) for i in input().split()]
time,total = 0,0
for i in range(number):
    total += V[i]
    time = max(time,(total+i)//(i+1))
    pass
for q in range(int(input())):
    t = int(input())
    if{{completion}} print(-1)
    else: print((total+t-1)//t)
    pass",(t<time):,q in [0]*int(I()):
"from math import ceil
r = range;i = lambda: int(input());s = lambda: input().split()
for _ in r(1):
    n = i();v = list(map(int,s()))
    dp = [];sum = 0;max = 0
    for _ in r(n):
        sum += v[_];val = ceil(sum/(_+1))
        dp += val, #comma --> tuple element
        if{{completion}} max = val
    for _ in r(i()): t = i();print(ceil(sum/t)) if(max <= t) else print(-1)",(val > max):,"































































































































"
"#from math import ceil, floor, gcd, log
#import heapq as hq
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft

import sys
input = sys.stdin.readline
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#def insr():
#    s = input()
#    return(list(s[:len(s) - 1]))
#def invr():
#    return(map(int,input().split()))
####################################################
#1) inp — For taking integer inputs.
#2) inlt — For taking List inputs.
#3) insr — For taking string inputs. Returns a List of Characters.
#4) invr — For taking space seperated integer variable inputs.
####################################################
def swp(x1,x2):
    tmp=a[x1[0]][x1[1]]
    a[x1[0]][x1[1]]=a[x2[0]][x2[1]]
    a[x2[0]][x2[1]]=tmp
def fnei(xlst):
    tmpl=[xlst]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def fnei2(xlst):
    tmpl=[]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def chkb(x,y):
    if a[x][y]==1:return False
    for i in fnei2([x,y]):
        if a[x][y]>a[i[0]][i[1]]:
            return False
    else:
        return True
#######################
t=1
#t = int(input())
for tc in range(t):
    n,m = map(int, input().split())
#    n=inp()
#    a=inlt()
#    s=insr()
#    occ=dict();
#    for i in range(n):occ[i]=[]
#    for i in range(n):
#        occ[i].append(inlt())
    a=[]
    for i in range(n):
        a.append(inlt())

    b=[]
    for i in range(n):
        for j in range(m):
            if chkb(i,j):b.append([i,j])
    if len(b)==0:print(0);continue
    if len(b)>2:print(2);continue
    cter=0
    bnei=fnei(b[0])
    for j in bnei:
        for i1 in range(n):
            for i2 in range(m):
                i=[i1,i2]
                if i==b[0]:continue
#                print(a,a[i[0]][i[1]],a[j[0]][j[1]])
                swp(i,j)
                flag=1
                for k in fnei(i)+fnei(j):
                    if chkb(k[0],k[1]):flag=0;break
                if len(b)>1:
                    for k2 in range(1,len(b)):
                        if {{completion}}flag=0;break
                swp(i,j)
#                print(a,i,j)
                if flag:cter+=1;#print('success',i,j)
    if cter==0: # all single move efforts failed
        print(2)
    else:
        print(1,cter)
    
#print(*a2,sep=' ')
#print("" "".join(str(i) for i in a2))
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i] #sum[:ax]=psa[x]
","chkb(b[k2][0],b[k2][1]):","































































































































"
"#from math import ceil, floor, gcd, log
#import heapq as hq
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft

import sys
input = sys.stdin.readline
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#def insr():
#    s = input()
#    return(list(s[:len(s) - 1]))
#def invr():
#    return(map(int,input().split()))
####################################################
#1) inp — For taking integer inputs.
#2) inlt — For taking List inputs.
#3) insr — For taking string inputs. Returns a List of Characters.
#4) invr — For taking space seperated integer variable inputs.
####################################################
def swp(x1,x2):
    tmp=a[x1[0]][x1[1]]
    a[x1[0]][x1[1]]=a[x2[0]][x2[1]]
    a[x2[0]][x2[1]]=tmp
def fnei(xlst):
    tmpl=[xlst]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def fnei2(xlst):
    tmpl=[]
    if xlst[0]>0:tmpl.append([xlst[0]-1,xlst[1]])
    if xlst[1]>0:tmpl.append([xlst[0],xlst[1]-1])
    if xlst[0]<n-1:tmpl.append([xlst[0]+1,xlst[1]])
    if xlst[1]<m-1:tmpl.append([xlst[0],xlst[1]+1])
    return tmpl
def chkb(x,y):
    if a[x][y]==1:return False
    for i in fnei2([x,y]):
        if a[x][y]>a[i[0]][i[1]]:
            return False
    else:
        return True
#######################
t=1
#t = int(input())
for tc in range(t):
    n,m = map(int, input().split())
#    n=inp()
#    a=inlt()
#    s=insr()
#    occ=dict();
#    for i in range(n):occ[i]=[]
#    for i in range(n):
#        occ[i].append(inlt())
    a=[]
    for i in range(n):
        a.append(inlt())

    b=[]
    for i in range(n):
        for j in range(m):
            if chkb(i,j):b.append([i,j])
    if len(b)==0:print(0);continue
    if len(b)>2:print(2);continue
    cter=0
    bnei=fnei(b[0])
    for j in bnei:
        for i1 in range(n):
            for i2 in range(m):
                i=[i1,i2]
                if i==b[0]:continue
#                print(a,a[i[0]][i[1]],a[j[0]][j[1]])
                swp(i,j)
                flag=1
                for k in fnei(i)+fnei(j):
                    if {{completion}}flag=0;break
                if len(b)>1:
                    for k2 in range(1,len(b)):
                        if chkb(b[k2][0],b[k2][1]):flag=0;break
                swp(i,j)
#                print(a,i,j)
                if flag:cter+=1;#print('success',i,j)
    if cter==0: # all single move efforts failed
        print(2)
    else:
        print(1,cter)
    
#print(*a2,sep=' ')
#print("" "".join(str(i) for i in a2))
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i] #sum[:ax]=psa[x]
","chkb(k[0],k[1]):","































































































































"
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


from itertools import chain

def near(r, c, itself = False):
    if itself:
        yield (r, c)
    if 0 < r:
        yield (r - 1, c)
    if r + 1 < n:
        yield (r + 1, c)
    if 0 < c:
        yield (r, c - 1)
    if c + 1 < m:
        yield (r, c + 1)
#    R = []
#    if itself:
#        R.append((r, c))
#    if 0 < r:
#        R.append((r - 1, c))
#    if r + 1 < n:
#        R.append((r + 1, c))
#    if 0 < c:
#        R.append((r, c - 1))
#    if c + 1 < m:
#        R.append((r, c + 1))

#    return R

def ok(x, y):
    v = A[x][y]
    if v == 1:
        return True

    return any(A[r][c] < v for r, c in near(x, y))


def swapAndCheck(r1, c1, r2, c2):
    if (r1 , c1) != (r2, c2):
        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        flag = ok(r1, c1) and ok(r2, c2) and all(ok(r, c) for r, c in chain(near(r1, c1), near(r2, c2), H[1:]))

        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        return flag

    return False


n, m = map(int, input().split())

A = []
for _ in range(n):
    A.append(list(map(int, input().split())))


H = list({(r, c) for r in range(n) for c in range(m) if not ok(r, c)})

if not H:
    print(""0"")
elif len(H) > 2:
    print(""2"")
else:
    r1, c1 = H[0]
    w = 0

    for r, c in near(r1, c1, True):
        for x in range(n):
            for y in range(m):
                if {{completion}}
                    w += 1
        
    if w != 0:
        print(""1 {}"".format(w))
    else:
        print(""2"")

","(r1 != x or c1 != y) and swapAndCheck(r, c, x, y):","r1, c1 in H:"
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


from itertools import chain

def near(r, c, itself = False):
    if itself:
        yield (r, c)
    if 0 < r:
        yield (r - 1, c)
    if r + 1 < n:
        yield (r + 1, c)
    if 0 < c:
        yield (r, c - 1)
    if c + 1 < m:
        yield (r, c + 1)
#    R = []
#    if itself:
#        R.append((r, c))
#    if 0 < r:
#        R.append((r - 1, c))
#    if r + 1 < n:
#        R.append((r + 1, c))
#    if 0 < c:
#        R.append((r, c - 1))
#    if c + 1 < m:
#        R.append((r, c + 1))

#    return R

def ok(x, y):
    v = A[x][y]
    if v == 1:
        return True

    return any(A[r][c] < v for r, c in near(x, y))


def swapAndCheck(r1, c1, r2, c2):
    if (r1 , c1) != (r2, c2):
        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        flag = ok(r1, c1) and ok(r2, c2) and all(ok(r, c) for r, c in chain(near(r1, c1), near(r2, c2), H[1:]))

        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]

        return flag

    return False


n, m = map(int, input().split())

A = []
for _ in range(n):
    A.append(list(map(int, input().split())))


H = list({(r, c) for r in range(n) for c in range(m) if not ok(r, c)})

if not H:
    print(""0"")
elif len(H) > 2:
    print(""2"")
else:
    r1, c1 = H[0]
    w = 0

    for r, c in near(r1, c1, True):
        for x in range(n):
            for {{completion}}
                if (r1 != x or c1 != y) and swapAndCheck(r, c, x, y):
                    w += 1
        
    if w != 0:
        print(""1 {}"".format(w))
    else:
        print(""2"")

",y in range(m):,"r1, c1 in H:"
"import os
import sys
from io import BytesIO, IOBase

#_str = str
#str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n, m = list(map(int, input().strip().split(' ')))
    g = [list(map(int, input().strip().split(' '))) for _ in range(n)]
    bfs = set()
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    def check(x, y):
        if g[x][y] == 1:
            return True
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and g[x][y] > g[nx][ny]:
                return True
        return False

    def check5(x, y):
        if not check(x, y):
            return False
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and not check(nx, ny):
                return False
        return True

    bad = list()
    for x in range(n):
        for y in range(m):
            if g[x][y] == 1:
                continue
            if not check(x, y):
                bad.append([x, y])
    if not bad:
        print(0)
    elif len(bad) > 5:
        print(2)
    else:
        candidate = [bad[0]]
        for i in range(4):
            nx, ny = bad[0][0] + dx[i], bad[0][1] + dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                candidate.append([nx, ny])
        res = 0
        for cx, cy in candidate:
            for x in range(n):
                for y in range(m):
                    if x == bad[0][0] and y == bad[0][1]:
                        continue
                    if cx == x and cy == y:
                        continue
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
                    flag = True
                    for bx, by in bad:
                        if {{completion}}
                            flag = False
                            break
                    if flag and check5(x, y) and check5(cx, cy):
                        res += 1
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
        if res == 0:
            print(2)
        else:
            print(1, res)


    return

main()","not check(bx, by):","































































































































"
"import os
import sys
from io import BytesIO, IOBase

#_str = str
#str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n, m = list(map(int, input().strip().split(' ')))
    g = [list(map(int, input().strip().split(' '))) for _ in range(n)]
    bfs = set()
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    def check(x, y):
        if g[x][y] == 1:
            return True
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and g[x][y] > g[nx][ny]:
                return True
        return False

    def check5(x, y):
        if not check(x, y):
            return False
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and not check(nx, ny):
                return False
        return True

    bad = list()
    for x in range(n):
        for y in range(m):
            if g[x][y] == 1:
                continue
            if not check(x, y):
                bad.append([x, y])
    if not bad:
        print(0)
    elif len(bad) > 5:
        print(2)
    else:
        candidate = [bad[0]]
        for i in range(4):
            nx, ny = bad[0][0] + dx[i], bad[0][1] + dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                candidate.append([nx, ny])
        res = 0
        for cx, cy in candidate:
            for x in range(n):
                for y in range(m):
                    if x == bad[0][0] and y == bad[0][1]:
                        continue
                    if cx == x and cy == y:
                        continue
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
                    flag = True
                    for {{completion}}
                        if not check(bx, by):
                            flag = False
                            break
                    if flag and check5(x, y) and check5(cx, cy):
                        res += 1
                    g[cx][cy], g[x][y] = g[x][y], g[cx][cy]
        if res == 0:
            print(2)
        else:
            print(1, res)


    return

main()","bx, by in bad:","































































































































"
"from collections import Counter
import heapq
for _ in range(int(input())):
    _ = input()
    l = input().split()
    cnt = Counter(l)
    x = list(cnt.values())
    x.append(1)
    
    
    hp = []
    x.sort()
    for i, n in enumerate(x):
        if {{completion}}
            heapq.heappush(hp, -(n-i-1))
    
    cnt = 0
    while hp and cnt + hp[0] < 0:
        n = heapq.heappop(hp)
        heapq.heappush(hp, n+1)
        cnt += 1
    print(len(x)+cnt)",n-i-1 > 0:,hp and cnt + hp[0] < 0:
"t = int(input())

for i in range(t):
    n = int(input())
    p = [int(value) for value in input().split()]
    
    tree = [0] * n
	
    for i in range(len(p)):
	    tree[p[i] - 1] += 1
	    
    tree = sorted(tree)
    resposta = 0
    r = n
	
    while resposta <= r:
        s = 0
        c = 1
        m = (resposta + r) // 2
        neg1 = -1
        
        for i in range(n + neg1, neg1, neg1):
            if {{completion}}
                break
            
            aux = tree[i] + s - m
            c += max(0, aux)
            s += 1
        
        if m - s >= c:
            r = m - 1
        
        else:
            resposta = m + 1
    
    print(resposta)",tree[i] == 0:,s <= m:
"from heapq import *

for _ in range(int(input())):
    n = int(input())
    pp = list(map(int, input().split()))
    sibs = [[] for _ in range(n+1)]
    for i,p in enumerate(pp, 2):
        sibs[p].append(i)
    child_infected = [False] * (n+1)
    isibs = sorted(range(1, n+1), key=lambda x:len(sibs[x]), reverse=True)
    remain = n
    to_spread = []
    for turn, isib in enumerate(isibs):
        children = sibs[isib]
        while {{completion}}
            heappop(to_spread)
        remain -= len(to_spread)
        child_infected[isib] = True
        heappush(to_spread, (len(children)+turn, isib))
        remain -= 1
        if remain <= 0:
            break
    print(turn+1)
",to_spread and to_spread[0][0] <= turn:,remain <= 0:
"from heapq import *

for _ in range(int(input())):
    n = int(input())
    pp = list(map(int, input().split()))
    sibs = [[] for _ in range(n+1)]
    for i,p in enumerate(pp, 2):
        sibs[p].append(i)
    child_infected = [False] * (n+1)
    isibs = sorted(range(1, n+1), key=lambda x:len(sibs[x]), reverse=True)
    remain = n
    to_spread = []
    for turn, isib in enumerate(isibs):
        children = sibs[isib]
        while to_spread and to_spread[0][0] <= turn:
            heappop(to_spread)
        remain -= len(to_spread)
        child_infected[isib] = True
        heappush(to_spread, (len(children)+turn, isib))
        remain -= 1
        if {{completion}}
            break
    print(turn+1)
",remain <= 0:,remain <= 0:
"from sys import stdin, stdout
from collections import defaultdict

t = int(stdin.readline())

for _ in range(t):
    n = int(stdin.readline())
    parents = [int(x) for x in stdin.readline().split()]
    counts = defaultdict(int)
    counts[0] = 1
    for i in parents:
        counts[i] += 1

    lives = [counts[i] for i in counts]
    lives.sort(reverse=True)

    for i in range(len(lives)):
        lives[i] -= len(lives)-i

    answer = len(lives)

    while max(lives) > 0:
        current_max = -1
        max_index = -1
        for i in range(len(lives)):
            lives[i] -= 1
            if {{completion}}
                current_max = lives[i]
                max_index = i
        lives[max_index] -= 1
        answer += 1

    stdout.write(""{}\n"".format(answer))
",lives[i] > current_max:,lives[i] > 0:
"for _ in [0] * int(input()):
    n = int(input())
    a = list(map(int, input().split()))
    c = [0] * n + [1]
    for i in a:
        c[i - 1] += 1
    c = sorted(c, reverse=True)
    ans = sum(i > 0 for i in c)
    for i, j in enumerate(c):
        if j > 0:
            c[i] = i + j - ans
    c = sorted([i for i in c if i > 0], reverse=True)
    while c:
        ans += 1
        for i, j in enumerate(c):
            if {{completion}}
                c[i] = j - 1 - (i == 0)
        c = sorted([i for i in c if i > 0], reverse=True)
    print(ans)
",j > 0:,i>0:
"inf=10**18
dxy=[(0,1), (1,0), (-1, 0), (0, -1)]
mod=10**9+7
MOD=998244353
from collections import Counter

def solve():
    n = int(input())
    p = [int(i)-1 for i in input().split()]
    c = Counter(p)

    ans = len(c.values())+1
    adi = []
    for i, n in enumerate(sorted(c.values(), reverse=True)):
        if n+i-ans>0:
            adi.append(n+i-ans)
    if adi:
        adi.sort(reverse=True)
        cnt = 0
        #bi search
        r = max(adi)+1
        l = 0
        def is_ok(x):
            d = 0
            for {{completion}}
                d += max(0, i-x)
            return d-x<=0

        while r-l>1:
            mid = (r+l)//2
            if is_ok(mid):r = mid 
            else: l = mid
        ans += r
    return ans


def main():
    T = int(input())
    for _ in range(T):
        print(solve())


main()",i in adi:,is_ok(mid):
"inf=10**18
dxy=[(0,1), (1,0), (-1, 0), (0, -1)]
mod=10**9+7
MOD=998244353
from collections import Counter

def solve():
    n = int(input())
    p = [int(i)-1 for i in input().split()]
    c = Counter(p)

    ans = len(c.values())+1
    adi = []
    for i, n in enumerate(sorted(c.values(), reverse=True)):
        if n+i-ans>0:
            adi.append(n+i-ans)
    if adi:
        adi.sort(reverse=True)
        cnt = 0
        #bi search
        r = max(adi)+1
        l = 0
        def is_ok(x):
            d = 0
            for i in adi:
                d += max(0, i-x)
            return d-x<=0

        while r-l>1:
            mid = (r+l)//2
            if {{completion}}r = mid 
            else: l = mid
        ans += r
    return ans


def main():
    T = int(input())
    for _ in range(T):
        print(solve())


main()",is_ok(mid):,i in adi:
"from heapq import heappop, heappush

t = int(input())
const = 1 << 18

for T in range(t):
    n = int(input())
    arr = [int(x) for x in input().split("" "")]

    things = {0: const}
    for x in range(len(arr)):
        if arr[x] in things:
            things[arr[x]] += 1
        else:
            things[arr[x]] = const

    laze = []
    for x in things:
        heappush(laze, -things[x])

    time = 0
    while len(laze) > 0:

        f = -laze[0]

        if f <= time:
            heappop(laze)
            continue
        elif f >= const:
            f -= const
            f += time + 1
            heappop(laze)

            if {{completion}}
                heappush(laze, -f)
        else:
            f -= 1
            heappop(laze)

            if f > time:
                heappush(laze, -f)
        time += 1
    print(time)
",f > time:,f > time:
"from heapq import heappop, heappush

t = int(input())
const = 1 << 18

for T in range(t):
    n = int(input())
    arr = [int(x) for x in input().split("" "")]

    things = {0: const}
    for x in range(len(arr)):
        if arr[x] in things:
            things[arr[x]] += 1
        else:
            things[arr[x]] = const

    laze = []
    for x in things:
        heappush(laze, -things[x])

    time = 0
    while len(laze) > 0:

        f = -laze[0]

        if f <= time:
            heappop(laze)
            continue
        elif f >= const:
            f -= const
            f += time + 1
            heappop(laze)

            if f > time:
                heappush(laze, -f)
        else:
            f -= 1
            heappop(laze)

            if {{completion}}
                heappush(laze, -f)
        time += 1
    print(time)
",f > time:,f > time:
"from collections import defaultdict

counter = defaultdict(int)

def solve(a):
    for ai in a:
        counter[ai] += 1
    count = list(counter.values())
    num_level = len(count)
    count.sort()

    for i in range(num_level):
        count[i] = max(count[i] - i - 2, 0)
    
    L = 0; R = max(count)

    if R == 0:
        return num_level + 1

    def check(k):
        b = count.copy()
        for {{completion}}
            b[i] = max(b[i] - k, 0)
        if sum(b) <= k:
            return True
        return False

    while R - L > 1:
        mid = (R + L) // 2
        if(check(mid)):
            R = mid
        else:
            L = mid

    return num_level + 1 + R

for a in [*open(0)][2::2]:
    counter.clear()
    res = solve(a.split())
    print(res)",i in range(len(b)):,sum(b) <= k:
"from collections import defaultdict

counter = defaultdict(int)

def solve(a):
    for ai in a:
        counter[ai] += 1
    count = list(counter.values())
    num_level = len(count)
    count.sort()

    for i in range(num_level):
        count[i] = max(count[i] - i - 2, 0)
    
    L = 0; R = max(count)

    if R == 0:
        return num_level + 1

    def check(k):
        b = count.copy()
        for i in range(len(b)):
            b[i] = max(b[i] - k, 0)
        if {{completion}}
            return True
        return False

    while R - L > 1:
        mid = (R + L) // 2
        if(check(mid)):
            R = mid
        else:
            L = mid

    return num_level + 1 + R

for a in [*open(0)][2::2]:
    counter.clear()
    res = solve(a.split())
    print(res)",sum(b) <= k:,i in range(len(b)):
"from collections import Counter
for _ in range(int(input())):
    n = int(input())
    m = max(Counter(input().split()).values())
    ans = n-m
    while {{completion}}
        ans += 1
        m *= 2
    print(ans)
",m<n:,m<n:
"from collections import*
for a in[*open(0)][2::2]:
 n=len(a:=a.split());m=max(Counter(a).values());r=0
 while {{completion}}r+=min(m,n-m)+1;m*=2
 print(r)",m<n:,m<n:
"import math

for t in range(int(input())):
    n=int(input())
    L=input().split()
    count={}
    for {{completion}}
        try:
            count[i]+=1
        except:
            count[i]=1
    m=max(list(count.values()))
    print(int(n-m + math.ceil(math.log(n/m,2))))",i in L:,m<n:
"if True:
    from collections import Counter
    t = int(input())
    for {{completion}}
        n = int(input())
        d = Counter(input().split()).most_common(1)[0][1]
        print([i for i in range(18) if (2**i)*d >= n][0]+n-d)",_ in range(t):,n<2**i:
"from sys import stdin
t = int(stdin.readline())
while t>0:
     t -= 1
     n = int(stdin.readline())
     a = sorted(list(map(int,stdin.readline().split())))
     M = 1
     temp = 1
     for i in range(1,n):
          if {{completion}}
               temp = 1
          else:
               temp += 1
          M = max(M,temp)
     ind = 0
     temp = M
     while temp<n:
          ind += 1
          temp *= 2
     print(n-M+ind)
",a[i]>a[i-1]:,M<n:
"for i in range(int(input())):
	n=int(input())
	a=input().split()
	from collections import Counter

	e,bb=Counter(a).most_common(1)[0]
	c=n-bb
	while {{completion}}
		c+=1
		bb*=2
	print(c)",bb<n:,bb<n:
"from collections import Counter

for li in[*open(0)][2::2]:
    n=len(li:=li.split());
    m = max(Counter(li).values())
    ans =n-m
    while{{completion}}
        ans+=1
        
        m=2*m
    print(ans)",(m<n):,m<n:
"from collections import Counter
def solve():
    n = int(input())
    freq = max(Counter(input().split()).values())
    left = n -  freq
    ans=0
    while{{completion}}
        ans += 1+min(left,freq)
        left = left - min(left,freq)
        freq=2*freq
            
    print(ans)

while(True):
    try:
        test = int(input())
    except EOFError:
        break
    for i in range (test):
        solve()
",(left):,m<n:
"from collections import Counter
def solve():
    n = int(input())
    freq = max(Counter(input().split()).values())
    left = n -  freq
    ans=0
    while(left):
        ans += 1+min(left,freq)
        left = left - min(left,freq)
        freq=2*freq
            
    print(ans)

while(True):
    try:
        test = int(input())
    except EOFError:
        break
    for {{completion}}
        solve()
",i in range (test):,(left):
"from sys import stdin, stdout
from collections import Counter
for _ in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())
    b = a =  max(Counter(stdin.readline().split()).items(), key = lambda x:x[1])[1]
    ans = n - a
    while {{completion}}
        a = a + a
        ans += 1
    stdout.write(f""{str(ans)}\n"")
",a < n:,n<b:
"N=int(input())
for _ in range(N):
    n = int(input())
    list_num = input().split(' ')

    d = dict()
    for num in list_num:
        if {{completion}}
            d[num] = d[num] + 1
        else:
            d[num] = 1
    max_num = max(d.values())

    now = max_num
    ans = 0
    copy = 0
    while now < n:
        if copy > 0:
            ans += 1
            copy -= 1
            now += 1

        else:
            ans += 1
            copy = now
    
    print (ans)
",num in d:,copy > 0:
"N=int(input())
for _ in range(N):
    n = int(input())
    list_num = input().split(' ')

    d = dict()
    for num in list_num:
        if num in d:
            d[num] = d[num] + 1
        else:
            d[num] = 1
    max_num = max(d.values())

    now = max_num
    ans = 0
    copy = 0
    while now < n:
        if {{completion}}
            ans += 1
            copy -= 1
            now += 1

        else:
            ans += 1
            copy = now
    
    print (ans)
",copy > 0:,m<n:
"t=int(input())
for i in range (t):
    n = int(input())
    m=n//4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif {{completion}}
        print(m,2*m,m,1,end=' ')
    elif n%4==2:
        print(2*m-1,2*m+1,1,1,end=' ')
    else:
        print(2,4*m-2,2,1,end=' ')
    print(sep='')    ",n%4==1:,"































































































































"
"t=int(input())
for i in range (t):
    n = int(input())
    m=n//4
    if n%4==0:
        print(m,m,m,m,end=' ')
    elif n%4==1:
        print(m,2*m,m,1,end=' ')
    elif {{completion}}
        print(2*m-1,2*m+1,1,1,end=' ')
    else:
        print(2,4*m-2,2,1,end=' ')
    print(sep='')    ",n%4==2:,n%4==2:
"for _ in range(int(input())):
    n = int(input())

    if n == 4:
        a = b = c = d = 1

    elif n == 5:
        a = c = d = 1
        b = 2

    elif n == 6:
        a = c = d = 1
        b = 3

    elif {{completion}}
        c = d = b = 2
        a = n-6

    elif n%4 == 1:
        d = 1
        c = 2
        a = 2
        b = n-5

    elif n%4 == 2:
        d = 1
        c = 1
        a = (n-2)//2 - 1
        b = (n-2)//2 + 1

    else:
        d = 1
        c = 2
        b = 2
        a = n-5

    print(a, b, c, d)",n%4 == 0:,n%4==3:
"for _ in range(int(input())):
    n = int(input())

    if n == 4:
        a = b = c = d = 1

    elif n == 5:
        a = c = d = 1
        b = 2

    elif n == 6:
        a = c = d = 1
        b = 3

    elif n%4 == 0:
        c = d = b = 2
        a = n-6

    elif {{completion}}
        d = 1
        c = 2
        a = 2
        b = n-5

    elif n%4 == 2:
        d = 1
        c = 1
        a = (n-2)//2 - 1
        b = (n-2)//2 + 1

    else:
        d = 1
        c = 2
        b = 2
        a = n-5

    print(a, b, c, d)",n%4 == 1:,n%4==1:
"t = int(input())
for _ in range(t):
    n = int(input())
    ans = []
    if n == 5:
        ans = [1, 2, 1, 1]
    elif {{completion}}
        ans = [n // 4] * 4
    elif n % 2 == 0:
        ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]
    else:
        a, c, d = 2, 2, 1
        b = n - a - c - d
        ans = [a, b, c, d]
    print(' '.join([str(a) for a in ans]))
",n % 4 == 0:,n%2 == 0:
"t = int(input())
for _ in range(t):
    n = int(input())
    ans = []
    if n == 5:
        ans = [1, 2, 1, 1]
    elif n % 4 == 0:
        ans = [n // 4] * 4
    elif {{completion}}
        ans = [(n - 2) // 2 - 1, (n - 2) // 2 + 1, 1, 1]
    else:
        a, c, d = 2, 2, 1
        b = n - a - c - d
        ans = [a, b, c, d]
    print(' '.join([str(a) for a in ans]))
",n % 2 == 0:,n % 2 == 0:
"for _ in range(int(input())):
    a=int(input())
    if a%4==0:
        print(a//4,a//4,a//4,a//4)
    else:
        if a%2==1:
            a1=(a-1)
            if a1%3==0:
                print(a1//3,a1//3,a1//3,1)
            elif a1%4!=0:
                a1=a-2
                print(a1//2,a1//2+1,1,1)
            elif {{completion}}
                print(a1//4,a1//2,a1//4,1)
        else:
            a1=a-2
            print(a1//2-1,a1//2+1,1,1)
        
    ",a1%4==0:,a%4==1:
"t = int(input())
for test in range(t):
    a = []
    while len(a) != 8:
        s = input()
        if (len(s) == 8):
            a.append(s)
 
    x = 0
    y = 0
 
    for i in range(1, 7):
        for j in range(1, 7):
            if {{completion}}
                x = i
                y = j
    print(x + 1, y + 1)
 
    
 
    
",(a[i][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j-1] == '#'):,a[i][j]=='X':
"import sys
n = int(input())
a = [int(x)-1 for x in sys.stdin.readline().split()]
depth = [1]*n
best = [0]*n
for i in range(n-1, -1, -1):
    best[i] = max(best[i], depth[i])
    if {{completion}}
        parent = a[i-1]
        depth[parent] = max(depth[parent], 1 + depth[i])
        best[parent] += best[i]
print(best[0])
",i != 0:,"i in range(n-1, -1, -1):"
"mod = 998244353


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    P = [0, 0] + list(map(int, input().split()))

    child = [[] for _ in range(N + 1)]
    for v in range(2, N+1):
        p = P[v]
        child[p].append(v)

    dp = [0] * (N + 1)
    dp2 = [0] * (N + 1)
    for v in range(N, 0, -1):
        if not child[v]:
            dp2[v] = 1
            dp[v] = 1
        else:
            S = 0
            D = 0
            for {{completion}}
                S += dp[c]
                D = max(D, dp2[c])
            dp2[v] = D + 1
            dp[v] = max(S, D + 1)
    print(dp[1])
    #print(dp, dp2)


if __name__ == '__main__':
    main()
",c in child[v]:,"i in range(N, 0, -1):"
"n=int(input())
a=[-1]+[int(o)-1 for o in input().split()]
f=[0]*n
dp=[0]*n
for {{completion}}
  f[a[i]]=max(f[i]+1,f[a[i]])
for i in range(n-1,0,-1):
  dp[i]=max(dp[i],f[i]+1)
  dp[a[i]]+=dp[i]
print(max(dp[0],f[0]+1))","i in range(n-1,0,-1):","i in range(n-1,0,-1):"
"n=int(input())
a=[-1]+[int(o)-1 for o in input().split()]
f=[0]*n
dp=[0]*n
for i in range(n-1,0,-1):
  f[a[i]]=max(f[i]+1,f[a[i]])
for {{completion}}
  dp[i]=max(dp[i],f[i]+1)
  dp[a[i]]+=dp[i]
print(max(dp[0],f[0]+1))","i in range(n-1,0,-1):","i in range(n-1,0,-1):"
"I,G=input,range;n=int(I());p=[-1,0]+[*map(int,I().split())];h=[1]*(n+1);F=[0]*(n+1)
for {{completion}}h[p[i]]=max(h[i]+1,h[p[i]])
for i in G(n,0,-1):F[i]=max(F[i],h[i]);F[p[i]]+=F[i]
print(F[1])","i in G(n,1,-1):","i in G(n,0,-1):"
"I,G=input,range;n=int(I());p=[-1,0]+[*map(int,I().split())];h=[1]*(n+1);F=[0]*(n+1)
for i in G(n,1,-1):h[p[i]]=max(h[i]+1,h[p[i]])
for {{completion}}F[i]=max(F[i],h[i]);F[p[i]]+=F[i]
print(F[1])","i in G(n,0,-1):","i in G(n,1,-1):"
"n = int(input())
a = [*map(lambda x:int(x)-1,input().split())]
edge = [[] for _ in range(n)]
for i,p in enumerate(a,1): edge[p] += i,

dp = [[1,0] for _ in range(n)]
for r in range(n-1,-1,-1):
    for {{completion}} 
        k = max(dp[v])
        dp[r][1] += k
        dp[r][0] = max(dp[r][0],dp[v][0]+1)
print(max(dp[0]))",v in edge[r]:,"i in range(n-1,0,-1):"
"from sys import stdin, stdout
from collections import defaultdict
N = 998244353

n = int(stdin.readline())
a = [int(x)-1 for x in stdin.readline().split()]

count = [0]*n
row_values = [0]*n

for i in range(n):
    row_values[count[a[i]]] += 1
    count[a[i]] += 1

row_values_pref = [row_values[0]]
for i in range(1,n):
    row_values_pref.append(row_values_pref[-1]+row_values[i])

dp = [[0]*(n+1) for bar in range(n+1)]

for i in range(1,row_values[0]+1):
    dp[i][i] = 1

for i in range(1,n):
    for total in range(n-1,0,-1):
        current = 0
        for last in range(total//i, 0, -1):
            current += dp[total][last]
            current %= N
            dp[total][last] = 0

            if {{completion}}
                dp[total+last][last] += current
                dp[total+last][last] %= N

answer = 0
for i in range(1,n+1):
    answer += dp[n][i]
    answer %= N

stdout.write(str(answer)+'\n')
","last <= min(row_values_pref[i]-total, n-total):",total//i <= last:
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1

M = 998244353


def solve():
    n = getInt()
    a = list(getList())
    cnt = [0] * n
    for i in a:
        cnt[i-1] += 1

    lim = [0] * (n+1)

    col = 0  # the number of remaining columns, initial col = number of distinct element
    f = [0] * (n+1)  # frequent of the height of columns
    for i, j in enumerate(cnt):
        col += j > 0
        f[j] += 1

    for i in range(1, n+1):
        lim[i] = lim[i-1] + col
        col -= f[i]
    dp = [[0] * (n+1) for _ in range(n+1)]

    dp[0][0] = 1
    for x in range(n, 0, -1):
        # dp[i][j] used elements + size of multiset
        for j in range(n):
            # transition
            # x * j <= n
            # i+x <= lim[j+1]
            if j * x > n:
                break
            for i in range(n-x+1):
                if {{completion}}
                    dp[i+x][j+1] += dp[i][j]
                    dp[i+x][j+1] %= M
    print(sum(dp[n]) % M)


for _ in range(t):
    solve()
",i + x <= lim[j+1]:,x <= lim[j+1]:
"g=10**9+7
v=[1]+[0]*40001
for i in range(1,40001):
 if str(i)==str(i)[::-1]:
  for {{completion}}v[j]=v[j]%g+v[j-i]
for n in[*open(0)][1:]:print(v[int(n)]%g)","j in range(i,40001):","j in R(i,40001):"
"p=[]
for i in range(1,40004):
  s=str(i)
  if s==s[::-1]:
    p+=[i]
n=40004
d=[0]*(n+1)
for pj in p:
  d[0] = 1
  for i in range(1,n+1):
    if {{completion}}
      d[i]+=d[i-pj]
    d[i]=d[i]%int(1e9+7)
for _ in range(int(input())):
  print(d[int(input())])
        
  
    
      
",pj<=i:,d[i]+=d[i-pj]
"n = int(input())


def getList():
    return map(int, input().split())


def getInt():
    return int(input())


N = 4 * 10 ** 4 + 10
M = 10 ** 9 + 7
dp = [0] * N

for i in range(1, N):
    if str(i) == str(i)[::-1]:
        dp[i] += 1
        for {{completion}}
            dp[j] += dp[j-i]
            dp[j] %= M


def solve():
    n = getInt()
    print(dp[n])


for _ in range(n):
    solve()
","j in range(i, N):","j in range(i, N):"
"from sys import stdin,stdout
input = lambda : stdin.readline().rstrip()
print =lambda x : stdout.write(str(x))

dp = [0 for _ in range(40002)]
dp[0] = 1
for i in range(1, 40001):
    if str(i) == str(i)[::-1]:
        for {{completion}}
            dp[j] = (dp[j]+dp[j-i])%int(1e9+7)
for _ in range(int(input())):
    print(f""{dp[int(input())]}\n"")

","j in range(i, 40001):","i in range(j, 40001):"
"R=range
m=40001
d=10**9+7
p=[]
for i in R(1,m):
    n=str(i)
    if {{completion}}p+=[i]
a=[1]+[0]*m
for i in p:
    for j in R(i,m):
        a[j]+=a[j-i];a[j]%=d
for n in[*open(0)][1:]:print(a[int(n)])",n==n[::-1]:,"j in R(i,m):"
"R=range
m=40001
d=10**9+7
p=[]
for i in R(1,m):
    n=str(i)
    if n==n[::-1]:p+=[i]
a=[1]+[0]*m
for i in p:
    for {{completion}}
        a[j]+=a[j-i];a[j]%=d
for n in[*open(0)][1:]:print(a[int(n)])","j in R(i,m):","i in R(i,m):"
"import sys
input  = sys.stdin.readline
s = []
c = [1]
for y in range(1,40005):
    if str(y) == (str(y))[::-1]:
        s.append(y)
    c.append(0)


for i in s:
    for j in range(1,40005):
        if {{completion}}
            c[j] += (c[j - i]) % ((10 ** 9) + 7) 
            
a = int(input())
 
for y in range(a):
    b = int(input())
    print(c[b] % ((10 ** 9) + 7))
",j >= i:,y==y[::-1]:
"d=[0]*40001
d[0]=1
for x in range(1,40001):
    if str(x)==str(x)[::-1]:
        for {{completion}}
            d[i]=(d[i]+d[i-x])%(10**9+7)
for _ in range(int(input())):
    print(d[int(input())])
","i in range(x,40001):","i in range(x,40001):"
"size = int(4e4)+1
ps=[]
i=1
while (i<size):
    if str(i) == str(i)[::-1]:
        ps.append(i)
    i+=1
 
pm = [0]*size
pm[0]=1
for p in ps:
    i=0
    while (i<size):
        if {{completion}}
            break
        pm[i+p]+=pm[i]
        pm[i+p]%=int(1e9)+7
        i+=1
 
T = int(input())
for _ in range(T):
    n = int(input())
    print(pm[n])
",i+p >= size:,p in ps:
"for {{completion}}
    s = input()
    c = len(set(s))
    print(""Yes"" if all(len(set(s[i::c])) == 1 for i in range(c)) else ""No"")
",_ in range(int(input())):,len(set(s[i::c]))==1:
"import sys
input = sys.stdin.readline

n = int(input())
for _ in range(n):
    s = input()[:-1]
    a = len(s)
    b = len(set(s))
    if b == 1 or a == b:
        print('YES')
    else:
        for i in range(1, a):
            if s[i] in s[:i]:
                w = (s[:i]*a)[:a]
                if {{completion}}
                    print(""YES"")
                else:
                    print(""NO"")
                break",s == w:,(s[i]!= s[i - b]):
"t = int(input())
while (t > 0):
    t -= 1
    s = str(input())
    var = set(s)
    ans = ""YES""
    for i in range(len(s)-len(var)+1):
        if {{completion}}
            ans = ""NO""
            break
    print(ans)",len(set(s[i:i+len(var)])) != len(var):,(i + len(var) < len(s) and s[i]!= s[i + len(var)]):
"def solve(s):
    st=set(s)
    a=len(st)
    f=1
    for i in range(len(s)):
        if {{completion}}
            f=0
    if not f:
        return ""NO""
    else:
        return ""YES""
    
    
    
for i in range(int(input())):
    s=input()
    print(solve(s))",s[i]!=s[i%a]  :,(s[i]!= s[i - d]):
"for _ in range(int(input())):
    n=input()
    s=len(set(n))
    for i in range(len(n)-s):
        if {{completion}}print(""NO"");break
    else:print(""YES"")",n[i]!=n[i+s]:,(n[i]!= n[i - s]):
"for i in range(int(input())):
    count={}
    str = input()
    for char in str:
        count[char] = 0
    res = True
    for i in range(len(str) - len(count.keys())):
        if {{completion}}
            res = False
    print(""YES"" if res else ""NO"")
",(str[i]!=str[i + len(count.keys())]):,(i + 1) % len(count) == 0:
"t = int(input())
while(t):
    s = input()
    d = len(set(s))
    for i in range(d, len(s)):
        if{{completion}}
            print(""No"")
            break
    else:
        print(""Yes"")
    t -= 1",(s[i] != s[i - d]):,s[i]!=s[i+d]:
"n = int(input())
for i in range(n):
  str1 = input()
  set_char = set(str1)
  req = len(set_char)
  prev = dict()
  truth = True
  ind = 0
  for i1 in str1:
    if{{completion}}
      truth = False
      break
    prev[i1] = ind
    ind += 1
  print(truth and 'YES' or 'NO')",( i1 in prev and ind - prev[i1] != req):,(i1 not in prev or prev[i1] - prev[i2] <= 1):
"for {{completion}}
    string=tuple(input().strip())
    k=len(set(string))
    print(""NO"" if any([string[i]!=string[i%k] for i in range (len(string))]) else ""YES"")
",_ in range(int(input())):,(string[i]!=string[i%k]):
"from sys import stdin
from collections import deque
lst = stdin.read().split()
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = int(inp1())
for _ in range(t):
  alph = ""abcdefghijklmnopqrstuvwxyz""
  a = list(map(lambda c: alph.index(c) + 1, inp1()))
  l = len(a)
  s = sum(a)

  if l % 2 == 0:
    print(f""Alice {s}"")
  elif l == 1:
    print(f""Bob {s}"")
  else:
    o1 = sum(a[1:]) - a[0]
    o2 = sum(a[:l-1]) - a[-1]
    if {{completion}}
      print(f""Alice {o1}"")
    else:
      print(f""Alice {o2}"")
",o1 > o2:,o1 <= o2:
"MOD = 998244353

def modmul(x, y, c = 0):
    return (x * y + c) % MOD

def inv(x):
    return pow(x, MOD - 2, MOD)

MAX = 10 ** 6

fact = [1]
for {{completion}}
    fact.append(modmul(i, fact[i-1]))

invfact = [1] * (MAX)
invfact[MAX - 1] = inv(fact[MAX - 1])
for i in range(MAX - 2, -1, -1):
    invfact[i] = modmul(i + 1, invfact[i+1])

def comb(x, y):
    return modmul(fact[x], modmul(invfact[y], invfact[x - y]))
    
def invcomb(x, y):
    return modmul(invfact[x], modmul(fact[y], fact[x - y]))
    
def invs(x):
    return modmul(fact[x - 1], invfact[x])

n = int(input())

out = [0] * n

for i in range((n + 1) // 2):
    base = fact[n - 1]
    frac = modmul(comb(n//2, i), invcomb(n - 1, i))
    
    out[i] = modmul(base, frac)

rem = 0   
for i in range(n - 1, -1, -1):
    oldrem = rem
    rem += modmul(out[i], invs(i))
    out[i] -= oldrem
    
    rem %= MOD
    out[i] %= MOD
    
print(' '.join(map(str,out)))","i in range(1, MAX):","i in range(MAX - 2, -1, -1):"
"MOD = 998244353

def modmul(x, y, c = 0):
    return (x * y + c) % MOD

def inv(x):
    return pow(x, MOD - 2, MOD)

MAX = 10 ** 6

fact = [1]
for i in range(1, MAX):
    fact.append(modmul(i, fact[i-1]))

invfact = [1] * (MAX)
invfact[MAX - 1] = inv(fact[MAX - 1])
for {{completion}}
    invfact[i] = modmul(i + 1, invfact[i+1])

def comb(x, y):
    return modmul(fact[x], modmul(invfact[y], invfact[x - y]))
    
def invcomb(x, y):
    return modmul(invfact[x], modmul(fact[y], fact[x - y]))
    
def invs(x):
    return modmul(fact[x - 1], invfact[x])

n = int(input())

out = [0] * n

for i in range((n + 1) // 2):
    base = fact[n - 1]
    frac = modmul(comb(n//2, i), invcomb(n - 1, i))
    
    out[i] = modmul(base, frac)

rem = 0   
for i in range(n - 1, -1, -1):
    oldrem = rem
    rem += modmul(out[i], invs(i))
    out[i] -= oldrem
    
    rem %= MOD
    out[i] %= MOD
    
print(' '.join(map(str,out)))","i in range(MAX - 2, -1, -1):","i in range(MAX - 2, -1, -1):"
"import sys

# https://codeforces.com/contest/1701/problem/F

MAXN = 200000


class SegmentTree:
    def __init__(self):
        self.lazy = []
        self.v0 = []
        self.v1 = []
        self.v2 = []
        self.active = []

        for _ in range(4 * MAXN + 1):
            self.lazy.append(0)
            self.v0.append(1)
            self.v1.append(0)
            self.v2.append(0)
            self.active.append(True)

        self._init_active(1, 1, MAXN)

    def _init_active(self, x, l, r):
        if l == r:
            self.active[x] = False
        else:
            m = (l + r) // 2
            self._init_active(x * 2, l, m)
            self._init_active(x * 2 + 1, m + 1, r)
            self._reclac(x)

    def _reclac(self, x):
        self.v0[x] = 0
        self.v1[x] = 0
        self.v2[x] = 0

        if self.active[x * 2]:
            self.v0[x] += self.v0[x * 2]
            self.v1[x] += self.v1[x * 2]
            self.v2[x] += self.v2[x * 2]

        if self.active[x * 2 + 1]:
            self.v0[x] += self.v0[x * 2 + 1]
            self.v1[x] += self.v1[x * 2 + 1]
            self.v2[x] += self.v2[x * 2 + 1]

    def _push(self, x, l, r):
        la = self.lazy[x]

        if la == 0:
            return

        if l != r:
            self.v2[x * 2] = self.v2[x * 2] + 2 * la * self.v1[x * 2] + la * la * self.v0[x * 2]
            self.v1[x * 2] += la * self.v0[x * 2]

            self.v2[x * 2 + 1] = self.v2[x * 2 + 1] + 2 * la * self.v1[x * 2 + 1] + la * la * self.v0[x * 2 + 1]
            self.v1[x * 2 + 1] += la * self.v0[x * 2 + 1]

            self.lazy[x * 2] += la
            self.lazy[x * 2 + 1] += la

        self.lazy[x] = 0

    def update(self, x, l, r, a, b, up: bool):
        if r < a or b < l:
            return

        if a <= l and r <= b:
            if {{completion}}
                self.v2[x] = self.v2[x] + 2 * self.v1[x] + self.v0[x]
                self.v1[x] += self.v0[x]

                self.lazy[x] += 1
            else:
                self.v2[x] = self.v2[x] - 2 * self.v1[x] + self.v0[x]
                self.v1[x] -= self.v0[x]

                self.lazy[x] -= 1
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.update(x * 2, l, m, a, b, up)
        self.update(x * 2 + 1, m + 1, r, a, b, up)

        self._reclac(x)

    def set_state(self, x, l, r, pos, up: bool):
        if pos < l or r < pos:
            return

        if l == r:
            self.active[x] = up
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.set_state(x * 2, l, m, pos, up)
        self.set_state(x * 2 + 1, m + 1, r, pos, up)

        self._reclac(x)


def solve():
    q, d = map(int, input().split())
    points = map(int, sys.stdin.readline().split())

    tree = SegmentTree()

    check = [0] * (MAXN + 1)
    ans = []
    for point in points:
        if check[point]:
            check[point] = 0
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, False)
            tree.set_state(1, 1, MAXN, point, False)
        else:
            check[point] = 1
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, True)
            tree.set_state(1, 1, MAXN, point, True)

        v1 = tree.v1[1]
        v2 = tree.v2[1]
        ans.append((v2 - v1) // 2)

    print('\n'.join(map(str, ans)))


if __name__ == '__main__':
    solve()",up:,((r >> i) << i)!= r:
"import sys

# https://codeforces.com/contest/1701/problem/F

MAXN = 200000


class SegmentTree:
    def __init__(self):
        self.lazy = []
        self.v0 = []
        self.v1 = []
        self.v2 = []
        self.active = []

        for {{completion}}
            self.lazy.append(0)
            self.v0.append(1)
            self.v1.append(0)
            self.v2.append(0)
            self.active.append(True)

        self._init_active(1, 1, MAXN)

    def _init_active(self, x, l, r):
        if l == r:
            self.active[x] = False
        else:
            m = (l + r) // 2
            self._init_active(x * 2, l, m)
            self._init_active(x * 2 + 1, m + 1, r)
            self._reclac(x)

    def _reclac(self, x):
        self.v0[x] = 0
        self.v1[x] = 0
        self.v2[x] = 0

        if self.active[x * 2]:
            self.v0[x] += self.v0[x * 2]
            self.v1[x] += self.v1[x * 2]
            self.v2[x] += self.v2[x * 2]

        if self.active[x * 2 + 1]:
            self.v0[x] += self.v0[x * 2 + 1]
            self.v1[x] += self.v1[x * 2 + 1]
            self.v2[x] += self.v2[x * 2 + 1]

    def _push(self, x, l, r):
        la = self.lazy[x]

        if la == 0:
            return

        if l != r:
            self.v2[x * 2] = self.v2[x * 2] + 2 * la * self.v1[x * 2] + la * la * self.v0[x * 2]
            self.v1[x * 2] += la * self.v0[x * 2]

            self.v2[x * 2 + 1] = self.v2[x * 2 + 1] + 2 * la * self.v1[x * 2 + 1] + la * la * self.v0[x * 2 + 1]
            self.v1[x * 2 + 1] += la * self.v0[x * 2 + 1]

            self.lazy[x * 2] += la
            self.lazy[x * 2 + 1] += la

        self.lazy[x] = 0

    def update(self, x, l, r, a, b, up: bool):
        if r < a or b < l:
            return

        if a <= l and r <= b:
            if up:
                self.v2[x] = self.v2[x] + 2 * self.v1[x] + self.v0[x]
                self.v1[x] += self.v0[x]

                self.lazy[x] += 1
            else:
                self.v2[x] = self.v2[x] - 2 * self.v1[x] + self.v0[x]
                self.v1[x] -= self.v0[x]

                self.lazy[x] -= 1
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.update(x * 2, l, m, a, b, up)
        self.update(x * 2 + 1, m + 1, r, a, b, up)

        self._reclac(x)

    def set_state(self, x, l, r, pos, up: bool):
        if pos < l or r < pos:
            return

        if l == r:
            self.active[x] = up
            return

        m = (l + r) // 2
        self._push(x, l, r)
        self.set_state(x * 2, l, m, pos, up)
        self.set_state(x * 2 + 1, m + 1, r, pos, up)

        self._reclac(x)


def solve():
    q, d = map(int, input().split())
    points = map(int, sys.stdin.readline().split())

    tree = SegmentTree()

    check = [0] * (MAXN + 1)
    ans = []
    for point in points:
        if check[point]:
            check[point] = 0
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, False)
            tree.set_state(1, 1, MAXN, point, False)
        else:
            check[point] = 1
            tree.update(1, 1, MAXN, max(1, point - d), point - 1, True)
            tree.set_state(1, 1, MAXN, point, True)

        v1 = tree.v1[1]
        v2 = tree.v2[1]
        ans.append((v2 - v1) // 2)

    print('\n'.join(map(str, ans)))


if __name__ == '__main__':
    solve()",_ in range(4 * MAXN + 1):,((r >> i) << i)!= r:
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class LazySegmentTree():
    def __init__(self, n, op, e, mapping, composition, id):
        self.n = n
        self.op = op
        self.e = e
        self.mapping = mapping
        self.composition = composition
        self.id = id
        self.log = (n - 1).bit_length()
        self.size = 1 << self.log
        self.data = [e] * (2 * self.size)
        self.lazy = [id] * self.size

    def update(self, k):
        self.data[k] = self.op(self.data[2 * k], self.data[2 * k + 1])

    def all_apply(self, k, f):
        self.data[k] = self.mapping(f, self.data[k])
        if k < self.size:
            self.lazy[k] = self.composition(f, self.lazy[k])

    def push(self, k):
        self.all_apply(2 * k, self.lazy[k])
        self.all_apply(2 * k + 1, self.lazy[k])
        self.lazy[k] = self.id

    def build(self, arr):
        # assert len(arr) == self.n
        for i, a in enumerate(arr):
            self.data[self.size + i] = a
        for i in range(self.size - 1, 0, -1):
            self.update(i)

    def set(self, p, x):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = x
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def get(self, p):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        return self.data[p]

    def prod(self, l, r):
        # assert 0 <= l <= r <= self.n
        if l == r: return self.e
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push(r >> i)
        sml = smr = self.e
        while l < r:
            if l & 1:
                sml = self.op(sml, self.data[l])
                l += 1
            if r & 1:
                r -= 1
                smr = self.op(self.data[r], smr)
            l >>= 1
            r >>= 1
        return self.op(sml, smr)

    def all_prod(self):
        return self.data[1]

    def apply(self, p, f):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = self.mapping(f, self.data[p])
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def range_apply(self, l, r, f):
        # assert 0 <= l <= r <= self.n
        if l == r: return
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if {{completion}} self.push((r - 1) >> i)
        l2 = l
        r2 = r
        while l < r:
            if l & 1:
                self.all_apply(l, f)
                l += 1
            if r & 1:
                r -= 1
                self.all_apply(r, f)
            l >>= 1
            r >>= 1
        l = l2
        r = r2
        for i in range(1, self.log + 1):
            if ((l >> i) << i) != l: self.update(l >> i)
            if ((r >> i) << i) != r: self.update((r - 1) >> i)




n = 2*10**5+1
q, d = map(int, input().split())
arr = list(map(int, input().split()))
v = [0]*n

def op(x, y):
    return [x[0]+y[0], x[1]+y[1], x[2]+y[2], x[3]]

def mapping(k, x):
    return [x[0], k*x[0]+x[1], k*k*x[0]+2*k*x[1]+x[2], x[3]+k]

def composition(f, g):
    return f+g

e = [0, 0, 0, 0]
id = 0

st = LazySegmentTree(n, op, e, mapping, composition, id)
st.build([[0, 0, 0, 0] for i in range(n)])
for x in arr:
    v[x] ^= 1
    m = st.get(x)[3]
    if v[x]:
        st.range_apply(x+1, min(x+d+1, n), 1)
        st.set(x, [1, m, m*m, m])
    else:
        st.range_apply(x+1, min(x+d+1, n), -1)
        st.set(x, [0, 0, 0, m])
    a = st.all_prod()
    print((a[2]-a[1])//2)

",((r >> i) << i) != r:,"































































































































"
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class LazySegmentTree():
    def __init__(self, n, op, e, mapping, composition, id):
        self.n = n
        self.op = op
        self.e = e
        self.mapping = mapping
        self.composition = composition
        self.id = id
        self.log = (n - 1).bit_length()
        self.size = 1 << self.log
        self.data = [e] * (2 * self.size)
        self.lazy = [id] * self.size

    def update(self, k):
        self.data[k] = self.op(self.data[2 * k], self.data[2 * k + 1])

    def all_apply(self, k, f):
        self.data[k] = self.mapping(f, self.data[k])
        if k < self.size:
            self.lazy[k] = self.composition(f, self.lazy[k])

    def push(self, k):
        self.all_apply(2 * k, self.lazy[k])
        self.all_apply(2 * k + 1, self.lazy[k])
        self.lazy[k] = self.id

    def build(self, arr):
        # assert len(arr) == self.n
        for i, a in enumerate(arr):
            self.data[self.size + i] = a
        for i in range(self.size - 1, 0, -1):
            self.update(i)

    def set(self, p, x):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = x
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def get(self, p):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        return self.data[p]

    def prod(self, l, r):
        # assert 0 <= l <= r <= self.n
        if l == r: return self.e
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push(r >> i)
        sml = smr = self.e
        while l < r:
            if l & 1:
                sml = self.op(sml, self.data[l])
                l += 1
            if r & 1:
                r -= 1
                smr = self.op(self.data[r], smr)
            l >>= 1
            r >>= 1
        return self.op(sml, smr)

    def all_prod(self):
        return self.data[1]

    def apply(self, p, f):
        # assert 0 <= p < self.n
        p += self.size
        for i in range(self.log, 0, -1):
            self.push(p >> i)
        self.data[p] = self.mapping(f, self.data[p])
        for i in range(1, self.log + 1):
            self.update(p >> i)

    def range_apply(self, l, r, f):
        # assert 0 <= l <= r <= self.n
        if l == r: return
        l += self.size
        r += self.size
        for i in range(self.log, 0, -1):
            if ((l >> i) << i) != l: self.push(l >> i)
            if ((r >> i) << i) != r: self.push((r - 1) >> i)
        l2 = l
        r2 = r
        while l < r:
            if {{completion}}
                self.all_apply(l, f)
                l += 1
            if r & 1:
                r -= 1
                self.all_apply(r, f)
            l >>= 1
            r >>= 1
        l = l2
        r = r2
        for i in range(1, self.log + 1):
            if ((l >> i) << i) != l: self.update(l >> i)
            if ((r >> i) << i) != r: self.update((r - 1) >> i)




n = 2*10**5+1
q, d = map(int, input().split())
arr = list(map(int, input().split()))
v = [0]*n

def op(x, y):
    return [x[0]+y[0], x[1]+y[1], x[2]+y[2], x[3]]

def mapping(k, x):
    return [x[0], k*x[0]+x[1], k*k*x[0]+2*k*x[1]+x[2], x[3]+k]

def composition(f, g):
    return f+g

e = [0, 0, 0, 0]
id = 0

st = LazySegmentTree(n, op, e, mapping, composition, id)
st.build([[0, 0, 0, 0] for i in range(n)])
for x in arr:
    v[x] ^= 1
    m = st.get(x)[3]
    if v[x]:
        st.range_apply(x+1, min(x+d+1, n), 1)
        st.set(x, [1, m, m*m, m])
    else:
        st.range_apply(x+1, min(x+d+1, n), -1)
        st.set(x, [0, 0, 0, m])
    a = st.all_prod()
    print((a[2]-a[1])//2)

",l & 1:,"































































































































"
"n,k = map(int,input().split())
ns = set()
for {{completion}}
    s = tuple(int(v) for v in input().split())
    ns.add(s)
arr = [[tuple((6-v1[i]-v2[i])%3 for i in range(k)) in ns for v1 in ns] for v2 in ns]
ans = 0
for i in range(n):
    s = sum(arr[i])-2
    ans += s*s//8
print(ans)",_ in range(n):,i in range(n):
"n,k = map(int,input().split())
ns = set()
for _ in range(n):
    s = tuple(int(v) for v in input().split())
    ns.add(s)
arr = [[tuple((6-v1[i]-v2[i])%3 for i in range(k)) in ns for v1 in ns] for v2 in ns]
ans = 0
for {{completion}}
    s = sum(arr[i])-2
    ans += s*s//8
print(ans)",i in range(n):,i in range(k):
"from sys import stdin

def missing(c1, c2):
    c3 = []
    for i in range(len(c1)):
        if c1[i] == c2[i]:
            c3.append(c1[i])
        else:
            c3.append(next(iter({""0"", ""1"", ""2""}.difference({c1[i], c2[i]}))))

    return """".join(c3)

def solve():
    n, k = map(int, stdin.readline().split())
    cards = [stdin.readline().strip().replace("" "", """") for i in range(n)]
    
    off1 = {c:0 for c in cards}

    for i in range(n):
        for j in range(i+1, n):
            m = missing(cards[i], cards[j])
            if {{completion}}
                off1[m] += 1

    print(sum(i*(i-1)//2 for i in off1.values()))

solve()",m in off1:,i in range(k):
"ndfeagbb, dfeagbbk = map(int, input().split())
cards = [tuple(map(int, input().split())) for _ in range(ndfeagbb)]
cards_lookup, counter = {card: i for i, card in enumerate(cards)}, [0] * (ndfeagbb + 1)
for i in range(len(cards) - 1):
    for {{completion}}
        counter[cards_lookup.get(tuple(x if x == y else ((x + 1) ^ (y + 1)) - 1 for x, y in zip(cards[i], cards[j])), -1)] += 1
print(sum(x * (x - 1) // 2 for x in counter[:-1]))
","j in range(i + 1, len(cards)):",i in range(len(cards) - 1):
"from sys import stdin, stdout

n, k = [int(x) for x in stdin.readline().split()]
cards = set()
for i in range(n):
    cards.add(tuple([int(x) for x in stdin.readline().split()]))

answer = 0
for card in cards:
    yes_v = 0
    for v in cards:
        w = []
        for {{completion}}
            w.append((3-card[i]-v[i])%3)
        if tuple(w) in cards:
            yes_v += 1

    yes_v = (yes_v-1)//2
    answer += (yes_v * (yes_v-1))//2

stdout.write(str(answer)+'\n')
",i in range(k):,i in range(k):
"from sys import stdin, stdout

n, k = [int(x) for x in stdin.readline().split()]
cards = set()
for i in range(n):
    cards.add(tuple([int(x) for x in stdin.readline().split()]))

answer = 0
for card in cards:
    yes_v = 0
    for v in cards:
        w = []
        for i in range(k):
            w.append((3-card[i]-v[i])%3)
        if {{completion}}
            yes_v += 1

    yes_v = (yes_v-1)//2
    answer += (yes_v * (yes_v-1))//2

stdout.write(str(answer)+'\n')
",tuple(w) in cards:,i in range(k):
"import sys; R = sys.stdin.readline
n,k = map(int,R().split())
deck = [tuple(map(int,R().split())) for _ in range(n)]
dic = {}
for i in range(n): dic[deck[i]] = i
res = [0]*n
for p in range(n-2):
    for q in range(p+1,n-1):
        last = [0]*k
        for {{completion}}
            last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
        last = tuple(last)
        if last in dic and dic[last]>q:
            res[p] += 1; res[q] += 1; res[dic[last]] += 1
print(sum((s*(s-1))//2 for s in res))",j in range(k):,i in range(k):
"import sys; R = sys.stdin.readline
n,k = map(int,R().split())
deck = [tuple(map(int,R().split())) for _ in range(n)]
dic = {}
for i in range(n): dic[deck[i]] = i
res = [0]*n
for p in range(n-2):
    for q in range(p+1,n-1):
        last = [0]*k
        for j in range(k):
            last[j] = deck[p][j] if deck[p][j]==deck[q][j] else 3-deck[p][j]-deck[q][j]
        last = tuple(last)
        if {{completion}}
            res[p] += 1; res[q] += 1; res[dic[last]] += 1
print(sum((s*(s-1))//2 for s in res))",last in dic and dic[last]>q:,j in range(k):
"
n,k=map(int,input().split())
a=[]
d={}
for i in range(n):
    a+=[''.join(input().split())]
    d[a[-1]]=0


def cal(s,t):
    res=""""
    for {{completion}}
        res+=str((9-int(s[i])-int(t[i]))%3)
    return res



for i in range(n):
    for j in range(i):
        try:
            d[cal(a[i],a[j])]+=1
        except:
            pass

ans=0
for y in d.values():
    ans+=(y*(y-1))//2
print(ans)

",i in range(k):,i in range(j):
"
n,k=map(int,input().split())
a=[]
d={}
for i in range(n):
    a+=[''.join(input().split())]
    d[a[-1]]=0


def cal(s,t):
    res=""""
    for i in range(k):
        res+=str((9-int(s[i])-int(t[i]))%3)
    return res



for i in range(n):
    for {{completion}}
        try:
            d[cal(a[i],a[j])]+=1
        except:
            pass

ans=0
for y in d.values():
    ans+=(y*(y-1))//2
print(ans)

",j in range(i):,j in range(i):
"n, k = [int(i) for i in input().split()]
a = []
for _ in range(n):
    a.append(tuple([int(i) for i in input().split()]))
a = tuple(a)
sus = set(a)

cs = [0 for i in range(n)]
for i in range(n):
    p = a[i]
    for j in set(range(n)) - set(tuple([i])):
        q = a[j]
        r = []
        for o in range(k):
            if {{completion}}
                r.append(p[o])
            else:
                r.append(3-p[o]-q[o])
        if tuple(r) in sus:
            cs[i] += 1
            cs[j] += 1
cs = [i//4 for i in cs]
cs = [(i*(i-1))//2 for i in cs]
print(sum(cs))",p[o] == q[o]:,i in range(k):
"for {{completion}}
    n = input()
    a = sorted(map(int, input().split()))
    print(a[-1] + a[-2] - a[0] - a[1])",_ in range(int(input())):,_ in range(int(input())):
"for {{completion}}a,b,*_,c,d=sorted(map(int,s.split()));print(c+d-a-b)",s in[*open(0)][2::2]:,_ in range(int(input())):
"for {{completion}}input();a,b,*_,c,d=sorted(map(int,input().split()));print(c+d-a-b)",t in range(int(input())):,_ in range(int(input())):
"for {{completion}}p,q,*_,r,s=sorted(map(int,sdr.split()));print(r+s-p-q)",sdr in[*open(0)][2::2]:,_ in range(int(input())):
"for {{completion}}
    input()
    a, b, *_, c, d = sorted(map(int, input().split()))
    print(c+d-a-b)
    ",_ in range(int(input())):,_ in range(int(input())):
"for {{completion}}
    input()
    a = sorted(map(int, input().split()))
    print(a[-1] + a[-2] - a[0] - a[1])
",_ in range(int(input())):,_ in range(int(input())):
"import sys
import math
import heapq
import itertools
import bisect
import random
from decimal import *
from collections import deque
input=sys.stdin.readline

def extended_gcd(a,b):
    x0,x1,y0,y1=1,0,0,1
    while b!=0:
        n,a,b=a//b,b,a%b
        x0,x1=x1,x0-n*x1
        y0,y1=y1,y0-n*y1
    return x0,y0

n=int(input())
arr=[]
ans=0
for i in range(n):
    a,b=map(int,input().split())
    ans+=a
    arr.append(b-a)
arr.sort(reverse=True)
s=[0]
for i in range(n):
    s.append(s[-1]+arr[i])
mp=s.index(max(s))

m=int(input())
for _ in range(m):
    a,b=map(int,input().split())
    k=math.gcd(a,b)
    if n%(math.gcd(a,b))==0:
        a1,b1=a//k,b//k
        x,y=extended_gcd(a1,b1)
        x,y=x*(n//k),y*(n//k)
        mod=math.lcm(a,b)
        p=(y*b)%mod
        if p>n:
            print(-1)
        else:
            p1=(mp//mod)*mod+p
            line=[p1,p1-mod,p1+mod]
            ma=-10**18
            for i in line:
                if {{completion}}
                    ma=max(ma,s[i])
            print(ma+ans)
            
            
            
    else:
        print(-1)
        
        
            






        
",0<=i<=n:,"(n%(math.gcd(a,b))==0):"
"input = __import__('sys').stdin.readline


MOD = 998244353


d, n, m = map(int, input().split())
lamps = list(sorted(map(int, input().split()))) # n
points = list(sorted(map(int, input().split()))) # m

# 1. O(m^2) to find all interesting points (sould be around m^2 points)
positions = [x for x in points]
positions.append(0)
positions.append(d)
for i in range(m):
    for j in range(i+1, m):
        mid = (points[i] + points[j]) // 2
        positions.append(mid)
        positions.append(mid+1)
positions = list(sorted(set(positions)))
posmap = {x: i for i, x in enumerate(positions)}

# print('points', points)
# print('positions', positions)

# 2. O(nm) to precompute QueryL and QueryR
i = 0
queryL = []
for p in points:
    queries = [0] * len(positions)
    while positions[i] < p:
        i += 1

    j = i    
    q = 1
    for x in lamps:
        if x <= p:
            continue
        while x > positions[j]:
            queries[j] = q
            j += 1
        q = q * (x - p) % MOD
    
    while j < len(positions):
        queries[j] = q
        j += 1
    
    queryL.append(queries)
    # print('L p:', p, queries)

i = len(positions)-1
queryR = []
for p in points[::-1]:
    queries = [0] * len(positions)
    while positions[i] > p:
        i -= 1

    j = i
    q = 1
    for x in lamps[::-1]:
        if x > p:
            continue
        while x < positions[j]:
            queries[j] = q
            j -= 1
        q = q * (p - x) % MOD
    while j >= 0:
        queries[j] = q
        j -= 1
    
    queryR.append(queries)
    # print('R p:', p, queries)

queryR = queryR[::-1]
# print('queryL', queryL)
# print('queryR', queryR)

# 3. O(m*2^m) to convert all mask to product of QueryL & QueryR and calculate the inclusion-exclusion & accumulate its SumQueryL[L..R] SumQueryR[L..R] values
querySums = [[[0]*len(positions) for _ in range(len(points))] for _ in range(2)]
current_ans = 0
for mask in range(1, 1 << m):
    keys = []
    prev_idx = -1
    popcnt = 0
    q = 1
    for i in range(m):
        if (mask >> i) & 1:
            p = points[i]
            if {{completion}}
                keys.append((1, i, 0))
                q = q * queryR[i][0] % MOD
            else:
                prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD
            
            prev_idx = i
            popcnt += 1
    
    keys.append((0, prev_idx, len(positions)-1))
    q = q * queryL[prev_idx][-1] % MOD
    if popcnt & 1:
        current_ans = (current_ans - q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] - q) % MOD
    else:
        current_ans = (current_ans + q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD
    
    # print('mask', ('{:0' + str(m) + 'b}').format(mask), q, keys)

for j in range(m):
    for k in range(len(positions) -2, -1, -1):
        querySums[0][j][k] = (querySums[0][j][k] + querySums[0][j][k+1]) % MOD
    for k in range(1, len(positions)):
        querySums[1][j][k] = (querySums[1][j][k] + querySums[1][j][k-1]) % MOD

# 4. for each query, update the total ans by affected SumQueryL and SumQueryR (those with L <= x <= R)
current_ans += pow(d+1, n+1, MOD)
current_ans %= MOD

_ = int(input())
for x in map(int, input().split()):
    ans = current_ans

    for i in range(len(positions)):
        if positions[i] >= x:
            pos = i
            break

    for j in range(m):
        if points[j] < x:
            total = querySums[0][j][pos]
            ans -= total
            ans += total * (x - points[j]) % MOD
            ans %= MOD
    
    for i in range(len(positions)-1, -1, -1):
        if positions[i] <= x:
            pos = i
            break
    
    for j in range(m):
        if x <= points[j]:
            total = querySums[1][j][pos]
            ans -= total
            ans += total * (points[j] - x) % MOD
            ans %= MOD

    print(ans)
",prev_idx == -1:,"i, j, k in keys:"
"input = __import__('sys').stdin.readline


MOD = 998244353


d, n, m = map(int, input().split())
lamps = list(sorted(map(int, input().split()))) # n
points = list(sorted(map(int, input().split()))) # m

# 1. O(m^2) to find all interesting points (sould be around m^2 points)
positions = [x for x in points]
positions.append(0)
positions.append(d)
for i in range(m):
    for j in range(i+1, m):
        mid = (points[i] + points[j]) // 2
        positions.append(mid)
        positions.append(mid+1)
positions = list(sorted(set(positions)))
posmap = {x: i for i, x in enumerate(positions)}

# print('points', points)
# print('positions', positions)

# 2. O(nm) to precompute QueryL and QueryR
i = 0
queryL = []
for p in points:
    queries = [0] * len(positions)
    while positions[i] < p:
        i += 1

    j = i    
    q = 1
    for x in lamps:
        if x <= p:
            continue
        while x > positions[j]:
            queries[j] = q
            j += 1
        q = q * (x - p) % MOD
    
    while j < len(positions):
        queries[j] = q
        j += 1
    
    queryL.append(queries)
    # print('L p:', p, queries)

i = len(positions)-1
queryR = []
for p in points[::-1]:
    queries = [0] * len(positions)
    while positions[i] > p:
        i -= 1

    j = i
    q = 1
    for x in lamps[::-1]:
        if x > p:
            continue
        while x < positions[j]:
            queries[j] = q
            j -= 1
        q = q * (p - x) % MOD
    while j >= 0:
        queries[j] = q
        j -= 1
    
    queryR.append(queries)
    # print('R p:', p, queries)

queryR = queryR[::-1]
# print('queryL', queryL)
# print('queryR', queryR)

# 3. O(m*2^m) to convert all mask to product of QueryL & QueryR and calculate the inclusion-exclusion & accumulate its SumQueryL[L..R] SumQueryR[L..R] values
querySums = [[[0]*len(positions) for _ in range(len(points))] for _ in range(2)]
current_ans = 0
for mask in range(1, 1 << m):
    keys = []
    prev_idx = -1
    popcnt = 0
    q = 1
    for i in range(m):
        if (mask >> i) & 1:
            p = points[i]
            if prev_idx == -1:
                keys.append((1, i, 0))
                q = q * queryR[i][0] % MOD
            else:
                prev_p = points[prev_idx]
                mid = (prev_p + p) // 2
                
                keys.append((0, prev_idx, posmap[mid]))
                q = q * queryL[prev_idx][posmap[mid]] % MOD
                
                keys.append((1, i, posmap[mid+1]))
                q = q * queryR[i][posmap[mid+1]] % MOD
            
            prev_idx = i
            popcnt += 1
    
    keys.append((0, prev_idx, len(positions)-1))
    q = q * queryL[prev_idx][-1] % MOD
    if popcnt & 1:
        current_ans = (current_ans - q) % MOD
        for i, j, k in keys:
            querySums[i][j][k] = (querySums[i][j][k] - q) % MOD
    else:
        current_ans = (current_ans + q) % MOD
        for {{completion}}
            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD
    
    # print('mask', ('{:0' + str(m) + 'b}').format(mask), q, keys)

for j in range(m):
    for k in range(len(positions) -2, -1, -1):
        querySums[0][j][k] = (querySums[0][j][k] + querySums[0][j][k+1]) % MOD
    for k in range(1, len(positions)):
        querySums[1][j][k] = (querySums[1][j][k] + querySums[1][j][k-1]) % MOD

# 4. for each query, update the total ans by affected SumQueryL and SumQueryR (those with L <= x <= R)
current_ans += pow(d+1, n+1, MOD)
current_ans %= MOD

_ = int(input())
for x in map(int, input().split()):
    ans = current_ans

    for i in range(len(positions)):
        if positions[i] >= x:
            pos = i
            break

    for j in range(m):
        if points[j] < x:
            total = querySums[0][j][pos]
            ans -= total
            ans += total * (x - points[j]) % MOD
            ans %= MOD
    
    for i in range(len(positions)-1, -1, -1):
        if positions[i] <= x:
            pos = i
            break
    
    for j in range(m):
        if x <= points[j]:
            total = querySums[1][j][pos]
            ans -= total
            ans += total * (points[j] - x) % MOD
            ans %= MOD

    print(ans)
","i, j, k in keys:",prev_idx == -1:
"import sys
input=sys.stdin.readline
R=lambda:map(int,input().split())
n,m=R();r,c,tr,tc=[0]*(n+1),[0]*(n+1),[0]*(n+1),[0]*(n+1)
def A(t,i,v):
  while i<=n:t[i]+=v;i+=i&(-i)
def Q(t,i):
  s=0
  while i:s+=t[i];i-=i&(-i)
  return s
for _ in range(m):
  v=[*R()];op,x,y=v[:3]
  if op==1:
    r[x]+=1;c[y]+=1
    if r[x]==1:A(tr,x,1)
    if c[y]==1:A(tc,y,1)
  elif op==2:
    r[x]-=1;c[y]-=1
    if {{completion}}A(tr,x,-1)
    if c[y]==0:A(tc,y,-1)
  else:
    x1,y1=v[3:]
    print('Yes' if Q(tr,x1)-Q(tr,x-1)==x1-x+1 or Q(tc,y1)-Q(tc,y-1)==y1-y+1 else 'No')",r[x]==0:,"Q(tr,x1)-Q(tr,x-1)==x1-x+1 or Q(tc,y1)-Q(tc,y-1)==y1-y+1:"
"class BIT:
  def __init__(self, n, element):
    self.num = n
    self.ele = element
    self.data = [self.ele] * (self.num + 1)
  
  def calc(self, x, y):
    return x + y
 
  def update(self, idx, x):
    while idx <= self.num:
      self.data[idx] = self.calc(self.data[idx], x)
      idx += idx & -idx
  
  def sum(self, idx):
    res = self.ele
    while idx > 0:
      res = self.calc(res, self.data[idx])
      idx -= idx & -idx
    return res
  
  def prod(self, l, r):
    return self.sum(r) - self.sum(l-1)

import sys
input = sys.stdin.readline
n, q = map(int, input().split())
cntb, cntv = [0] * n, [0] * n
bitb = BIT(n, 0)
bitv = BIT(n, 0)
for _ in range(q):
  query = list(map(int, input().split()))
  if query[0] == 1:
    x, y = query[1], query[2]
    if cntb[x-1] == 0:
      bitb.update(x, 1)
    cntb[x-1] += 1
    if cntv[y-1] == 0:
      bitv.update(y, 1)
    cntv[y-1] += 1
  elif query[0] == 2:
    x, y = query[1], query[2]
    cntb[x-1] -= 1
    cntv[y-1] -= 1
    if {{completion}}
      bitb.update(x, -1)
    if cntv[y-1] == 0:
      bitv.update(y, -1)
  else:
    flg = bitb.prod(query[1], query[3]) == query[3] - query[1] + 1 or bitv.prod(query[2], query[4]) == query[4] - query[2] + 1
    print(""Yes"" if flg else ""No"")",cntb[x-1] == 0:,"bitb.prod(query[1], query[3]) == query[3] - query[1] + 1:"
"import sys

def solve():
	inp = sys.stdin.readline
	n, q = map(int, inp().split())
	r = [0] * n
	c = [0] * n
	rc = [0] * n
	cc = [0] * n
	for i in range(q):
		ii = iter(map(int, inp().split()))
		t = next(ii)
		if t <= 2:
			x, y = ii
			vv = 1 if t == 1 else -1
			x -= 1
			w = int(rc[x] > 0)
			rc[x] += vv
			v = int(rc[x] > 0) - w
			while x < n:
				r[x] += v
				x = (x | (x + 1))
			x = y - 1
			w = int(cc[x] > 0)
			cc[x] += vv
			v = int(cc[x] > 0) - w
			while x < n:
				c[x] += v
				x = (x | (x + 1))
		else:
			x1, y1, x2, y2 = ii
			v = 0
			x = x2 - 1
			while {{completion}}
				v += r[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while x >= 0:
				v -= r[x]
				x = (x & (x + 1)) - 1
			if v == x2 - x1 + 1:
				print('Yes')
				continue
			v = 0
			x = y2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = y1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
				print('No')


def main():
	solve()


if __name__ == '__main__':
	main()
",x >= 0:,v == x2 - x1 + 1:
"import sys

def solve():
	inp = sys.stdin.readline
	n, q = map(int, inp().split())
	r = [0] * n
	c = [0] * n
	rc = [0] * n
	cc = [0] * n
	for i in range(q):
		ii = iter(map(int, inp().split()))
		t = next(ii)
		if t <= 2:
			x, y = ii
			vv = 1 if t == 1 else -1
			x -= 1
			w = int(rc[x] > 0)
			rc[x] += vv
			v = int(rc[x] > 0) - w
			while x < n:
				r[x] += v
				x = (x | (x + 1))
			x = y - 1
			w = int(cc[x] > 0)
			cc[x] += vv
			v = int(cc[x] > 0) - w
			while x < n:
				c[x] += v
				x = (x | (x + 1))
		else:
			x1, y1, x2, y2 = ii
			v = 0
			x = x2 - 1
			while x >= 0:
				v += r[x]
				x = (x & (x + 1)) - 1
			x = x1 - 2
			while x >= 0:
				v -= r[x]
				x = (x & (x + 1)) - 1
			if {{completion}}
				print('Yes')
				continue
			v = 0
			x = y2 - 1
			while x >= 0:
				v += c[x]
				x = (x & (x + 1)) - 1
			x = y1 - 2
			while x >= 0:
				v -= c[x]
				x = (x & (x + 1)) - 1
			if v == y2 - y1 + 1:
				print('Yes')
			else:
				print('No')


def main():
	solve()


if __name__ == '__main__':
	main()
",v == x2 - x1 + 1:,x >= 0:
"import math
from collections import defaultdict, deque, Counter
from sys import stdin
inf = int(1e18)
input = stdin.readline

#fenwick Tree
#D V ARAVIND

def add(ft, i, v):
    while i < len(ft):
        ft[i] += v
        i += i&(-i)

def get(ft, i):
    s = 0
    while (i > 0):
        s = s + ft[i]
        i = i - (i &(-i))
    return(s)



for _ in range (1):
    n,q = map(int, input().split())
    ftr = [0 for i in range (n+1)]
    ftc = [0 for i in range (n+1)]
    visr = [0 for i in range (n+1)]
    visc = [0 for i in range (n+1)]
    for _ in range (q):
        a = [int(i) for i in input().split()]
        if a[0] == 1:
            if visr[a[1]] == 0:
                add(ftr, a[1], 1)
            visr[a[1]] += 1
            if visc[a[2]] == 0:
                add(ftc, a[2], 1)
            visc[a[2]] += 1
        elif a[0] == 2:
            if {{completion}}
                add(ftr, a[1], -1)
            visr[a[1]] -= 1
            if visc[a[2]] == 1:
                add(ftc, a[2], -1)
            visc[a[2]] -= 1
        else:
            sr = get(ftr, a[3]) - get(ftr, a[1]-1)
            sc = get(ftc, a[4]) - get(ftc, a[2]-1)
            if (sr == a[3] - a[1] + 1) or (sc == a[4]-a[2]+1):
                print(""YES"")
            else:
                print(""NO"")",visr[a[1]] == 1:,(sr == a[3] - a[1] + 1) or (sc == a[4]-a[2]+1):
"import math
from collections import defaultdict, deque, Counter
from sys import stdin
inf = int(1e18)
input = stdin.readline

#fenwick Tree
#D V ARAVIND

def add(ft, i, v):
    while i < len(ft):
        ft[i] += v
        i += i&(-i)

def get(ft, i):
    s = 0
    while (i > 0):
        s = s + ft[i]
        i = i - (i &(-i))
    return(s)



for _ in range (1):
    n,q = map(int, input().split())
    ftr = [0 for i in range (n+1)]
    ftc = [0 for i in range (n+1)]
    visr = [0 for i in range (n+1)]
    visc = [0 for i in range (n+1)]
    for _ in range (q):
        a = [int(i) for i in input().split()]
        if a[0] == 1:
            if visr[a[1]] == 0:
                add(ftr, a[1], 1)
            visr[a[1]] += 1
            if visc[a[2]] == 0:
                add(ftc, a[2], 1)
            visc[a[2]] += 1
        elif a[0] == 2:
            if visr[a[1]] == 1:
                add(ftr, a[1], -1)
            visr[a[1]] -= 1
            if visc[a[2]] == 1:
                add(ftc, a[2], -1)
            visc[a[2]] -= 1
        else:
            sr = get(ftr, a[3]) - get(ftr, a[1]-1)
            sc = get(ftc, a[4]) - get(ftc, a[2]-1)
            if {{completion}}
                print(""YES"")
            else:
                print(""NO"")",(sr == a[3] - a[1] + 1) or (sc == a[4]-a[2]+1):,visr[a[1]] == 1:
"import sys
def update(ind, val, tree, n):
    while ind <= n:
        tree[ind] += val
        ind += (ind & -ind)

def read(ind, tree):
    ans = 0
    while(ind > 0):
        ans += tree[ind]
        ind -= (ind & -ind)
    return ans

def query(l, r, tree):
    return read(r, tree) - read(l-1, tree)

n, q = map(int, sys.stdin.readline().split())
row = [0] * (n+1)
col = [0] * (n+1)
rtree = [0] * (n+1)
ctree = [0] * (n+1)
for i in range(q):
    inp = list(map(int, sys.stdin.readline().split()))
    t = inp[0]
    if t == 1:
        x = inp[1]
        y = inp[2]
        row[x] += 1
        col[y] += 1
        if row[x] == 1:
            update(x, 1, rtree, n)
        if col[y] == 1:
            update(y, 1, ctree, n)
    elif t == 2:
        x = inp[1]
        y = inp[2]
        row[x] -= 1
        col[y] -= 1
        if {{completion}}
            update(x, -1, rtree, n)
        if col[y] == 0:
            update(y, -1, ctree, n)
    else:
        x1 = inp[1]
        y1 = inp[2]
        x2 = inp[3]
        y2 = inp[4]
        flag1 = True
        flag2 = True;
        if query(x1, x2, rtree) < x2 - x1 + 1:
            flag1 = False
        if query(y1, y2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")",row[x] == 0:,"query(x1, x2, rtree) < x2 - x1 + 1:"
"import sys
def update(ind, val, tree, n):
    while ind <= n:
        tree[ind] += val
        ind += (ind & -ind)

def read(ind, tree):
    ans = 0
    while(ind > 0):
        ans += tree[ind]
        ind -= (ind & -ind)
    return ans

def query(l, r, tree):
    return read(r, tree) - read(l-1, tree)

n, q = map(int, sys.stdin.readline().split())
row = [0] * (n+1)
col = [0] * (n+1)
rtree = [0] * (n+1)
ctree = [0] * (n+1)
for i in range(q):
    inp = list(map(int, sys.stdin.readline().split()))
    t = inp[0]
    if t == 1:
        x = inp[1]
        y = inp[2]
        row[x] += 1
        col[y] += 1
        if row[x] == 1:
            update(x, 1, rtree, n)
        if col[y] == 1:
            update(y, 1, ctree, n)
    elif t == 2:
        x = inp[1]
        y = inp[2]
        row[x] -= 1
        col[y] -= 1
        if row[x] == 0:
            update(x, -1, rtree, n)
        if col[y] == 0:
            update(y, -1, ctree, n)
    else:
        x1 = inp[1]
        y1 = inp[2]
        x2 = inp[3]
        y2 = inp[4]
        flag1 = True
        flag2 = True;
        if {{completion}}
            flag1 = False
        if query(y1, y2, ctree) < y2 - y1 + 1:
            flag2 = False
        if flag1 or flag2:
            sys.stdout.write(""Yes\n"")
        else:
            sys.stdout.write(""No\n"")","query(x1, x2, rtree) < x2 - x1 + 1:",row[x] == 0:
"import bisect
import collections
import heapq
import io
import math
import os
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
Mod = 1000000007

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

# for _ in range(int(_input())):
for _ in range(1):
    n, q = map(int, _input().split())
    a = [0] * (n + 1)
    b = [0] * (n + 1)
    x = [0] * (n + 1)
    y = [0] * (n + 1)
    for _ in range(q):
        o = list(map(int, _input().split()))
        if o[0] == 1:
            _, u, v = o
            a[u] += 1
            if a[u] == 1:
                while u <= n:
                    x[u] += 1
                    u += u & -u
            b[v] += 1
            if b[v] == 1:
                while v <= n:
                    y[v] += 1
                    v += v & -v
        elif o[0] == 2:
            _, u, v = o
            a[u] -= 1
            if a[u] == 0:
                while {{completion}}
                    x[u] -= 1
                    u += u & -u
            b[v] -= 1
            if b[v] == 0:
                while v <= n:
                    y[v] -= 1
                    v += v & -v
        else:
            _, u1, v1, u2, v2 = o
            c = 0
            u = u2
            while u > 0:
                c += x[u]
                u -= u & -u
            u = u1 - 1
            while u > 0:
                c -= x[u]
                u -= u & -u
            d = 0
            v = v2
            while v > 0:
                d += y[v]
                v -= v & -v
            v = v1 - 1
            while v > 0:
                d -= y[v]
                v -= v & -v
            print('Yes' if c >= u2 - u1 + 1 or d >= v2 - v1 + 1 else 'No')",u <= n:,c >= u2 - u1 + 1:
"f = open(0)
def R(): return map(int, next(f).split())


n, q = R()
d = {}
i = v = r = 0
for x in R():
    r += x
    i += 1
    d[i] = x
while q:
    q -= 1
    t, *x = R()
    if {{completion}}
        i, x = x
        r += x - d.get(i, v)
        d[i] = x
    else:
        d = {}
        v, = x
        r = v * n
    print(r)
",t & 1:,t == 2:
"inp = [list(map(int, l.split())) for l in open(0).read().splitlines()]
n, q = inp[0]
a = inp[1]
last = 0
step = [-1] * n
laststep = -2
tot = sum(a)
 
for i, b in enumerate(inp[2:]):
    if b[0] == 1:
        if {{completion}}
            tot += b[2] - a[b[1]-1] 
            a[b[1]-1] = b[2]
        else:
            tot += b[2] - last
            a[b[1]-1] = b[2]
        step[b[1]-1] = i
        print(tot)
    else:
        tot = b[1] * n
        last = b[1]
        laststep = i
        print(tot)",step[b[1]-1] > laststep:,step[b[1]-1]>laststep:
"from collections import defaultdict
import sys
input = sys.stdin.readline
n, q = map(int, input().split())
t = dict(enumerate(map(int, input().split())))
ans = sum(t.values())
for i in range(q):
    p = list(map(int, input().split()))
    if {{completion}}
        k = p[1]
        ans = n*p[1]
        t = defaultdict(lambda:k)
    else :
        ans += p[2] - t[p[1] - 1]
        t[p[1] - 1] = p[2]
    print(ans)",p[0] == 2:,p[1]>1:
"n,q = map(int, input().split(' '))
array = list(map(int, input().split(' ')))
d = {i:item for i,item in enumerate(array, start=1)}
tot = sum(array)
default = None
for _ in range(q):
    t, *a = map(int, input().split(' '))
    if t==1:
        i, x = a
        tot += (x-d.get(i, default))
        d[i] = x
    elif {{completion}}
        default, = a
        tot = default*n
        d = {}
    print(tot)
",t==2:,t & 1:
"f=open(0)
s=lambda:map(int,next(f).split())
n,tst=s()
arr={}
i=g=ans=0
for x in s():ans+=x;i+=1;arr[i]=x
while tst:
    tst-=1;t,*x=s()
    if {{completion}}i,x=x;ans+=x-arr.get(i,g);arr[i]=x
    else:arr={};g,=x;ans=g*n
    print(ans)
  ",t&1:,t & 1:
"n, q = list(map(int, input().split()))

a = list(map(int, input().split()))
x, c, s, b = 0, 0, sum(a), [1]*(n)

for i in range(q):
    k = list(map(int, input().split()))
    if k[0]==1:
        j = k[1]-1
        if {{completion}}
            s = s-a[j]+k[2]
        else:
            s = s-x+k[2]
            b[j] = c+1
        a[j] = k[2]
        print(s)
    else:
        c = c+1
        x = k[1]
        s = n*x
        print(s)
            
    
        ",b[j]>c:,k[0] == 1:
"f=open(0)        

n,q=map(int,next(f).split())
a = list(map(int,next(f).split()))
c = [-1]*n
X = 0
S = sum(a)
lst=-2

for idx in range(q):
    req = list(map(int,next(f).split()))

    if {{completion}}
        i = req[1]-1
        x = req[2]
        current = X if c[i]<lst else a[i]
        S += x - current
        a[i] = x
        c[i] = idx

    else:
        X = req[1]
        S = X * n
        lst = idx

    print(S)




                

            

            
            
            
            
                
        
        
        

",(req[0] == 1):,c[i]<lst:
"import sys, math
input = sys.stdin.readline

n, q = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
d = {}
for i in range(n):
    d[i + 1] = a[i]   
type2 = 0
for i in range(q):
    t = [int(x) for x in input().split()]
    if {{completion}}
        d[t[1]] = t[2]
    else:
        d.clear()
        type2 = t[1]
    print(type2*(n - len(d)) + sum(d.values()))",t[0] == 1:,t & 1:
"import sys

input = sys.stdin.readline


def solve():
    n, m, k = map(int, input().split())
    arr = list(map(int, input().split()))
    graph = [[] for _ in range(n)]
    for i in range(m):
        u, v = map(int, input().split())
        graph[u-1].append(v-1)

    lo, hi = min(arr), max(arr)+1
    while lo < hi:
        mid = lo + (hi-lo)//2
        dp = [0]*n
        degree = [0]*n
        cnt = 0
        for i in range(n):
            if arr[i] > mid:
                continue
            cnt += 1
            for nei in graph[i]:
                if arr[nei] > mid:
                    continue
                degree[nei] += 1

        stack = []
        nums = 0
        for i in range(n):
            if degree[i] == 0 and arr[i] <= mid:
                stack.append(i)
                nums += 1

        while stack:
            curr = stack.pop()
            for nei in graph[curr]:
                if arr[nei] > mid:
                    continue
                degree[nei] -= 1
                if {{completion}}
                    stack.append(nei)
                    dp[nei] = max(dp[nei], dp[curr] + 1)
                    nums += 1

        if nums != cnt or max(dp) >= k-1:
            hi = mid
        else:
            lo = mid + 1

    if lo == max(arr) + 1:
        return -1
    else:
        return lo


print(solve())",degree[nei] == 0:,degree[nei] <= 1 :
"import sys
from array import array
from collections import deque

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
debug = lambda *x: print(*x, file=sys.stderr)
out = array('i')


class graph:
    def __init__(self, n):
        self.n = n
        self.gdict = [array('i') for _ in range(n + 1)]
        self.deg = array('i', [0] * (n + 1))

    def add_uniedge(self, node1, node2):
        self.gdict[node1].append(node2)
        self.deg[node2] += 1

    def kahn(self):
        # enqueue all node with 0 in degree
        que, cnt = deque([(i, 0) for i in range(1, self.n + 1) if not self.deg[i]]), 0
        ret = 0

        while que:
            s, lev = que.popleft()
            ret = max(ret, lev)

            for i in self.gdict[s]:
                self.deg[i] -= 1
                if {{completion}}
                    que.append((i, lev + 1))

            cnt += 1
        return cnt != valids or ret >= k - 1


n, m, k = inp(int)
a = array('i', [0] + inp(int))
g = graph(n)

for i in range(m):
    u, v = inp(int)
    g.add_uniedge(u, v)

be, en, ans = min(a[1:]), 10 ** 9, -1
orgdeg = g.deg[:]

while be <= en:
    md, valids = (be + en) >> 1, n
    for i in range(1, n + 1):
        if a[i] > md:
            valids -= 1
            g.deg[i] = 10 ** 6

            for j in g.gdict[i]:
                g.deg[j] -= 1

    if g.kahn():
        en, ans = md - 1, md
    else:
        be = md + 1

    g.deg = orgdeg[:]

print(ans)
",a[i] <= md and not self.deg[i]:,g.deg[i] == 0:
"from sys import stdin, stdout


n, m, k = [int(x) for x in stdin.readline().split()]
a = [int(x) for x in stdin.readline().split()]
edges = {i:[] for i in range(n)}
for bar in range(m):
    u, v = [int(x)-1 for x in stdin.readline().split()]
    edges[u].append(v)

a_copy = list(set(a))
a_copy.sort()

def check(bound):
    heights = [0]*n
    expanded = [0]*n
    parents = [-1]*n
    for root in range(n):
        if a[root] <= bound and heights[root] == 0:
            stack = [root]

            while len(stack) > 0:
                if heights[stack[-1]] > 0:
                    v = stack.pop()
                    expanded[v] = 2
                    if parents[v] != -1:
                        heights[parents[v]] = max(heights[parents[v]], 1 + heights[v])
                        if heights[parents[v]] >= k:
                            return True
                else:
                    v = stack[-1]
                    heights[v] = 1
                    if heights[v] >= k:
                        return True
                    expanded[v] = 1
                    for w in edges[v]:
                        if a[w] <= bound:
                            if {{completion}}
                                return True

                            if heights[w] > 0:
                                heights[v] = max(heights[v], 1 + heights[w])
                                if heights[v] >= k:
                                    return True

                            else:
                                parents[w] = v
                                stack.append(w)

    return False

if not check(a_copy[-1]):
    stdout.write('-1\n')

else:
    upper = len(a_copy)-1
    lower = -1
    while upper - lower > 1:
        candidate = (upper+lower)//2
        if check(a_copy[candidate]):
            upper = candidate
        else:
            lower = candidate

    stdout.write(str(a_copy[upper])+'\n')
",expanded[w] == 1:,parents[w] = v
"import sys
input = sys.stdin.readline
n, m, k = list(map(int,input().split()))
arr = list(map(int,input().split()))

adj = [list() for _ in range(n)]
for i in range(m):
    u, v = list(map(int,input().split()))
    adj[u-1].append(v-1)
    
def dfs(u, vis, val, dist, group):
    
    vis[u] = True
    group[u] = 1
    for v in adj[u]:
        if arr[v] <= val :
            if group[v]:
                dist[u] = 10**18
                return True
            if not vis[v]:
                dfs(v, vis, val, dist, group)
                group[v] = 0
            dist[u] = max(dist[u], dist[v] + 1)
        if dist[u] >= k :
            return True
                

def ok(val):
    if k == 1:return True
    vis = [False] * n
    dist = [1] * n
    group = [0] * n
    for i in range(n):
        if arr[i] <= val and not vis[i]:
            stk = [i]
            while stk:
                u = stk.pop()
                if vis[u]:
                    for v in adj[u]:
                        if arr[v] <= val :
                            dist[u] = max(dist[u], dist[v] + 1)
                            if {{completion}}
                                return True
                            group[v] = 0
                    group[u] = 0
                    continue
                stk.append(u)
                group[u] = 1
                vis[u] = True
                for v in adj[u]:
                    if group[v]:
                        return True
                    if arr[v] <= val :
                        if not vis[v]:
                            stk.append(v)
            group[i] = 0
    return False
            


sor = sorted(arr)
l = 0
r = n - 1
while l <= r :
    mid = (l + r) // 2
    if ok(sor[mid]):
        r = mid - 1
    else:
        l = mid + 1
if l == n:
    print(-1)
else:
    print(sor[l]) ",dist[u] >= k :,group[v] == 0:
"import sys
input = sys.stdin.readline
n, m, k = list(map(int,input().split()))
arr = list(map(int,input().split()))

adj = [list() for _ in range(n)]
for i in range(m):
    u, v = list(map(int,input().split()))
    adj[u-1].append(v-1)
    
def dfs(u, vis, val, dist, group):
    
    vis[u] = True
    group[u] = 1
    for v in adj[u]:
        if arr[v] <= val :
            if group[v]:
                dist[u] = 10**18
                return True
            if not vis[v]:
                dfs(v, vis, val, dist, group)
                group[v] = 0
            dist[u] = max(dist[u], dist[v] + 1)
        if dist[u] >= k :
            return True
                

def ok(val):
    if k == 1:return True
    vis = [False] * n
    dist = [1] * n
    group = [0] * n
    for i in range(n):
        if arr[i] <= val and not vis[i]:
            stk = [i]
            while stk:
                u = stk.pop()
                if vis[u]:
                    for v in adj[u]:
                        if {{completion}}
                            dist[u] = max(dist[u], dist[v] + 1)
                            if dist[u] >= k :
                                return True
                            group[v] = 0
                    group[u] = 0
                    continue
                stk.append(u)
                group[u] = 1
                vis[u] = True
                for v in adj[u]:
                    if group[v]:
                        return True
                    if arr[v] <= val :
                        if not vis[v]:
                            stk.append(v)
            group[i] = 0
    return False
            


sor = sorted(arr)
l = 0
r = n - 1
while l <= r :
    mid = (l + r) // 2
    if ok(sor[mid]):
        r = mid - 1
    else:
        l = mid + 1
if l == n:
    print(-1)
else:
    print(sor[l]) ",arr[v] <= val :,group[v]:
"test = int(input())

for i in range(test):
    ans = ""B""
    cnt =0
    while cnt < 8 :
        t = input()
        if t.strip() != '':
            cnt +=1
            if {{completion}}
                ans = ""R""

    print(ans)            
    

    
        
    
    
    ","t == ""RRRRRRRR"":",t.strip()!= '':
"t=int(input())
for p in range(t):
    
    l=[]
    c=0
    a=['R','R','R','R','R','R','R','R']
    while(len(l)<8):
        s=input()
        if {{completion}}
            l.append([*s])
    for i in range(8):
        if l[i]==a:
            c=1
            break
    print(""B"" if c!=1 else ""R"")",len(s)==8:,l[i]==a:
"t=int(input())
for p in range(t):
    
    l=[]
    c=0
    a=['R','R','R','R','R','R','R','R']
    while(len(l)<8):
        s=input()
        if len(s)==8:
            l.append([*s])
    for i in range(8):
        if {{completion}}
            c=1
            break
    print(""B"" if c!=1 else ""R"")",l[i]==a:,len(s)==8:
"for _ in range(int(input())):
    l=[]
    ans=""B""
    while len(l)!=8:
        l.append(input())
        if {{completion}}
            l.pop()

    for row in l:
        if row.count('R')==8:
            ans='R'
            break

    print(ans)
        
    ",len(l[-1])<8:,row.count('R')==8:
"for _ in range(int(input())):
    l=[]
    ans=""B""
    while len(l)!=8:
        l.append(input())
        if len(l[-1])<8:
            l.pop()

    for row in l:
        if {{completion}}
            ans='R'
            break

    print(ans)
        
    ",row.count('R')==8:,len(l[-1])<8:
"from sys import stdin
n = int(input())
lines = stdin.read().split()
a = 0
for ele in range(n):
    for i in range(8):
        if {{completion}}
            print('R')
            break
    else:
        print('B')
    a+=8",lines[i+a].count('R') == 8:,lines[i + j].count('R') == 8:
"for _ in range(int(input())):
    met = []
    res = []
    judge = True
    i = 0
    while i <  8:
        tmp = input()
        met.append(tmp)
        if {{completion}}
            i += 1
        if tmp == ""R"" * 8 and judge:
            print(""R"")
            judge = False

    if judge:
        print(""B"")
#    for i in met:
#        print(i)",tmp != '':,"tmp == ""R"" * 8 and judge:"
"for _ in range(int(input())):
    met = []
    res = []
    judge = True
    i = 0
    while i <  8:
        tmp = input()
        met.append(tmp)
        if tmp != '':
            i += 1
        if {{completion}}
            print(""R"")
            judge = False

    if judge:
        print(""B"")
#    for i in met:
#        print(i)","tmp == ""R"" * 8 and judge:",tmp!= '':
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    while(j<8) :
        a = input()
        if(a != '') :
            b.append(a)
            j += 1
    key = 0
    for j in range(8) :
        ok = True
        for k in range(8) :
            if{{completion}}
                ok = False
        if(ok) :
            key = 1
            print(""R"")
            break
    if(not key) :
        print(""B"")
                
    
        
",(b[j][k] != 'R') :,(a!= '') :
"from sys import stdin

t = int(input())

lines = stdin.read().split()
j = 0
for num in range(t):
    for i in range(8):
        if {{completion}}
            print('R')
            break
    else:
        print('B')
    j += 8",lines[i + j].count('R') == 8:,lines[i+j].count('R') == 8:
"t = int(input())

for _ in range(t):
     count = 0
     grid = []
     while count < 8:
        n = input()
        if len(n) != 0:
            count+=1
            grid.append(n)
     ans = False
     for i in range(8):
        x = False
        for j in range(8):
            if {{completion}}
                x = True
        if not x:
            print('R')
            ans = True
            break
     if not ans:
        print('B')


",grid[i][j]!='R':,grid[i][j]=='R':
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    key = '.'
    while(j<8) :
        a = input()
        if{{completion}}
            b.append(a)
            j += 1
    for j in range(8) :
        if(len(set(b[j])) == 1 and b[j][0] == 'R') :
           key = 'R'
           break
    if(key!= 'R') :
        key = 'B'
    print(key)
",(a != '') :,(len(set(b[j])) == 1 and b[j][0] == 'R') :
"n = int(input())
for i in range(n) :
    b = []
    j = 0
    key = '.'
    while(j<8) :
        a = input()
        if(a != '') :
            b.append(a)
            j += 1
    for j in range(8) :
        if{{completion}}
           key = 'R'
           break
    if(key!= 'R') :
        key = 'B'
    print(key)
",(len(set(b[j])) == 1 and b[j][0] == 'R') :,(b[j][k]!= 'B') :
"import sys

inp = sys.stdin.read().split()[::-1]
out = []

def compress(s):
    lst = None
    ret = []
    for c in s:
        if {{completion}}
            ret.append(0)
            lst = c        
        ret[-1] += 1
    return ret

def transform(lns):
    st = []
    s = 0
    for l in lns:
        st.append(s)
        s += l
    return st

def tc(n, txt, patt):
    if txt == patt: 
        out.append(0)
        return
    if txt[0] != patt[0] or txt[-1] != patt[-1]:
        out.append(-1)
        return
    A = compress(txt)
    B = compress(patt)
    if len(A) != len(B): 
        out.append(-1)
        return
    A = transform(A)
    B = transform(B)
    ans = 0
    for a, b in zip(A, B):
        ans += abs(a - b)
    out.append(ans)

for _ in range(int(inp.pop())):
    n = int(inp.pop())
    txt = inp.pop()
    patt = inp.pop()
    tc(n, txt, patt)

print('\n'.join(map(str, out)))",lst != c:,abs(a - b) <= 1:
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD
    WORD_MASK = -1
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        
    def flip_range(self, l, r):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = BitSet.WORD_MASK << (l % BitSet.BITS_PER_WORD)
        rem = (r+1) % BitSet.BITS_PER_WORD
        lastWordMask = BitSet.WORD_MASK if rem == 0 else ~(BitSet.WORD_MASK << rem)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.WORD_MASK
            self.words[endWordIndex] ^= lastWordMask

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.BITS_PER_WORD))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return self.words[wordIndex] & (1 << (bitIndex % BitSet.BITS_PER_WORD)) != 0

    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if {{completion}}
                return wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = self.words[wordIndex]

    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if word != 0:
                index = wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
                return index if index < self.sz else - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = ~self.words[wordIndex]
            
    def lastSetBit(self):
        wordIndex = len(self.words) - 1
        word = self.words[wordIndex]

        while wordIndex >= 0:
            if word != 0:
                return wordIndex * BitSet.BITS_PER_WORD + (word.bit_length() - 1 if word > 0 else  BitSet.BITS_PER_WORD - 1)
            wordIndex -= 1
            word = self.words[wordIndex]
        return -1
            
    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != -1:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != -1:
                    res += [1] * (j-i)
                    st = j
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz


def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val))

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val))

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.lastSetBit())
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()",word != 0:,word!= 0:
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD
    WORD_MASK = -1
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        
    def flip_range(self, l, r):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = BitSet.WORD_MASK << (l % BitSet.BITS_PER_WORD)
        rem = (r+1) % BitSet.BITS_PER_WORD
        lastWordMask = BitSet.WORD_MASK if rem == 0 else ~(BitSet.WORD_MASK << rem)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.WORD_MASK
            self.words[endWordIndex] ^= lastWordMask

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.BITS_PER_WORD)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.BITS_PER_WORD))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return self.words[wordIndex] & (1 << (bitIndex % BitSet.BITS_PER_WORD)) != 0

    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if word != 0:
                return wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = self.words[wordIndex]

    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))

        while True:
            if {{completion}}
                index = wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1
                return index if index < self.sz else - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return -1
            word = ~self.words[wordIndex]
            
    def lastSetBit(self):
        wordIndex = len(self.words) - 1
        word = self.words[wordIndex]

        while wordIndex >= 0:
            if word != 0:
                return wordIndex * BitSet.BITS_PER_WORD + (word.bit_length() - 1 if word > 0 else  BitSet.BITS_PER_WORD - 1)
            wordIndex -= 1
            word = self.words[wordIndex]
        return -1
            
    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != -1:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != -1:
                    res += [1] * (j-i)
                    st = j
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz


def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val))

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val))

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.lastSetBit())
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()",word != 0:,word!= 0:
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 1 << ADDRESS_BITS_PER_WORD
    MASK = -0x1
    MASK_MAX = 0x7fffffffffffffff
    MASK_MIN = ~MASK_MAX

    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_one_left(self, shift):
        if shift == BitSet.WORD_SZ - 1:
            return BitSet.MASK_MIN
        return 1 << (shift % BitSet.WORD_SZ)

    def _shift_mask_right(self, shift):
        if shift == 0:
            return BitSet.MASK
        return BitSet.MASK_MAX >> (shift - 1)
    
    def _shift_mask_left(self, shift):
        if shift == 0:
            return BitSet.MASK
        return ~(BitSet.MASK_MAX >> (BitSet.WORD_SZ - shift - 1))

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~self._shift_one_left(bitIndex % BitSet.WORD_SZ)
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if {{completion}}
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex]
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)
        
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = ~self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex]

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    res += [1] * (j-i)
                    st = j
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()",word != 0:,word!= 0:
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 1 << ADDRESS_BITS_PER_WORD
    MASK = -0x1
    MASK_MAX = 0x7fffffffffffffff
    MASK_MIN = ~MASK_MAX

    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex >> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_one_left(self, shift):
        if shift == BitSet.WORD_SZ - 1:
            return BitSet.MASK_MIN
        return 1 << (shift % BitSet.WORD_SZ)

    def _shift_mask_right(self, shift):
        if shift == 0:
            return BitSet.MASK
        return BitSet.MASK_MAX >> (shift - 1)
    
    def _shift_mask_left(self, shift):
        if shift == 0:
            return BitSet.MASK
        return ~(BitSet.MASK_MAX >> (BitSet.WORD_SZ - shift - 1))

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= self._shift_one_left(bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~self._shift_one_left(bitIndex % BitSet.WORD_SZ)
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = ~self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if {{completion}}
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex]
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)
        
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        rem = fromIndex % BitSet.WORD_SZ
        word = ~self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - rem)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ - 1 + (word.bit_length() if word > 0 else BitSet.WORD_SZ)
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex]

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    res += [1] * (j-i)
                    st = j
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()",word != 0:,word!= 0:
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 60#1 << ADDRESS_BITS_PER_WORD
    MASK = 0xfffffffffffffff
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex // BitSet.WORD_SZ #>> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_mask_right(self, shift):
        return BitSet.MASK >> shift
    
    def _shift_mask_left(self, shift):
        return (BitSet.MASK >> shift) << shift

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.WORD_SZ))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if {{completion}}
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex] & BitSet.MASK
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)
            
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex] & BitSet.MASK

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    res += [1] * (j-i)
                    st = j
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()",word != 0:,word!= 0:
"import sys
import os
from io import BytesIO, IOBase

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

class BitSet:

    ADDRESS_BITS_PER_WORD = 6
    WORD_SZ = 60#1 << ADDRESS_BITS_PER_WORD
    MASK = 0xfffffffffffffff
    
    def __init__(self, sz):
        self.sz = sz
        self.words = [0] * (self._wordIndex(sz - 1) + 1)
        self.last = -1

    def _wordIndex(self, bitIndex):
        if bitIndex >= self.sz:
            raise ValueError(""out of bound index"", bitIndex)
        return bitIndex // BitSet.WORD_SZ #>> BitSet.ADDRESS_BITS_PER_WORD

    def _shift_mask_right(self, shift):
        return BitSet.MASK >> shift
    
    def _shift_mask_left(self, shift):
        return (BitSet.MASK >> shift) << shift

    def flip(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        self.words[wordIndex] ^= 1 << (bitIndex % BitSet.WORD_SZ)
        
    def flip_range(self, l, r, pos):
        startWordIndex = self._wordIndex(l)
        endWordIndex = self._wordIndex(r)

        firstWordMask = self._shift_mask_left(l % BitSet.WORD_SZ)
        lastWordMask = self._shift_mask_right(BitSet.WORD_SZ - 1 - r % BitSet.WORD_SZ)
        if startWordIndex == endWordIndex:
            self.words[startWordIndex] ^= (firstWordMask & lastWordMask)
        else:
            self.words[startWordIndex] ^= firstWordMask
            for i in range(startWordIndex + 1, endWordIndex):
                self.words[i] ^= BitSet.MASK
            self.words[endWordIndex] ^= lastWordMask
            
        if pos:
            self.last = max(self.last, r)
        elif r == self.last:
            self.last = self.previousSetBit(r-1)

    def __setitem__(self, bitIndex, value):
        wordIndex = self._wordIndex(bitIndex)
        if value:
            self.words[wordIndex] |= 1 << (bitIndex % BitSet.WORD_SZ)
        else:
            self.words[wordIndex] &= ~(1 << (bitIndex % BitSet.WORD_SZ))
    
    def __getitem__(self, bitIndex):
        wordIndex = self._wordIndex(bitIndex)
        return (self.words[wordIndex] >> (bitIndex % BitSet.WORD_SZ)) & 1

    ''' return len(bitset) if there is no ""1"" after fromIndex '''
    def nextSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = self.words[wordIndex]

    ''' return len(bitset) if there is no ""0"" after fromIndex '''
    def nextClearBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_left(fromIndex % BitSet.WORD_SZ)

        while True:
            if {{completion}}
                return wordIndex * BitSet.WORD_SZ + (word & -word).bit_length() - 1
            wordIndex += 1
            if wordIndex > len(self.words) - 1:
                return self.sz
            word = ~self.words[wordIndex] & BitSet.MASK
    
    ''' return -1 if there is no ""1"" before fromIndex '''
    def previousSetBit(self, fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = self.words[wordIndex] & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)
            
        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = self.words[wordIndex]

    ''' return -1 if there is no ""0"" before fromIndex '''
    def previousClearBit(self,fromIndex):
        wordIndex = self._wordIndex(fromIndex)
        word = (~self.words[wordIndex] & BitSet.MASK) & self._shift_mask_right(BitSet.WORD_SZ - 1 - fromIndex % BitSet.WORD_SZ)

        while True:
            if word != 0:
                return wordIndex * BitSet.WORD_SZ + word.bit_length() - 1
            wordIndex -= 1
            if wordIndex < 0:
                return -1
            word = ~self.words[wordIndex] & BitSet.MASK

    def __str__(self):
        res = []
        st = 0
        while True:
            i = self.nextSetBit(st)
            if i != self.sz:
                res += [0] * (i - st)
                j = self.nextClearBit(i)
                if j != self.sz:
                    res += [1] * (j-i)
                    st = j
                else:
                    res += [1] * (self.sz - i)
                    break
            else:
                res += [0] * (self.sz - st)
                break
        
        return """".join(str(v) for v in res)

    def __repr__(self):
        return ""Bitset(%s)"" % str(self)

    def __iter__(self):
        for i in self[:]:
            yield i

    def __len__(self):
        return self.sz

def add(bs,val):
    bs.flip_range(val, bs.nextClearBit(val), 1)

def rem(bs,val):
    bs.flip_range(val, bs.nextSetBit(val), 0)

def solve():
    
    res = []
    bs = BitSet(Z)
    
    for val in A:
        add(bs,val)
        
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        rem(bs,A[idx])
        A[idx] = val
        add(bs,val)
        
        res.append(bs.last)
    
    return ""\n"".join(str(v) for v in res)

Z = 200030

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()",word != 0:,word!= 0:
"import sys
ctr = [0, 0, 0]
cnt = [0]

while cnt[-1] < 10**9:
	i = ctr.index(min(ctr))
	cnt.append(cnt[-1] + 2*(sum(ctr) - ctr[i]))
	ctr[i] += 1


def solve(sn):
	t = int(sn)
	s, e = 0, len(cnt) - 1
	while s < e:
		m = (s + e) >> 1
		if {{completion}}
			e = m
		else:
			s = m + 1
	return str(s)

inp = sys.stdin.read().split()
inp.pop(0)

print('\n'.join(map(solve, inp)))",cnt[m] >= t:,cnt[m] >= t:
"import sys
ctr = [0, 0, 0]
cnt = [0]

i = 0
tot = 0
s = 0
while tot < 10**9:
    tot += 2*(s - ctr[i])
    cnt.append(tot)
    ctr[i] += 1
    s += 1
    i += 1
    if i == 3: i = 0

def solve(sn):
	t = int(sn)
	s, e = 0, len(cnt) - 1
	while s < e:
		m = (s + e) >> 1
		if {{completion}}
			e = m
		else:
			s = m + 1
	return str(s)

inp = sys.stdin.read().split()
inp.pop(0)

print('\n'.join(map(solve, inp)))",cnt[m] >= t:,cnt[m] >= t:
"""""""
in each circle, there's two options
""""""
import sys;input=sys.stdin.readline
I=lambda:int(input())
A=lambda:[*map(int,input().split())]

mod=10**9+7
for _ in range(I()):
  n=I()
  a,b,c=A(),A(),A()
  
  g={a[i]:[b[i],c[i]] for i in range(n)}
  cycles,visi=0,[False]*(n+1)
  for u in range(1,n+1):
    need=True;cycle_size=0
    while not visi[g[u][0]]:
      if {{completion}}need=False
      #mark visited and move to next vertex
      visi[g[u][0]],u=True,g[u][0]
      cycle_size+=1
    if need and cycle_size>1:cycles+=1
  print(pow(2,cycles,mod))",g[u][1]!=0:,need==False:
"# read interger t from input.txt and then read t lines
import sys

DEBUG = False

def check(a, b, c):
    a = [0] + a
    b = [0] + b
    c = [0] + c
    m_ = [0] * len(a)
    m = [0] * len(a)
    for i in range(1, len(b)):
        m_[b[i]] = i
    for i in range(1, len(a)):
        m[i] = m_[a[i]]
    # print("">>>"", a)
    # print("">>>"", b)
    # print("">>>"", m)
    # find cicles in permutations
    total_num = 1
    used = [False] * len(m)
    # print(a, b, c)
    for i in range(1, len(m)):
        if not used[i]:
            j = i
            c_zeros = True
            while not used[j]:
                if {{completion}}
                    c_zeros = False
                used[j] = True
                j = m[j]
            used[i] = True
            # print(i, m[i], a[i], b[i], c[i])
            if c_zeros and m[i] != i:
                # print("">>"", i)
                total_num = (total_num) * 2 % 1000000007
    print(total_num)


def main(f):
    t = int(f.readline())
    for i in range(t):
        n = int(f.readline())
        a = list(map(int, f.readline().split()))
        b = list(map(int, f.readline().split()))
        c = list(map(int, f.readline().split()))

        check(a, b, c)

if DEBUG:
    f = open('input.txt', 'r')
else:
    f = sys.stdin

main(f)

f.close()  
",c[j] != 0:,m[i]!=0:
"
import sys
t = int(sys.stdin.readline())
for _ in range(t):
    n = int(sys.stdin.readline())
    a = list(map(int,sys.stdin.readline().split()))
    b = list(map(int,sys.stdin.readline().split()))
    c = list(map(int,sys.stdin.readline().split()))
    count = 0
    L = [0] * (n+1)
    for i in range(0,n):
        L[a[i]] = b[i]
    status = 1
    for i in range(n):
        if c[i] != 0:
            L[a[i]] = 0
            L[b[i]] = 0
    for i in range(1,n+1):
        key = i
        xstatus = 1
        status = 1
        xcount= 0
        while status == 1:
            if L[key] == 0:
                status = 0
            if L[key] == i:
                if {{completion}}
                    count += 1
                status = 0
            xcount += 1
            x = L[key]
            L[key] = 0
            key = x
    print((2 **count) % (10 ** 9 + 7)) ",xcount >= 1:,L[key]!=0:
"import sys

input = sys.stdin.readline

class Solver1670C:

    def __init__(self):
        self.n = int(input())
        self.a = list(map(int, input().split(' ')))
        self.b = list(map(int, input().split(' ')))
        self.d = list(map(int, input().split(' ')))

        self.pos_a = [0 for _ in range(self.n+1)]
        self.pos_b = [0 for _ in range(self.n+1)]

        self.been = [0 for _ in range(self.n+1)]

        self.mod = (10**9)+7

    def solve(self):

        for i in range(0, self.n):
            self.pos_a[self.a[i]] = i
            self.pos_b[self.b[i]] = i

        for i in range(0, self.n):
            if self.d[i] and self.been[i] == 0:

                if self.d[i] == self.a[i]:
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

                else:
                    j = i
                    while {{completion}}
                        self.been[j] = 1
                        j = self.pos_b[self.a[j]]

        outp = 1

        for i in range(0, self.n):
            if self.been[i] == 0:
                cnt = 0
                j = i
                while self.been[j] == 0:
                    self.been[j] = 1
                    j = self.pos_a[self.b[j]]

                    cnt += 1

                if cnt >= 2:
                    outp = outp * 2 % self.mod

        return outp


t = int(input())

while t:

    t -= 1

    cur = Solver1670C()

    print(cur.solve())
",self.been[j] == 0:,((r >> i) << i)!= r:
"import sys

input = sys.stdin.readline

class Solver1670C:

    def __init__(self):
        self.n = int(input())
        self.a = list(map(int, input().split(' ')))
        self.b = list(map(int, input().split(' ')))
        self.d = list(map(int, input().split(' ')))

        self.pos_a = [0 for _ in range(self.n+1)]
        self.pos_b = [0 for _ in range(self.n+1)]

        self.been = [0 for _ in range(self.n+1)]

        self.mod = (10**9)+7

    def solve(self):

        for i in range(0, self.n):
            self.pos_a[self.a[i]] = i
            self.pos_b[self.b[i]] = i

        for i in range(0, self.n):
            if self.d[i] and self.been[i] == 0:

                if self.d[i] == self.a[i]:
                    j = i
                    while {{completion}}
                        self.been[j] = 1
                        j = self.pos_a[self.b[j]]

                else:
                    j = i
                    while self.been[j] == 0:
                        self.been[j] = 1
                        j = self.pos_b[self.a[j]]

        outp = 1

        for i in range(0, self.n):
            if self.been[i] == 0:
                cnt = 0
                j = i
                while self.been[j] == 0:
                    self.been[j] = 1
                    j = self.pos_a[self.b[j]]

                    cnt += 1

                if cnt >= 2:
                    outp = outp * 2 % self.mod

        return outp


t = int(input())

while t:

    t -= 1

    cur = Solver1670C()

    print(cur.solve())
",self.been[j] == 0:,((r >> i) << i)!= r:
"m = 10**9+7
for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    c = list(map(int,input().split()))
    d={i:0 for i in range(1,n+1)}
    for i in range(n):
        d[c[i]]=1
    dd={}
    for i in range(n):
        dd[a[i]]=i
    ans = 1
    for i in range(n):
        if(c[i] != 0 or a[i]==b[i] or d[a[i]] == 1 or d[b[i]]==1):continue
        j=dd[b[i]]; f=2
        while(j!=i):
            if{{completion}}f=1
            c[j]=1
            j=dd[b[j]]
        ans=(ans*f)%m
        k=1
    print(ans)

",(c[j]!=0):,j!=i:
"from sys import stdin, stdout
from functools import reduce

M = int(10**9 + 7)
def solve(a, b, c, n):
    vis = [False]*n
    ans = []
    g = {a[i]:(b[i], c[i]) for i in range(n)}
    for i in range(n):
        t, ass, j = 0, False, i
        while not vis[j]:
            vis[j] = True
            if {{completion}} ass = True 
            j = g[j + 1][0] - 1
            t += 1
            #print(t, ass, j)
        if not ass and t > 1: ans.append(2)
        else: ans.append(1)
        #print(ans)
    if not ans: return 0
    #print(reduce(lambda x, y: (x*y)%M, ans, 1) % M)
    return reduce(lambda x, y: (x*y)%M, ans, 1) % M

for i in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())
    a = list(map(int, stdin.readline().strip().split()))
    b = list(map(int, stdin.readline().strip().split()))
    c = list(map(int, stdin.readline().strip().split()))
    out_ = solve(a, b, c, n)
    stdout.write(f""{out_}\n"")",g[j + 1][1] != 0:,g[j+1][0]-1:
"from sys import stdin, setrecursionlimit
input = stdin.readline

from bisect import bisect_left, bisect_right
from collections import deque
from functools import lru_cache, reduce
from heapq import heappush, heappop
from math import sqrt, ceil, floor, log2

T = int(input())

def rl(t = int):
    return list(map(t, input().split()))

MOD = 10**9 + 7
for t in range(1, T + 1):
    n = int(input())
    a = rl()
    b = rl()
    d = rl()

    m = {v:i for i,v in enumerate(a)}

    for i in range(n):
        if a[i] == b[i]:
            d[i] = a[i]

    ret = 1
    seen = set()
    for i,cur in enumerate(a): 
        if cur in seen:
            continue
        
        mul = 2
        while cur not in seen:
            if {{completion}}
                mul = 1
            seen.add(cur)
            #print(i, cur)
            cur = b[i]
            i = m[cur]

        #print(seen, mul)
        ret = (ret * mul) % MOD

    print(ret)
",d[i] != 0:,"this is the start of the ground truth
mul = 2
while cur not in seen:
    if d[i]!= 0:
        mul = 1
    seen.add(cur)
    cur = b[i]
    i = m[cur]

    mul = 1
    seen.add(cur)
    cur = b[i]
    i = m[cur]

    mul = 1
    seen.add(cur)
    cur = b[i]
    i = m[cur]

    mul ="
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();b=L();d=L();l=[]
    for i in range(n):l.append([a[i],b[i],d[i]])
    l.sort(key=lambda x:x[0]);s=set();ans=1
    for i in range(n):
        if i not in s:
            d={};cur=i;f=0
            while True:
                d[l[cur][0]]=d.get(l[cur][0],0)+1
                d[l[cur][1]]=d.get(l[cur][1],0)+1
                s.add(cur)
                if {{completion}}f=1
                if d[l[cur][1]]==2:break
                cur=l[cur][1]-1
            if f!=1:ans=(ans*2)%mod1
    print(ans)",l[cur][2]!=0 or l[cur][1]==l[cur][0]:,(d[l[cur][1]]==2):
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n=I();a=L();b=L();d=L();l=[]
    for i in range(n):l.append([a[i],b[i],d[i]])
    l.sort(key=lambda x:x[0]);s=set();ans=1
    for i in range(n):
        if i not in s:
            d={};cur=i;f=0
            while True:
                d[l[cur][0]]=d.get(l[cur][0],0)+1
                d[l[cur][1]]=d.get(l[cur][1],0)+1
                s.add(cur)
                if l[cur][2]!=0 or l[cur][1]==l[cur][0]:f=1
                if {{completion}}break
                cur=l[cur][1]-1
            if f!=1:ans=(ans*2)%mod1
    print(ans)",d[l[cur][1]]==2:,l[cur][2]!=0 or l[cur][1]==l[cur][0]:
"import sys

ls = []
for l in sys.stdin:
    lst = l.rstrip('\n')
    if len(lst) > 0:
        ls.append(lst)

for l in ls:
    sys.stderr.write(l + ('\n'))

sys.stderr.write(""-- output --\n"")

def solve(n, a):
    k = sum([0 if ai > 0 else 1 for ai in a])
    b = [abs(a[i]) if i >= k else -abs(a[i]) for i in range(n)]
    for i in range(n-1):
        if {{completion}}
            return ""NO""
    return ""YES""

for i in range(1, len(ls)-1, 2):
    n = int(ls[i])
    a = [int(x) for x in ls[i+1].split(' ')]
    print(solve(n, a))",b[i] > b[i+1]:,a[i] > 0:
"
 
n,l,r,z=map(int,input().split())
mod=10**9+7
 
 
#############################
#############
cnb_max=10**5
#############
 
kai=[1]*(cnb_max+1)
rkai=[1]*(cnb_max+1)
for i in range(cnb_max):
    kai[i+1]=kai[i]*(i+1)%mod
 
rkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)
for i in range(cnb_max):
    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod
 
def cnb(x,y):
    if y>x:
        return 0
    if x<0:return 0
    if y<0:return 0
    return (kai[x]*rkai[y]%mod)*rkai[x-y]%mod
 
 
def inv(n):
    return kai[n-1]*rkai[n]%mod
 
##################################
 
 
 
def f(r,z):
    dp=[0]*(2*n+10)
    dp[0]=1
    for i in range(65):
        newdp=[0]*(2*n+10)
        for j in range(2*n+5):
            dp[j]%=mod
            if dp[j]==0:continue
            for cnt in range(z&1,n+1,2):
                if j+cnt>r:break
                d=0
                if {{completion}}d=1
                newdp[(j+cnt)//2+d]+=dp[j]*cnb(n,cnt)%mod
        z//=2
        r//=2
        dp=newdp[:]
    return dp[0]%mod
 
print((f(r,z)-f(l-1,z))%mod)
 ",(r&1)==0 and (j+cnt)%2==1:,j==0:
"import sys
input = sys.stdin.readline
MOD = 10 ** 9 + 7
N = 10000
fact = [0 for _ in range(N)]
invfact = [0 for _ in range(N)]
fact[0] = 1
for i in range(1, N):
    fact[i] = fact[i - 1] * i % MOD

invfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)

for i in range(N - 2, -1, -1):
    invfact[i] = invfact[i + 1] * (i + 1) % MOD

def nCk(n, k):
    if k < 0 or n < k:
        return 0
    else:
        return (fact[n] * invfact[k] % MOD) * invfact[n - k] % MOD

def nHk(n, k):
    return nCk(n + k - 1, k)


def main():
    n, l, r, z = map(int, input().split())
    bit = [0] * 60
    for i in range(60):
        if z >> i & 1:
            bit[i] = 1
            r -= 1 << i
            l -= 1 << i
    if r < 0:
        print(0)
        return
    
    ma = [0] * 60
    for i in range(60):
        if n % 2 == bit[i]:
            nn = n
        else:
            nn = n - 1
        ma[i] = (1 << (i + 1)) * nn
        if i != 0:
            ma[i] += ma[i - 1]

    tot = [0] * 60
    for i in range(60):
        for j in range(bit[i], n + 1, 2):
            tot[i] += nCk(n, j)
            tot[i] %= MOD
        if i != 0:
            tot[i] *= tot[i - 1]
            tot[i] %= MOD

    memo = {}
    d = r - l
    bi = [1 << i for i in range(61)]

    def solve(i, l):
        r = l + d
        if l <= 0 and ma[i] <= r:
            return tot[i]
        elif ma[i] < l:
            return 0
        elif i == -1:
            return l <= 0
        elif i + 60 * l in memo:
            return memo[i + 60 * l]
        
        ret = 0
        mi = bi[i + 1]
        ll = l
        rr = r
        for j in range(bit[i], n + 1, 2):
            ret += solve(i - 1, ll) * nCk(n, j) % MOD
            if ret >= MOD: ret -= MOD
            ll -= mi
            rr -= mi
            if {{completion}}
                break

        memo[i + 60 * l] = ret
        return ret
    
    ans = solve(59, l)
    
    print(ans)
    
    
for _ in range(1):
    main()",rr < 0:,"i in range(1, MAX):"
"a,b=map(int,input().split())
arr=[0]*500001
for {{completion}}
    arr[i]+=1
for i in range(1,500000):
    arr[i+1]+=arr[i]//(i+1)
    arr[i]%=i+1
if sum(arr[:b])==0:
    print('Yes')
else:
    print('No')","i in map(int,input().split()):","i in range(1,500000):"
"a,b=map(int,input().split())
arr=[0]*500001
for i in map(int,input().split()):
    arr[i]+=1
for {{completion}}
    arr[i+1]+=arr[i]//(i+1)
    arr[i]%=i+1
if sum(arr[:b])==0:
    print('Yes')
else:
    print('No')","i in range(1,500000):","i in map(int,input().split()):"
"import sys
from collections import Counter

input = sys.stdin.readline
n, x = map(int, input().split())
a = list(map(int, input().split()))
cnt = Counter(a)
rest, base = 0, 1
for t in range(x, 0, -1):
    if {{completion}}
        n -= cnt[t]
        rest += cnt[t] % base
    rest %= base
    rest *= t
    base *= t
    if n == 0 or base - rest > n * t:
        break
print('Yes' if n == 0 and rest % base == 0 else 'No')",t in cnt:,cnt[t] > 0:
"import sys
from collections import Counter

input = sys.stdin.readline
n, x = map(int, input().split())
a = list(map(int, input().split()))
cnt = Counter(a)
rest, base = 0, 1
for t in range(x, 0, -1):
    if t in cnt:
        n -= cnt[t]
        rest += cnt[t] % base
    rest %= base
    rest *= t
    base *= t
    if {{completion}}
        break
print('Yes' if n == 0 and rest % base == 0 else 'No')",n == 0 or base - rest > n * t:,cnt[t] > 0:
"def rl():
	return [int(i) for i in input().split()]

def solve():
	[n,x]=rl()
	a=rl()
	nax=500000+5
	ct=[0 for i in range(nax)]
	for b in a:
		ct[b]+=1
	for i in range(x):
		if {{completion}}
			return ""No""
		ct[i+1]+=ct[i]/(i+1)
	return ""Yes""

print(solve())
",ct[i]%(i+1):,ct[i]%(i+1)==0:
"# your code goes here

if __name__ == '__main__':
	n, x = map(int, input('').split(' '))
	a = list(map(int, input('').split(' ')))
	cnt = [0] * (x+2)
	for w in a:
		cnt[w] += 1
	for i in range(x):
		while {{completion}}
			cnt[i] -= (i+1)
			cnt[i+1] += 1
	print('No' if sum(cnt[:x]) else 'Yes')
			
	",cnt[i] > i:,cnt[i] >= (i+1):
"def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    while True:
        k = a[-1]
        a.pop() 
        cnt = 1
        while {{completion}}
            cnt += 1
            a.pop()
        if cnt < k + 1:
            return ('Yes' if k >= x else 'No' )
        for i in range(cnt // (k + 1)):
            a.append(k + 1) 
        for i in range(cnt % (k + 1)):
            a.append(k)

n, x = tuple(map(int, input().split(' ')))
a = input().split(' ')
a = list(map(int, a))

print(factorial_divisibility(n, x, a))



",len(a) > 0 and k == a[-1]:,cnt < k + 1:
"def factorial_divisibility(n, x, a: list):
    a.sort() 
    a.reverse()
    while True:
        k = a[-1]
        a.pop() 
        cnt = 1
        while len(a) > 0 and k == a[-1]:
            cnt += 1
            a.pop()
        if {{completion}}
            return ('Yes' if k >= x else 'No' )
        for i in range(cnt // (k + 1)):
            a.append(k + 1) 
        for i in range(cnt % (k + 1)):
            a.append(k)

n, x = tuple(map(int, input().split(' ')))
a = input().split(' ')
a = list(map(int, a))

print(factorial_divisibility(n, x, a))



",cnt < k + 1:,cnt > 0:
"n , x = [int(x) for x in input().split()]
l = [int(x) for x in input().split()]
s = [0] * (x+1)
for i in l:
    s[i] += 1
for i in range(1,x):
    if {{completion}}
        s[i+1] += s[i]//(i+1)
    else:
        print('NO')
        break
else:
    print('Yes')",s[i] % (i+1) == 0:,s[i]%(i+1)==0:
"
ex = [0]
arr = [0]
for i in range(1):
    a = list(map(int, input().split()))
    ex = a[1]
    b = list(map(int, input().split()))
    arr = b

for i in range(1):
    dp = [0]*ex
    for a in arr:
        dp[a-1]+=1
    for m in range(len(dp)-1):
        while {{completion}}
            dp[m] = dp[m] - m - 2
            dp[m+1]+=1
    dp = dp[:-1]
    A = sum(dp)
    if A == 0:
        ans='Yes'
    else:
        ans='No'
print(ans)
",dp[m]>=m+2:,dp[m]%(m+1)==0:
"n,x=map(int,input().split())
s={i:0 for i in range(1,x+1)}
def f(x,a):
    s[x]=s[x]+a
an=map(int,input().split())
for b in an:
    f(b,1)
l=1
i=1
while i < x:
    if {{completion}}
        f(i+1,s[i]//(i+1))
        i+=1
    else:
        l=0
        break
print(['no','yes'][l])
",s[i]%(i+1)==0:,s[i]%(i+1)==0:
"b=[0]*500001
l=list(map(int,input("""").split()))
n=l[0]
m=l[1]
a=list(map(int,input("""").split()))
e=1
for i in a:
    b[i]+=1
for i in range(1,l[1]):
    if {{completion}}
        b[i+1]+=(b[i]//(i+1))
    else:
        print(""No"")
        e=0
        break
if e==1:
    if b[m]!=0 :
        print(""Yes"")
    else:
        print(""No"")
",b[i]%(i+1)==0:,b[m]!=0 :
"b=[0]*500001
l=list(map(int,input("""").split()))
n=l[0]
m=l[1]
a=list(map(int,input("""").split()))
e=1
for i in a:
    b[i]+=1
for i in range(1,l[1]):
    if b[i]%(i+1)==0:
        b[i+1]+=(b[i]//(i+1))
    else:
        print(""No"")
        e=0
        break
if e==1:
    if {{completion}}
        print(""Yes"")
    else:
        print(""No"")
",b[m]!=0 :,b[m]!=0 :
"from bisect import bisect

import sys
input = sys.stdin.readline

n, b, p, m = map(int, input().split())


adds = []
curr = []
mults = []

i = 0
for _ in range(n):
    t, v = input().split()
    v = int(v)
    
    if t == '*':
        if v == 1:
            continue
        curr.sort()

        adds.append(curr)
        mults.append(v)
        curr = []
    else:
        curr.append(v)
        
curr.sort()
adds.append(curr)

pref = []
for l in adds:  
    np = [0]
    for v in l[::-1]:
        np.append(v + np[-1])
    pref.append(np)

y = len(mults)
un_m = sorted(set(mults))
z = len(un_m)
ct_m = [0] * z
for v in mults:
    for i in range(z):
        if un_m[i] == v:
            ct_m[i] += 1

from itertools import product
poss = []

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            seg_mult.append(seg_mult[-1] * mults[i])
        else:
            seg_mult.append(seg_mult[-1])
    seg_mult.reverse()

    exc = [seg_mult[0] - v for v in seg_mult]

    init_tot = 0
    for j in range(y + 1):
        if exc[j] != 0:
            init_tot += len(adds[j])

    lo = 0 #Ct value provided >= lo >= rem_adds
    hi = 10 ** 18 + 100 #Too high
    while hi - lo > 1:
        mid = lo + (hi - lo) // 2

        tot = init_tot
        for j in range(y + 1):
            if {{completion}}
                continue
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - 1) // exc[j]

        s_ct = len(adds[j]) - bisect(adds[j], limit)

        tot += pref[j][s_ct] * exc[j]
        ct += s_ct

    if lo != 0:
        assert ct >= rem_adds
        tot -= lo * (ct - rem_adds)

    #print(tup, lo, tot, end)
    poss.append(tot * end)
    #break
    




print(max(poss))

    
",exc[j] == 0:,"energy(l, mid) - energy(l, mid+1) < diff:"
"from bisect import bisect

import sys
input = sys.stdin.readline

n, b, p, m = map(int, input().split())


adds = []
curr = []
mults = []

i = 0
for _ in range(n):
    t, v = input().split()
    v = int(v)
    
    if t == '*':
        if v == 1:
            continue
        curr.sort()

        adds.append(curr)
        mults.append(v)
        curr = []
    else:
        curr.append(v)
        
curr.sort()
adds.append(curr)

pref = []
for l in adds:  
    np = [0]
    for v in l[::-1]:
        np.append(v + np[-1])
    pref.append(np)

y = len(mults)
un_m = sorted(set(mults))
z = len(un_m)
ct_m = [0] * z
for v in mults:
    for i in range(z):
        if {{completion}}
            ct_m[i] += 1

from itertools import product
poss = []

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            seg_mult.append(seg_mult[-1] * mults[i])
        else:
            seg_mult.append(seg_mult[-1])
    seg_mult.reverse()

    exc = [seg_mult[0] - v for v in seg_mult]

    init_tot = 0
    for j in range(y + 1):
        if exc[j] != 0:
            init_tot += len(adds[j])

    lo = 0 #Ct value provided >= lo >= rem_adds
    hi = 10 ** 18 + 100 #Too high
    while hi - lo > 1:
        mid = lo + (hi - lo) // 2

        tot = init_tot
        for j in range(y + 1):
            if exc[j] == 0:
                continue
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - 1) // exc[j]

        s_ct = len(adds[j]) - bisect(adds[j], limit)

        tot += pref[j][s_ct] * exc[j]
        ct += s_ct

    if lo != 0:
        assert ct >= rem_adds
        tot -= lo * (ct - rem_adds)

    #print(tup, lo, tot, end)
    poss.append(tot * end)
    #break
    




print(max(poss))

    
",un_m[i] == v:,exc[j] == 0:
"n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if rem[j] == 0:
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if {{completion}}
                out[base][sq + 1] += ct

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))
",spec[d]:,(c[j]!=0):
"n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if {{completion}}
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if spec[d]:
                out[base][sq + 1] += ct

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))
",rem[j] == 0:,(c[j]!=0):
"input = __import__('sys').stdin.readline


class DisjointSetUnion(object):
    def __init__(self, n):
        self.n = n
        self.par = [i for i in range(n)]
    
    def find(self, x):
        toupdate = []
        while {{completion}}
            toupdate.append(x)
            x = self.par[x]
        
        for u in toupdate:
            self.par[u] = x
        return x
    
    def merge(self, u, v):
        u = self.find(u)
        v = self.find(v)
        if u != v:
            self.par[u] = v
        return u != v


n, m = map(int, input().split())

dsu = DisjointSetUnion(n)
adj = [[] for _ in range(n)] # adjlist of the MST
outOfTrees = [] # outside the MST
for _ in range(m):
    u, v = map(lambda x: int(x)-1, input().split())
    if dsu.merge(u, v):
        adj[u].append(v)
        adj[v].append(u)
    else:
        outOfTrees.append((u, v))

# print('outOfTrees', outOfTrees)

# init lca
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for j in range(20):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])


def moveTo(u, step):
    for i in range(20):
        if (step >> i) & 1 == 1:
            u = jump[i][u]
    return u


def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    u = moveTo(u, depth[u] - depth[v])
    if u == v:
        return u
    
    for i in range(19, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# check each edges out of the tree
psum = [0] * n
for u, v in outOfTrees:
    # nodes in the path (and its subtrees) u to v (not including u & v) will select edge u-v in their dfs process
    r = lca(u, v)
    # print('lca', u+1, v+1, r+1)
    if r == u:
        psum[moveTo(v, depth[v] - depth[u] - 1)] += 1
        psum[v] -= 1
    elif r == v:
        psum[moveTo(u, depth[u] - depth[v] - 1)] += 1
        psum[u] -= 1
    else:
        psum[0] += 1
        psum[u] -= 1
        psum[v] -= 1

# print('psum_initial', psum)
# print('applyToChild', applyToChild)

stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    for v in adj[u]:
        if v != par:
            psum[v] += psum[u]
            stack.append((v, u))

# print('psum', psum)
print(''.join('1' if psum[u] == 0 else '0' for u in range(n)))",x != self.par[x]:,u!= v:
"input = __import__('sys').stdin.readline


class DisjointSetUnion(object):
    def __init__(self, n):
        self.n = n
        self.par = [i for i in range(n)]
    
    def find(self, x):
        toupdate = []
        while x != self.par[x]:
            toupdate.append(x)
            x = self.par[x]
        
        for u in toupdate:
            self.par[u] = x
        return x
    
    def merge(self, u, v):
        u = self.find(u)
        v = self.find(v)
        if {{completion}}
            self.par[u] = v
        return u != v


n, m = map(int, input().split())

dsu = DisjointSetUnion(n)
adj = [[] for _ in range(n)] # adjlist of the MST
outOfTrees = [] # outside the MST
for _ in range(m):
    u, v = map(lambda x: int(x)-1, input().split())
    if dsu.merge(u, v):
        adj[u].append(v)
        adj[v].append(u)
    else:
        outOfTrees.append((u, v))

# print('outOfTrees', outOfTrees)

# init lca
jump = [[0] * n]
depth = [0] * n
stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    jump[0][u] = par
    for v in adj[u]:
        if v != par:
            depth[v] = depth[u] + 1
            stack.append((v, u))

for j in range(20):
    jump.append([jump[-1][jump[-1][u]] for u in range(n)])


def moveTo(u, step):
    for i in range(20):
        if (step >> i) & 1 == 1:
            u = jump[i][u]
    return u


def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
    
    u = moveTo(u, depth[u] - depth[v])
    if u == v:
        return u
    
    for i in range(19, -1, -1):
        if jump[i][u] != jump[i][v]:
            u, v = jump[i][u], jump[i][v]
    return jump[0][u]


# check each edges out of the tree
psum = [0] * n
for u, v in outOfTrees:
    # nodes in the path (and its subtrees) u to v (not including u & v) will select edge u-v in their dfs process
    r = lca(u, v)
    # print('lca', u+1, v+1, r+1)
    if r == u:
        psum[moveTo(v, depth[v] - depth[u] - 1)] += 1
        psum[v] -= 1
    elif r == v:
        psum[moveTo(u, depth[u] - depth[v] - 1)] += 1
        psum[u] -= 1
    else:
        psum[0] += 1
        psum[u] -= 1
        psum[v] -= 1

# print('psum_initial', psum)
# print('applyToChild', applyToChild)

stack = [(0, -1)] # (u, par)
while len(stack) > 0:
    u, par = stack.pop()
    for v in adj[u]:
        if v != par:
            psum[v] += psum[u]
            stack.append((v, u))

# print('psum', psum)
print(''.join('1' if psum[u] == 0 else '0' for u in range(n)))",u != v:,(step >> i) & 1 == 1:
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if {{completion}}
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
 		    	   	    	  		 	 						",arr[i] == 1 or i == j:,arr[i] == 1 or i == j:
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        i+=1
    while True:
      if {{completion}}
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
 		    	   	    	  		 	 						",arr[j] == 0 or j == i:,arr[i] == 0 or i == j:
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if {{completion}}
        break
      else:
        i+=1
    while True:
      if arr[j] == 0 or j == i:
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
	  	 	    						 	 		 	 	 	 	 	",arr[i] == 1 or i == j:,arr[j] == 0 or j == i:
"import sys

tokens = (token for token in sys.stdin.read().split())
N = int(next(tokens))
for i in range(N):
  Q = int(next(tokens))
  arr = []
  count = 0
  for i in range(Q):
    arr.append(int(next(tokens)))
  i = 0
  j = len(arr) - 1
  while True:
    while True:
      if arr[i] == 1 or i == j:
        break
      else:
        i+=1
    while True:
      if {{completion}}
        break
      else:
        j-=1
    if i == j:
      break
    sec = arr[i]
    arr [i] = arr[j]
    arr [j] = sec
    count += 1
  print (count)
	  	 	    						 	 		 	 	 	 	 	",arr[j] == 0 or j == i:,arr[i] == 0 or i == j:
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for {{completion}}
  n = inp1()
  k = inp1()
  a = set(inp(n))
  print(""YES"" if 1 in a else ""NO"")
",_ in range(t):,_ in range(t):
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def solve():
    n = getInt()
    a = list(getList())
    j = res = 0
    p = [0] * n
    P = [0] * n
    from bisect import bisect_left
    f = {}
    for i, x in enumerate(a):
        j = max(j, i)
        while j < n and a[j] >= j+1 - i:
            j += 1
        res += j - i
        if j-1 not in f:
            f[j-1] = i
            J = j + 1  # further extends
        while J < n and a[J] >= J + 1 - i:
            J += 1
        p[i] = p[i-1] + j - 1
        P[i] = P[i-1] + J - j
    q = getInt()

    def calc(l, r, p):
        if l > r:
            return 0
        res = p[r]
        if l:
            res -= p[l-1]
        return res

    keys = sorted(f.keys())
    for _ in range(q):
        u, v = getList()
        u -= 1
        ans = res
        it = bisect_left(keys, u)
        if v < a[u]:
            it = keys[it]
            l = max(f[it], u + 1 - v)
            ans -= calc(f[it], l-1, p) - (u-1) * (l-f[it])
        elif v > a[u]:
            if {{completion}}
                l = max(f[keys[it-1]], u+1-v)
                ans += calc(l, f[keys[it]]-1, P)
        print(ans)


for _ in range(t):
    solve()
",it and keys[it-1] + 1 == u:,v < a[u]:
"import sys

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def solve():
    n = getInt()
    a = list(getList())
    j = res = 0
    p = [0] * n
    P = [0] * n
    from bisect import bisect_left
    f = {}
    for i, x in enumerate(a):
        j = max(j, i)
        while j < n and a[j] >= j+1 - i:
            j += 1
        res += j - i
        if j-1 not in f:
            f[j-1] = i
            J = j + 1  # further extends
        while J < n and a[J] >= J + 1 - i:
            J += 1
        p[i] = p[i-1] + j - 1
        P[i] = P[i-1] + J - j
    q = getInt()

    def calc(l, r, p):
        if l > r:
            return 0
        res = p[r]
        if l:
            res -= p[l-1]
        return res

    keys = sorted(f.keys())
    for _ in range(q):
        u, v = getList()
        u -= 1
        ans = res
        it = bisect_left(keys, u)
        if v < a[u]:
            it = keys[it]
            l = max(f[it], u + 1 - v)
            ans -= calc(f[it], l-1, p) - (u-1) * (l-f[it])
        elif {{completion}}
            if it and keys[it-1] + 1 == u:
                l = max(f[keys[it-1]], u+1-v)
                ans += calc(l, f[keys[it]]-1, P)
        print(ans)


for _ in range(t):
    solve()
",v > a[u]:,i < len(s) and s[i] == d:
"from sys import stdin, stdout
from collections import defaultdict

n = int(stdin.readline())
a = [int(x) for x in stdin.readline().split()]

left = 0
right = 0
right_array = []
right_prefix = [0]
answer = 0

second_right = 0
second_right_array = []
second_right_prefix = [0]

while left < n:
    if right < left:
        right = left
    while right < n and a[right] >= right-left+1:
        right += 1
    right_array.append(right)
    right_prefix.append(right_prefix[-1]+right_array[-1])
    answer += right - left

    if second_right <= right:
        second_right = right + 1
        if second_right > n:
            second_right = n
    while second_right < n and a[second_right] >= second_right-left+1:
        second_right += 1
    second_right_array.append(second_right)
    second_right_prefix.append(second_right_prefix[-1]+second_right_array[-1])

    left += 1

p_to_right = defaultdict(list)
for i in range(n):
    p_to_right[right_array[i]].append(i)

q = int(stdin.readline())
for _ in range(q):
    p, x = [int(z) for z in stdin.readline().split()]
    p -= 1
    if x == a[p]:
        adjustment = 0
    elif x < a[p]:
        if right_array[-1] <= p:
            adjustment = 0
        else:
            upper = n-1
            lower = -1
            while upper - lower > 1:
                candidate = (upper + lower)//2
                if {{completion}}
                    upper = candidate
                else:
                    lower = candidate

            if upper > p-x:
                adjustment = 0
            else:
                adjustment = -(right_prefix[p-x+1] - right_prefix[upper] - p*(p-x-upper+1))

    else:
        if len(p_to_right[p]) == 0:
            adjustment = 0
        elif p_to_right[p][0] > p-a[p] or p_to_right[p][-1] < p-x+1:
            adjustment = 0
        else:
            lower = max(p-x+1, p_to_right[p][0])
            upper = min(p-a[p], p_to_right[p][-1])
            adjustment = second_right_prefix[upper+1] - second_right_prefix[lower] - p*(upper-lower+1)

    stdout.write(str(answer+adjustment)+'\n')
",right_array[candidate] > p:,upper - lower > 1:
"from sys import stdin, stdout
from collections import defaultdict

n = int(stdin.readline())
a = [int(x) for x in stdin.readline().split()]

left = 0
right = 0
right_array = []
right_prefix = [0]
answer = 0

second_right = 0
second_right_array = []
second_right_prefix = [0]

while left < n:
    if right < left:
        right = left
    while right < n and a[right] >= right-left+1:
        right += 1
    right_array.append(right)
    right_prefix.append(right_prefix[-1]+right_array[-1])
    answer += right - left

    if second_right <= right:
        second_right = right + 1
        if second_right > n:
            second_right = n
    while second_right < n and a[second_right] >= second_right-left+1:
        second_right += 1
    second_right_array.append(second_right)
    second_right_prefix.append(second_right_prefix[-1]+second_right_array[-1])

    left += 1

p_to_right = defaultdict(list)
for i in range(n):
    p_to_right[right_array[i]].append(i)

q = int(stdin.readline())
for _ in range(q):
    p, x = [int(z) for z in stdin.readline().split()]
    p -= 1
    if x == a[p]:
        adjustment = 0
    elif x < a[p]:
        if right_array[-1] <= p:
            adjustment = 0
        else:
            upper = n-1
            lower = -1
            while {{completion}}
                candidate = (upper + lower)//2
                if right_array[candidate] > p:
                    upper = candidate
                else:
                    lower = candidate

            if upper > p-x:
                adjustment = 0
            else:
                adjustment = -(right_prefix[p-x+1] - right_prefix[upper] - p*(p-x-upper+1))

    else:
        if len(p_to_right[p]) == 0:
            adjustment = 0
        elif p_to_right[p][0] > p-a[p] or p_to_right[p][-1] < p-x+1:
            adjustment = 0
        else:
            lower = max(p-x+1, p_to_right[p][0])
            upper = min(p-a[p], p_to_right[p][-1])
            adjustment = second_right_prefix[upper+1] - second_right_prefix[lower] - p*(upper-lower+1)

    stdout.write(str(answer+adjustment)+'\n')
",upper - lower > 1:,upper > p-x:
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        n, k, r, c = list(map(int, input_arr[pos:pos + 4]))
        pos += 4
        mat = [[""."" for _ in range(n)] for j in range(n)]
        r = r - 1
        c = c - 1
        l = n // k
        for j in range(n):
            for {{completion}}
                mat[(r+ll*k) % n][c % n] = 'X'
                mat[r][(c + ll*k) % n] = 'X'
            r -= 1
            c += 1
        for i in mat:
            for j in i:
                print(j, end="""")
            print("""")
# '3 3 3 3 2 2 1 1 2 6 3 4 2'",ll in range(l):,j in range(n):
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for case in range(tc):
        n, k, r, c = list(map(int, input_arr[pos:pos + 4]))
        pos += 4
        mat = [[""."" for _ in range(n)] for j in range(n)]
        r = r - 1
        c = c - 1
        l = n // k
        for j in range(n):
            for ll in range(l):
                mat[(r+ll*k) % n][c % n] = 'X'
                mat[r][(c + ll*k) % n] = 'X'
            r -= 1
            c += 1
        for i in mat:
            for {{completion}}
                print(j, end="""")
            print("""")
# '3 3 3 3 2 2 1 1 2 6 3 4 2'",j in i:,ll in range(l):
"import fileinput

def f(n):
    i = 0
    while i<len(n):
        if n[i] == ""Q"":
            found = False
            for j in range(i,len(n)):
                if {{completion}}
                    n = n[:j] + n[j+1:]
                    found = True
                    break
            if not found:
                print(""NO"")
                return
        i += 1
    print(""YES"")

for line in fileinput.input():
    if len(line) > 0 and line[0] == ""Q"":
        f(line)","n[j] == ""A"":","n[j] == ""Q"":"
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for {{completion}}f.append(f[-1]*i%m)
for z in map(int,input().split()):d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1
print(d%m)","i in range(1,9**6):","z in list(map(int,input().split())):"
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6):f.append(f[-1]*i%m)
for {{completion}}d+=f[z+x]*pow(f[x+1]*f[z-1],-1,m)*(z>0);x+=1
print(d%m)","z in map(int,input().split()):","i in range(1,9**6):"
"from math import gcd

mod=1_000_000_007
maxn=400_100
fac=[1]*maxn
for i in range(2,maxn):
  fac[i]=(fac[i-1]*i)%mod

def inv(b,m):
  return pow(b, m - 2, m)

n=int(input())
a=list(map(int,input().split()))
o=0
for i in range(n+1):
  if {{completion}} break
  c=fac[a[i]+i]*inv(fac[i+1]*fac[a[i]-1],mod)
  o=(o+c)%mod
print(o)",a[i]==0:,"i in range(1,9**6):"
"N = 4 * 10**5 + 5
MOD = 10**9 + 7

fact = [1]
invf = [1]

for i in range(1, N):
    fact.append(fact[i-1] * i % MOD)
    invf.append(pow(fact[-1], MOD-2, MOD))


def C(m, n):
    if {{completion}}
        return 0
    return fact[m] * invf[n] % MOD * invf[m-n] % MOD


n = int(input())
a = list(map(int, input().split()))
ans = sum(C(v+i, i+1) for i, v in enumerate(a)) % MOD
print(ans)
",n < 0 or m < n:,"v in range(1,9**6):"
"import sys
input = sys.stdin.readline
MOD = 10 ** 9 + 7
n = int(input())
a = [int(x) for x in input().split()]
fac = [1]
for i in range(8 * 10 ** 5 - 1):
    fac.append((fac[-1] * (i + 1)) % MOD)
ans = 0
for i in range(n + 1):
    if {{completion}}
        ans = (ans + fac[a[i] + i] * pow((fac[i + 1] * fac[a[i] - 1]), -1, MOD))
print(int(ans % MOD))",a[i] != 0:,a[i]==0:
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for {{completion}} f.append(f[-1]*i%m)
for z in list(map(int,input().split())):
    d+=f[z+x]*pow(f[x+1]*f[z-1],m-2,m)*(z!=0)
    x+=1
print(d%m)","i in range(1,9**6):","z in list(map(int,input().split())):"
"n,x,d,m,f=int(input()),0,0,10**9+7,[1]
for i in range(1,9**6): f.append(f[-1]*i%m)
for {{completion}}
    d+=f[z+x]*pow(f[x+1]*f[z-1],m-2,m)*(z!=0)
    x+=1
print(d%m)","z in list(map(int,input().split())):","z in map(int,input().split()):"
"import math

pi = 3.14159265358979323846264338327950288419716939937510
eps, sq2 = 1e-13, math.sqrt(2)
x, y = [], []
n = 0


def binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab):
    while math.fabs(cy - fy) > eps:
        mid_y = cy / 2.0 + fy / 2.0
        la = lb = 0.0
        ra, rb = pi - alpha_1, pi - alpha_2
        while math.fabs(ra - la) > eps:
            mid_a = ra / 2.0 + la / 2.0
            yy = - pow(math.sin(mid_a), 2) * math.cos(alpha_1 + mid_a) / math.sin(alpha_1)
            if {{completion}}
                la = mid_a
            if yy > mid_y:
                ra = mid_a
        while math.fabs(rb - lb) > eps:
            mid_b = rb / 2.0 + lb / 2.0
            yy = - pow(math.sin(mid_b), 2) * math.cos(alpha_2 + mid_b) / math.sin(alpha_2)
            if yy < mid_y:
                lb = mid_b
            if yy > mid_y:
                rb = mid_b
        x1 = (2.0 * math.sin(la / 2.0 + ra / 2.0 + alpha_1) +
              math.sin(la + ra) * math.cos(la / 2.0 + ra / 2.0 + alpha_1)) / (2 * math.sin(alpha_1))
        x2 = ab - (2.0 * math.sin(lb / 2.0 + rb / 2.0 + alpha_2) +
                   math.sin(lb + rb) * math.cos(lb / 2.0 + rb / 2.0 + alpha_2)) / (2 * math.sin(alpha_2))
        if x1 < x2:
            cy = mid_y
        if x1 > x2:
            fy = mid_y
    return la, lb, ra, rb, cy, fy


def get_area(_i, ni, i_, i_2):
    ans = 0.00
    ab = math.sqrt(pow((x[i_] - x[ni]), 2) + pow((y[i_] - y[ni]), 2))
    ad = math.sqrt(pow((x[_i] - x[ni]), 2) + pow((y[_i] - y[ni]), 2))
    bc = math.sqrt(pow((x[i_2] - x[i_]), 2) + pow((y[i_2] - y[i_]), 2))
    ux, uy = x[_i] - x[ni], y[_i] - y[ni]
    vx, vy = x[i_] - x[ni], y[i_] - y[ni]
    alpha_1 = math.acos((ux * vx + uy * vy) / ab / ad)
    if math.fabs(ab - sq2) < eps or math.fabs(ab - 1.00) < eps:
        wx, wy = x[i_2] - x[i_], y[i_2] - y[i_]
        alpha_2 = math.acos((-vx * wx - wy * vy) / ab / bc)
        la, lb, ra, rb, cy, fy = 0.0, 0.0, pi - alpha_1, pi - alpha_2, min(alpha_1, alpha_2), 0.0000
        la, lb, ra, rb, cy, fy = binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab)

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_1)) * la - 2.0 * math.sin(la * 2.0 + ra * 2.0) +
                     4.0 * math.sin(2.0 * alpha_1 + la + ra) - math.sin(2.0 * alpha_1 + 3.0 * la + 3.0 * ra)
                     - 5.0 * math.sin(2.0 * alpha_1)+ math.sin(2.0 * alpha_1 - la - ra)
                     + math.sin(2.0 * (ra + la + alpha_1))) / (64.0 * math.sin(alpha_1) * math.sin(alpha_1))

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_2)) * lb - 2.0 * math.sin(lb * 2.0 + rb * 2.0) +
                     4.0 * math.sin(2.0 * alpha_2 + lb + rb) - math.sin(2.0 * alpha_2 + 3.0 * lb + 3.0 * rb)
                     - 5.0 * math.sin(2.0 * alpha_2) + math.sin(2.0 * alpha_2 - lb - rb)
                     + math.sin(2.0 * (rb + lb + alpha_2))) / (64.0 * math.sin(alpha_2) * math.sin(alpha_2))

    ans -= math.sin(pi - alpha_1) * math.cos(pi - alpha_1) * 0.500000
    ans += ((4.0 - 2.0 * math.cos(2.0 * alpha_1)) * (pi - alpha_1) + 2.0 * math.sin(4.0 * alpha_1)
                 - 3.0 * math.sin(2.0 * alpha_1)) / (32.0 * math.sin(alpha_1) * math.sin(alpha_1))
    return ans


if __name__ == ""__main__"":

    n = eval(input())
    for i in range(1, n + 1):
        a, b = input().split()
        a, b = eval(a), eval(b)
        x.append(a), y.append(b)
    if n == 4:
        Ax, Ay = x[0], y[0]
        Bx, By = x[1], y[1]
        Cx, Cy = x[2], y[2]
        Dx, Dy = x[3], y[3]
        ABx, ABy = Bx - Ax, By - Ay
        ADx, ADy = Dx - Ax, Dy - Ay
        CBx, CBy = Bx - Cx, By - Cy
        CDx, CDy = Dx - Cx, Dy - Cy
        LenAB, LenAD = math.sqrt(ABx * ABx + ABy * ABy), math.sqrt(ADx * ADx + ADy * ADy)
        LenCB, LenCD = math.sqrt(CBx * CBx + CBy * CBy), math.sqrt(CDx * CDx + CDy * CDy)
        a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)
        b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)
        c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)
        d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)
        if math.fabs(a - pi / 2.0) < eps and math.fabs(b - pi / 2.0) < eps and \
                math.fabs(c - pi / 2.0) < eps and math.fabs(d - pi / 2.0) < eps and \
                ((math.fabs(LenAB - 1.00) < eps and math.fabs(LenAB - LenCD) < eps) or
                 (math.fabs(LenCB - 1.00) < eps and math.fabs(LenCB - LenAD) < eps)):
            print('%.11Lf' % (LenAB * LenCB)), exit(0)
    res = 0.0000
    for i in range(1, n + 1):
        res += get_area((i - 1 + n) % n, i % n, (i + 1) % n, (i + 2) % n)
    if math.fabs(res-1.02638863065) < 100*eps:
        print('1.04719792254'), exit(0)
    if math.fabs(res-1.04692745180) < 100*eps:
        print('1.04720015894'), exit(0)

    print('%.11Lf' % res)",yy < mid_y:,k in reversed(a[:i]):
"import math

pi = 3.14159265358979323846264338327950288419716939937510
eps, sq2 = 1e-13, math.sqrt(2)
x, y = [], []
n = 0


def binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab):
    while math.fabs(cy - fy) > eps:
        mid_y = cy / 2.0 + fy / 2.0
        la = lb = 0.0
        ra, rb = pi - alpha_1, pi - alpha_2
        while math.fabs(ra - la) > eps:
            mid_a = ra / 2.0 + la / 2.0
            yy = - pow(math.sin(mid_a), 2) * math.cos(alpha_1 + mid_a) / math.sin(alpha_1)
            if yy < mid_y:
                la = mid_a
            if {{completion}}
                ra = mid_a
        while math.fabs(rb - lb) > eps:
            mid_b = rb / 2.0 + lb / 2.0
            yy = - pow(math.sin(mid_b), 2) * math.cos(alpha_2 + mid_b) / math.sin(alpha_2)
            if yy < mid_y:
                lb = mid_b
            if yy > mid_y:
                rb = mid_b
        x1 = (2.0 * math.sin(la / 2.0 + ra / 2.0 + alpha_1) +
              math.sin(la + ra) * math.cos(la / 2.0 + ra / 2.0 + alpha_1)) / (2 * math.sin(alpha_1))
        x2 = ab - (2.0 * math.sin(lb / 2.0 + rb / 2.0 + alpha_2) +
                   math.sin(lb + rb) * math.cos(lb / 2.0 + rb / 2.0 + alpha_2)) / (2 * math.sin(alpha_2))
        if x1 < x2:
            cy = mid_y
        if x1 > x2:
            fy = mid_y
    return la, lb, ra, rb, cy, fy


def get_area(_i, ni, i_, i_2):
    ans = 0.00
    ab = math.sqrt(pow((x[i_] - x[ni]), 2) + pow((y[i_] - y[ni]), 2))
    ad = math.sqrt(pow((x[_i] - x[ni]), 2) + pow((y[_i] - y[ni]), 2))
    bc = math.sqrt(pow((x[i_2] - x[i_]), 2) + pow((y[i_2] - y[i_]), 2))
    ux, uy = x[_i] - x[ni], y[_i] - y[ni]
    vx, vy = x[i_] - x[ni], y[i_] - y[ni]
    alpha_1 = math.acos((ux * vx + uy * vy) / ab / ad)
    if math.fabs(ab - sq2) < eps or math.fabs(ab - 1.00) < eps:
        wx, wy = x[i_2] - x[i_], y[i_2] - y[i_]
        alpha_2 = math.acos((-vx * wx - wy * vy) / ab / bc)
        la, lb, ra, rb, cy, fy = 0.0, 0.0, pi - alpha_1, pi - alpha_2, min(alpha_1, alpha_2), 0.0000
        la, lb, ra, rb, cy, fy = binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab)

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_1)) * la - 2.0 * math.sin(la * 2.0 + ra * 2.0) +
                     4.0 * math.sin(2.0 * alpha_1 + la + ra) - math.sin(2.0 * alpha_1 + 3.0 * la + 3.0 * ra)
                     - 5.0 * math.sin(2.0 * alpha_1)+ math.sin(2.0 * alpha_1 - la - ra)
                     + math.sin(2.0 * (ra + la + alpha_1))) / (64.0 * math.sin(alpha_1) * math.sin(alpha_1))

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_2)) * lb - 2.0 * math.sin(lb * 2.0 + rb * 2.0) +
                     4.0 * math.sin(2.0 * alpha_2 + lb + rb) - math.sin(2.0 * alpha_2 + 3.0 * lb + 3.0 * rb)
                     - 5.0 * math.sin(2.0 * alpha_2) + math.sin(2.0 * alpha_2 - lb - rb)
                     + math.sin(2.0 * (rb + lb + alpha_2))) / (64.0 * math.sin(alpha_2) * math.sin(alpha_2))

    ans -= math.sin(pi - alpha_1) * math.cos(pi - alpha_1) * 0.500000
    ans += ((4.0 - 2.0 * math.cos(2.0 * alpha_1)) * (pi - alpha_1) + 2.0 * math.sin(4.0 * alpha_1)
                 - 3.0 * math.sin(2.0 * alpha_1)) / (32.0 * math.sin(alpha_1) * math.sin(alpha_1))
    return ans


if __name__ == ""__main__"":

    n = eval(input())
    for i in range(1, n + 1):
        a, b = input().split()
        a, b = eval(a), eval(b)
        x.append(a), y.append(b)
    if n == 4:
        Ax, Ay = x[0], y[0]
        Bx, By = x[1], y[1]
        Cx, Cy = x[2], y[2]
        Dx, Dy = x[3], y[3]
        ABx, ABy = Bx - Ax, By - Ay
        ADx, ADy = Dx - Ax, Dy - Ay
        CBx, CBy = Bx - Cx, By - Cy
        CDx, CDy = Dx - Cx, Dy - Cy
        LenAB, LenAD = math.sqrt(ABx * ABx + ABy * ABy), math.sqrt(ADx * ADx + ADy * ADy)
        LenCB, LenCD = math.sqrt(CBx * CBx + CBy * CBy), math.sqrt(CDx * CDx + CDy * CDy)
        a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)
        b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)
        c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)
        d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)
        if math.fabs(a - pi / 2.0) < eps and math.fabs(b - pi / 2.0) < eps and \
                math.fabs(c - pi / 2.0) < eps and math.fabs(d - pi / 2.0) < eps and \
                ((math.fabs(LenAB - 1.00) < eps and math.fabs(LenAB - LenCD) < eps) or
                 (math.fabs(LenCB - 1.00) < eps and math.fabs(LenCB - LenAD) < eps)):
            print('%.11Lf' % (LenAB * LenCB)), exit(0)
    res = 0.0000
    for i in range(1, n + 1):
        res += get_area((i - 1 + n) % n, i % n, (i + 1) % n, (i + 2) % n)
    if math.fabs(res-1.02638863065) < 100*eps:
        print('1.04719792254'), exit(0)
    if math.fabs(res-1.04692745180) < 100*eps:
        print('1.04720015894'), exit(0)

    print('%.11Lf' % res)",yy > mid_y:,k in reversed(a[:i]):
"for {{completion}}
    p = list(map(int, input()))
    print('YES' if sum(p[:3]) == sum(p[3:]) else 'NO')
",_ in range(int(input())):,t in range(int(input())):
for {{completion}}print('yes' if int(_[0]) + int(_[1]) + int(_[2]) == int(_[3]) + int(_[4]) + int(_[5]) else 'NO'),_ in [*open(0)][1:]:,i in range(int(input())):
"t = int(input())
for i in range(1, t + 1):
   summa = 0
   a = int(input())
   a6 = a % 10
   a5 = (a // 10) % 10
   a4 = (a // 100) % 10
   a3 = (a // 1000) % 10
   a2 = (a // 10000) % 10
   a1 = (a // 100000) % 10
   if {{completion}}
      print('YES')
   else:
      print(""NO"")",a1 + a2 + a3 == a4 + a5 + a6:,i in range(int(input())):
"for {{completion}} print(('NO', 'YES')[sum(int(p) for p in (c[:3])) == sum(int(p) for p in (c[3:]))])",c in [input() for i in range(int(input()))]:,_ in range(int(input())):
"import sys

def main():
    s = sys.stdin.read().strip().split('\n')[1:]
    r = []
    for {{completion}}
        nums = list(map(int, i))
        r.append(('NO', 'YES')[sum(nums[:3]) == sum(nums[3:])])
    return r
print(*main(), sep='\n')

",i in s:,i in range(int(input())):
"for {{completion}}
    a = [int(j) for j in input()]
    print(""YES"" if sum(a[0:3])==sum(a[3:6]) else ""NO"")",i in range(int(input())):,_ in range(int(input())):
"t = int(input(""""))
for i in range(t):
    ticket = input("""")
    if {{completion}}
        print(""YES"")
    else:
        print(""NO"")",int(ticket[0])+int(ticket[1])+int(ticket[2]) == int(ticket[3])+int(ticket[4])+int(ticket[5]):,"ticket = input()
print(""YES"" if sum(map(int, ticket[:3])) == sum(map(int, ticket[3:])) else ""NO"")
Replace the ""# TODO: Your code here"" in the code above with the appropriate control expression. Provide only the replaced control expression."
"s = int(input())
r = []
for i in range(s):
	a = int(input())
	if {{completion}}
		print(""YES"", end="" "")
	else:
		print(""NO"", end="" "")
",a // 100000 + a // 10000 % 10 + a // 1000 % 10 == a // 100 % 10 + a % 10 + a // 10 % 10:,_ in range(int(input())):
"n=input()

for i in range(int(n)):  
    sumf=0
    suml=0
    
    s =  input()
    for {{completion}}
           sumf += int(s[x])
           
    for x in range(3,6):
        suml += int(s[x])

    if sumf== suml:
        print('YES')
    else:
         print('NO')
  	 			 		 	 	 	 		   	  						","x in range(0,3):","































































































































"
"n=input()

for i in range(int(n)):  
    sumf=0
    suml=0
    
    s =  input()
    for x in range(0,3):
           sumf += int(s[x])
           
    for {{completion}}
        suml += int(s[x])

    if sumf== suml:
        print('YES')
    else:
         print('NO')
  	 			 		 	 	 	 		   	  						","x in range(3,6):","































































































































"
"for {{completion}}
    n = list(map(int, list(input())))
    print(""YES"" if n[0]+n[1]+n[2]==n[3]+n[4]+n[5] else ""NO"")",t in range(int(input())):,i in range(int(input())):
"t = int(input())

def solve():
  n, m = map(int, input().split())
  A = [list(map(int, input().split())) for _ in range(n)]
  ans = 0
  for i in range(n):
    for j in range(m):
      temp = -A[i][j]
      for x in range(n):
        # i - j == x - y => y = x - i + j
        y = x - i + j
        if {{completion}}
          temp += A[x][y]
        # i + j == x + y
        y = i + j - x
        if 0 <= y < m:
          temp += A[x][y]
      ans = max(ans, temp)
  print(ans)

for _ in range(t):
  solve()",0 <= y < m:,0 <= y < m:
"t = int(input())

def solve():
  n, m = map(int, input().split())
  A = [list(map(int, input().split())) for _ in range(n)]
  ans = 0
  for i in range(n):
    for j in range(m):
      temp = -A[i][j]
      for x in range(n):
        # i - j == x - y => y = x - i + j
        y = x - i + j
        if 0 <= y < m:
          temp += A[x][y]
        # i + j == x + y
        y = i + j - x
        if {{completion}}
          temp += A[x][y]
      ans = max(ans, temp)
  print(ans)

for _ in range(t):
  solve()",0 <= y < m:,0 <= y < m:
"k,o=lambda:map(int,input().split()),range
for f in o(*k()):
 n,m=k();a=[[*k()]for t in o(n)];l=[0]*(m+n);r=l[:]
 for i in o(n):
  for {{completion}}b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b
 print(max(l[i-j+m-1]+r[i+j]-a[i][j]for i in o(n)for j in o(m)))",j in o(m):,j in o(m):
"T = int(input())

for tc in range(T):
    (A, B) = map(int, input().split(' '))
    nums = []
    for i in range(A):
        nums.append([int(x) for x in input().split()])


    C = A + B - 1
    left = [0 for _ in range(C)]
    right = [0 for _ in range(C)]
    for a in range(A):
        for {{completion}}
            left_index = a + b
            right_index = a + B - 1 - b
            left[left_index] += nums[a][b]
            right[right_index] += nums[a][b]
    # print (left)
    # print (right)

    damage = 0
    for a in range(A):
        for b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)

    print (damage)
",b in range(B):,b in range(B):
"T = int(input())

for tc in range(T):
    (A, B) = map(int, input().split(' '))
    nums = []
    for i in range(A):
        nums.append([int(x) for x in input().split()])


    C = A + B - 1
    left = [0 for _ in range(C)]
    right = [0 for _ in range(C)]
    for a in range(A):
        for b in range(B):
            left_index = a + b
            right_index = a + B - 1 - b
            left[left_index] += nums[a][b]
            right[right_index] += nums[a][b]
    # print (left)
    # print (right)

    damage = 0
    for a in range(A):
        for {{completion}}
            left_index = a + b
            right_index = a + B - 1 - b
            d = left[left_index] + right[right_index] - nums[a][b]
            damage = max(d, damage)

    print (damage)
",b in range(B):,b in range(B):
"import sys
sm_row = [-1, +1, -1, +1]
sm_column = [-1, +1, +1, -1]
for _ in range(int(sys.stdin.readline())):
    n, m = map(int, sys.stdin.readline().split())
    t = []
    maximum = 0
    for i in range(n):
        t.append(list(map(int, sys.stdin.readline().split())))
    for row in range(n):
        for column in range(m):
            summa = 0
            for i in range(4):
                new_row = row
                new_column = column
                while {{completion}}
                    summa += t[new_row][new_column]
                    new_row += sm_row[i]
                    new_column += sm_column[i]
            summa -= (t[row][column] * 3)
            maximum = max(maximum, summa)
    print(maximum)
",0 <= new_row < n and 0 <= new_column < m:,while new_row >= 0 and new_row < n and new_column >= 0 and new_column < m:
"# auther: codeCell
for _ in range(int(input())):
    n,m=map(int,input().split())
    a = [ [*map(int, input().split())] for _ in range(n)]
 
    u = [0]*(n+m-1)
    v = [0]*(n+m-1)
    for i in range(n):
        for {{completion}}
            u[i+j] += a[i][j]
            v[i-j] += a[i][j]
    for i in range(n):
        for j in range(m):
            a[i][j] = u[i+j] + v[i-j] - a[i][j]
    print(max(map(max,a)))          



",j in range(m):,i in range(n):
"# auther: codeCell
for _ in range(int(input())):
    n,m=map(int,input().split())
    a = [ [*map(int, input().split())] for _ in range(n)]
 
    u = [0]*(n+m-1)
    v = [0]*(n+m-1)
    for i in range(n):
        for j in range(m):
            u[i+j] += a[i][j]
            v[i-j] += a[i][j]
    for i in range(n):
        for {{completion}}
            a[i][j] = u[i+j] + v[i-j] - a[i][j]
    print(max(map(max,a)))          



",j in range(m):,j in range(m):
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n,m=M();l=[L() for i in range(n)];ans=0
    for i in range(n):
        for j in range(m):
            s=l[i][j]
            p,q=i,j;s-=l[p][q]
            while {{completion}}
                s+=l[p][q];p-=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p>=0 and q<m:
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p<n and q>=0:
                s+=l[p][q];p+=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p<n and q<m:
                s+=l[p][q];p+=1;q+=1
            ans=max(ans,s)
    print(ans)",p>=0 and q>=0:,p>=0 and q>=0:
"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
for _ in range(I()):
    n,m=M();l=[L() for i in range(n)];ans=0
    for i in range(n):
        for j in range(m):
            s=l[i][j]
            p,q=i,j;s-=l[p][q]
            while p>=0 and q>=0:
                s+=l[p][q];p-=1;q-=1
            p,q=i,j;s-=l[p][q]
            while {{completion}}
                s+=l[p][q];p-=1;q+=1
            p,q=i,j;s-=l[p][q]
            while p<n and q>=0:
                s+=l[p][q];p+=1;q-=1
            p,q=i,j;s-=l[p][q]
            while p<n and q<m:
                s+=l[p][q];p+=1;q+=1
            ans=max(ans,s)
    print(ans)",p>=0 and q<m:,p>=0 and q<m:
"t=eval(input())

for i in range(t):
    ans=-1
    temp=[int(x) for x in input().split()]
    n,m=temp[0],temp[1] # n*m
    check=[]
    for j in range(n):
        temp=[int(x) for x in input().split()]
        check.append(temp)

    dic_l={}
    dic_r={}

    for x in range(n):
        for y in range(m):
            if {{completion}}
                dic_l[x+y]=check[x][y]
            else:
                dic_l[x+y]+=check[x][y]
            if y-x not in dic_r:
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for y in range(m):
            ans=max(ans,dic_l[x+y]+dic_r[y-x]-check[x][y])
    
    print(ans)
            
    ",x+y not in dic_l:,x-y not in dic_r:
"t=eval(input())

for i in range(t):
    ans=-1
    temp=[int(x) for x in input().split()]
    n,m=temp[0],temp[1] # n*m
    check=[]
    for j in range(n):
        temp=[int(x) for x in input().split()]
        check.append(temp)

    dic_l={}
    dic_r={}

    for x in range(n):
        for y in range(m):
            if x+y not in dic_l:
                dic_l[x+y]=check[x][y]
            else:
                dic_l[x+y]+=check[x][y]
            if {{completion}}
                dic_r[y-x]=check[x][y]
            else:
                dic_r[y-x]+=check[x][y]
    
    for x in range(n):
        for y in range(m):
            ans=max(ans,dic_l[x+y]+dic_r[y-x]-check[x][y])
    
    print(ans)
            
    ",y-x not in dic_r:,y-x not in dic_r:
"def calc(x, y):
    ans = 0
    x1, y1 = x, y
    while x1 > 0 and y1 > 0:
        ans += field[y1 - 1][x1 - 1]
        x1 -= 1
        y1 -= 1
    # print(""OK"", x1, y1)
    x1, y1 = x, y
    x1 += 1
    y1 += 1
    while x1 <= m and y1 <= n:
        ans += field[y1 - 1][x1 - 1]
        x1 += 1
        y1 += 1
    x1, y1 = x, y
    x1 -= 1
    y1 += 1

    while x1 > 0 and y1 <= n:
        ans += field[y1 - 1][x1 - 1]
        x1 -= 1
        y1 += 1
    x1, y1 = x, y
    x1 += 1
    y1 -= 1

    while x1 <= m and y1 > 0:
        ans += field[y1 - 1][x1 - 1]
        x1 += 1
        y1 -= 1
    return ans


for _ in range(int(input())):
    n, m = map(int, input().split())
    field = [list(map(int, input().split())) for _ in range(n)]
    max_sum = -1
    for y in range(n):
        for {{completion}}
            max_sum = max(max_sum, calc(x + 1, y + 1))
    print(max_sum)
",x in range(m):,y<=n:
"I,R=lambda:map(int,input().split()),range
for _ in R(*I()):
 n,m=I();a=[[*I()] for _ in R(n)];l=[0]*(m+n);r=l[:]
 for i in R(n):
  for {{completion}}
   b=a[i][j];l[i-j+m-1]+=b;r[i+j]+=b
 print(max(l[i-j+m-1]+r[i+j]-a[i][j] for i in R(n) for j in R(m)))",j in R(m):,j in R(m):
"t=int(input())
for p in range(t):
    n,m=map(int,input().split())
    c=[]
    b=[]
    s=0
    for i in range(n):
        a=list(map(int,input().split()))
        b+=[a]
    for k in range(n):
        for l in range(m):
            for {{completion}}
                s+=b[k-v][l-v]
            for w in range(1,min(n-k-1,m-l-1)+1):
                s+=b[k+w][l+w]
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
","v in range(min(l,k)+1):","w in range(1,min(n-k-1,m-l-1)+1):"
"t=int(input())
for p in range(t):
    n,m=map(int,input().split())
    c=[]
    b=[]
    s=0
    for i in range(n):
        a=list(map(int,input().split()))
        b+=[a]
    for k in range(n):
        for l in range(m):
            for v in range(min(l,k)+1):
                s+=b[k-v][l-v]
            for {{completion}}
                s+=b[k+w][l+w]
            for i1 in range(1,min(k,m-l-1)+1):
                s+=b[k-i1][l+i1]
            for j1 in range(1,min(n-k-1,l)+1):
                s+=b[k+j1][l-j1]
            c+=[s]
            s=0
    print(max(c))
","w in range(1,min(n-k-1,m-l-1)+1):","w in range(1,min(n-k-1,m-l-1)+1):"
"h, w, q = map(int, input().split())
p = [False] * (h * w)

c = cc = 0


def query(y, x):
    global c, cc
    i = x*h+y
    p[i] = not p[i]
    if p[i]:
        if i < c:
            cc += 1
        c += 1
        if p[c-1]:
            cc += 1
    else:
        if {{completion}}
            cc -= 1
        c -= 1
        if p[c]:
            cc -= 1
    return c - cc


for y in range(h):
    inp = input()
    for x in range(w):
        if inp[x] == '*':
            query(y, x)

for _ in range(q):
    x, y = map(int, input().split())
    print(query(x-1, y-1))
",i < c:,p[c-1]==1:
"h, w, q = map(int, input().split())
p = [False] * (h * w)

c = cc = 0


def query(y, x):
    global c, cc
    i = x*h+y
    p[i] = not p[i]
    if p[i]:
        if i < c:
            cc += 1
        c += 1
        if p[c-1]:
            cc += 1
    else:
        if i < c:
            cc -= 1
        c -= 1
        if {{completion}}
            cc -= 1
    return c - cc


for y in range(h):
    inp = input()
    for x in range(w):
        if inp[x] == '*':
            query(y, x)

for _ in range(q):
    x, y = map(int, input().split())
    print(query(x-1, y-1))
",p[c]:,p[c-1]==0:
"from sys import stdin
rln=stdin.buffer.readline
rl=lambda:rln().rstrip(b'\r\n').rstrip(b'\n')
ri=lambda:int(rln())
rif=lambda:[*map(int,rln().split())]
rt=lambda:rl().decode()
rtf=lambda:rln().decode().split()
inf=float('inf')
dir4=[(-1,0),(0,1),(1,0),(0,-1)]
dir8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'

m,n,q=rif()
a=[0]*(m*n)
for y in range(m):
  s=rt()
  for {{completion}}
    a[m*x+y]=s[x]=='*'
k=sum(a)
l=sum(a[:k])
for _ in range(q):    
  x,y=rif()
  x,y=x-1,y-1
  i=x+m*y
  if a[i]:
    k-=1
    l-=a[k]
    l-=i<k
    a[i]^=1
  else:
    a[i]^=1
    l+=i<k
    l+=a[k]
    k+=1
  print(k-l)
",x in range(n):,a[i]:
"from sys import stdin
rln=stdin.buffer.readline
rl=lambda:rln().rstrip(b'\r\n').rstrip(b'\n')
ri=lambda:int(rln())
rif=lambda:[*map(int,rln().split())]
rt=lambda:rl().decode()
rtf=lambda:rln().decode().split()
inf=float('inf')
dir4=[(-1,0),(0,1),(1,0),(0,-1)]
dir8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
YES,NO,Yes,No,yes,no='YES','NO','Yes','No','yes','no'

m,n,q=rif()
a=[0]*(m*n)
for y in range(m):
  s=rt()
  for x in range(n):
    a[m*x+y]=s[x]=='*'
k=sum(a)
l=sum(a[:k])
for _ in range(q):    
  x,y=rif()
  x,y=x-1,y-1
  i=x+m*y
  if {{completion}}
    k-=1
    l-=a[k]
    l-=i<k
    a[i]^=1
  else:
    a[i]^=1
    l+=i<k
    l+=a[k]
    k+=1
  print(k-l)
",a[i]:,a[i]==1:
"import sys

n, m, k = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(n)]
cnt = 0
for i in range(n):
    for j in range(m):
        cnt += board[i][j] == '*'

clean = 0
q, r = divmod(cnt, n)
for j in range(q):
    for i in range(n):
        clean += board[i][j] == '*'

for i in range(r):
    clean += board[i][q] == '*'

for _ in range(k):
    x, y = map(int, sys.stdin.readline().split())
    x -= 1
    y -= 1
    if board[x][y] == '.':
        board[x][y] = '*'
        cnt += 1
        q, r = divmod(cnt - 1, n)
        if board[r][q] == '*':
            clean += 1
        if n * y + x <= cnt - 1:
            clean += 1
        if (q, r) == (y, x):
            clean -= 1
    else:
        cnt -= 1
        q, r = divmod(cnt, n)
        if {{completion}}
            clean -= 1
        if n * y + x <= cnt - 1:
            clean -= 1
        board[x][y] = '.'

    print(cnt - clean)
",board[r][q] == '*':,n * y + x <= cnt - 1:
"import sys

n, m, k = map(int, sys.stdin.readline().split())
board = [list(sys.stdin.readline().strip()) for _ in range(n)]
cnt = 0
for i in range(n):
    for j in range(m):
        cnt += board[i][j] == '*'

clean = 0
q, r = divmod(cnt, n)
for j in range(q):
    for i in range(n):
        clean += board[i][j] == '*'

for i in range(r):
    clean += board[i][q] == '*'

for _ in range(k):
    x, y = map(int, sys.stdin.readline().split())
    x -= 1
    y -= 1
    if board[x][y] == '.':
        board[x][y] = '*'
        cnt += 1
        q, r = divmod(cnt - 1, n)
        if board[r][q] == '*':
            clean += 1
        if n * y + x <= cnt - 1:
            clean += 1
        if (q, r) == (y, x):
            clean -= 1
    else:
        cnt -= 1
        q, r = divmod(cnt, n)
        if board[r][q] == '*':
            clean -= 1
        if {{completion}}
            clean -= 1
        board[x][y] = '.'

    print(cnt - clean)
",n * y + x <= cnt - 1:,board[r][q] == '*':
"
n,m,q = map(int, input().split())
s = [input() for _ in range(n)]
s = [s[j][i] for i in range(m) for j in range(n)]
qrr = [list(map(int, input().split())) for _ in range(q)]
qrr = [n * (q[1] - 1) + q[0] - 1 for q in qrr]
count = s.count('*')
correct = s[:count].count('*')
for q in qrr:
	count += 1 if s[q] == '.' else -1
	if {{completion}}
		correct += 1 if q < count else 0
		correct += 1 if s[count-1] == '*' else 0
	else:
		correct -= 1 if q < count else 0
		correct -= 1 if s[count] == '*' else 0
	print(count - correct)
	s[q] = '.' if s[q] == '*' else '*'
	",s[q] == '.':,q < count:
"from itertools import chain
I=lambda:map(int,input().split())
n,m,q=I()
g0=[list(input()) for _ in range(n)]
g=list(chain.from_iterable(zip(*g0)))
tot=g.count('*')
inner=g[:tot].count('*')

for _ in range(q):
  i,j=I()
  p=(j-1)*n+i-1
  if g[p]=='*':
    tot-=1
    #""tide fall""
    if g[tot]=='*':inner-=1
    if p<tot:inner-=1
    g[p]='.'
  else:
    g[p]='*'
    #""tide rise""
    if {{completion}}inner+=1
    if p<tot:inner+=1
    tot+=1
  print(tot-inner)",g[tot]=='*':,inner+=1
"from itertools import chain
I=lambda:map(int,input().split())
n,m,q=I()
g0=[list(input()) for _ in range(n)]
g=list(chain.from_iterable(zip(*g0)))
tot=g.count('*')
inner=g[:tot].count('*')

for _ in range(q):
  i,j=I()
  p=(j-1)*n+i-1
  if g[p]=='*':
    tot-=1
    #""tide fall""
    if g[tot]=='*':inner-=1
    if p<tot:inner-=1
    g[p]='.'
  else:
    g[p]='*'
    #""tide rise""
    if g[tot]=='*':inner+=1
    if {{completion}}inner+=1
    tot+=1
  print(tot-inner)",p<tot:,p<tot:
"n,m,q=map(int,input().split())
z=[] # 2d
a=[] # 1d
c=0 # count icons
ans=0
for i in range(n):
    z.append(list(input()))
for i in range(m):
    for j in range(n):
        if z[j][i]==""*"":
            a.append(1)
            c+=1
        else:
            a.append(0)
ans=c
for i in range(c):
    if a[i]==1:
        ans-=1
for i in range(q):
    x,y=map(int,input().split())
    if a[n*(y-1)+x-1]==1:
        a[n*(y-1)+x-1]=0
        c-=1
        if n*(y-1)+x-1 > c:
            ans-=1
        if a[c]==1:
            ans+=1
    elif a[n*(y-1)+x-1]==0: # xor
        a[n*(y-1)+x-1]=1
        c+=1
        if n*(y-1)+x-1 >= c-1: # c or c-1?
            ans+=1
        if c: # if c>0
            if {{completion}}
                ans-=1
    print(ans)",a[c-1]==1:,n*(y-1)+x-1 >= c-1:
"n,m,q=map(int,input().split())
z=[] # 2d
a=[] # 1d
c=0 # count icons
ans=0
for i in range(n):
    z.append(list(input()))
for i in range(m):
    for j in range(n):
        if z[j][i]==""*"":
            a.append(1)
            c+=1
        else:
            a.append(0)
ans=c
for i in range(c):
    if a[i]==1:
        ans-=1
for i in range(q):
    x,y=map(int,input().split())
    if a[n*(y-1)+x-1]==1:
        a[n*(y-1)+x-1]=0
        c-=1
        if n*(y-1)+x-1 > c:
            ans-=1
        if a[c]==1:
            ans+=1
    elif a[n*(y-1)+x-1]==0: # xor
        a[n*(y-1)+x-1]=1
        c+=1
        if {{completion}} # c or c-1?
            ans+=1
        if c: # if c>0
            if a[c-1]==1:
                ans-=1
    print(ans)",n*(y-1)+x-1 >= c-1:,n*(y-1)+x-1 >= c-1:
"import sys


def solve():
    # n = int(sys.stdin.readline().strip())
    n, m, q = [int(x) for x in sys.stdin.readline().strip().split()]

    a = []
    m = [0] * (m * n)
    for y in range(n):
        s = sys.stdin.readline().strip()
        for x, c in enumerate(s):
            if c == '*':
                a.append(x * n + y)
                m[x * n + y] = 1

    cnt = len(a)
    correct = sum(1 for x in a if x < cnt)

    for _ in range(q):
        y, x = [int(p) for p in sys.stdin.readline().strip().split()]
        y -= 1
        x -= 1
        z = x * n + y
        if m[z] == 0:
            if m[cnt] == 1:
                correct += 1
            m[z] = 1
            cnt += 1
            if z < cnt:
                correct += 1
        else:
            cnt -= 1
            if {{completion}}
                correct -= 1
            m[z] = 0
            if z < cnt:
                correct -= 1
        # print(f""cnt={cnt} cor={correct}"")
        print(cnt - correct)

# t = int(sys.stdin.readline().strip())
t = 1
for _ in range(t):
    solve()
",m[cnt] == 1:,m[z]==0:
"import sys


def solve():
    # n = int(sys.stdin.readline().strip())
    n, m, q = [int(x) for x in sys.stdin.readline().strip().split()]

    a = []
    m = [0] * (m * n)
    for y in range(n):
        s = sys.stdin.readline().strip()
        for x, c in enumerate(s):
            if c == '*':
                a.append(x * n + y)
                m[x * n + y] = 1

    cnt = len(a)
    correct = sum(1 for x in a if x < cnt)

    for _ in range(q):
        y, x = [int(p) for p in sys.stdin.readline().strip().split()]
        y -= 1
        x -= 1
        z = x * n + y
        if m[z] == 0:
            if m[cnt] == 1:
                correct += 1
            m[z] = 1
            cnt += 1
            if z < cnt:
                correct += 1
        else:
            cnt -= 1
            if m[cnt] == 1:
                correct -= 1
            m[z] = 0
            if {{completion}}
                correct -= 1
        # print(f""cnt={cnt} cor={correct}"")
        print(cnt - correct)

# t = int(sys.stdin.readline().strip())
t = 1
for _ in range(t):
    solve()
",z < cnt:,m[cnt]==1:
"
from collections import deque

n,m=[int(x) for x  in input().split()]
g=[[] for _ in range(n)]
indeg=[0]*n
outdeg=[0]*n
tpdeg=[0]*n
for _ in range(m):
    v,u=[int(x) for x  in input().split()]
    v-=1
    u-=1
    g[v].append(u)
    outdeg[v]+=1
    indeg[u]+=1
    tpdeg[u]+=1


q=deque(i for i in range(n) if indeg[i]==0)
f=[1]*n

while q:
    u=q.popleft()

    for v in g[u]:
        if {{completion}}
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if tpdeg[v]==0:
            q.append(v)


print(max(f))



",indeg[v]>1 and outdeg[u]>1:,tpdeg[v]==0:
"
from collections import deque

n,m=[int(x) for x  in input().split()]
g=[[] for _ in range(n)]
indeg=[0]*n
outdeg=[0]*n
tpdeg=[0]*n
for _ in range(m):
    v,u=[int(x) for x  in input().split()]
    v-=1
    u-=1
    g[v].append(u)
    outdeg[v]+=1
    indeg[u]+=1
    tpdeg[u]+=1


q=deque(i for i in range(n) if indeg[i]==0)
f=[1]*n

while q:
    u=q.popleft()

    for v in g[u]:
        if indeg[v]>1 and outdeg[u]>1:
            f[v]=max(f[v],f[u]+1)
        tpdeg[v] -= 1
        if {{completion}}
            q.append(v)


print(max(f))



",tpdeg[v]==0:,indeg[v]>1 and outdeg[u]>1:
"
def iint():
    return int(input().strip())

def iints():
    return map(int, input().strip().split("" ""))

def arr():
    return list(input().strip().split("" ""))

def arri():
    return list(iints())

n,m = iints()

class Graph:
    def __init__(self, n):
        self.adj = [[] for _ in range(n)]
        self.ins = [0 for _ in range(n)]
        self.outs = [0 for _ in range(n)]
    def add(self, a, b):
        self.adj[a].append(b)
        self.ins[b]+=1
        self.outs[a]+=1

g = Graph(n)
ins2 = [0 for _ in range(n)]
for _ in range(m):
    a,b = iints()
    a-=1
    b-=1
    g.add(a,b)
    ins2[b]+=1


order = [0 for _ in range(n)]
f = 0
b = 0
for i in range(n):
    if not ins2[i]:
        order[b] = i
        b+=1
dp = [1 for _ in range(n)]
ans = 0
while f < n:
    cur = order[f]
    f += 1
    for x in g.adj[cur]:
        ins2[x] -= 1
        if {{completion}}
            order[b] = x
            b += 1
        if g.ins[x] > 1 and g.outs[cur] > 1:
            dp[x] = max(dp[x], 1 + dp[cur])
    ans = max(ans, dp[cur])
print(ans)
",not ins2[x]:,in_deg[j] > 1 and out_deg[i] > 1:
"
def iint():
    return int(input().strip())

def iints():
    return map(int, input().strip().split("" ""))

def arr():
    return list(input().strip().split("" ""))

def arri():
    return list(iints())

n,m = iints()

class Graph:
    def __init__(self, n):
        self.adj = [[] for _ in range(n)]
        self.ins = [0 for _ in range(n)]
        self.outs = [0 for _ in range(n)]
    def add(self, a, b):
        self.adj[a].append(b)
        self.ins[b]+=1
        self.outs[a]+=1

g = Graph(n)
ins2 = [0 for _ in range(n)]
for _ in range(m):
    a,b = iints()
    a-=1
    b-=1
    g.add(a,b)
    ins2[b]+=1


order = [0 for _ in range(n)]
f = 0
b = 0
for i in range(n):
    if not ins2[i]:
        order[b] = i
        b+=1
dp = [1 for _ in range(n)]
ans = 0
while f < n:
    cur = order[f]
    f += 1
    for x in g.adj[cur]:
        ins2[x] -= 1
        if not ins2[x]:
            order[b] = x
            b += 1
        if {{completion}}
            dp[x] = max(dp[x], 1 + dp[cur])
    ans = max(ans, dp[cur])
print(ans)
",g.ins[x] > 1 and g.outs[cur] > 1:,not ins2[x]:
"import sys
from collections import deque

n, m = map(int, sys.stdin.readline().split())
inv = [0] * (n + 1)
outv = [0] * (n + 1)
graph = [[] for _ in range(n + 1)]
reverse = [[] for _ in range(n + 1)]
for _ in range(m):
    v, u = map(int, sys.stdin.readline().split())
    graph[v].append(u)
    reverse[u].append(v)
    inv[u] += 1
    outv[v] += 1

dp = [0] * (n + 1)
dq = deque()
for i in range(1, n + 1):
    if outv[i] == 0:
        dq.append(i)

while dq:
    cur = dq.popleft()
    if len(graph[cur]) == 1:
        dp[cur] = 1
    else:
        res = 0
        for nxt in graph[cur]:
            if {{completion}}
                res = max(res, dp[nxt])
        dp[cur] = res + 1
    
    for prv in reverse[cur]:
        outv[prv] -= 1
        if outv[prv] == 0:
            dq.append(prv)

print(max(dp))",inv[nxt] > 1:,outv[prv] == 0:
"import sys
input = sys.stdin.readline
import math

for _ in range(1):
    n, m = map(int, input().split())
    g = [[] for i in range(n)]
    deg = [0] * n
    in_deg = [0] * n
    out_deg = [0] * n
    for i in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        g[x].append(y)
        deg[y] += 1
        out_deg[x] += 1
        in_deg[y] += 1
    order = []
    for i in range(n):
        if deg[i] == 0:
            order.append(i)
    for i in range(n):
        for to in g[order[i]]:
            deg[to] -= 1
            if {{completion}}
                order.append(to)
    dp = [1] * n
    for i in order:
        for j in g[i]:
            if in_deg[j] > 1 and out_deg[i] > 1:
                dp[j] = max(dp[j], dp[i] + 1)
    print(max(dp))",deg[to] == 0:,"































































































































"
"import sys
input = sys.stdin.readline
import math

for _ in range(1):
    n, m = map(int, input().split())
    g = [[] for i in range(n)]
    deg = [0] * n
    in_deg = [0] * n
    out_deg = [0] * n
    for i in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        g[x].append(y)
        deg[y] += 1
        out_deg[x] += 1
        in_deg[y] += 1
    order = []
    for i in range(n):
        if deg[i] == 0:
            order.append(i)
    for i in range(n):
        for to in g[order[i]]:
            deg[to] -= 1
            if deg[to] == 0:
                order.append(to)
    dp = [1] * n
    for i in order:
        for j in g[i]:
            if {{completion}}
                dp[j] = max(dp[j], dp[i] + 1)
    print(max(dp))",in_deg[j] > 1 and out_deg[i] > 1:,deg[to] == 0:
"from collections import deque
I=lambda:map(int,input().split())
n,m=I()
g=[[]for _ in range(n)]
din,dout,dcur=[0]*n,[0]*n,[0]*n
for _ in range(m):
  u,v=I()
  u,v=u-1,v-1
  g[u].append(v)
  dout[u]+=1;din[v]+=1;dcur[v]+=1
  
q=deque([i for i,d in enumerate(din) if d==0])
f=[1]*n
while q:
  u=q.popleft()
  for v in g[u]:
    if {{completion}}
      f[v]=max(f[v],f[u]+1)
    dcur[v]-=1
    if dcur[v]==0:q.append(v)
print(max(f))
",dout[u]>1 and din[v]>1:,dcur[v]==0:
"from collections import deque
I=lambda:map(int,input().split())
n,m=I()
g=[[]for _ in range(n)]
din,dout,dcur=[0]*n,[0]*n,[0]*n
for _ in range(m):
  u,v=I()
  u,v=u-1,v-1
  g[u].append(v)
  dout[u]+=1;din[v]+=1;dcur[v]+=1
  
q=deque([i for i,d in enumerate(din) if d==0])
f=[1]*n
while q:
  u=q.popleft()
  for v in g[u]:
    if dout[u]>1 and din[v]>1:
      f[v]=max(f[v],f[u]+1)
    dcur[v]-=1
    if {{completion}}q.append(v)
print(max(f))
",dcur[v]==0:,"































































































































"
"N=int(input())
A=[int(x) for x in input().split()]
B=sorted(A)
ans=-(-B[0]//2)-(-B[1]//2)
for {{completion}}
  ans=min(ans,-(-(A[i]+A[i+2])//2))
for i in range(N-1):
  score=max(-(-(A[i]+A[i+1])//3),-(-A[i]//2),-(-A[i+1]//2))
  ans=min(score,ans)
print(ans)  ",i in range(N-2):,i in range(N-1):
"N=int(input())
A=[int(x) for x in input().split()]
B=sorted(A)
ans=-(-B[0]//2)-(-B[1]//2)
for i in range(N-2):
  ans=min(ans,-(-(A[i]+A[i+2])//2))
for {{completion}}
  score=max(-(-(A[i]+A[i+1])//3),-(-A[i]//2),-(-A[i+1]//2))
  ans=min(score,ans)
print(ans)  ",i in range(N-1):,i in range(N-1):
"def onagr(x, y):
    x, y = max(x, y), min(x, y)
    if x >= 2 * y:
        res = (x + 1) // 2
    else:
        res = x - y + (2 * y - x) // 3 * 2 + (2 * y - x) % 3
    return res


def onagr1(x, y):
    return min(x, y) + (abs(x - y) + 1) // 2


n = int(input())
m1, m2, *a = list(map(int, input().split()))
if n == 2:
    print(onagr(m1, m2))
else:
    p = m2
    pp = m1
    r1 = onagr1(m1, a[0])
    if m2 < m1:
        m1, m2 = m2, m1
    r = onagr(m1, m2)
    for k in a:
        if k < m1:
            m2 = m1
            m1 = k
        elif {{completion}}
            m2 = k
        r = min(r, onagr(k, p))
        r1 = min(r1, onagr1(k, pp))
        pp = p
        p = k
    print(min((m1 + 1) // 2 + (m2 + 1) // 2, r, r1))
",k < m2:,"this is the start of the ground truth
if n == 2:
    print(onagr(m1, m2))
else:
    p = m2
    pp = m1
    r1 = onagr1(m1, a[0])
    if m2 < m1:
        m1, m2 = m2, m1
    r = onagr(m1, m2)
    for k in a:
        if k < m1:
            m2 = m1
            m1 = k
        elif k < m"
"import sys

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
x, y = sorted(arr)[:2]
ans = (x + 1) // 2 + (y + 1) // 2

for i in range(n - 2):
    x, y = arr[i], arr[i + 2]
    if {{completion}}
        x -= 1
        y -= 1
        ans = min(ans, (x + 1) // 2 + (y + 1) // 2 + 1)
    else:
        ans = min(ans, (x + 1) // 2 + (y + 1) // 2)

for i in range(n - 1):
    x, y = arr[i], arr[i + 1]
    if x > y:
        x, y = y, x
    
    if y >= 2 * x:
        ans = min(ans, (y + 1) // 2)
    else:
        res = y - x
        x -= res
        y -= 2 * res
        tmp = x // 3
        res += 2 * tmp
        x -= 3 * tmp
        ans = min(ans, res + x)

print(ans)",(x % 2 == 1) and (y % 2 == 1):,i in range(n-2):
"from math import ceil


def cal(a,b):
    if a>b:
        a,b=b,a
    if {{completion}}
        return ceil((a+b)/3)
    else:
        return ceil(b/2)

def cal2(a,b,c):
    if a%2==1 or c%2==1:
        return a//2+c//2+1
    return a//2+b//2


n=int(input())
l=list(map(int,input().split()))
t=sorted(l)
ans=ceil(t[0]/2)+ceil(t[1]/2)
for i in range(1,n):
    ans=min(ans,cal(l[i],l[i-1]))
    if i+1<n:
        ans=min(ans,cal2(l[i-1],l[i],l[i+1]))
print(ans)

",a>b//2:,i in range(N-2):
"from math import ceil


def cal(a,b):
    if a>b:
        a,b=b,a
    if a>b//2:
        return ceil((a+b)/3)
    else:
        return ceil(b/2)

def cal2(a,b,c):
    if {{completion}}
        return a//2+c//2+1
    return a//2+b//2


n=int(input())
l=list(map(int,input().split()))
t=sorted(l)
ans=ceil(t[0]/2)+ceil(t[1]/2)
for i in range(1,n):
    ans=min(ans,cal(l[i],l[i-1]))
    if i+1<n:
        ans=min(ans,cal2(l[i-1],l[i],l[i+1]))
print(ans)

",a%2==1 or c%2==1:,a>b//2:
"import sys
sys.setrecursionlimit(10000)
 
def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))
 
def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)
 
 
def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases
 
 
 
 
 
 
 
def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if {{completion}}
                return False
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            used[prv]=used.get(prv,0)+1
        prv=c
    return True
 
 
 
 
 
 
def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""
 
 
def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    
 
process()
","used.get(an[pa],0)<=0:","used.get(an[pa],0)<=0:"
"import sys
sys.setrecursionlimit(10000)

def read_line(f):
    while True:
        s=f.readline().strip()
        if s:
            return s
def read_list(f):
    return [int(x) for x in read_line(f).split()]
def read_tuple(f):
    return tuple(read_list(f))

def load_single_case(f):
    read_line(f)
    return read_list(f),read_list(f)


def load_cases(f):
    n=int(f.readline())
    cases=[]
    for _ in range(n):
        yield load_single_case(f)
    return cases







def solve(case):
    an,bn=case
    an=an[::-1]
    bn=bn[::-1]
    used={}
    pa=0
    prv=None
    for c in bn:
        while c not in (an[pa],prv):
            if {{completion}}
                return False
            used[an[pa]]-=1
            pa+=1
        if c==an[pa]:
            pa+=1
        else:
            used[prv]=used.get(prv,0)+1
        prv=c
    return True






def outcome_string(outcome):
    return ""YES"" if outcome else ""NO""


def save_outcomes(f, outcomes):
    for n,o in enumerate(outcomes):
        f.write(""{}\n"".format( outcome_string(o) ))
def process(path_in=None, path_out=None):
    if path_out is None and path_in is not None:
        path_out=path_in.rsplit(""."",1)[0]+"".out""
    f_in=open(path_in) if path_in else sys.stdin
    f_out=open(path_out,""w"") if path_out else sys.stdout
    try:
        outcomes=[solve(c) for c in load_cases(f_in)]
        save_outcomes(f_out, outcomes)
    finally:
        if path_in:
            f_in.close()
        if path_out:
            f_out.close()
    

process()","used.get(an[pa],0)<=0:","used.get(an[pa],0)<=0:"
"import sys;input=sys.stdin.readline

I=lambda:map(int,input().split())
n, q = I()
s = input()
pre0,pre1 = [0]*n,[0]*n
for i in range(1,n):
  c1,c2=s[i-1],s[i]
  pre0[i],pre1[i] = pre0[i-1],pre1[i-1]
  if c1 == c2 == '0':pre0[i]+=1
  elif {{completion}}pre1[i]+=1
for _ in range(q):
  l,r=I()
  print(max(pre0[r-1]-pre0[l-1], pre1[r-1]-pre1[l-1])+1)",c1 == c2 == '1':,pre1[i] > 0:
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

n, q = I()
s = input()
ones = [0, 0]
zeroes = [0, 0]
for i in range(1, n):
	if s[i] == s[i - 1] == '0':
		zeroes.append(zeroes[-1] + 1)
	else:
		zeroes.append(zeroes[-1])
	if {{completion}}
		ones.append(ones[-1] + 1)
	else:
		ones.append(ones[-1])
for i in range(q):
	l, r = I()
	o = ones[r] - ones[l]
	z = zeroes[r] - zeroes[l]
	print(max(o, z) + 1)",s[i] == s[i - 1] == '1':,s[i] == s[i - 1] == '1':
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 998244353
r, c = I()
rows = []
for i in range(r):
	rows.append([*input()])
if r % 2 == 0 and c % 2 == 0:
	blanks = 0
	for i in range(r):
		blanks += rows[i].count('?')
	print(pow(2, blanks, M))
elif r % 2 + c % 2 == 1:
	if r % 2 == 1:
		nrows = []
		for i in range(c):
			nrows.append([rows[j][i] for j in range(r)])
		rows = nrows
	ones = 1
	zeroes = 1
	for row in rows:
		unk = 0
		xor = 0
		for char in row:
			if char == '?':
				unk += 1
			elif char == '1':
				xor = 1 - xor
		if unk == 0:
			if xor == 1:
				zeroes = 0
			else:
				ones = 0
		else:
			zeroes = zeroes * pow(2, unk - 1, M) % M
			ones = ones * pow(2, unk - 1, M ) % M
	print((ones + zeroes) % M)
else:
	RC = [0] * (r + c)
	edges = [[] for i in range(r + c)]
	for i in range(r):
		for j in range(c):
			char = rows[i][j]
			if char == '?':
				edges[i].append(j + r)
				edges[j + r].append(i)
			elif char == '1':
				RC[i] = 1 - RC[i]
				RC[r + j] = 1 - RC[r + j]
	seen = [0] * (r + c)
	zeroes = []
	ones = []
	for i in range(r + c):
		if not seen[i]:
			component = [i]
			seen[i] = 1
			j = 0
			while j < len(component):
				if len(component) == r + c:
					break
				for v in edges[component[j]]:
					if {{completion}}
						seen[v] = 1
						component.append(v)
				j += 1
			n = len(component)
			m = 0
			x = 0
			for v in component:
				m += len(edges[v])
				x ^= RC[v]
			m //= 2
			if n % 2 == 0:
				if x == 0:
					y = pow(2, m - n + 1, M)
					zeroes.append(y)
					ones.append(y)
				else:
					print(0)
					exit()
			else:
				y = pow(2, m - n + 1, M)
				if x == 0:
					zeroes.append(y)
					ones.append(0)
				else:
					ones.append(y)
					zeroes.append(0)
	zs = 1
	for g in zeroes:
		zs = zs * g % M
	os = 1
	for g in ones:
		os = os * g % M
	print((zs + os) % M)",not seen[v]:,v in edges[component[j]]:
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

M = 998244353
r, c = I()
rows = []
for i in range(r):
	rows.append([*input()])
if r % 2 == 0 and c % 2 == 0:
	blanks = 0
	for i in range(r):
		blanks += rows[i].count('?')
	print(pow(2, blanks, M))
elif r % 2 + c % 2 == 1:
	if r % 2 == 1:
		nrows = []
		for i in range(c):
			nrows.append([rows[j][i] for j in range(r)])
		rows = nrows
	ones = 1
	zeroes = 1
	for row in rows:
		unk = 0
		xor = 0
		for char in row:
			if char == '?':
				unk += 1
			elif char == '1':
				xor = 1 - xor
		if unk == 0:
			if xor == 1:
				zeroes = 0
			else:
				ones = 0
		else:
			zeroes = zeroes * pow(2, unk - 1, M) % M
			ones = ones * pow(2, unk - 1, M ) % M
	print((ones + zeroes) % M)
else:
	RC = [0] * (r + c)
	edges = [[] for i in range(r + c)]
	for i in range(r):
		for j in range(c):
			char = rows[i][j]
			if char == '?':
				edges[i].append(j + r)
				edges[j + r].append(i)
			elif char == '1':
				RC[i] = 1 - RC[i]
				RC[r + j] = 1 - RC[r + j]
	seen = [0] * (r + c)
	zeroes = []
	ones = []
	for i in range(r + c):
		if not seen[i]:
			component = [i]
			seen[i] = 1
			j = 0
			while j < len(component):
				if len(component) == r + c:
					break
				for {{completion}}
					if not seen[v]:
						seen[v] = 1
						component.append(v)
				j += 1
			n = len(component)
			m = 0
			x = 0
			for v in component:
				m += len(edges[v])
				x ^= RC[v]
			m //= 2
			if n % 2 == 0:
				if x == 0:
					y = pow(2, m - n + 1, M)
					zeroes.append(y)
					ones.append(y)
				else:
					print(0)
					exit()
			else:
				y = pow(2, m - n + 1, M)
				if x == 0:
					zeroes.append(y)
					ones.append(0)
				else:
					ones.append(y)
					zeroes.append(0)
	zs = 1
	for g in zeroes:
		zs = zs * g % M
	os = 1
	for g in ones:
		os = os * g % M
	print((zs + os) % M)",v in edges[component[j]]:,not seen[v]:
"for _ in range(int(input())):
    n = int(input())
    a = b = 0
    c = '-'
    for x, y in zip(*[iter(input())]*2):
        if {{completion}}
            a += 1
        else:
            b += x != c
            c = x
    print(a, max(1, b))",x != y:,(x!=c):
"
inp = [*open(0)]

for s in inp[2::2]:
    s = s.strip()
    res = 0
    mseg = 1
    prebit = None
    for i in range(len(s) // 2):
        if s[2*i] != s[2*i+1]:
            res += 1
        else:
            if {{completion}}
                prebit = s[2*i]
            else:
                mseg += 1 if s[2*i] != prebit else 0
                prebit = s[2*i]

    print(res, mseg)
",prebit is None:,prebit!= s[2*i+1]:
"
for _ in range(int(input().strip())):
    n = int(input().strip())
    arr = input()
    ans = 0
    t = []
    for i in range(0, len(arr), 2):
        if {{completion}}
            ans += 1
        else:
            t.append(arr[i])
    seg = 1
    for i in range(0, len(t) - 1):
        if t[i] != t[i + 1]:
            seg += 1
    print(ans, seg)
",arr[i] != arr[i + 1]:,"x, y in zip(*[iter(input())]*2):"
"
for _ in range(int(input().strip())):
    n = int(input().strip())
    arr = input()
    ans = 0
    t = []
    for i in range(0, len(arr), 2):
        if arr[i] != arr[i + 1]:
            ans += 1
        else:
            t.append(arr[i])
    seg = 1
    for i in range(0, len(t) - 1):
        if {{completion}}
            seg += 1
    print(ans, seg)
",t[i] != t[i + 1]:,arr[i]!= arr[i + 1]:
"import sys

input=sys.stdin.readline

for _ in range(int(input())):
    n=int(input())
    s=input()
    x,y,Lf=0,0,-1
    for i in range(0,n,2):
        if(s[i]!=s[i+1]):
            x+=1
        else:
            if{{completion}}
                y+=1
            Lf=s[i]
    print(x,max(y,1))",(Lf!=s[i]):,Lf==s[i+1]:
"for _ in range(int(input())):
    n = int(input())
    l = [[], []]
    for {{completion}}
        l[x==y].append(int(x))
    print(len(l[0]), sum(map(lambda x : x[0] ^ x[1], zip(l[1], l[1][1:]))) + 1)","x, y in zip(*[iter(input())]*2):",(x==y):
"def solve(s):
	res = 0
	seg = 0
	prev = -1
	allDiff = True
	for i in range(1,len(s),2):
		if s[i] == s[i-1]:
			allDiff = False
			if {{completion}} seg += 1
			prev = s[i]
		else:
			res += 1
	if allDiff: seg += 1
	print(res,seg)


if __name__ == ""__main__"":
	t = int(input())
	while t:
		n= int(input())
		s = input()
		solve(s)
		t -= 1

",prev != s[i]:,s[i]!= s[i - 1]:
"for {{completion}}
	n,s=int(input()),input()
	print(sum([1 for i in range(1,n,2) if s[i]!=s[i-1]]))",_ in range(int(input())):,_ in range(int(input())):
"import re
for s in[*open(0)][2::2]:
 i=p=r=0
 for t in re.findall('0+|1+',s):
  i+=1
  if len(t)&1:
   if {{completion}}r+=i-p;p=0
   else:p=i
 print(r)",p:,_ in range(int(input())):
"t=int(input(""""))
for z in range(t):
    n=int(input(""""))
    a=input("""")
    s=[]
    for {{completion}}
        ab=a[i]+a[i+1]
        s.append(ab)

    b=s.count('10')
    c=s.count('01')
    print(b+c)","i in range(0,len(a)-1,2):",s[i]=='0' and s[i+1]=='1':
"def func(s):
    curr=s[0]
    c=0
    count=0
    for i in s:
        if i==curr:
            c+=1
        elif {{completion}}
            c=1
            curr=i
            continue
        else:
            curr=i
            c=2
            count+=1
    return count

for i in range(int(input())):
    n=int(input())
    print(func(input()))
",c%2==0:,s[i]!=s[i-1]:
"for _ in range(int(input())):
	input()
	inp, count = input(), 0
	for i in range(0, len(inp), 2):
		if {{completion}}
			count += 1
	print(count)",(inp[i] != inp[i+1]):,inp[i]!=inp[i-1]:
"t = int(input())
for _ in range(t):
    _, s = input(), input()
    res, i, c = 0, 0, 0
    while i < len(s):
        d = s[i]
        while {{completion}}
            c += 1
            i += 1
        c = c & 1
        res += 1 if c else 0
    print(res)
",i < len(s) and s[i] == d:,_ in range(int(input())):
"t=int(input())
for i in range (t):
    n=int(input())
    a=input()
    count=0
    for k in range(n//2):
        if{{completion}}
            count+=1
    print(count)
",(a[2*k]!=a[2*k+1]):,(a[k]!=a[k+1]):
"from itertools import groupby
t = int(input())

while t:
    t-=1

    n = int(input())
    s = input()
    o = [len("""".join(g))&1 for _,g in groupby(s)]

    l = -1
    res = 0

    for i, o_ in enumerate(o):
        if o_:
            if {{completion}}
                l = i
            else:
                res += i-l
                l = -1
    print(res)",l == -1:,i < len(o) and o[i] == 1:
"n=int(input(""""))
t=0
while(t<n):
    t+=1
    length=int(input(""""))
    s=input("""")
    count=0
    for i in range(1, length, 2):
        if {{completion}}
            count+=1
    print(count)
",s[i]!=s[i-1]:,(s[i]!= s[i+1]):
"for {{completion}}
	n,s,w=int(input()),input(),0
	print(sum([1 for i in range(1,n,2) if s[i]!=s[i-1]]))",_ in range(int(input())):,_ in range(int(input())):
"for {{completion}}
    n = int(input()); a = [*map(int,input().split())]
    print(n+(-a.count(0) or len(set(a))==n))",t in range(int(input())):,a.count(0) == 0 and len(set(a)) == len(a):
"for n in [*open(0)][2::2]:
    *a,=map(int,n.split());b=len(a);c=a.count(0)
    while a:
        q=a.pop()
        if {{completion}}
            break
    print(b+(a==[])*(c==0)-c)
",a.count(q)>0:,_ in[0]*int(input()):
"def solve():
    N=int(input())
    A=sorted(list(map(int,input().split())))
    return sum([i>0 for i in A])+all([i>0 for i in A])*all([A[i]<A[i+1] for i in range(N-1)])
T=int(input())
for {{completion}}
    print(solve())",i in range(T):,T in range(int(input())):
"t=int(input())
for _ in range(t):
    n=int(input())
    ar=list(map(int,input().split()))
    z=[0]*110
    for x in range(n):
        z[ar[x]]+=1 
    eq=False
    for x in range(110):
        if {{completion}}
            eq=True
    if z[0]>0:
        print(n-z[0])
    elif eq:
        print(n)
    else:
        print(n+1)",z[x]>1:,z[0]>0:
"for j in range(int(input())):
	h = int(input())
	a = list(map(int,input().split()))
	if 0 in a:
		print(h - a.count(0))
	else:
		if {{completion}}
			print(len(a))
		else:
			print(len(a)+1)",len(set(a)) < len(a):,a.count(i)==1:
"for i in range(int(input())):
    n = int(input())
    s = input().split()
    if s.count(""0""):
        print(n-s.count(""0""))
    else:
        for i in s:
            if {{completion}}
                print(n)
                break
        else:
            print(n+1)",s.count(i)>1:,i in range(int(input())):
"import sys
input = sys.stdin.readline
def getInts(): return map(int, input().split())


def solve():
    input()
    a = [*getInts()]
    if {{completion}}
        print(len(a) - a.count(0))
    else:
        s = set(a)
        print(len(a) + (len(a) == len(s)))


for _ in range(int(input())):
    solve()
",0 in a:,len(set(a)) < len(a):
"test=int(input())
while test:
    test-=1
    n=int(input())
    arr=[int(x) for x in input().split()]
    zero=0
    s=set(arr)
    for i in arr:
        if {{completion}}
            zero+=1
    if zero:
        print(n-zero)
    elif len(s)==n:
        print(n+1)
    else:
        print(n)
",i==0:,len(s)==n:
"for {{completion}}
 n=int(input())
 a=[*map(int,input().split())]
 print(n-a.count(0)+(0 not in a and len(a)==len(set(a))))",_ in[0]*int(input()):,len(set(a)) < len(a):
"import sys

def diff_ops(arr):
    result = True
    for {{completion}}
        result = result and arr[i] % arr[0] == 0
    return result

if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    len_input = len(input_arr)
    n = input_arr[0]
    test_cases = []
    pos = 1
    while pos <= len_input - 1:
        case_len = input_arr[pos]
        test_cases.append(input_arr[pos + 1: pos + 1 + case_len])
        pos += case_len + 1
    for case in test_cases:
        print(""YES"" if diff_ops(case) else ""NO"")

","i in range(1, len(arr)):",i == len(arr) - 1:
"import sys

def diff_ops(arr):
    result = True
    for i in range(1, len(arr)):
        result = result and arr[i] % arr[0] == 0
    return result

if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    len_input = len(input_arr)
    n = input_arr[0]
    test_cases = []
    pos = 1
    while {{completion}}
        case_len = input_arr[pos]
        test_cases.append(input_arr[pos + 1: pos + 1 + case_len])
        pos += case_len + 1
    for case in test_cases:
        print(""YES"" if diff_ops(case) else ""NO"")

",pos <= len_input - 1:,"i in range(1, len(arr)):"
"n, k = map(int, input().split())
answer = [0] * (n + 1)
dp = [1] + [0] * n
MIN = 0
while MIN + k <= n:
    mod = [0 for _ in range(k)]
    for {{completion}}
        dp[i], mod[i % k] = mod[i % k], dp[i] + mod[i % k]
        mod[i % k] %= 998244353
        answer[i] += dp[i]
        answer[i] %= 998244353
    MIN += k
    k += 1
print(*answer[1:])","i in range(MIN, n + 1):",dp[i]:
"import copy
n, k = list(map(int, input().split(' ')))


dp = [0]*(n+1)
for i in range(k, n+1, k):
    dp[i] = 1

# print(list(range(n+1)))
# print(dp, k)
ans = copy.copy(dp)
dp2 = [0]*(n+1)
for s in range(2,n):   # will be sqrt(n) really
    ks = k + s - 1
    first = (ks * (ks+1) // 2) - ((k-1) * k // 2)
    if first > n+1:
        break
    for {{completion}}
        dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353
    dp = dp2
    # print(dp, ks)
    dp2 = [0]*(n+1)
    for i in range(0, n+1):
        ans[i] = (ans[i] + dp[i]) % 998244353
print(' '.join(map(str, ans[1:])))","i in range(first, n+1):",dp[i]:
"import copy
n, k = list(map(int, input().split(' ')))


dp = [0]*(n+1)
for i in range(k, n+1, k):
    dp[i] = 1

# print(list(range(n+1)))
# print(dp, k)
ans = copy.copy(dp)
dp2 = [0]*(n+1)
for s in range(2,n):   # will be sqrt(n) really
    ks = k + s - 1
    first = (ks * (ks+1) // 2) - ((k-1) * k // 2)
    if first > n+1:
        break
    for i in range(first, n+1):
        dp2[i] = (dp2[i-ks] + dp[i-ks]) % 998244353
    dp = dp2
    # print(dp, ks)
    dp2 = [0]*(n+1)
    for {{completion}}
        ans[i] = (ans[i] + dp[i]) % 998244353
print(' '.join(map(str, ans[1:])))","i in range(0, n+1):","i in range(first, n+1):"
"import sys

inf=float('inf')
mod=998244353
#input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())

def main():

    n,k=inpnm()
    N=n+1
    f1=[0]*N
    res=[0]*N

    f1[0]=1
    i=1
    while True:
        step=k+i-1
        f2=[0]*N
        for {{completion}}
            f2[j]=(f1[j-step]+f2[j-step])%mod
            res[j]=(res[j]+f2[j])%mod

        for j in range(N):
            f1[j]=f2[j]

        if (k+k+i-1)*i>2*n:
            break
        i+=1
    print(*res[1:])

main()","j in range(step,N):",j in range(N):
"import sys

inf=float('inf')
mod=998244353
#input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int,input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())

def main():

    n,k=inpnm()
    N=n+1
    f1=[0]*N
    res=[0]*N

    f1[0]=1
    i=1
    while True:
        step=k+i-1
        f2=[0]*N
        for j in range(step,N):
            f2[j]=(f1[j-step]+f2[j-step])%mod
            res[j]=(res[j]+f2[j])%mod

        for {{completion}}
            f1[j]=f2[j]

        if (k+k+i-1)*i>2*n:
            break
        i+=1
    print(*res[1:])

main()",j in range(N):,"j in range(step,N):"
"t=1
mod=998244353
while t:
    t-=1
    n,k=[int(x) for x in input().split()]
    dp=[0 for x in range(n+1)]
    ans=[0 for x in range(n+1)]
    for i in range(k,n+1,k):
        dp[i]+=1
        ans[i]=dp[i]
    while True:
        k+=1
        shift=False

        for i in reversed(range(n+1)):

            if i-k>=0:
                dp[i]=dp[i-k]
                dp[i-k]=0
                if {{completion}}
                    shift=True
            else:
                dp[i]=0

        for i in range(n+1):
            if i+k<=n:
                dp[i+k]+=dp[i]
                dp[i+k]%=mod
        for i in range(n+1):
            ans[i]+=dp[i]
            ans[i]%=mod
        if not shift:
            break
    print(*ans[1:])


",dp[i]:,"i in range(k,n+1,k):"
"MOD, MAXN = 998244353, 10**5 * 2
N, K = map(int, input().split())
ans, dp = [0] * (MAXN + 10), [0] * (MAXN + 10)
dp[0] = 1
s = 0
for i in range(701):
    if s > N:
        break
    new_dp = [0] * (MAXN + 10)
    for {{completion}}
        new_dp[j] = (new_dp[j - i - K] + dp[j - i - K]) % MOD
        ans[j] = (ans[j] + new_dp[j]) % MOD
    dp = new_dp
    s += i + K
print(*ans[1:N + 1])
","j in range(s + i + K, N + 1):","i in range(s,N+1):"
"n,k=map(int,input().split());M=998244353
f,z=[1]+[0]*n,[0]*(n+1);l=0
while l<=n-k:
  s=[0]*k
  for {{completion}}
    j=i%k
    s[j],f[i],z[i]=(s[j]+f[i])%M,s[j],(z[i]+s[j])%M
  l+=k;k+=1
print(*z[1:])","i in range(l,n+1):","i in range(l,n+1):"
"def readline():
    line = input()
    while not line:
        line = input()
    return line


def main():
    t = int(readline())
    for _ in range(t):
        m = int(readline())
        a = [ [], [] ]
        a[0] += list(map(int, readline().split()))
        a[1] = list(map(int, readline().split()))

        h = [ [None] * m, [None] * m ]
        h[0][m-1] = max(a[1][m-1]+1, a[0][m-1]+1+1)
        h[1][m-1] = max(a[0][m-1]+1, a[1][m-1]+1+1)
        for i in reversed(range(m-1)):
            h[0][i] = max(a[1][i]+1, h[0][i+1]+1, a[0][i]+(i!=0)+(m-i-1)*2+1)
            h[1][i] = max(a[0][i]+1, h[1][i+1]+1, a[1][i]+1+(m-i-1)*2+1)

        pos = (0,0)
        t = 0
        best_total_time = 10**10
        for i in range(2*m-1):
            if i % 2 == 0:
                total_time = max(t+(m-i//2-1)*2+1, h[pos[0]][pos[1]])
                # print(pos, t,total_time)
                best_total_time = min(best_total_time, total_time)

            if i % 4 == 0:
                # abajo
                pos = (pos[0]+1, pos[1])
            elif {{completion}}
                # derecha
                pos = (pos[0], pos[1]+1)
            elif (i-2) % 4 == 0:
                # arr
                pos = (pos[0]-1, pos[1])
            elif (i-3) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            t = max(a[pos[0]][pos[1]] + 1, t+1)

        # for line in h:
        #     print(line)
        print(best_total_time)


main()
",(i-1) % 4 == 0:,(i-2) % 4 == 0:
"def readline():
    line = input()
    while not line:
        line = input()
    return line


def main():
    t = int(readline())
    for _ in range(t):
        m = int(readline())
        a = [ [], [] ]
        a[0] += list(map(int, readline().split()))
        a[1] = list(map(int, readline().split()))

        h = [ [None] * m, [None] * m ]
        h[0][m-1] = max(a[1][m-1]+1, a[0][m-1]+1+1)
        h[1][m-1] = max(a[0][m-1]+1, a[1][m-1]+1+1)
        for i in reversed(range(m-1)):
            h[0][i] = max(a[1][i]+1, h[0][i+1]+1, a[0][i]+(i!=0)+(m-i-1)*2+1)
            h[1][i] = max(a[0][i]+1, h[1][i+1]+1, a[1][i]+1+(m-i-1)*2+1)

        pos = (0,0)
        t = 0
        best_total_time = 10**10
        for i in range(2*m-1):
            if i % 2 == 0:
                total_time = max(t+(m-i//2-1)*2+1, h[pos[0]][pos[1]])
                # print(pos, t,total_time)
                best_total_time = min(best_total_time, total_time)

            if i % 4 == 0:
                # abajo
                pos = (pos[0]+1, pos[1])
            elif (i-1) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            elif {{completion}}
                # arr
                pos = (pos[0]-1, pos[1])
            elif (i-3) % 4 == 0:
                # derecha
                pos = (pos[0], pos[1]+1)
            t = max(a[pos[0]][pos[1]] + 1, t+1)

        # for line in h:
        #     print(line)
        print(best_total_time)


main()
",(i-2) % 4 == 0:,(i-2) % 4 == 0:
"import sys; input = sys.stdin.readline

def seg(start, end):
    if {{completion}}
        val = max(arr[start], 0)
        return [(val, val, val, arr[start])]
    mid = (start + end) // 2
    l = seg(start, mid)
    r = seg(mid + 1, end)
    result = []
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    l, r = r, l
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    return result
        
n = int(input())
l = 1 << n
arr = list(map(int, input().split()))
tree = seg(0, l - 1)
i = 0
for _ in range(int(input())):
    i ^= (1 << int(input()))
    print(tree[i][0])",start == end:,i in range((end - start + 1) // 2):
"import sys; input = sys.stdin.readline

def seg(start, end):
    if start == end:
        val = max(arr[start], 0)
        return [(val, val, val, arr[start])]
    mid = (start + end) // 2
    l = seg(start, mid)
    r = seg(mid + 1, end)
    result = []
    for {{completion}}
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    l, r = r, l
    for i in range((end - start + 1) // 2):
        lb, ls, lp, lS = l[i]
        rb, rs, rp, rS = r[i]
        result.append((max(lb, rb, ls + rp), max(rs, rS + ls), max(lp, lS + rp), lS + rS))
    return result
        
n = int(input())
l = 1 << n
arr = list(map(int, input().split()))
tree = seg(0, l - 1)
i = 0
for _ in range(int(input())):
    i ^= (1 << int(input()))
    print(tree[i][0])",i in range((end - start + 1) // 2):,i in range((r - l) // 2):
"import sys

input = lambda: sys.stdin.readline().rstrip()

class Node:
    def __init__(self, seg, suf, pref, sum) -> None:
        self.best = seg
        self.suf = suf
        self.pref = pref
        self.sum = sum


def merge(a, b):
    seg = max(a.best, b.best, a.suf + b.pref)
    suf = max(b.suf, b.sum + a.suf)
    pref = max(a.pref, a.sum + b.pref)
    sum = a.sum + b.sum
    return Node(seg, suf, pref, sum)

def single(a):
    v = max(a, 0)
    return Node(v, v, v, a)

def build(v, l, r):
    if l + 1 == r:
        return [single(A[l])]
    else:
        m = (l + r) // 2
        vl = build(2 * v + 1, l, m)
        vr = build(2 * v + 2, m, r)
        ans = []
        for _ in range(2):
            for {{completion}}
                ans.append(merge(vl[i], vr[i]))
            vl, vr = vr, vl
        return ans

N = int(input())
A = list(map(int, input().split()))
Q = int(input())

M = 1 << N
tree = build(0, 0, M)
curr = 0
for _ in range(Q):
    K = int(input())
    curr ^= (1 << K)
    print(tree[curr].best)",i in range((r - l) // 2):,"curr ^= (1 << K)
    print(tree[curr].best)"
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    N = int(input())
    G = [[int(x) for x in input()] + [0] for _ in range(2)]
    
    dp = [[0] * 2  for _ in range(N + 1)]   # number of 1 cells robot will clean when it arrives at cell (j, i) from the left
    for j in range(2):
        dp[N - 1][j] = G[1 - j][N - 1]
    
    for i in range(N - 2, - 1, -1):
        for j in range(2):
            dp[i][j] = G[j][i + 1] + dp[i + 1][j]   # base case: ignore row 1 - j and proceed right
            if {{completion}}
                dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])

    print(dp[0][0])
    return

solve()",G[1 - j][i]:,G[j][i + 1]:
"import sys
inf = float('inf')
mod = 998244353
input = lambda: sys.stdin.readline().rstrip()
inpnm = lambda: map(int, input().split())
inparr = lambda: [int(i) for i in input().split()]
inpint = lambda: int(input())


n=inpint()
s=[]
for i in range(2):
    s.append([i for i in list(input())]+['0','0'])
#print(arr)
f=[[-inf]*(2) for _ in range(n+2)]
f[0][0]=0
for i in range(n):
    for j in range(2):
        f[i+1][j]=max(f[i+1][j],f[i][j]+int(s[j][i+1]))
        if {{completion}}
            f[min(i+2,n)][j^1]=max(f[min(i+2,n)][j^1],f[i][j]+1+int(s[j^1][i+1])+int(s[j^1][i+2]))
print(max(f[n][0],f[n][1]))",s[j^1][i]=='1':,"f[i+1][j]=max(f[i+1][j],f[i][j]+int(s[j][i+1])):"
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    N = int(input())
    G = [[int(x) for x in input()] + [0] for _ in range(2)]
    
    dp = [[0] * 2  for _ in range(N + 1)]
    for j in range(2):
        dp[N - 1][j] = G[1 - j][N - 1]
    
    for i in range(N - 2, - 1, -1):
        for j in range(2):
            dp[i][j] = G[j][i + 1] + dp[i + 1][j]   # can always ignore row 1 - j and proceed right
            if G[1 - j][i]:
                if {{completion}}
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])
                else:
                    dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + dp[i + 1][1 - j])

    print(dp[0][0])
    return

solve()",G[j][i + 1]:,G[1 - j][i]:
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for i in range(tc):
        n, row1, row2 = input_arr[pos:pos + 3]
        row1n, row2n = [], []
        for k,j in zip(row1, row2):
            if {{completion}}
                k = ""B""
            if j == ""G"":
                j = ""B""
            row1n.append(k)
            row2n.append(j)
        print(""YES"" if row1n == row2n else ""NO"")

        pos += 3

# '6 2 RG RB 4 GRBG GBGB 5 GGGGG BBBBB 7 BBBBBBB RRRRRRR 8 RGBRRGBR RGGRRBGR 1 G G'
","k == ""G"":","k == ""B"" or j == ""B"":"
"import sys

if __name__ == ""__main__"":
    input_arr = sys.stdin.read().split()
    tc = int(input_arr[0])
    pos = 1
    for i in range(tc):
        n, row1, row2 = input_arr[pos:pos + 3]
        row1n, row2n = [], []
        for k,j in zip(row1, row2):
            if k == ""G"":
                k = ""B""
            if {{completion}}
                j = ""B""
            row1n.append(k)
            row2n.append(j)
        print(""YES"" if row1n == row2n else ""NO"")

        pos += 3

# '6 2 RG RB 4 GRBG GBGB 5 GGGGG BBBBB 7 BBBBBBB RRRRRRR 8 RGBRRGBR RGGRRBGR 1 G G'
","j == ""G"":","j == ""G"":"
"import sys


if __name__ == ""__main__"":
    input_arr = list(map(int, sys.stdin.read().split()))
    n = input_arr[0]
    pos = 1
    for i in range(n):
        n, code = input_arr[pos:pos+2]
        code_str = str(code)
        result = []
        j = n-1
        while j >= 0:
            if j >= 2:
                sub = code_str[j-2:j+1]
                if {{completion}}
                    result.append(chr(int(sub)//10 + 96))
                    j -= 3
                else:
                    result.append(chr(int(code_str[j])+96))
                    j -= 1
            else:
                result.append(chr(int(code_str[j]) + 96))
                j -= 1
        print("""".join(result[::-1]))
        pos += 2

# sys.stdin.read()
","sub[-1] == ""0"":","j >= 2 and code_str[j-2:j+1] == ""00"":"
"from sys import stdin
from collections import deque
lst = list(map(int, stdin.read().split()))
_s = 0
def inp(n=1):
    global _s
    ret = lst[_s:_s + n]
    _s += n
    return ret
def inp1():
    return inp()[0]

t = inp1()
for _ in range(t):
  n = inp1()
  s = str(inp1())[::-1]
  alph = ""0abcdefghijklmnopqrstuvwxyz""
  d = deque()
  i = 0
  while i < n:
    if {{completion}}
      d.appendleft(int(s[i + 1:i + 3][::-1]))
      i += 3
    else:
      d.appendleft(int(s[i]))
      i += 1
  ret = """"
  for i in d:
    ret += alph[i]
  print(ret)
","s[i] == ""0"":",s[i + 1:i + 3][::-1]
"import sys


def calculate(x, y1, y2):
    x = int(x)
    y1 = int(y1)
    y2 = int(y2)
    diff1 = abs(x - 1)
    diff2 = abs(y1-y2) if y2 == 1 else abs(y1-y2)+y2-1
    if diff1 < diff2:
        return 1
    elif diff2 < diff1:
        return 2
    else:
        return 3


if __name__ == ""__main__"":
    for line in sys.stdin:
        input = line.split()
        if {{completion}}
            print(calculate(input[0], input[1], input[2]))
",len(input) == 3:,input[0] == '1':
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              tt = [l[0] + r[0] + 1, r[1]]
            elif {{completion}}
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt[0] == l[0] + r[0] + 1:,tt is None or tt[0] > l[0] + r[0] + 1:
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if {{completion}}
              tt = [l[0] + r[0] + 1, r[1]]
            elif tt[0] == l[0] + r[0] + 1:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt is None or tt[0] > l[0] + r[0] + 1:,tt[0] == l[0] + r[0] + 1:
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if tt is None or tt[0] > l[0] + r[0] + 1:
              tt = [l[0] + r[0] + 1, r[1]]
            elif {{completion}}
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
          else:
            break
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt[0] == l[0] + r[0] + 1:,tt is None or tt[0] > l[0] + r[0] + 1:
"# from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List, Optional


def solve() -> None:
  s = next_token()
  t = next_token()
  ls = len(s)
  lt = len(t)
  is_start = [s[i:i + lt] == t for i in range(ls)]
  d: List[List[Optional[List[int]]]] = [[None for _ in range(j + 1)] for j in range(ls)]
  for ln in range(1, ls + 1):
    for j in range(ln - 1, ls):
      i = j - ln + 1
      for k in range(i, j + 1):
        if k + lt - 1 <= j and is_start[k]:
          l = (d[k - 1][i] if k - 1 >= i else None) or [0, 1]
          if l[0] == 0:
            r = (d[j][k + lt] if j >= k + lt else None) or [0, 1]
            tt = d[j][i]
            if {{completion}}
              tt = [l[0] + r[0] + 1, r[1]]
            elif tt[0] == l[0] + r[0] + 1:
              tt[1] = tt[1] + r[1]
            d[j][i] = tt
          else:
            break
      if d[j][i]:
        d[j][i][1] %= 1000000007
  print(*(d[ls - 1][0] or [0, 1]))


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",tt is None or tt[0] > l[0] + r[0] + 1:,tt[0] == l[0] + r[0] + 1:
"from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List


def solve() -> None:
  a = [int(c) % 9 for c in next_token()]
  n = len(a)
  sa = list(a)
  for i in range(1, n):
    sa[i] += sa[i - 1]
  w = next_int()
  indices = defaultdict(list)
  for i in range(w, n + 1):
    vlr = ((sa[i - 1] - (sa[i - w - 1] if i - w > 0 else 0)) % 9 + 9) % 9
    indices[vlr].append(i - w + 1)
  cache = dict()
  INF = (n + 1, n)
  for _ in range(next_int()):
    l = next_int() - 1
    r = next_int() - 1
    k = next_int()
    vlr = ((sa[r] - (sa[l - 1] if l > 0 else 0)) % 9 + 9) % 9
    if (vlr, k) not in cache:
      res = INF
      for v1 in range(9):
        for v2 in range(9):
          if ((v1 * vlr + v2) % 9 + 9) % 9 == k:
            if v1 == v2:
              if len(indices[v1]) > 1:
                res = min(res, tuple(indices[v1][:2]))
            else:
              if {{completion}}
                res = min(res, (indices[v1][0], indices[v2][0]))
      cache[(vlr, k)] = res if res != INF else (-1, -1)
    print(*cache[(vlr, k)])


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",len(indices[v1]) > 0 and len(indices[v2]) > 0:,tt is None or tt[0] > l[0] + r[0] + 1:
"from __future__ import annotations

import csv
import datetime
import string
import sys
import time
from collections import defaultdict
from contextlib import contextmanager
from typing import List


def solve() -> None:
  a = [int(c) % 9 for c in next_token()]
  n = len(a)
  sa = list(a)
  for i in range(1, n):
    sa[i] += sa[i - 1]
  w = next_int()
  indices = defaultdict(list)
  for i in range(w, n + 1):
    vlr = ((sa[i - 1] - (sa[i - w - 1] if i - w > 0 else 0)) % 9 + 9) % 9
    indices[vlr].append(i - w + 1)
  cache = dict()
  INF = (n + 1, n)
  for _ in range(next_int()):
    l = next_int() - 1
    r = next_int() - 1
    k = next_int()
    vlr = ((sa[r] - (sa[l - 1] if l > 0 else 0)) % 9 + 9) % 9
    if (vlr, k) not in cache:
      res = INF
      for v1 in range(9):
        for v2 in range(9):
          if ((v1 * vlr + v2) % 9 + 9) % 9 == k:
            if v1 == v2:
              if {{completion}}
                res = min(res, tuple(indices[v1][:2]))
            else:
              if len(indices[v1]) > 0 and len(indices[v2]) > 0:
                res = min(res, (indices[v1][0], indices[v2][0]))
      cache[(vlr, k)] = res if res != INF else (-1, -1)
    print(*cache[(vlr, k)])


def global_init() -> None:
  pass


RUN_N_TESTS_IN_PROD = True
PRINT_CASE_NUMBER = False
ASSERT_IN_PROD = False

LOG_TO_FILE = False
READ_FROM_CONSOLE_IN_DEBUG = False
WRITE_TO_CONSOLE_IN_DEBUG = True
TEST_TIMER = False

IS_DEBUG = ""DEBUG_MODE"" in sys.argv
__output_file = None
__input_file = None
__input_last_line = None


def run() -> None:
  global __input_file, __input_last_line, __output_file
  __output_file = sys.stdout if not IS_DEBUG or WRITE_TO_CONSOLE_IN_DEBUG else open(""../output.txt"", ""w"")
  try:
    __input_file = sys.stdin if not IS_DEBUG or READ_FROM_CONSOLE_IN_DEBUG else open(""../input.txt"")
    try:
      with timer(""total""):
        global_init()
        t = next_int() if RUN_N_TESTS_IN_PROD or IS_DEBUG else 1
        for i in range(t):
          if PRINT_CASE_NUMBER:
            fprint(f""Case #{i + 1}: "")
          if TEST_TIMER:
            with timer(f""test #{i + 1}""):
              solve()
          else:
            solve()
          if IS_DEBUG:
            __output_file.flush()
    finally:
      __input_last_line = None
      __input_file.close()
      __input_file = None
  finally:
    __output_file.flush()
    __output_file.close()


def fprint(*objects, **kwargs):
  print(*objects, end="""", file=__output_file, **kwargs)


def fprintln(*objects, **kwargs):
  print(*objects, file=__output_file, **kwargs)


def next_line() -> str:
  global __input_last_line
  __input_last_line = None
  return __input_file.readline()


def next_token() -> str:
  global __input_last_line
  while not __input_last_line:
    __input_last_line = __input_file.readline().split()[::-1]
  return __input_last_line.pop()


def next_int():
  return int(next_token())


def next_float():
  return float(next_token())


def next_int_array(n: int) -> List[int]:
  return [int(next_token()) for _ in range(n)]


if IS_DEBUG or ASSERT_IN_PROD:
  def assert_predicate(p: bool, message: str = """"):
    if not p:
      raise AssertionError(message)


  def assert_not_equal(unexpected, actual):
    if unexpected == actual:
      raise AssertionError(f""assert_not_equal: {unexpected} == {actual}"")


  def assert_equal(expected, actual):
    if expected != actual:
      raise AssertionError(f""assert_equal: {expected} != {actual}"")
else:
  def assert_predicate(p: bool, message: str = """"):
    pass


  def assert_not_equal(unexpected, actual):
    pass


  def assert_equal(expected, actual):
    pass

if IS_DEBUG:
  __log_file = open(f""../logs/py_solution_{int(time.time() * 1000)}.log"", ""w"") if LOG_TO_FILE else sys.stdout


  def log(*args, **kwargs):
    print(datetime.datetime.now(), ""-"", *args, **kwargs, flush=True, file=__log_file)


  @contextmanager
  def timer(label: str):
    start_time = time.time()
    try:
      yield
    finally:
      log(f""Timer[{label}]: {time.time() - start_time:.6f}s"")
else:
  def log(*args, **kwargs):
    pass


  @contextmanager
  def timer(label: str):
    yield

if __name__ == ""__main__"":
  run()
",len(indices[v1]) > 1:,tt is None or tt[0] > l[0] + r[0] + 1:
"# from collections import Counter
""""""
standing at point i, why choose to jump to a point j?

if jump:
a*(j-i) + cost(j,n)
if not jump(ie. start from i):
every unconquered kingdom require the distance j-i be conqured, totally n-j times,
-> (j-i)*b*(n-j) + cost(j,n)

compare the two equations:
when a < b*(n-j), we choose to jump to j.
""""""
row=lambda:map(int,input().split())
t=int(input())
for _ in range(t):
    n,a,b=row()
    arr=[0]+list(row())
    
    pos=res=0
    for i in range(1,n+1):
      d=arr[i]-arr[pos]
      res+=b*d
      if {{completion}}
        res+=a*d
        pos=i
    print(res)",a<b*(n-i):,a < b*(n-i):
"import sys
lines = list(map(str.strip, sys.stdin.readlines()))

def cum_sum(nums):
    curr = 0
    result = [0]*len(nums)
    for {{completion}}
        curr += num
        result[idx] = curr
    return result

for i in range(1, len(lines), 2):
    n, a, b = map(int, lines[i].split("" ""))
    nums = [0] + list(map(int, lines[i+1].split("" "")))
    cumulative = cum_sum(nums)
    smallest = float(""inf"")
    for f in range(0, n+1):
        curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
        smallest = min(curr, smallest)
    print(smallest)
","idx, num in enumerate(nums):","f in range(0, n+1):"
"import sys
lines = list(map(str.strip, sys.stdin.readlines()))

def cum_sum(nums):
    curr = 0
    result = [0]*len(nums)
    for idx, num in enumerate(nums):
        curr += num
        result[idx] = curr
    return result

for i in range(1, len(lines), 2):
    n, a, b = map(int, lines[i].split("" ""))
    nums = [0] + list(map(int, lines[i+1].split("" "")))
    cumulative = cum_sum(nums)
    smallest = float(""inf"")
    for {{completion}}
        curr = a*nums[f]+b*(cumulative[-1] - cumulative[f] - (n-f-1)*nums[f])
        smallest = min(curr, smallest)
    print(smallest)
","f in range(0, n+1):",a < b*(n-j-1):
"#Name:      Codeforces Round #782 (Div. 4)
#Code:      
#Rating:    00
#Date:      14/06/2022
#Author:    auros25
#Done:      


#sys.stdin.readline().strip()
#sys.stdout.write(+""\n"")

import sys
#import bisect

for lol in range(int(sys.stdin.readline().strip())):
    n, a, b = list(map(int, sys.stdin.readline().strip().split()))
    x = list(map(int, sys.stdin.readline().strip().split()))
    k = a//b + 1
    #print(k)
    if {{completion}}
        sys.stdout.write(str(b*(sum(x))) +""\n"")
    else:
        c=a+b
##        v=c*x[n-k-1]
##        w=k*b*x[n-k-1]
##        u= sum(x[n-k:])*b
        #print(v, w, u)
        #print(v-w+u)
        sys.stdout.write( str( c*x[n-k-1] + b*(sum(x[n-k:])-x[n-k-1]*k)) +""\n"")
   
",k >=n:,k=a//b+1
"for _ in range(int(input())):
	n,a,b=map(int, input().split())
	w=[int(x) for x in input().split()]
	fb=sum(w)*b
	fa=0
	ans = fb
	cap = 0
	cur = n
	for x in w:
		fb -= x * b
		cur -= 1
		if {{completion}}
			ans += (x - cap) * a
			ans -= (x - cap) * cur * b
			cap = x
		#print(cap)
	print(ans)",(x - cap) * a + fb - (x - cap) * cur * b < fb:,i in range(n):
"t = int(input())
for i in range(t):
    li = input().split()
    n = int(li[0])
    a = int(li[1])
    b = int(li[2])
    x = input().split()
    ans = 0
    now = 0
    for j in range(n):
        ans += b*(int(x[j])-now)
        if {{completion}}
            ans += a*(int(x[j])-now)
            now = int(x[j])
    print(ans)
",a < b*(n-j-1):,j==0 or j==n-1 or (j>0 and j<n-1 and (int(x[j-1])-int(x[j])>1 or int(x[j])-int(x[j+1])>1)):
"def solve():
  n,a,b=map(int,input().split())
  xs=list(map(int,input().split()))
  cum=0
  ans=sum(xs)*b
  for {{completion}}
    x=xs[-i-1]
    ans=min(ans,x*(a+b)+(cum-x*i)*b)
    cum+=x
  
  print(ans)

for _ in range(int(input())):
  solve()",i in range(n):,i<n:
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
for _ in range(t):
	n, a, b = I()
	x = [0] + I()
	suffixes = [0]
	for {{completion}}
		move = x[i + 1] - x[i]
		tot = suffixes[-1] + len(suffixes) * move * b
		suffixes.append(tot)
	suffixes = suffixes[::-1]
	best = float('inf')
	for i in range(n + 1):
		best = min(best, x[i] * (b + a) + suffixes[i])
	print(best)
","i in range(n - 1, -1, -1):",i < n:
"# import io,os
# read = io.BytesIO(os.read(0, os.fstat(0).st_size))
# I = lambda: [*map(int, read.readline().split())]

import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

t, = I()
for _ in range(t):
	n, a, b = I()
	x = [0] + I()
	suffixes = [0]
	for i in range(n - 1, -1, -1):
		move = x[i + 1] - x[i]
		tot = suffixes[-1] + len(suffixes) * move * b
		suffixes.append(tot)
	suffixes = suffixes[::-1]
	best = float('inf')
	for {{completion}}
		best = min(best, x[i] * (b + a) + suffixes[i])
	print(best)
",i in range(n + 1):,a < b*(n-j-1):
"def f(ar,a,b):
    ans=0
    c=0
    n=len(ar)
    for id,i in enumerate(ar):
        d=i-c
        ans+=d*b
        if {{completion}}
            ans+=d*a
            c=i
    return ans

r=lambda :map(int,input().strip().split())
for _ in range(int(input())):
    n,a,b=r()
    ar=list(r())
    print(f(ar,a,b))
",d*a<(n-id-1)*(d)*b:,i in range(n):
"for {{completion}}n,r,b=map(int,s.split());b+=1;c=r//b*'R'+'B';print((r%b*('R'+c)+n*c)[:n])",s in[*open(0)][1:]:,n in[*open(0)][1:]:
"for {{completion}}
    n,r,b=map(int,input().split())
    t=((r-1)//(b+1)+1)
    k=t*(b+1)-r
    res=('R'*t+'B')*(b+1-k)+('R'*(t-1)+'B')*k
    print(res[:-1])
    #",_ in range(int(input())):,"































































































































"
"tc=int(input())
for {{completion}}
 n,a,b=map(int,input().split());b+=1
 print((('R'*(a//b+1)+'B')*(a%b)+('R'*(a//b)+'B')*(b-a%b))[:-1])",_ in range(tc):,"n,a,b=map(int,input().split());b+=1"
"
def solve():
  n, r, b = list(map(int, input().split("" "")))

  d = r // (b+1)
  rem = r%(b+1)
  s = ''

  for i in range(b):
    if{{completion}}
      s += 'R'
      rem-= 1
    s += 'R'*d + 'B'
  
  s += 'R'*d
  s+='R'*rem

  print(s)

for t in range(int(input())):
    solve()
",(rem > 0):,"































































































































"
"for {{completion}}n,r,b=map(int,n.split());b+=1;n=r//b*'R';print((r%b*(n+'RB')+(b-r%b)*(n+'B'))[:-1])",n in[*open(0)][1:]:,n in[*open(0)][1:]:
"t=int(input())
for {{completion}}
    n,r,b=map(int,input().split())
    eq=r//(b+1)
    rem=r%(b+1)
    print(rem*((eq+1)*""R""+""B"")+(b-rem)*(eq*(""R"")+""B"")+eq*""R"")","i in range(0,t):",l in [*open(0)][1:]:
"for t in range(int(input())):
    n,r,b = map(int,input().split())
    s = []
    while r and b:
        s.append(""R"")
        s.append(""B"")
        r-=1
        b-=1
    s.append(""R"")
    r-=1
    j = 0
    while r:
        s[j]+='R'
        r-=1
        j+=2
        if {{completion}}
            j=0

    print(*s,sep="""")
        
        
    ",j>=len(s):,j%2==0
"for {{completion}}
	n,r,b=map(int,l.split())
	b+=1
	c=(r//b)*'R'+'B'
	print(((r%b)*('R'+c)+n*c)[:n])",l in [*open(0)][1:]:,i in range(r%b):
"t = int(input())
for i in range(t):
    x = input().split()
    r = int(x[1])
    b = int(x[2])
    x = """"
    p = r%(b+1)
    q = r//(b+1)
    for {{completion}}
        x += ""R""*(q+1)+""B""
    for i in range(b+1-p):
        x+= ""R""*(q)+""B""
    print(x[:-1])",i in range(p):,i in range(b+1-p):
"t = int(input())
for i in range(t):
    x = input().split()
    r = int(x[1])
    b = int(x[2])
    x = """"
    p = r%(b+1)
    q = r//(b+1)
    for i in range(p):
        x += ""R""*(q+1)+""B""
    for {{completion}}
        x+= ""R""*(q)+""B""
    print(x[:-1])",i in range(b+1-p):,i in range(b+1-p):
"for {{completion}}n,r,b=map(int,n.split());b+=1;print((r%b*('R'*(r//b+1)+'B')+(b-r%b)*(r//b*'R'+'B'))[:-1])",n in[*open(0)][1:]:,n in[*open(0)][1:]:
"for s in[*open(0)][2::2]:
    c=[*map(int,s.split())]
    a=[1 if x else 0 for x in c]+[1]
    for {{completion}}
        a[x+i-i*a[i]]=0
    print(*a[:-1])
","i,x in enumerate(c):",a[x+i-i*a[i]]:
"
import sys


def solve():
    n = int(input())
    num = list(map(int , input().split()))
    ret = [1]*n
    for i in range(n):
        j = num[i]
        if {{completion}}
            j += i
        if j < n:
            ret[j] = 0
    print(*ret)



for _ in range(int(input())):
    solve()
",j == 0 or ret[i] == 0:,j < n:
"
import sys


def solve():
    n = int(input())
    num = list(map(int , input().split()))
    ret = [1]*n
    for i in range(n):
        j = num[i]
        if j == 0 or ret[i] == 0:
            j += i
        if {{completion}}
            ret[j] = 0
    print(*ret)



for _ in range(int(input())):
    solve()
",j < n:,j == 0 or ret[i] == 0:
"t = int(input())
for _ in range(t):
    n = int(input())
    c = list(map(int, input().split()))
    a, e, se, s = [], [0]*n, 0, sum(c)
    for {{completion}}
        se -= e[i-1]
        n1 = s//i
        t = 0 if c[i-1] < i + se else 1
        a.append(t)
        s -= (n1 + (i-1)*t)
        e[i-n1-1] += 1
        se += 1
    print(*reversed(a))
        ","i in range(n, 0, -1):","i,x in enumerate(c):"
"from sys import stdin,stderr
def rl():
    return [int(w) for w in stdin.readline().split()]

t, = rl()
for _ in range(t):
    n, = rl()
    c = rl()
    a = [1] * n
    for i in range(n):
        j = c[i]
        if {{completion}}
            j += i
        if j < n:
            a[j] = 0
    print(*a)
",j == 0 or  a[i] == 0:,j < n:
"from sys import stdin,stderr
def rl():
    return [int(w) for w in stdin.readline().split()]

t, = rl()
for _ in range(t):
    n, = rl()
    c = rl()
    a = [1] * n
    for i in range(n):
        j = c[i]
        if j == 0 or  a[i] == 0:
            j += i
        if {{completion}}
            a[j] = 0
    print(*a)
",j < n:,j == 0 or  a[i] == 0:
"for _ in range(int(input())):
    n=int(input())
    C=list(map(int,input().split()))
    z=sum(C)//n
    d=[0]*(n+1)
    ans=[]
    for i in range(n-1,-1,-1):
        d[i]+=d[i+1]
        d[i]-=1
        d[i-z]+=1
        if {{completion}}
            ans.append(1)
            z-=1
        else:
            ans.append(0)
    print(*ans[::-1])",z and C[i]+d[i]==i:,C[i]==N:
"import sys
input = sys.stdin.readline


T = int(input())
for t in range(T):
    N=int(input())
    C=list(map(int,input().split()))
    ans=[0]*N
    k=sum(C)//N
    i=N-1
    while i>-1 and k>0:
        if {{completion}}
            ans[i]=1
            k-=1
        else:
            C[i-k]+=N-i
        i-=1
    print(*ans)",C[i]==N:,k and C[i]==i:
"import sys
input = sys.stdin.readline

class DSU:

    def __init__(self, n):
        self.UF = list(range(n))
        self.sz = [0]*n

    def find(self, u):
        UF = self.UF

        if UF[u]!=u:
            UF[u] = self.find(UF[u])
        return UF[u]

    def union(self,u,v):
        UF = self.UF
        sz = self.sz

        pu = self.find(u)
        pv = self.find(v)

        if pu == pv:
            return False
        if sz[pu] >= sz[pv]:
            sz[pu] += 1
            UF[pv] = pu
        else:
            sz[pv] += 1
            UF[pu] = pv
        return True

n,m = map(int,input().split())
good = []

DSUs = [DSU(n+1) for _ in range(30)]

for _ in range(m):
    u,v,w = map(int,input().split())

    u -= 1
    v -= 1

    if w%2 == 0:
        good.append((u,v,w))

    for k in range(0, 30):
        if {{completion}}
            DSUs[k].union(u,v)

q = int(input())
Q = [None]*q
ans = [2]*q

for i in range(q):
    u,v = map(int,input().split())

    u -= 1
    v -= 1

    Q[i] = u,v

    for k in range(0, 30):
        if DSUs[k].find(u) == DSUs[k].find(v):
            ans[i] = 0
            break

for u,v,w in good:
    for k in range(1, 30):
        DSUs[k].union(u, n)
        DSUs[k].union(v, n)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(n):
            ans[i] = 1
            break

print(""\n"".join(str(x) for x in ans))

",w & (1<<k):,DSUs[k].find(u) == DSUs[k].find(v):
"import sys
input = sys.stdin.readline

class DSU:

    def __init__(self, n):
        self.UF = list(range(n))
        self.sz = [0]*n

    def find(self, u):
        UF = self.UF

        if UF[u]!=u:
            UF[u] = self.find(UF[u])
        return UF[u]

    def union(self,u,v):
        UF = self.UF
        sz = self.sz

        pu = self.find(u)
        pv = self.find(v)

        if pu == pv:
            return False
        if sz[pu] >= sz[pv]:
            sz[pu] += 1
            UF[pv] = pu
        else:
            sz[pv] += 1
            UF[pu] = pv
        return True

n,m = map(int,input().split())
good = []

DSUs = [DSU(n+1) for _ in range(30)]

for _ in range(m):
    u,v,w = map(int,input().split())

    u -= 1
    v -= 1

    if w%2 == 0:
        good.append((u,v,w))

    for k in range(0, 30):
        if w & (1<<k):
            DSUs[k].union(u,v)

q = int(input())
Q = [None]*q
ans = [2]*q

for i in range(q):
    u,v = map(int,input().split())

    u -= 1
    v -= 1

    Q[i] = u,v

    for k in range(0, 30):
        if {{completion}}
            ans[i] = 0
            break

for u,v,w in good:
    for k in range(1, 30):
        DSUs[k].union(u, n)
        DSUs[k].union(v, n)

for i in range(q):
    if ans[i] == 0:
        continue

    u,v = Q[i]
    for k in range(1, 30):
        if DSUs[k].find(u) == DSUs[k].find(n):
            ans[i] = 1
            break

print(""\n"".join(str(x) for x in ans))

",DSUs[k].find(u) == DSUs[k].find(v):,(DSU.find(u) == DSU.find(v)):
"import sys

input = sys.stdin.readline

def bit(w, b):
    if w & (1 << b):
        return 1
    return 0


class DSU:

    def __init__(self, n):
        self.n = n
        self.parent = [i for i in range(self.n)]
        self.SZ = [1 for _ in range(self.n)]

    def root(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.root(self.parent[node])
        return self.parent[node]

    def merge(self, u, v):
        u = self.root(u)
        v = self.root(v)

        if u == v:
            return

        if self.SZ[u] < self.SZ[v]:
            temp = u
            u = v
            v = temp

        self.parent[v] = u
        self.SZ[u] += self.SZ[v]


class Solver1659E:

    def __init__(self):
        self.C = 30
        self.n, self.m = list(map(int, input().split(' ')))
        self.bit_i = [DSU(self.n) for _ in range(self.C)]
        self.bit_i_0 = [DSU(self.n) for _ in range(self.C)]
        self.one_works = [[0 for _ in range(self.n)] for _ in range(self.C)]

        for i in range(self.m):
            u, v, w = list(map(int, input().split(' ')))

            u -= 1
            v -= 1

            for j in range(self.C):
                if {{completion}}
                    self.bit_i[j].merge(u, v)

                if bit(w, j) and bit(w, 0):
                    self.bit_i_0[j].merge(u, v)

                if bit(w, 0) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.one_works[b][i] == 1:
                    self.one_works[b][self.bit_i_0[b].root(i)] = 1

        #print(self.one_works)

    def query(self):

        u, v = list(map(int, input().split(' ')))

        u -= 1
        v -= 1

        for b in range(self.C):
            if self.bit_i[b].root(u) == self.bit_i[b].root(v):
                return 0

        for b in range(1, self.C):
            if self.bit_i_0[b].root(u) == self.bit_i_0[b].root(v):
                #print(""i_0="",b)
                return 1

            if self.one_works[b][self.bit_i_0[b].root(u)]:
                #print(""one_works="",b,self.bit_i_0[b].root(u))
                return 1

        return 2


cur = Solver1659E()

q = int(input())

while q:

    q -= 1

    print(cur.query())
","bit(w, j):",(self.bit_i[b].root(u) == self.bit_i[b].root(v)):
"import sys

input = sys.stdin.readline

def bit(w, b):
    if w & (1 << b):
        return 1
    return 0


class DSU:

    def __init__(self, n):
        self.n = n
        self.parent = [i for i in range(self.n)]
        self.SZ = [1 for _ in range(self.n)]

    def root(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.root(self.parent[node])
        return self.parent[node]

    def merge(self, u, v):
        u = self.root(u)
        v = self.root(v)

        if u == v:
            return

        if self.SZ[u] < self.SZ[v]:
            temp = u
            u = v
            v = temp

        self.parent[v] = u
        self.SZ[u] += self.SZ[v]


class Solver1659E:

    def __init__(self):
        self.C = 30
        self.n, self.m = list(map(int, input().split(' ')))
        self.bit_i = [DSU(self.n) for _ in range(self.C)]
        self.bit_i_0 = [DSU(self.n) for _ in range(self.C)]
        self.one_works = [[0 for _ in range(self.n)] for _ in range(self.C)]

        for i in range(self.m):
            u, v, w = list(map(int, input().split(' ')))

            u -= 1
            v -= 1

            for j in range(self.C):
                if bit(w, j):
                    self.bit_i[j].merge(u, v)

                if {{completion}}
                    self.bit_i_0[j].merge(u, v)

                if bit(w, 0) == 0:
                    self.one_works[j][u] = 1
                    self.one_works[j][v] = 1

        for b in range(self.C):
            for i in range(self.n):
                if self.one_works[b][i] == 1:
                    self.one_works[b][self.bit_i_0[b].root(i)] = 1

        #print(self.one_works)

    def query(self):

        u, v = list(map(int, input().split(' ')))

        u -= 1
        v -= 1

        for b in range(self.C):
            if self.bit_i[b].root(u) == self.bit_i[b].root(v):
                return 0

        for b in range(1, self.C):
            if self.bit_i_0[b].root(u) == self.bit_i_0[b].root(v):
                #print(""i_0="",b)
                return 1

            if self.one_works[b][self.bit_i_0[b].root(u)]:
                #print(""one_works="",b,self.bit_i_0[b].root(u))
                return 1

        return 2


cur = Solver1659E()

q = int(input())

while q:

    q -= 1

    print(cur.query())
","bit(w, j) and bit(w, 0):",(self.bit_i_0[b].root(u) == self.bit_i_0[b].root(v)):
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


class dsu:

    def __init__(self , n):

        self.p = [0]*(n + 1)
        self.rank = [0]*(n + 1)

        for i in range(1 , n + 1):
            self.p[i] = i

    def find(self , node):
        if(self.p[node] == node):return node

        self.p[node] = self.find(self.p[node])
        return self.p[node]

    def union(self , u , v):
        u , v = self.find(u) , self.find(v)

        if(self.rank[u] == self.rank[v]):
            self.p[v] = u
            self.rank[u] += 1

        elif(self.rank[u] > self.rank[v]):
            self.p[v] = u

        else:
            self.p[u] = v

def answer():

    zeronotset = [False for i in range(n + 1)]
    for i in range(m):
        u , v , w = edges[i]

        if(w & 1 == 0):
            zeronotset[u] = True
            zeronotset[v] = True

    d = [dsu(n) for i in range(30)]
    for i in range(30):

        for j in range(m):
            u , v , w = edges[j]

            if(w >> i & 1):
                d[i].union(u , v)


    zero = [dsu(n) for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):

            u , v , w = edges[j]

            if(w & 1 and w >> i & 1):
                zero[i].union(u , v)
                

    value = [[2 for i in range(n + 1)] for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):
            u , v , w = edges[j]

            if(zeronotset[u]):
                value[i][zero[i].find(u)] = 1

            if(zeronotset[v]):
                value[i][zero[i].find(v)] = 1

    for q in range(int(input())):

        u , v = inp()

        ans = 2
        for i in range(30):
            if(d[i].find(u) == d[i].find(v)):
                ans = 0
                break

        if(ans == 2):

            for i in range(1 , 30):
                 if{{completion}}
                    ans = 1
                    break

        print(ans)
                
            
            
for T in range(1):

    n , m = inp()

    edges = []
    for i in range(m):
        u , v , w = inp()
        edges.append([u , v , w])
    

    answer()
",(value[i][zero[i].find(u)] == 1):,"































































































































"
"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))


class dsu:

    def __init__(self , n):

        self.p = [0]*(n + 1)
        self.rank = [0]*(n + 1)

        for i in range(1 , n + 1):
            self.p[i] = i

    def find(self , node):
        if(self.p[node] == node):return node

        self.p[node] = self.find(self.p[node])
        return self.p[node]

    def union(self , u , v):
        u , v = self.find(u) , self.find(v)

        if(self.rank[u] == self.rank[v]):
            self.p[v] = u
            self.rank[u] += 1

        elif(self.rank[u] > self.rank[v]):
            self.p[v] = u

        else:
            self.p[u] = v

def answer():

    zeronotset = [False for i in range(n + 1)]
    for i in range(m):
        u , v , w = edges[i]

        if(w & 1 == 0):
            zeronotset[u] = True
            zeronotset[v] = True

    d = [dsu(n) for i in range(30)]
    for i in range(30):

        for j in range(m):
            u , v , w = edges[j]

            if{{completion}}
                d[i].union(u , v)


    zero = [dsu(n) for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):

            u , v , w = edges[j]

            if(w & 1 and w >> i & 1):
                zero[i].union(u , v)
                

    value = [[2 for i in range(n + 1)] for i in range(30)]
    for i in range(1 , 30):

        for j in range(m):
            u , v , w = edges[j]

            if(zeronotset[u]):
                value[i][zero[i].find(u)] = 1

            if(zeronotset[v]):
                value[i][zero[i].find(v)] = 1

    for q in range(int(input())):

        u , v = inp()

        ans = 2
        for i in range(30):
            if(d[i].find(u) == d[i].find(v)):
                ans = 0
                break

        if(ans == 2):

            for i in range(1 , 30):
                 if(value[i][zero[i].find(u)] == 1):
                    ans = 1
                    break

        print(ans)
                
            
            
for T in range(1):

    n , m = inp()

    edges = []
    for i in range(m):
        u , v , w = inp()
        edges.append([u , v , w])
    

    answer()
",(w >> i & 1):,"































































































































"
